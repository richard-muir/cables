/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var CABLES;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/core/cgl/cgl_shader_default_glsl.vert":
/*!***************************************************!*\
  !*** ./src/core/cgl/cgl_shader_default_glsl.vert ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"{{MODULES_HEAD}}\\nIN vec3 vPosition; //!@\\nIN vec2 attrTexCoord;\\nIN vec3 attrVertNormal;\\nIN vec3 attrTangent,attrBiTangent;\\n\\nIN float attrVertIndex;\\n\\nOUT vec2 texCoord;\\nOUT vec3 norm;\\nUNI mat4 projMatrix;\\nUNI mat4 viewMatrix;\\nUNI mat4 modelMatrix;\\n\\nvoid main()\\n{\\n    texCoord=attrTexCoord;\\n    norm=attrVertNormal;\\n    vec4 pos=vec4(vPosition,  1.0);\\n    vec3 tangent=attrTangent;\\n    vec3 bitangent=attrBiTangent;\\n    mat4 mMatrix=modelMatrix;\\n    gl_PointSize=10.0;\\n\\n    {{MODULE_VERTEX_POSITION}}\\n\\n    mat4 modelViewMatrix=viewMatrix*mMatrix;\\n    {{MODULE_VERTEX_MOVELVIEW}}\\n\\n    gl_Position = projMatrix * modelViewMatrix * pos;\\n}\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3NoYWRlcl9kZWZhdWx0X2dsc2wudmVydC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnbC9jZ2xfc2hhZGVyX2RlZmF1bHRfZ2xzbC52ZXJ0P2M1MmYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJ7e01PRFVMRVNfSEVBRH19XFxuSU4gdmVjMyB2UG9zaXRpb247IC8vIUBcXG5JTiB2ZWMyIGF0dHJUZXhDb29yZDtcXG5JTiB2ZWMzIGF0dHJWZXJ0Tm9ybWFsO1xcbklOIHZlYzMgYXR0clRhbmdlbnQsYXR0ckJpVGFuZ2VudDtcXG5cXG5JTiBmbG9hdCBhdHRyVmVydEluZGV4O1xcblxcbk9VVCB2ZWMyIHRleENvb3JkO1xcbk9VVCB2ZWMzIG5vcm07XFxuVU5JIG1hdDQgcHJvak1hdHJpeDtcXG5VTkkgbWF0NCB2aWV3TWF0cml4O1xcblVOSSBtYXQ0IG1vZGVsTWF0cml4O1xcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgICB0ZXhDb29yZD1hdHRyVGV4Q29vcmQ7XFxuICAgIG5vcm09YXR0clZlcnROb3JtYWw7XFxuICAgIHZlYzQgcG9zPXZlYzQodlBvc2l0aW9uLCAgMS4wKTtcXG4gICAgdmVjMyB0YW5nZW50PWF0dHJUYW5nZW50O1xcbiAgICB2ZWMzIGJpdGFuZ2VudD1hdHRyQmlUYW5nZW50O1xcbiAgICBtYXQ0IG1NYXRyaXg9bW9kZWxNYXRyaXg7XFxuICAgIGdsX1BvaW50U2l6ZT0xMC4wO1xcblxcbiAgICB7e01PRFVMRV9WRVJURVhfUE9TSVRJT059fVxcblxcbiAgICBtYXQ0IG1vZGVsVmlld01hdHJpeD12aWV3TWF0cml4Km1NYXRyaXg7XFxuICAgIHt7TU9EVUxFX1ZFUlRFWF9NT1ZFTFZJRVd9fVxcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2pNYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiBwb3M7XFxufVxcblwiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_shader_default_glsl.vert\n");

/***/ }),

/***/ "./src/core/cgp/cgl_shader_default.wgsl":
/*!**********************************************!*\
  !*** ./src/core/cgp/cgl_shader_default.wgsl ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"struct VSUniforms\\n{\\n    modelMatrix: mat4x4<f32>,\\n    viewMatrix: mat4x4<f32>,\\n    projMatrix: mat4x4<f32>,\\n};\\n\\nstruct FSUniforms\\n{\\n    color:vec4<f32>\\n};\\n\\n@group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;\\n@group(0) @binding(1) var<uniform> fsUniforms: FSUniforms;\\n\\nstruct MyVSInput\\n{\\n    @location(0) position: vec3<f32>,\\n    @location(1) normal: vec3<f32>,\\n    @location(2) texcoord: vec2<f32>,\\n};\\n\\nstruct MyVSOutput\\n{\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) normal: vec3<f32>,\\n    @location(1) texcoord: vec2<f32>,\\n};\\n\\n@vertex\\nfn myVSMain(v: MyVSInput) -> MyVSOutput\\n{\\n    var vsOut: MyVSOutput;\\n    var pos =vec4<f32>(v.position, 1.0);\\n\\n    var mvMatrix=vsUniforms.viewMatrix * vsUniforms.modelMatrix;\\n    vsOut.position = vsUniforms.projMatrix * mvMatrix * pos;\\n\\n    vsOut.normal = v.normal;\\n    vsOut.texcoord = v.texcoord;\\n    return vsOut;\\n}\\n\\n@fragment\\nfn myFSMain(v: MyVSOutput) -> @location(0) vec4<f32>\\n{\\n    return fsUniforms.color+vec4<f32>(.5,.5,.5,1.0);\\n}\\n\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvY2dsX3NoYWRlcl9kZWZhdWx0Lndnc2wuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZ3AvY2dsX3NoYWRlcl9kZWZhdWx0Lndnc2w/NmZhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcInN0cnVjdCBWU1VuaWZvcm1zXFxue1xcbiAgICBtb2RlbE1hdHJpeDogbWF0NHg0PGYzMj4sXFxuICAgIHZpZXdNYXRyaXg6IG1hdDR4NDxmMzI+LFxcbiAgICBwcm9qTWF0cml4OiBtYXQ0eDQ8ZjMyPixcXG59O1xcblxcbnN0cnVjdCBGU1VuaWZvcm1zXFxue1xcbiAgICBjb2xvcjp2ZWM0PGYzMj5cXG59O1xcblxcbkBncm91cCgwKSBAYmluZGluZygwKSB2YXI8dW5pZm9ybT4gdnNVbmlmb3JtczogVlNVbmlmb3JtcztcXG5AZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHVuaWZvcm0+IGZzVW5pZm9ybXM6IEZTVW5pZm9ybXM7XFxuXFxuc3RydWN0IE15VlNJbnB1dFxcbntcXG4gICAgQGxvY2F0aW9uKDApIHBvc2l0aW9uOiB2ZWMzPGYzMj4sXFxuICAgIEBsb2NhdGlvbigxKSBub3JtYWw6IHZlYzM8ZjMyPixcXG4gICAgQGxvY2F0aW9uKDIpIHRleGNvb3JkOiB2ZWMyPGYzMj4sXFxufTtcXG5cXG5zdHJ1Y3QgTXlWU091dHB1dFxcbntcXG4gICAgQGJ1aWx0aW4ocG9zaXRpb24pIHBvc2l0aW9uOiB2ZWM0PGYzMj4sXFxuICAgIEBsb2NhdGlvbigwKSBub3JtYWw6IHZlYzM8ZjMyPixcXG4gICAgQGxvY2F0aW9uKDEpIHRleGNvb3JkOiB2ZWMyPGYzMj4sXFxufTtcXG5cXG5AdmVydGV4XFxuZm4gbXlWU01haW4odjogTXlWU0lucHV0KSAtPiBNeVZTT3V0cHV0XFxue1xcbiAgICB2YXIgdnNPdXQ6IE15VlNPdXRwdXQ7XFxuICAgIHZhciBwb3MgPXZlYzQ8ZjMyPih2LnBvc2l0aW9uLCAxLjApO1xcblxcbiAgICB2YXIgbXZNYXRyaXg9dnNVbmlmb3Jtcy52aWV3TWF0cml4ICogdnNVbmlmb3Jtcy5tb2RlbE1hdHJpeDtcXG4gICAgdnNPdXQucG9zaXRpb24gPSB2c1VuaWZvcm1zLnByb2pNYXRyaXggKiBtdk1hdHJpeCAqIHBvcztcXG5cXG4gICAgdnNPdXQubm9ybWFsID0gdi5ub3JtYWw7XFxuICAgIHZzT3V0LnRleGNvb3JkID0gdi50ZXhjb29yZDtcXG4gICAgcmV0dXJuIHZzT3V0O1xcbn1cXG5cXG5AZnJhZ21lbnRcXG5mbiBteUZTTWFpbih2OiBNeVZTT3V0cHV0KSAtPiBAbG9jYXRpb24oMCkgdmVjNDxmMzI+XFxue1xcbiAgICByZXR1cm4gZnNVbmlmb3Jtcy5jb2xvcit2ZWM0PGYzMj4oLjUsLjUsLjUsMS4wKTtcXG59XFxuXFxuXCI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgp/cgl_shader_default.wgsl\n");

/***/ }),

/***/ "./src/core/anim.js":
/*!**************************!*\
  !*** ./src/core/anim.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ANIM\": () => (/* binding */ ANIM),\n/* harmony export */   \"Anim\": () => (/* binding */ Anim)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n/* harmony import */ var _anim_key_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anim_key.js */ \"./src/core/anim_key.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"./src/core/constants.js\");\n/* harmony import */ var _eventtarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eventtarget.js */ \"./src/core/eventtarget.js\");\n\n\n\n\n\n/**\n * Keyframed interpolated animation.\n *\n * Available Easings:\n * <pre>\n * CONSTANTS.ANIM.EASING_LINEAR\n * CONSTANTS.ANIM.EASING_ABSOLUTE\n * CONSTANTS.ANIM.EASING_SMOOTHSTEP\n * CONSTANTS.ANIM.EASING_SMOOTHERSTEP\n * CONSTANTS.ANIM.EASING_CUBICSPLINE\n\n * CONSTANTS.ANIM.EASING_CUBIC_IN\n * CONSTANTS.ANIM.EASING_CUBIC_OUT\n * CONSTANTS.ANIM.EASING_CUBIC_INOUT\n\n * CONSTANTS.ANIM.EASING_EXPO_IN\n * CONSTANTS.ANIM.EASING_EXPO_OUT\n * CONSTANTS.ANIM.EASING_EXPO_INOUT\n\n * CONSTANTS.ANIM.EASING_SIN_IN\n * CONSTANTS.ANIM.EASING_SIN_OUT\n * CONSTANTS.ANIM.EASING_SIN_INOUT\n\n * CONSTANTS.ANIM.EASING_BACK_IN\n * CONSTANTS.ANIM.EASING_BACK_OUT\n * CONSTANTS.ANIM.EASING_BACK_INOUT\n\n * CONSTANTS.ANIM.EASING_ELASTIC_IN\n * CONSTANTS.ANIM.EASING_ELASTIC_OUT\n\n * CONSTANTS.ANIM.EASING_BOUNCE_IN\n * CONSTANTS.ANIM.EASING_BOUNCE_OUT\n\n * CONSTANTS.ANIM.EASING_QUART_IN\n * CONSTANTS.ANIM.EASING_QUART_OUT\n * CONSTANTS.ANIM.EASING_QUART_INOUT\n\n * CONSTANTS.ANIM.EASING_QUINT_IN\n * CONSTANTS.ANIM.EASING_QUINT_OUT\n * CONSTANTS.ANIM.EASING_QUINT_INOUT\n * </pre>\n * @hideconstructor\n * @external CABLES\n * @namespace Anim\n * @class\n * @example\n * var anim=new CABLES.Anim();\n * anim.setValue(0,0);  // set value 0 at 0 seconds\n * anim.setValue(10,1); // set value 1 at 10 seconds\n * anim.getValue(5);    // get value at 5 seconds - this returns 0.5\n */\n\nconst Anim = function (cfg)\n{\n    _eventtarget_js__WEBPACK_IMPORTED_MODULE_0__.EventTarget.apply(this);\n\n    cfg = cfg || {};\n    this.keys = [];\n    this.onChange = null;\n    this.stayInTimeline = false;\n    this.loop = false;\n    this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"Anim\");\n    this._lastKeyIndex = 0;\n    this._cachedIndex = 0;\n    this.name = cfg.name || null;\n\n    /**\n     * @member defaultEasing\n     * @memberof Anim\n     * @instance\n     * @type {Number}\n     */\n    this.defaultEasing = cfg.defaultEasing || _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_LINEAR;\n    this.onLooped = null;\n\n    this._timesLooped = 0;\n    this._needsSort = false;\n};\n\nAnim.prototype.forceChangeCallback = function ()\n{\n    if (this.onChange !== null) this.onChange();\n    this.emitEvent(\"onChange\", this);\n};\n\nAnim.prototype.getLoop = function ()\n{\n    return this.loop;\n};\n\nAnim.prototype.setLoop = function (target)\n{\n    this.loop = target;\n    this.emitEvent(\"onChange\", this);\n};\n\n/**\n * returns true if animation has ended at @time\n * checks if last key time is < time\n * @param {Number} time\n * @returns {Boolean}\n * @memberof Anim\n * @instance\n * @function\n */\nAnim.prototype.hasEnded = function (time)\n{\n    if (this.keys.length === 0) return true;\n    if (this.keys[this._lastKeyIndex].time <= time) return true;\n    return false;\n};\n\nAnim.prototype.isRising = function (time)\n{\n    if (this.hasEnded(time)) return false;\n    const ki = this.getKeyIndex(time);\n    if (this.keys[ki].value < this.keys[ki + 1].value) return true;\n    return false;\n};\n\n/**\n * remove all keys from animation before time\n * @param {Number} time\n * @memberof Anim\n * @instance\n * @function\n */\nAnim.prototype.clearBefore = function (time)\n{\n    const v = this.getValue(time);\n    const ki = this.getKeyIndex(time);\n\n    this.setValue(time, v);\n\n    if (ki > 1) this.keys.splice(0, ki);\n    this._updateLastIndex();\n};\n/**\n * remove all keys from animation\n * @param {Number} [time=0] set a new key at time with the old value at time\n * @memberof Anim\n * @instance\n * @function\n */\nAnim.prototype.clear = function (time)\n{\n    let v = 0;\n    if (time) v = this.getValue(time);\n    this.keys.length = 0;\n    this._updateLastIndex();\n    if (time) this.setValue(time, v);\n    if (this.onChange !== null) this.onChange();\n    this.emitEvent(\"onChange\", this);\n};\n\nAnim.prototype.sortKeys = function ()\n{\n    this.keys.sort((a, b) => { return parseFloat(a.time) - parseFloat(b.time); });\n    this._updateLastIndex();\n    this._needsSort = false;\n    if (this.keys.length % 1000 == 0)console.log(this.name, this.keys.length);\n};\n\nAnim.prototype.getLength = function ()\n{\n    if (this.keys.length === 0) return 0;\n    return this.keys[this.keys.length - 1].time;\n};\n\nAnim.prototype.getKeyIndex = function (time)\n{\n    let index = 0;\n    let start = 0;\n    if (this._cachedIndex && this.keys.length > this._cachedIndex && time >= this.keys[this._cachedIndex].time) start = this._cachedIndex;\n    for (let i = start; i < this.keys.length; i++)\n    {\n        if (time >= this.keys[i].time) index = i;\n        if (this.keys[i].time > time)\n        {\n            if (time != 0) this._cachedIndex = index;\n            return index;\n        }\n    }\n\n    return index;\n};\n\n/**\n * set value at time\n * @function setValue\n * @memberof Anim\n * @instance\n * @param {Number} time\n * @param {Number} value\n * @param {Function} [callback] callback\n */\nAnim.prototype.setValue = function (time, value, cb)\n{\n    let found = null;\n\n    if (this.keys.length == 0 || time <= this.keys[this.keys.length - 1].time)\n        for (let i = 0; i < this.keys.length; i++)\n            if (this.keys[i].time == time)\n            {\n                found = this.keys[i];\n                this.keys[i].setValue(value);\n                this.keys[i].cb = cb;\n                break;\n            }\n\n    if (!found)\n    {\n        found = new _anim_key_js__WEBPACK_IMPORTED_MODULE_3__.Key(\n            {\n                \"time\": time,\n                \"value\": value,\n                \"e\": this.defaultEasing,\n                \"cb\": cb,\n            });\n        this.keys.push(found);\n\n        // if (this.keys.length % 1000 == 0)console.log(this.name, this.keys.length);\n        this._updateLastIndex();\n    }\n\n    if (this.onChange) this.onChange();\n    this.emitEvent(\"onChange\", this);\n    this._needsSort = true;\n    return found;\n};\n\nAnim.prototype.setKeyEasing = function (index, e)\n{\n    if (this.keys[index])\n    {\n        this.keys[index].setEasing(e);\n        this.emitEvent(\"onChange\", this);\n    }\n};\n\nAnim.prototype.getSerialized = function ()\n{\n    const obj = {};\n    obj.keys = [];\n    obj.loop = this.loop;\n\n    for (let i = 0; i < this.keys.length; i++)\n        obj.keys.push(this.keys[i].getSerialized());\n\n    return obj;\n};\n\nAnim.prototype.getKey = function (time)\n{\n    const index = this.getKeyIndex(time);\n    return this.keys[index];\n};\n\nAnim.prototype.getNextKey = function (time)\n{\n    let index = this.getKeyIndex(time) + 1;\n    if (index >= this.keys.length) index = this.keys.length - 1;\n\n    return this.keys[index];\n};\n\nAnim.prototype.isFinished = function (time)\n{\n    if (this.keys.length <= 0) return true;\n    return time > this.keys[this.keys.length - 1].time;\n};\n\nAnim.prototype.isStarted = function (time)\n{\n    if (this.keys.length <= 0) return false;\n    return time >= this.keys[0].time;\n};\n\n/**\n * get value at time\n * @function getValue\n * @memberof Anim\n * @instance\n * @param {Number} [time] time\n * @returns {Number} interpolated value at time\n */\nAnim.prototype.getValue = function (time)\n{\n    if (this.keys.length === 0)\n    {\n        return 0;\n    }\n    if (this._needsSort) this.sortKeys();\n\n    if (!this.loop && time > this.keys[this._lastKeyIndex].time)\n    {\n        if (this.keys[this._lastKeyIndex].cb && !this.keys[this._lastKeyIndex].cbTriggered) this.keys[this._lastKeyIndex].trigger();\n\n        return this.keys[this._lastKeyIndex].value;\n    }\n\n    if (time < this.keys[0].time)\n    {\n        // if (this.name)console.log(\"A\");\n\n        return this.keys[0].value;\n    }\n\n    if (this.loop && time > this.keys[this._lastKeyIndex].time)\n    {\n        const currentLoop = time / this.keys[this._lastKeyIndex].time;\n        if (currentLoop > this._timesLooped)\n        {\n            this._timesLooped++;\n            if (this.onLooped) this.onLooped();\n        }\n        time = (time - this.keys[0].time) % (this.keys[this._lastKeyIndex].time - this.keys[0].time);\n        time += this.keys[0].time;\n    }\n\n    const index = this.getKeyIndex(time);\n    if (index >= this._lastKeyIndex)\n    {\n        if (this.keys[this._lastKeyIndex].cb && !this.keys[this._lastKeyIndex].cbTriggered) this.keys[this._lastKeyIndex].trigger();\n\n        return this.keys[this._lastKeyIndex].value;\n    }\n\n\n    const index2 = index + 1;\n    const key1 = this.keys[index];\n    const key2 = this.keys[index2];\n\n    if (key1.cb && !key1.cbTriggered) key1.trigger();\n\n    if (!key2) return -1;\n\n    const perc = (time - key1.time) / (key2.time - key1.time);\n\n    if (!key1.ease) this.log._warn(\"has no ease\", key1, key2);\n\n    return key1.ease(perc, key2);\n};\n\nAnim.prototype._updateLastIndex = function ()\n{\n    this._lastKeyIndex = this.keys.length - 1;\n};\n\nAnim.prototype.addKey = function (k)\n{\n    if (k.time === undefined)\n    {\n        this.log.warn(\"key time undefined, ignoring!\");\n    }\n    else\n    {\n        this.keys.push(k);\n        if (this.onChange !== null) this.onChange();\n        this.emitEvent(\"onChange\", this);\n    }\n    this._updateLastIndex();\n};\n\nAnim.prototype.easingFromString = function (str)\n{\n    if (str == \"linear\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_LINEAR;\n    if (str == \"absolute\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_ABSOLUTE;\n    if (str == \"smoothstep\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_SMOOTHSTEP;\n    if (str == \"smootherstep\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_SMOOTHERSTEP;\n\n    if (str == \"Cubic In\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_CUBIC_IN;\n    if (str == \"Cubic Out\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_CUBIC_OUT;\n    if (str == \"Cubic In Out\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_CUBIC_INOUT;\n\n    if (str == \"Expo In\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_EXPO_IN;\n    if (str == \"Expo Out\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_EXPO_OUT;\n    if (str == \"Expo In Out\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_EXPO_INOUT;\n\n    if (str == \"Sin In\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_SIN_IN;\n    if (str == \"Sin Out\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_SIN_OUT;\n    if (str == \"Sin In Out\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_SIN_INOUT;\n\n    if (str == \"Back In\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_BACK_IN;\n    if (str == \"Back Out\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_BACK_OUT;\n    if (str == \"Back In Out\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_BACK_INOUT;\n\n    if (str == \"Elastic In\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_ELASTIC_IN;\n    if (str == \"Elastic Out\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_ELASTIC_OUT;\n\n    if (str == \"Bounce In\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_BOUNCE_IN;\n    if (str == \"Bounce Out\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_BOUNCE_OUT;\n\n    if (str == \"Quart Out\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_QUART_OUT;\n    if (str == \"Quart In\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_QUART_IN;\n    if (str == \"Quart In Out\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_QUART_INOUT;\n\n    if (str == \"Quint Out\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_QUINT_OUT;\n    if (str == \"Quint In\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_QUINT_IN;\n    if (str == \"Quint In Out\") return _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASING_QUINT_INOUT;\n};\n\nAnim.prototype.createPort = function (op, title, cb)\n{\n    const port = op.inDropDown(title, _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.ANIM.EASINGS);\n\n    // const port = op.addInPort(\n    //     new Port(op, title, CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n    //         \"display\": \"dropdown\",\n    //         \"values\": CONSTANTS.ANIM.EASINGS,\n    //     }),\n    // );\n\n    port.set(\"linear\");\n    port.defaultValue = \"linear\";\n\n    port.onChange = function ()\n    {\n        this.defaultEasing = this.easingFromString(port.get());\n        this.emitEvent(\"onChangeDefaultEasing\", this);\n\n        if (cb) cb();\n    }.bind(this);\n\n    return port;\n};\n\n// ------------------------------\n\nAnim.slerpQuaternion = function (time, q, animx, animy, animz, animw)\n{\n    if (!Anim.slerpQuaternion.q1)\n    {\n        Anim.slerpQuaternion.q1 = quat.create();\n        Anim.slerpQuaternion.q2 = quat.create();\n    }\n\n    const i1 = animx.getKeyIndex(time);\n    let i2 = i1 + 1;\n    if (i2 >= animx.keys.length) i2 = animx.keys.length - 1;\n\n    if (i1 == i2)\n    {\n        quat.set(q, animx.keys[i1].value, animy.keys[i1].value, animz.keys[i1].value, animw.keys[i1].value);\n    }\n    else\n    {\n        const key1Time = animx.keys[i1].time;\n        const key2Time = animx.keys[i2].time;\n        const perc = (time - key1Time) / (key2Time - key1Time);\n\n        quat.set(Anim.slerpQuaternion.q1, animx.keys[i1].value, animy.keys[i1].value, animz.keys[i1].value, animw.keys[i1].value);\n\n        quat.set(Anim.slerpQuaternion.q2, animx.keys[i2].value, animy.keys[i2].value, animz.keys[i2].value, animw.keys[i2].value);\n\n        quat.slerp(q, Anim.slerpQuaternion.q1, Anim.slerpQuaternion.q2, perc);\n    }\n    return q;\n};\n\nconst ANIM = { \"Key\": _anim_key_js__WEBPACK_IMPORTED_MODULE_3__.Key };\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9hbmltLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvYW5pbS5qcz82YzMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJjYWJsZXMtc2hhcmVkLWNsaWVudFwiO1xuaW1wb3J0IHsgS2V5IH0gZnJvbSBcIi4vYW5pbV9rZXkuanNcIjtcbmltcG9ydCB7IENPTlNUQU5UUyB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgRXZlbnRUYXJnZXQgfSBmcm9tIFwiLi9ldmVudHRhcmdldC5qc1wiO1xuXG4vKipcbiAqIEtleWZyYW1lZCBpbnRlcnBvbGF0ZWQgYW5pbWF0aW9uLlxuICpcbiAqIEF2YWlsYWJsZSBFYXNpbmdzOlxuICogPHByZT5cbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19MSU5FQVJcbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19BQlNPTFVURVxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1NNT09USFNURVBcbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19TTU9PVEhFUlNURVBcbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19DVUJJQ1NQTElORVxuXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQ1VCSUNfSU5cbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19DVUJJQ19PVVRcbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19DVUJJQ19JTk9VVFxuXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfRVhQT19JTlxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0VYUE9fT1VUXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfRVhQT19JTk9VVFxuXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfU0lOX0lOXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfU0lOX09VVFxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1NJTl9JTk9VVFxuXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQkFDS19JTlxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0JBQ0tfT1VUXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQkFDS19JTk9VVFxuXG4gKiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfRUxBU1RJQ19JTlxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0VMQVNUSUNfT1VUXG5cbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19CT1VOQ0VfSU5cbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19CT1VOQ0VfT1VUXG5cbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19RVUFSVF9JTlxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1FVQVJUX09VVFxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1FVQVJUX0lOT1VUXG5cbiAqIENPTlNUQU5UUy5BTklNLkVBU0lOR19RVUlOVF9JTlxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1FVSU5UX09VVFxuICogQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1FVSU5UX0lOT1VUXG4gKiA8L3ByZT5cbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqIEBleHRlcm5hbCBDQUJMRVNcbiAqIEBuYW1lc3BhY2UgQW5pbVxuICogQGNsYXNzXG4gKiBAZXhhbXBsZVxuICogdmFyIGFuaW09bmV3IENBQkxFUy5BbmltKCk7XG4gKiBhbmltLnNldFZhbHVlKDAsMCk7ICAvLyBzZXQgdmFsdWUgMCBhdCAwIHNlY29uZHNcbiAqIGFuaW0uc2V0VmFsdWUoMTAsMSk7IC8vIHNldCB2YWx1ZSAxIGF0IDEwIHNlY29uZHNcbiAqIGFuaW0uZ2V0VmFsdWUoNSk7ICAgIC8vIGdldCB2YWx1ZSBhdCA1IHNlY29uZHMgLSB0aGlzIHJldHVybnMgMC41XG4gKi9cblxuY29uc3QgQW5pbSA9IGZ1bmN0aW9uIChjZmcpXG57XG4gICAgRXZlbnRUYXJnZXQuYXBwbHkodGhpcyk7XG5cbiAgICBjZmcgPSBjZmcgfHwge307XG4gICAgdGhpcy5rZXlzID0gW107XG4gICAgdGhpcy5vbkNoYW5nZSA9IG51bGw7XG4gICAgdGhpcy5zdGF5SW5UaW1lbGluZSA9IGZhbHNlO1xuICAgIHRoaXMubG9vcCA9IGZhbHNlO1xuICAgIHRoaXMuX2xvZyA9IG5ldyBMb2dnZXIoXCJBbmltXCIpO1xuICAgIHRoaXMuX2xhc3RLZXlJbmRleCA9IDA7XG4gICAgdGhpcy5fY2FjaGVkSW5kZXggPSAwO1xuICAgIHRoaXMubmFtZSA9IGNmZy5uYW1lIHx8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIGRlZmF1bHRFYXNpbmdcbiAgICAgKiBAbWVtYmVyb2YgQW5pbVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0RWFzaW5nID0gY2ZnLmRlZmF1bHRFYXNpbmcgfHwgQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0xJTkVBUjtcbiAgICB0aGlzLm9uTG9vcGVkID0gbnVsbDtcblxuICAgIHRoaXMuX3RpbWVzTG9vcGVkID0gMDtcbiAgICB0aGlzLl9uZWVkc1NvcnQgPSBmYWxzZTtcbn07XG5cbkFuaW0ucHJvdG90eXBlLmZvcmNlQ2hhbmdlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLm9uQ2hhbmdlICE9PSBudWxsKSB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgdGhpcy5lbWl0RXZlbnQoXCJvbkNoYW5nZVwiLCB0aGlzKTtcbn07XG5cbkFuaW0ucHJvdG90eXBlLmdldExvb3AgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLmxvb3A7XG59O1xuXG5BbmltLnByb3RvdHlwZS5zZXRMb29wID0gZnVuY3Rpb24gKHRhcmdldClcbntcbiAgICB0aGlzLmxvb3AgPSB0YXJnZXQ7XG4gICAgdGhpcy5lbWl0RXZlbnQoXCJvbkNoYW5nZVwiLCB0aGlzKTtcbn07XG5cbi8qKlxuICogcmV0dXJucyB0cnVlIGlmIGFuaW1hdGlvbiBoYXMgZW5kZWQgYXQgQHRpbWVcbiAqIGNoZWNrcyBpZiBsYXN0IGtleSB0aW1lIGlzIDwgdGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQG1lbWJlcm9mIEFuaW1cbiAqIEBpbnN0YW5jZVxuICogQGZ1bmN0aW9uXG4gKi9cbkFuaW0ucHJvdG90eXBlLmhhc0VuZGVkID0gZnVuY3Rpb24gKHRpbWUpXG57XG4gICAgaWYgKHRoaXMua2V5cy5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLmtleXNbdGhpcy5fbGFzdEtleUluZGV4XS50aW1lIDw9IHRpbWUpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbkFuaW0ucHJvdG90eXBlLmlzUmlzaW5nID0gZnVuY3Rpb24gKHRpbWUpXG57XG4gICAgaWYgKHRoaXMuaGFzRW5kZWQodGltZSkpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBraSA9IHRoaXMuZ2V0S2V5SW5kZXgodGltZSk7XG4gICAgaWYgKHRoaXMua2V5c1traV0udmFsdWUgPCB0aGlzLmtleXNba2kgKyAxXS52YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiByZW1vdmUgYWxsIGtleXMgZnJvbSBhbmltYXRpb24gYmVmb3JlIHRpbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXG4gKiBAbWVtYmVyb2YgQW5pbVxuICogQGluc3RhbmNlXG4gKiBAZnVuY3Rpb25cbiAqL1xuQW5pbS5wcm90b3R5cGUuY2xlYXJCZWZvcmUgPSBmdW5jdGlvbiAodGltZSlcbntcbiAgICBjb25zdCB2ID0gdGhpcy5nZXRWYWx1ZSh0aW1lKTtcbiAgICBjb25zdCBraSA9IHRoaXMuZ2V0S2V5SW5kZXgodGltZSk7XG5cbiAgICB0aGlzLnNldFZhbHVlKHRpbWUsIHYpO1xuXG4gICAgaWYgKGtpID4gMSkgdGhpcy5rZXlzLnNwbGljZSgwLCBraSk7XG4gICAgdGhpcy5fdXBkYXRlTGFzdEluZGV4KCk7XG59O1xuLyoqXG4gKiByZW1vdmUgYWxsIGtleXMgZnJvbSBhbmltYXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZT0wXSBzZXQgYSBuZXcga2V5IGF0IHRpbWUgd2l0aCB0aGUgb2xkIHZhbHVlIGF0IHRpbWVcbiAqIEBtZW1iZXJvZiBBbmltXG4gKiBAaW5zdGFuY2VcbiAqIEBmdW5jdGlvblxuICovXG5BbmltLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICh0aW1lKVxue1xuICAgIGxldCB2ID0gMDtcbiAgICBpZiAodGltZSkgdiA9IHRoaXMuZ2V0VmFsdWUodGltZSk7XG4gICAgdGhpcy5rZXlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fdXBkYXRlTGFzdEluZGV4KCk7XG4gICAgaWYgKHRpbWUpIHRoaXMuc2V0VmFsdWUodGltZSwgdik7XG4gICAgaWYgKHRoaXMub25DaGFuZ2UgIT09IG51bGwpIHRoaXMub25DaGFuZ2UoKTtcbiAgICB0aGlzLmVtaXRFdmVudChcIm9uQ2hhbmdlXCIsIHRoaXMpO1xufTtcblxuQW5pbS5wcm90b3R5cGUuc29ydEtleXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMua2V5cy5zb3J0KChhLCBiKSA9PiB7IHJldHVybiBwYXJzZUZsb2F0KGEudGltZSkgLSBwYXJzZUZsb2F0KGIudGltZSk7IH0pO1xuICAgIHRoaXMuX3VwZGF0ZUxhc3RJbmRleCgpO1xuICAgIHRoaXMuX25lZWRzU29ydCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmtleXMubGVuZ3RoICUgMTAwMCA9PSAwKWNvbnNvbGUubG9nKHRoaXMubmFtZSwgdGhpcy5rZXlzLmxlbmd0aCk7XG59O1xuXG5BbmltLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLmtleXMubGVuZ3RoID09PSAwKSByZXR1cm4gMDtcbiAgICByZXR1cm4gdGhpcy5rZXlzW3RoaXMua2V5cy5sZW5ndGggLSAxXS50aW1lO1xufTtcblxuQW5pbS5wcm90b3R5cGUuZ2V0S2V5SW5kZXggPSBmdW5jdGlvbiAodGltZSlcbntcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgaWYgKHRoaXMuX2NhY2hlZEluZGV4ICYmIHRoaXMua2V5cy5sZW5ndGggPiB0aGlzLl9jYWNoZWRJbmRleCAmJiB0aW1lID49IHRoaXMua2V5c1t0aGlzLl9jYWNoZWRJbmRleF0udGltZSkgc3RhcnQgPSB0aGlzLl9jYWNoZWRJbmRleDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZiAodGltZSA+PSB0aGlzLmtleXNbaV0udGltZSkgaW5kZXggPSBpO1xuICAgICAgICBpZiAodGhpcy5rZXlzW2ldLnRpbWUgPiB0aW1lKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGltZSAhPSAwKSB0aGlzLl9jYWNoZWRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xufTtcblxuLyoqXG4gKiBzZXQgdmFsdWUgYXQgdGltZVxuICogQGZ1bmN0aW9uIHNldFZhbHVlXG4gKiBAbWVtYmVyb2YgQW5pbVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrXG4gKi9cbkFuaW0ucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHRpbWUsIHZhbHVlLCBjYilcbntcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMua2V5cy5sZW5ndGggPT0gMCB8fCB0aW1lIDw9IHRoaXMua2V5c1t0aGlzLmtleXMubGVuZ3RoIC0gMV0udGltZSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5rZXlzW2ldLnRpbWUgPT0gdGltZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRoaXMua2V5c1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleXNbaV0uc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5c1tpXS5jYiA9IGNiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgaWYgKCFmb3VuZClcbiAgICB7XG4gICAgICAgIGZvdW5kID0gbmV3IEtleShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcInRpbWVcIjogdGltZSxcbiAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLFxuICAgICAgICAgICAgICAgIFwiZVwiOiB0aGlzLmRlZmF1bHRFYXNpbmcsXG4gICAgICAgICAgICAgICAgXCJjYlwiOiBjYixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLmtleXMucHVzaChmb3VuZCk7XG5cbiAgICAgICAgLy8gaWYgKHRoaXMua2V5cy5sZW5ndGggJSAxMDAwID09IDApY29uc29sZS5sb2codGhpcy5uYW1lLCB0aGlzLmtleXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlTGFzdEluZGV4KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub25DaGFuZ2UpIHRoaXMub25DaGFuZ2UoKTtcbiAgICB0aGlzLmVtaXRFdmVudChcIm9uQ2hhbmdlXCIsIHRoaXMpO1xuICAgIHRoaXMuX25lZWRzU29ydCA9IHRydWU7XG4gICAgcmV0dXJuIGZvdW5kO1xufTtcblxuQW5pbS5wcm90b3R5cGUuc2V0S2V5RWFzaW5nID0gZnVuY3Rpb24gKGluZGV4LCBlKVxue1xuICAgIGlmICh0aGlzLmtleXNbaW5kZXhdKVxuICAgIHtcbiAgICAgICAgdGhpcy5rZXlzW2luZGV4XS5zZXRFYXNpbmcoZSk7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwib25DaGFuZ2VcIiwgdGhpcyk7XG4gICAgfVxufTtcblxuQW5pbS5wcm90b3R5cGUuZ2V0U2VyaWFsaXplZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgY29uc3Qgb2JqID0ge307XG4gICAgb2JqLmtleXMgPSBbXTtcbiAgICBvYmoubG9vcCA9IHRoaXMubG9vcDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSsrKVxuICAgICAgICBvYmoua2V5cy5wdXNoKHRoaXMua2V5c1tpXS5nZXRTZXJpYWxpemVkKCkpO1xuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbkFuaW0ucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uICh0aW1lKVxue1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRLZXlJbmRleCh0aW1lKTtcbiAgICByZXR1cm4gdGhpcy5rZXlzW2luZGV4XTtcbn07XG5cbkFuaW0ucHJvdG90eXBlLmdldE5leHRLZXkgPSBmdW5jdGlvbiAodGltZSlcbntcbiAgICBsZXQgaW5kZXggPSB0aGlzLmdldEtleUluZGV4KHRpbWUpICsgMTtcbiAgICBpZiAoaW5kZXggPj0gdGhpcy5rZXlzLmxlbmd0aCkgaW5kZXggPSB0aGlzLmtleXMubGVuZ3RoIC0gMTtcblxuICAgIHJldHVybiB0aGlzLmtleXNbaW5kZXhdO1xufTtcblxuQW5pbS5wcm90b3R5cGUuaXNGaW5pc2hlZCA9IGZ1bmN0aW9uICh0aW1lKVxue1xuICAgIGlmICh0aGlzLmtleXMubGVuZ3RoIDw9IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiB0aW1lID4gdGhpcy5rZXlzW3RoaXMua2V5cy5sZW5ndGggLSAxXS50aW1lO1xufTtcblxuQW5pbS5wcm90b3R5cGUuaXNTdGFydGVkID0gZnVuY3Rpb24gKHRpbWUpXG57XG4gICAgaWYgKHRoaXMua2V5cy5sZW5ndGggPD0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aW1lID49IHRoaXMua2V5c1swXS50aW1lO1xufTtcblxuLyoqXG4gKiBnZXQgdmFsdWUgYXQgdGltZVxuICogQGZ1bmN0aW9uIGdldFZhbHVlXG4gKiBAbWVtYmVyb2YgQW5pbVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gW3RpbWVdIHRpbWVcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGludGVycG9sYXRlZCB2YWx1ZSBhdCB0aW1lXG4gKi9cbkFuaW0ucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKHRpbWUpXG57XG4gICAgaWYgKHRoaXMua2V5cy5sZW5ndGggPT09IDApXG4gICAge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX25lZWRzU29ydCkgdGhpcy5zb3J0S2V5cygpO1xuXG4gICAgaWYgKCF0aGlzLmxvb3AgJiYgdGltZSA+IHRoaXMua2V5c1t0aGlzLl9sYXN0S2V5SW5kZXhdLnRpbWUpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5rZXlzW3RoaXMuX2xhc3RLZXlJbmRleF0uY2IgJiYgIXRoaXMua2V5c1t0aGlzLl9sYXN0S2V5SW5kZXhdLmNiVHJpZ2dlcmVkKSB0aGlzLmtleXNbdGhpcy5fbGFzdEtleUluZGV4XS50cmlnZ2VyKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMua2V5c1t0aGlzLl9sYXN0S2V5SW5kZXhdLnZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0aW1lIDwgdGhpcy5rZXlzWzBdLnRpbWUpXG4gICAge1xuICAgICAgICAvLyBpZiAodGhpcy5uYW1lKWNvbnNvbGUubG9nKFwiQVwiKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5rZXlzWzBdLnZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxvb3AgJiYgdGltZSA+IHRoaXMua2V5c1t0aGlzLl9sYXN0S2V5SW5kZXhdLnRpbWUpXG4gICAge1xuICAgICAgICBjb25zdCBjdXJyZW50TG9vcCA9IHRpbWUgLyB0aGlzLmtleXNbdGhpcy5fbGFzdEtleUluZGV4XS50aW1lO1xuICAgICAgICBpZiAoY3VycmVudExvb3AgPiB0aGlzLl90aW1lc0xvb3BlZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fdGltZXNMb29wZWQrKztcbiAgICAgICAgICAgIGlmICh0aGlzLm9uTG9vcGVkKSB0aGlzLm9uTG9vcGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGltZSA9ICh0aW1lIC0gdGhpcy5rZXlzWzBdLnRpbWUpICUgKHRoaXMua2V5c1t0aGlzLl9sYXN0S2V5SW5kZXhdLnRpbWUgLSB0aGlzLmtleXNbMF0udGltZSk7XG4gICAgICAgIHRpbWUgKz0gdGhpcy5rZXlzWzBdLnRpbWU7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEtleUluZGV4KHRpbWUpO1xuICAgIGlmIChpbmRleCA+PSB0aGlzLl9sYXN0S2V5SW5kZXgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5rZXlzW3RoaXMuX2xhc3RLZXlJbmRleF0uY2IgJiYgIXRoaXMua2V5c1t0aGlzLl9sYXN0S2V5SW5kZXhdLmNiVHJpZ2dlcmVkKSB0aGlzLmtleXNbdGhpcy5fbGFzdEtleUluZGV4XS50cmlnZ2VyKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMua2V5c1t0aGlzLl9sYXN0S2V5SW5kZXhdLnZhbHVlO1xuICAgIH1cblxuXG4gICAgY29uc3QgaW5kZXgyID0gaW5kZXggKyAxO1xuICAgIGNvbnN0IGtleTEgPSB0aGlzLmtleXNbaW5kZXhdO1xuICAgIGNvbnN0IGtleTIgPSB0aGlzLmtleXNbaW5kZXgyXTtcblxuICAgIGlmIChrZXkxLmNiICYmICFrZXkxLmNiVHJpZ2dlcmVkKSBrZXkxLnRyaWdnZXIoKTtcblxuICAgIGlmICgha2V5MikgcmV0dXJuIC0xO1xuXG4gICAgY29uc3QgcGVyYyA9ICh0aW1lIC0ga2V5MS50aW1lKSAvIChrZXkyLnRpbWUgLSBrZXkxLnRpbWUpO1xuXG4gICAgaWYgKCFrZXkxLmVhc2UpIHRoaXMubG9nLl93YXJuKFwiaGFzIG5vIGVhc2VcIiwga2V5MSwga2V5Mik7XG5cbiAgICByZXR1cm4ga2V5MS5lYXNlKHBlcmMsIGtleTIpO1xufTtcblxuQW5pbS5wcm90b3R5cGUuX3VwZGF0ZUxhc3RJbmRleCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fbGFzdEtleUluZGV4ID0gdGhpcy5rZXlzLmxlbmd0aCAtIDE7XG59O1xuXG5BbmltLnByb3RvdHlwZS5hZGRLZXkgPSBmdW5jdGlvbiAoaylcbntcbiAgICBpZiAoay50aW1lID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICB0aGlzLmxvZy53YXJuKFwia2V5IHRpbWUgdW5kZWZpbmVkLCBpZ25vcmluZyFcIik7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMua2V5cy5wdXNoKGspO1xuICAgICAgICBpZiAodGhpcy5vbkNoYW5nZSAhPT0gbnVsbCkgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcIm9uQ2hhbmdlXCIsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVMYXN0SW5kZXgoKTtcbn07XG5cbkFuaW0ucHJvdG90eXBlLmVhc2luZ0Zyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyKVxue1xuICAgIGlmIChzdHIgPT0gXCJsaW5lYXJcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19MSU5FQVI7XG4gICAgaWYgKHN0ciA9PSBcImFic29sdXRlXCIpIHJldHVybiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQUJTT0xVVEU7XG4gICAgaWYgKHN0ciA9PSBcInNtb290aHN0ZXBcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19TTU9PVEhTVEVQO1xuICAgIGlmIChzdHIgPT0gXCJzbW9vdGhlcnN0ZXBcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19TTU9PVEhFUlNURVA7XG5cbiAgICBpZiAoc3RyID09IFwiQ3ViaWMgSW5cIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19DVUJJQ19JTjtcbiAgICBpZiAoc3RyID09IFwiQ3ViaWMgT3V0XCIpIHJldHVybiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQ1VCSUNfT1VUO1xuICAgIGlmIChzdHIgPT0gXCJDdWJpYyBJbiBPdXRcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19DVUJJQ19JTk9VVDtcblxuICAgIGlmIChzdHIgPT0gXCJFeHBvIEluXCIpIHJldHVybiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfRVhQT19JTjtcbiAgICBpZiAoc3RyID09IFwiRXhwbyBPdXRcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19FWFBPX09VVDtcbiAgICBpZiAoc3RyID09IFwiRXhwbyBJbiBPdXRcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19FWFBPX0lOT1VUO1xuXG4gICAgaWYgKHN0ciA9PSBcIlNpbiBJblwiKSByZXR1cm4gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1NJTl9JTjtcbiAgICBpZiAoc3RyID09IFwiU2luIE91dFwiKSByZXR1cm4gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1NJTl9PVVQ7XG4gICAgaWYgKHN0ciA9PSBcIlNpbiBJbiBPdXRcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19TSU5fSU5PVVQ7XG5cbiAgICBpZiAoc3RyID09IFwiQmFjayBJblwiKSByZXR1cm4gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0JBQ0tfSU47XG4gICAgaWYgKHN0ciA9PSBcIkJhY2sgT3V0XCIpIHJldHVybiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQkFDS19PVVQ7XG4gICAgaWYgKHN0ciA9PSBcIkJhY2sgSW4gT3V0XCIpIHJldHVybiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQkFDS19JTk9VVDtcblxuICAgIGlmIChzdHIgPT0gXCJFbGFzdGljIEluXCIpIHJldHVybiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfRUxBU1RJQ19JTjtcbiAgICBpZiAoc3RyID09IFwiRWxhc3RpYyBPdXRcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19FTEFTVElDX09VVDtcblxuICAgIGlmIChzdHIgPT0gXCJCb3VuY2UgSW5cIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19CT1VOQ0VfSU47XG4gICAgaWYgKHN0ciA9PSBcIkJvdW5jZSBPdXRcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19CT1VOQ0VfT1VUO1xuXG4gICAgaWYgKHN0ciA9PSBcIlF1YXJ0IE91dFwiKSByZXR1cm4gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1FVQVJUX09VVDtcbiAgICBpZiAoc3RyID09IFwiUXVhcnQgSW5cIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19RVUFSVF9JTjtcbiAgICBpZiAoc3RyID09IFwiUXVhcnQgSW4gT3V0XCIpIHJldHVybiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfUVVBUlRfSU5PVVQ7XG5cbiAgICBpZiAoc3RyID09IFwiUXVpbnQgT3V0XCIpIHJldHVybiBDT05TVEFOVFMuQU5JTS5FQVNJTkdfUVVJTlRfT1VUO1xuICAgIGlmIChzdHIgPT0gXCJRdWludCBJblwiKSByZXR1cm4gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1FVSU5UX0lOO1xuICAgIGlmIChzdHIgPT0gXCJRdWludCBJbiBPdXRcIikgcmV0dXJuIENPTlNUQU5UUy5BTklNLkVBU0lOR19RVUlOVF9JTk9VVDtcbn07XG5cbkFuaW0ucHJvdG90eXBlLmNyZWF0ZVBvcnQgPSBmdW5jdGlvbiAob3AsIHRpdGxlLCBjYilcbntcbiAgICBjb25zdCBwb3J0ID0gb3AuaW5Ecm9wRG93bih0aXRsZSwgQ09OU1RBTlRTLkFOSU0uRUFTSU5HUyk7XG5cbiAgICAvLyBjb25zdCBwb3J0ID0gb3AuYWRkSW5Qb3J0KFxuICAgIC8vICAgICBuZXcgUG9ydChvcCwgdGl0bGUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUsIHtcbiAgICAvLyAgICAgICAgIFwiZGlzcGxheVwiOiBcImRyb3Bkb3duXCIsXG4gICAgLy8gICAgICAgICBcInZhbHVlc1wiOiBDT05TVEFOVFMuQU5JTS5FQVNJTkdTLFxuICAgIC8vICAgICB9KSxcbiAgICAvLyApO1xuXG4gICAgcG9ydC5zZXQoXCJsaW5lYXJcIik7XG4gICAgcG9ydC5kZWZhdWx0VmFsdWUgPSBcImxpbmVhclwiO1xuXG4gICAgcG9ydC5vbkNoYW5nZSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLmRlZmF1bHRFYXNpbmcgPSB0aGlzLmVhc2luZ0Zyb21TdHJpbmcocG9ydC5nZXQoKSk7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwib25DaGFuZ2VEZWZhdWx0RWFzaW5nXCIsIHRoaXMpO1xuXG4gICAgICAgIGlmIChjYikgY2IoKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICByZXR1cm4gcG9ydDtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5BbmltLnNsZXJwUXVhdGVybmlvbiA9IGZ1bmN0aW9uICh0aW1lLCBxLCBhbmlteCwgYW5pbXksIGFuaW16LCBhbmltdylcbntcbiAgICBpZiAoIUFuaW0uc2xlcnBRdWF0ZXJuaW9uLnExKVxuICAgIHtcbiAgICAgICAgQW5pbS5zbGVycFF1YXRlcm5pb24ucTEgPSBxdWF0LmNyZWF0ZSgpO1xuICAgICAgICBBbmltLnNsZXJwUXVhdGVybmlvbi5xMiA9IHF1YXQuY3JlYXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgaTEgPSBhbmlteC5nZXRLZXlJbmRleCh0aW1lKTtcbiAgICBsZXQgaTIgPSBpMSArIDE7XG4gICAgaWYgKGkyID49IGFuaW14LmtleXMubGVuZ3RoKSBpMiA9IGFuaW14LmtleXMubGVuZ3RoIC0gMTtcblxuICAgIGlmIChpMSA9PSBpMilcbiAgICB7XG4gICAgICAgIHF1YXQuc2V0KHEsIGFuaW14LmtleXNbaTFdLnZhbHVlLCBhbmlteS5rZXlzW2kxXS52YWx1ZSwgYW5pbXoua2V5c1tpMV0udmFsdWUsIGFuaW13LmtleXNbaTFdLnZhbHVlKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgY29uc3Qga2V5MVRpbWUgPSBhbmlteC5rZXlzW2kxXS50aW1lO1xuICAgICAgICBjb25zdCBrZXkyVGltZSA9IGFuaW14LmtleXNbaTJdLnRpbWU7XG4gICAgICAgIGNvbnN0IHBlcmMgPSAodGltZSAtIGtleTFUaW1lKSAvIChrZXkyVGltZSAtIGtleTFUaW1lKTtcblxuICAgICAgICBxdWF0LnNldChBbmltLnNsZXJwUXVhdGVybmlvbi5xMSwgYW5pbXgua2V5c1tpMV0udmFsdWUsIGFuaW15LmtleXNbaTFdLnZhbHVlLCBhbmltei5rZXlzW2kxXS52YWx1ZSwgYW5pbXcua2V5c1tpMV0udmFsdWUpO1xuXG4gICAgICAgIHF1YXQuc2V0KEFuaW0uc2xlcnBRdWF0ZXJuaW9uLnEyLCBhbmlteC5rZXlzW2kyXS52YWx1ZSwgYW5pbXkua2V5c1tpMl0udmFsdWUsIGFuaW16LmtleXNbaTJdLnZhbHVlLCBhbmltdy5rZXlzW2kyXS52YWx1ZSk7XG5cbiAgICAgICAgcXVhdC5zbGVycChxLCBBbmltLnNsZXJwUXVhdGVybmlvbi5xMSwgQW5pbS5zbGVycFF1YXRlcm5pb24ucTIsIHBlcmMpO1xuICAgIH1cbiAgICByZXR1cm4gcTtcbn07XG5cbmNvbnN0IEFOSU0gPSB7IFwiS2V5XCI6IEtleSB9O1xuXG5leHBvcnQgeyBBTklNIH07XG5leHBvcnQgeyBBbmltIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/anim.js\n");

/***/ }),

/***/ "./src/core/anim_key.js":
/*!******************************!*\
  !*** ./src/core/anim_key.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Key\": () => (/* binding */ Key)\n/* harmony export */ });\n/* unused harmony exports easeExpoIn, easeExpoOut, easeExpoInOut, easeCubicIn, easeCubicOut, easeCubicInOut */\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./src/core/constants.js\");\n\n\nconst Key = function (obj)\n{\n    this.time = 0.0;\n    this.value = 0.0;\n    // this.ui = null;\n    this.onChange = null;\n    this._easing = 0;\n    // this.bezTangIn = 0;\n    // this.bezTangOut = 0;\n    // this.bezTime = 0.5;\n    // this.bezValue = 0;\n    // this.bezTimeIn = -0.5;\n    // this.bezValueIn = 0;\n\n    this.cb = null;\n    this.cbTriggered = false;\n\n    // const bezierAnim = null;\n    // this._updateBezier = false;\n\n    this.setEasing(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_LINEAR);\n    this.set(obj);\n};\n\nKey.cubicSpline = function (perc, key1, key2)\n{\n    let\n        previousPoint = key1.value,\n        previousTangent = key1.bezTangOut,\n        nextPoint = key2.value,\n        nextTangent = key2.bezTangIn;\n    let t = perc;\n    let t2 = t * t;\n    let t3 = t2 * t;\n\n    return (2 * t3 - 3 * t2 + 1) * previousPoint + (t3 - 2 * t2 + t) * previousTangent + (-2 * t3 + 3 * t2) * nextPoint + (t3 - t2) * nextTangent;\n};\n\nKey.easeCubicSpline = function (perc, key2)\n{\n    return Key.cubicSpline(perc, this, key2);\n};\n\n\nKey.linear = function (perc, key1, key2)\n{\n    return parseFloat(key1.value) + parseFloat(key2.value - key1.value) * perc;\n};\n\nKey.easeLinear = function (perc, key2)\n{\n    return Key.linear(perc, this, key2);\n};\n\nKey.easeAbsolute = function (perc, key2)\n{\n    return this.value;\n};\n\nconst easeExpoIn = function (t)\n{\n    return (t = 2 ** (10 * (t - 1)));\n};\n\nKey.easeExpoIn = function (t, key2)\n{\n    t = easeExpoIn(t);\n    return Key.linear(t, this, key2);\n};\n\nconst easeExpoOut = function (t)\n{\n    t = -(2 ** (-10 * t)) + 1;\n    return t;\n};\n\nKey.easeExpoOut = function (t, key2)\n{\n    t = easeExpoOut(t);\n    return Key.linear(t, this, key2);\n};\n\nconst easeExpoInOut = function (t)\n{\n    t *= 2;\n    if (t < 1)\n    {\n        t = 0.5 * 2 ** (10 * (t - 1));\n    }\n    else\n    {\n        t--;\n        t = 0.5 * (-(2 ** (-10 * t)) + 2);\n    }\n    return t;\n};\n\nKey.easeExpoInOut = function (t, key2)\n{\n    t = easeExpoInOut(t);\n    return Key.linear(t, this, key2);\n};\n\nKey.easeSinIn = function (t, key2)\n{\n    t = -1 * Math.cos((t * Math.PI) / 2) + 1;\n    return Key.linear(t, this, key2);\n};\n\nKey.easeSinOut = function (t, key2)\n{\n    t = Math.sin((t * Math.PI) / 2);\n    return Key.linear(t, this, key2);\n};\n\nKey.easeSinInOut = function (t, key2)\n{\n    t = -0.5 * (Math.cos(Math.PI * t) - 1.0);\n    return Key.linear(t, this, key2);\n};\n\nconst easeCubicIn = function (t)\n{\n    t = t * t * t;\n    return t;\n};\n\nKey.easeCubicIn = function (t, key2)\n{\n    t = easeCubicIn(t);\n    return Key.linear(t, this, key2);\n};\n\n\n// b 0\n// c 1/2 or 1\n// d always 1\n// easeOutCubic: function (x, t, b, c, d) {\n//     return c*((t=t/d-1)*t*t + 1) + b;\n\nKey.easeInQuint = function (t, key2)\n{\n    t = t * t * t * t * t;\n    return Key.linear(t, this, key2);\n};\nKey.easeOutQuint = function (t, key2)\n{\n    t = (t -= 1) * t * t * t * t + 1;\n    return Key.linear(t, this, key2);\n};\nKey.easeInOutQuint = function (t, key2)\n{\n    if ((t /= 0.5) < 1) t = 0.5 * t * t * t * t * t;\n    else t = 0.5 * ((t -= 2) * t * t * t * t + 2);\n    return Key.linear(t, this, key2);\n};\n\nKey.easeInQuart = function (t, key2)\n{\n    t = t * t * t * t;\n    return Key.linear(t, this, key2);\n};\n\nKey.easeOutQuart = function (t, key2)\n{\n    // return -c * ((t=t/d-1)*t*t*t - 1) + b;\n    t = -1 * ((t -= 1) * t * t * t - 1);\n    return Key.linear(t, this, key2);\n};\n\nKey.easeInOutQuart = function (t, key2)\n{\n    if ((t /= 0.5) < 1) t = 0.5 * t * t * t * t;\n    else t = -0.5 * ((t -= 2) * t * t * t - 2);\n    return Key.linear(t, this, key2);\n};\n\nKey.bounce = function (t)\n{\n    if ((t /= 1) < 1 / 2.75) t = 7.5625 * t * t;\n    else if (t < 2 / 2.75) t = 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;\n    else if (t < 2.5 / 2.75) t = 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;\n    else t = 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;\n    return t;\n};\n\nKey.easeInBounce = function (t, key2)\n{\n    return Key.linear(Key.bounce(t), this, key2);\n    // return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d);\n};\n\nKey.easeOutBounce = function (t, key2)\n{\n    return Key.linear(Key.bounce(t), this, key2);\n};\n\nKey.easeInElastic = function (t, key2)\n{\n    let s = 1.70158;\n    let p = 0;\n    let a = 1;\n\n    const b = 0;\n    const d = 1;\n    const c = 1;\n\n    if (t === 0) t = b;\n    else if ((t /= d) == 1) t = b + c;\n    else\n    {\n        if (!p) p = d * 0.3;\n        if (a < Math.abs(c))\n        {\n            a = c;\n            s = p / 4;\n        }\n        else s = (p / (2 * Math.PI)) * Math.asin(c / a);\n        t = -(a * 2 ** (10 * (t -= 1)) * Math.sin(((t * d - s) * (2 * Math.PI)) / p)) + b;\n    }\n\n    return Key.linear(t, this, key2);\n};\n\n\nKey.easeOutElastic = function (t, key2)\n{\n    let s = 1.70158;\n    let p = 0;\n    let a = 1;\n\n    const b = 0;\n    const d = 1;\n    const c = 1;\n\n    if (t === 0) t = b;\n    else if ((t /= d) == 1) t = b + c;\n    else\n    {\n        if (!p) p = d * 0.3;\n        if (a < Math.abs(c))\n        {\n            a = c;\n            s = p / 4;\n        }\n        else s = (p / (2 * Math.PI)) * Math.asin(c / a);\n        t = a * 2 ** (-10 * t) * Math.sin(((t * d - s) * (2 * Math.PI)) / p) + c + b;\n    }\n\n    return Key.linear(t, this, key2);\n};\n\nKey.easeInBack = function (t, key2)\n{\n    const s = 1.70158;\n    t = t * t * ((s + 1) * t - s);\n\n    return Key.linear(t, this, key2);\n};\n\nKey.easeOutBack = function (t, key2)\n{\n    const s = 1.70158;\n    t = (t = t / 1 - 1) * t * ((s + 1) * t + s) + 1;\n\n    return Key.linear(t, this, key2);\n};\n\nKey.easeInOutBack = function (t, key2)\n{\n    let s = 1.70158;\n    const c = 1 / 2;\n    if ((t /= 1 / 2) < 1) t = c * (t * t * (((s *= 1.525) + 1) * t - s));\n    else t = c * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n\n    return Key.linear(t, this, key2);\n};\n\nconst easeCubicOut = function (t)\n{\n    t--;\n    t = t * t * t + 1;\n    return t;\n};\n\nKey.easeCubicOut = function (t, key2)\n{\n    t = easeCubicOut(t);\n    return Key.linear(t, this, key2);\n};\n\nconst easeCubicInOut = function (t)\n{\n    t *= 2;\n    if (t < 1) t = 0.5 * t * t * t;\n    else\n    {\n        t -= 2;\n        t = 0.5 * (t * t * t + 2);\n    }\n    return t;\n};\n\nKey.easeCubicInOut = function (t, key2)\n{\n    t = easeCubicInOut(t);\n    return Key.linear(t, this, key2);\n};\n\nKey.easeSmoothStep = function (perc, key2)\n{\n    // var x = Math.max(0, Math.min(1, (perc-0)/(1-0)));\n    const x = Math.max(0, Math.min(1, perc));\n    perc = x * x * (3 - 2 * x); // smoothstep\n    return Key.linear(perc, this, key2);\n};\n\nKey.easeSmootherStep = function (perc, key2)\n{\n    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));\n    perc = x * x * x * (x * (x * 6 - 15) + 10); // smootherstep\n    return Key.linear(perc, this, key2);\n};\n\nKey.prototype.setEasing = function (e)\n{\n    this._easing = e;\n\n    if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_LINEAR) this.ease = Key.easeLinear;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_ABSOLUTE) this.ease = Key.easeAbsolute;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_SMOOTHSTEP) this.ease = Key.easeSmoothStep;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_SMOOTHERSTEP) this.ease = Key.easeSmootherStep;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_CUBIC_IN) this.ease = Key.easeCubicIn;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_CUBIC_OUT) this.ease = Key.easeCubicOut;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_CUBIC_INOUT) this.ease = Key.easeCubicInOut;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_EXPO_IN) this.ease = Key.easeExpoIn;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_EXPO_OUT) this.ease = Key.easeExpoOut;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_EXPO_INOUT) this.ease = Key.easeExpoInOut;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_SIN_IN) this.ease = Key.easeSinIn;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_SIN_OUT) this.ease = Key.easeSinOut;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_SIN_INOUT) this.ease = Key.easeSinInOut;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_BACK_OUT) this.ease = Key.easeOutBack;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_BACK_IN) this.ease = Key.easeInBack;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_BACK_INOUT) this.ease = Key.easeInOutBack;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_ELASTIC_IN) this.ease = Key.easeInElastic;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_ELASTIC_OUT) this.ease = Key.easeOutElastic;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_ELASTIC_INOUT) this.ease = Key.easeElasticInOut;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_BOUNCE_IN) this.ease = Key.easeInBounce;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_BOUNCE_OUT) this.ease = Key.easeOutBounce;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_QUART_OUT) this.ease = Key.easeOutQuart;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_QUART_IN) this.ease = Key.easeInQuart;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_QUART_INOUT) this.ease = Key.easeInOutQuart;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_QUINT_OUT) this.ease = Key.easeOutQuint;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_QUINT_IN) this.ease = Key.easeInQuint;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_QUINT_INOUT) this.ease = Key.easeInOutQuint;\n    else if (this._easing == _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_CUBICSPLINE)\n    {\n        // this._updateBezier = true;\n        this.ease = Key.easeCubicSpline;\n    }\n    else\n    {\n        this._easing = _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.ANIM.EASING_LINEAR;\n        this.ease = Key.easeLinear;\n    }\n};\n\nKey.prototype.trigger = function ()\n{\n    this.cb();\n    this.cbTriggered = true;\n};\n\nKey.prototype.setValue = function (v)\n{\n    this.value = v;\n    // this._updateBezier = true;\n    if (this.onChange !== null) this.onChange();\n};\n\nKey.prototype.set = function (obj)\n{\n    if (obj)\n    {\n        if (obj.e) this.setEasing(obj.e);\n        if (obj.cb)\n        {\n            this.cb = obj.cb;\n            this.cbTriggered = false;\n        }\n\n        if (obj.b)\n        {\n            // this.bezTime = obj.b[0];\n            // this.bezValue = obj.b[1];\n            // this.bezTimeIn = obj.b[2];\n            // this.bezValueIn = obj.b[3];\n            // this._updateBezier = true;\n        }\n\n        if (obj.hasOwnProperty(\"t\")) this.time = obj.t;\n        if (obj.hasOwnProperty(\"time\")) this.time = obj.time;\n        if (obj.hasOwnProperty(\"v\")) this.value = obj.v;\n        else if (obj.hasOwnProperty(\"value\")) this.value = obj.value;\n    }\n    if (this.onChange !== null) this.onChange();\n};\n\nKey.prototype.getSerialized = function ()\n{\n    const obj = {};\n    obj.t = this.time;\n    obj.v = this.value;\n    obj.e = this._easing;\n    // if (this._easing == CONSTANTS.ANIM.EASING_CUBICSPLINE) obj.b = [this.bezTime, this.bezValue, this.bezTimeIn, this.bezValueIn];\n\n    return obj;\n};\n\nKey.prototype.getEasing = function ()\n{\n    return this._easing;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9hbmltX2tleS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvYW5pbV9rZXkuanM/Yjg0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcblxuY29uc3QgS2V5ID0gZnVuY3Rpb24gKG9iailcbntcbiAgICB0aGlzLnRpbWUgPSAwLjA7XG4gICAgdGhpcy52YWx1ZSA9IDAuMDtcbiAgICAvLyB0aGlzLnVpID0gbnVsbDtcbiAgICB0aGlzLm9uQ2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLl9lYXNpbmcgPSAwO1xuICAgIC8vIHRoaXMuYmV6VGFuZ0luID0gMDtcbiAgICAvLyB0aGlzLmJlelRhbmdPdXQgPSAwO1xuICAgIC8vIHRoaXMuYmV6VGltZSA9IDAuNTtcbiAgICAvLyB0aGlzLmJlelZhbHVlID0gMDtcbiAgICAvLyB0aGlzLmJlelRpbWVJbiA9IC0wLjU7XG4gICAgLy8gdGhpcy5iZXpWYWx1ZUluID0gMDtcblxuICAgIHRoaXMuY2IgPSBudWxsO1xuICAgIHRoaXMuY2JUcmlnZ2VyZWQgPSBmYWxzZTtcblxuICAgIC8vIGNvbnN0IGJlemllckFuaW0gPSBudWxsO1xuICAgIC8vIHRoaXMuX3VwZGF0ZUJlemllciA9IGZhbHNlO1xuXG4gICAgdGhpcy5zZXRFYXNpbmcoQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0xJTkVBUik7XG4gICAgdGhpcy5zZXQob2JqKTtcbn07XG5cbktleS5jdWJpY1NwbGluZSA9IGZ1bmN0aW9uIChwZXJjLCBrZXkxLCBrZXkyKVxue1xuICAgIGxldFxuICAgICAgICBwcmV2aW91c1BvaW50ID0ga2V5MS52YWx1ZSxcbiAgICAgICAgcHJldmlvdXNUYW5nZW50ID0ga2V5MS5iZXpUYW5nT3V0LFxuICAgICAgICBuZXh0UG9pbnQgPSBrZXkyLnZhbHVlLFxuICAgICAgICBuZXh0VGFuZ2VudCA9IGtleTIuYmV6VGFuZ0luO1xuICAgIGxldCB0ID0gcGVyYztcbiAgICBsZXQgdDIgPSB0ICogdDtcbiAgICBsZXQgdDMgPSB0MiAqIHQ7XG5cbiAgICByZXR1cm4gKDIgKiB0MyAtIDMgKiB0MiArIDEpICogcHJldmlvdXNQb2ludCArICh0MyAtIDIgKiB0MiArIHQpICogcHJldmlvdXNUYW5nZW50ICsgKC0yICogdDMgKyAzICogdDIpICogbmV4dFBvaW50ICsgKHQzIC0gdDIpICogbmV4dFRhbmdlbnQ7XG59O1xuXG5LZXkuZWFzZUN1YmljU3BsaW5lID0gZnVuY3Rpb24gKHBlcmMsIGtleTIpXG57XG4gICAgcmV0dXJuIEtleS5jdWJpY1NwbGluZShwZXJjLCB0aGlzLCBrZXkyKTtcbn07XG5cblxuS2V5LmxpbmVhciA9IGZ1bmN0aW9uIChwZXJjLCBrZXkxLCBrZXkyKVxue1xuICAgIHJldHVybiBwYXJzZUZsb2F0KGtleTEudmFsdWUpICsgcGFyc2VGbG9hdChrZXkyLnZhbHVlIC0ga2V5MS52YWx1ZSkgKiBwZXJjO1xufTtcblxuS2V5LmVhc2VMaW5lYXIgPSBmdW5jdGlvbiAocGVyYywga2V5MilcbntcbiAgICByZXR1cm4gS2V5LmxpbmVhcihwZXJjLCB0aGlzLCBrZXkyKTtcbn07XG5cbktleS5lYXNlQWJzb2x1dGUgPSBmdW5jdGlvbiAocGVyYywga2V5MilcbntcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5cbmV4cG9ydCBjb25zdCBlYXNlRXhwb0luID0gZnVuY3Rpb24gKHQpXG57XG4gICAgcmV0dXJuICh0ID0gMiAqKiAoMTAgKiAodCAtIDEpKSk7XG59O1xuXG5LZXkuZWFzZUV4cG9JbiA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHQgPSBlYXNlRXhwb0luKHQpO1xuICAgIHJldHVybiBLZXkubGluZWFyKHQsIHRoaXMsIGtleTIpO1xufTtcblxuZXhwb3J0IGNvbnN0IGVhc2VFeHBvT3V0ID0gZnVuY3Rpb24gKHQpXG57XG4gICAgdCA9IC0oMiAqKiAoLTEwICogdCkpICsgMTtcbiAgICByZXR1cm4gdDtcbn07XG5cbktleS5lYXNlRXhwb091dCA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHQgPSBlYXNlRXhwb091dCh0KTtcbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbmV4cG9ydCBjb25zdCBlYXNlRXhwb0luT3V0ID0gZnVuY3Rpb24gKHQpXG57XG4gICAgdCAqPSAyO1xuICAgIGlmICh0IDwgMSlcbiAgICB7XG4gICAgICAgIHQgPSAwLjUgKiAyICoqICgxMCAqICh0IC0gMSkpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0LS07XG4gICAgICAgIHQgPSAwLjUgKiAoLSgyICoqICgtMTAgKiB0KSkgKyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuXG5LZXkuZWFzZUV4cG9Jbk91dCA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHQgPSBlYXNlRXhwb0luT3V0KHQpO1xuICAgIHJldHVybiBLZXkubGluZWFyKHQsIHRoaXMsIGtleTIpO1xufTtcblxuS2V5LmVhc2VTaW5JbiA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHQgPSAtMSAqIE1hdGguY29zKCh0ICogTWF0aC5QSSkgLyAyKSArIDE7XG4gICAgcmV0dXJuIEtleS5saW5lYXIodCwgdGhpcywga2V5Mik7XG59O1xuXG5LZXkuZWFzZVNpbk91dCA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHQgPSBNYXRoLnNpbigodCAqIE1hdGguUEkpIC8gMik7XG4gICAgcmV0dXJuIEtleS5saW5lYXIodCwgdGhpcywga2V5Mik7XG59O1xuXG5LZXkuZWFzZVNpbkluT3V0ID0gZnVuY3Rpb24gKHQsIGtleTIpXG57XG4gICAgdCA9IC0wLjUgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQpIC0gMS4wKTtcbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbmV4cG9ydCBjb25zdCBlYXNlQ3ViaWNJbiA9IGZ1bmN0aW9uICh0KVxue1xuICAgIHQgPSB0ICogdCAqIHQ7XG4gICAgcmV0dXJuIHQ7XG59O1xuXG5LZXkuZWFzZUN1YmljSW4gPSBmdW5jdGlvbiAodCwga2V5MilcbntcbiAgICB0ID0gZWFzZUN1YmljSW4odCk7XG4gICAgcmV0dXJuIEtleS5saW5lYXIodCwgdGhpcywga2V5Mik7XG59O1xuXG5cbi8vIGIgMFxuLy8gYyAxLzIgb3IgMVxuLy8gZCBhbHdheXMgMVxuLy8gZWFzZU91dEN1YmljOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xuLy8gICAgIHJldHVybiBjKigodD10L2QtMSkqdCp0ICsgMSkgKyBiO1xuXG5LZXkuZWFzZUluUXVpbnQgPSBmdW5jdGlvbiAodCwga2V5MilcbntcbiAgICB0ID0gdCAqIHQgKiB0ICogdCAqIHQ7XG4gICAgcmV0dXJuIEtleS5saW5lYXIodCwgdGhpcywga2V5Mik7XG59O1xuS2V5LmVhc2VPdXRRdWludCA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHQgPSAodCAtPSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxO1xuICAgIHJldHVybiBLZXkubGluZWFyKHQsIHRoaXMsIGtleTIpO1xufTtcbktleS5lYXNlSW5PdXRRdWludCA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIGlmICgodCAvPSAwLjUpIDwgMSkgdCA9IDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0O1xuICAgIGVsc2UgdCA9IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKTtcbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbktleS5lYXNlSW5RdWFydCA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHQgPSB0ICogdCAqIHQgKiB0O1xuICAgIHJldHVybiBLZXkubGluZWFyKHQsIHRoaXMsIGtleTIpO1xufTtcblxuS2V5LmVhc2VPdXRRdWFydCA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIC8vIHJldHVybiAtYyAqICgodD10L2QtMSkqdCp0KnQgLSAxKSArIGI7XG4gICAgdCA9IC0xICogKCh0IC09IDEpICogdCAqIHQgKiB0IC0gMSk7XG4gICAgcmV0dXJuIEtleS5saW5lYXIodCwgdGhpcywga2V5Mik7XG59O1xuXG5LZXkuZWFzZUluT3V0UXVhcnQgPSBmdW5jdGlvbiAodCwga2V5MilcbntcbiAgICBpZiAoKHQgLz0gMC41KSA8IDEpIHQgPSAwLjUgKiB0ICogdCAqIHQgKiB0O1xuICAgIGVsc2UgdCA9IC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKTtcbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbktleS5ib3VuY2UgPSBmdW5jdGlvbiAodClcbntcbiAgICBpZiAoKHQgLz0gMSkgPCAxIC8gMi43NSkgdCA9IDcuNTYyNSAqIHQgKiB0O1xuICAgIGVsc2UgaWYgKHQgPCAyIC8gMi43NSkgdCA9IDcuNTYyNSAqICh0IC09IDEuNSAvIDIuNzUpICogdCArIDAuNzU7XG4gICAgZWxzZSBpZiAodCA8IDIuNSAvIDIuNzUpIHQgPSA3LjU2MjUgKiAodCAtPSAyLjI1IC8gMi43NSkgKiB0ICsgMC45Mzc1O1xuICAgIGVsc2UgdCA9IDcuNTYyNSAqICh0IC09IDIuNjI1IC8gMi43NSkgKiB0ICsgMC45ODQzNzU7XG4gICAgcmV0dXJuIHQ7XG59O1xuXG5LZXkuZWFzZUluQm91bmNlID0gZnVuY3Rpb24gKHQsIGtleTIpXG57XG4gICAgcmV0dXJuIEtleS5saW5lYXIoS2V5LmJvdW5jZSh0KSwgdGhpcywga2V5Mik7XG4gICAgLy8gcmV0dXJuIGMgLSBqUXVlcnkuZWFzaW5nLmVhc2VPdXRCb3VuY2UgKHgsIGQtdCwgMCwgYywgZCk7XG59O1xuXG5LZXkuZWFzZU91dEJvdW5jZSA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHJldHVybiBLZXkubGluZWFyKEtleS5ib3VuY2UodCksIHRoaXMsIGtleTIpO1xufTtcblxuS2V5LmVhc2VJbkVsYXN0aWMgPSBmdW5jdGlvbiAodCwga2V5MilcbntcbiAgICBsZXQgcyA9IDEuNzAxNTg7XG4gICAgbGV0IHAgPSAwO1xuICAgIGxldCBhID0gMTtcblxuICAgIGNvbnN0IGIgPSAwO1xuICAgIGNvbnN0IGQgPSAxO1xuICAgIGNvbnN0IGMgPSAxO1xuXG4gICAgaWYgKHQgPT09IDApIHQgPSBiO1xuICAgIGVsc2UgaWYgKCh0IC89IGQpID09IDEpIHQgPSBiICsgYztcbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiAoIXApIHAgPSBkICogMC4zO1xuICAgICAgICBpZiAoYSA8IE1hdGguYWJzKGMpKVxuICAgICAgICB7XG4gICAgICAgICAgICBhID0gYztcbiAgICAgICAgICAgIHMgPSBwIC8gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHMgPSAocCAvICgyICogTWF0aC5QSSkpICogTWF0aC5hc2luKGMgLyBhKTtcbiAgICAgICAgdCA9IC0oYSAqIDIgKiogKDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKCh0ICogZCAtIHMpICogKDIgKiBNYXRoLlBJKSkgLyBwKSkgKyBiO1xuICAgIH1cblxuICAgIHJldHVybiBLZXkubGluZWFyKHQsIHRoaXMsIGtleTIpO1xufTtcblxuXG5LZXkuZWFzZU91dEVsYXN0aWMgPSBmdW5jdGlvbiAodCwga2V5MilcbntcbiAgICBsZXQgcyA9IDEuNzAxNTg7XG4gICAgbGV0IHAgPSAwO1xuICAgIGxldCBhID0gMTtcblxuICAgIGNvbnN0IGIgPSAwO1xuICAgIGNvbnN0IGQgPSAxO1xuICAgIGNvbnN0IGMgPSAxO1xuXG4gICAgaWYgKHQgPT09IDApIHQgPSBiO1xuICAgIGVsc2UgaWYgKCh0IC89IGQpID09IDEpIHQgPSBiICsgYztcbiAgICBlbHNlXG4gICAge1xuICAgICAgICBpZiAoIXApIHAgPSBkICogMC4zO1xuICAgICAgICBpZiAoYSA8IE1hdGguYWJzKGMpKVxuICAgICAgICB7XG4gICAgICAgICAgICBhID0gYztcbiAgICAgICAgICAgIHMgPSBwIC8gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHMgPSAocCAvICgyICogTWF0aC5QSSkpICogTWF0aC5hc2luKGMgLyBhKTtcbiAgICAgICAgdCA9IGEgKiAyICoqICgtMTAgKiB0KSAqIE1hdGguc2luKCgodCAqIGQgLSBzKSAqICgyICogTWF0aC5QSSkpIC8gcCkgKyBjICsgYjtcbiAgICB9XG5cbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbktleS5lYXNlSW5CYWNrID0gZnVuY3Rpb24gKHQsIGtleTIpXG57XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgdCA9IHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG5cbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbktleS5lYXNlT3V0QmFjayA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHQgPSAodCA9IHQgLyAxIC0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xuXG4gICAgcmV0dXJuIEtleS5saW5lYXIodCwgdGhpcywga2V5Mik7XG59O1xuXG5LZXkuZWFzZUluT3V0QmFjayA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIGxldCBzID0gMS43MDE1ODtcbiAgICBjb25zdCBjID0gMSAvIDI7XG4gICAgaWYgKCh0IC89IDEgLyAyKSA8IDEpIHQgPSBjICogKHQgKiB0ICogKCgocyAqPSAxLjUyNSkgKyAxKSAqIHQgLSBzKSk7XG4gICAgZWxzZSB0ID0gYyAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9IDEuNTI1KSArIDEpICogdCArIHMpICsgMik7XG5cbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbmV4cG9ydCBjb25zdCBlYXNlQ3ViaWNPdXQgPSBmdW5jdGlvbiAodClcbntcbiAgICB0LS07XG4gICAgdCA9IHQgKiB0ICogdCArIDE7XG4gICAgcmV0dXJuIHQ7XG59O1xuXG5LZXkuZWFzZUN1YmljT3V0ID0gZnVuY3Rpb24gKHQsIGtleTIpXG57XG4gICAgdCA9IGVhc2VDdWJpY091dCh0KTtcbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbmV4cG9ydCBjb25zdCBlYXNlQ3ViaWNJbk91dCA9IGZ1bmN0aW9uICh0KVxue1xuICAgIHQgKj0gMjtcbiAgICBpZiAodCA8IDEpIHQgPSAwLjUgKiB0ICogdCAqIHQ7XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdCAtPSAyO1xuICAgICAgICB0ID0gMC41ICogKHQgKiB0ICogdCArIDIpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5cbktleS5lYXNlQ3ViaWNJbk91dCA9IGZ1bmN0aW9uICh0LCBrZXkyKVxue1xuICAgIHQgPSBlYXNlQ3ViaWNJbk91dCh0KTtcbiAgICByZXR1cm4gS2V5LmxpbmVhcih0LCB0aGlzLCBrZXkyKTtcbn07XG5cbktleS5lYXNlU21vb3RoU3RlcCA9IGZ1bmN0aW9uIChwZXJjLCBrZXkyKVxue1xuICAgIC8vIHZhciB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHBlcmMtMCkvKDEtMCkpKTtcbiAgICBjb25zdCB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgcGVyYykpO1xuICAgIHBlcmMgPSB4ICogeCAqICgzIC0gMiAqIHgpOyAvLyBzbW9vdGhzdGVwXG4gICAgcmV0dXJuIEtleS5saW5lYXIocGVyYywgdGhpcywga2V5Mik7XG59O1xuXG5LZXkuZWFzZVNtb290aGVyU3RlcCA9IGZ1bmN0aW9uIChwZXJjLCBrZXkyKVxue1xuICAgIGNvbnN0IHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAocGVyYyAtIDApIC8gKDEgLSAwKSkpO1xuICAgIHBlcmMgPSB4ICogeCAqIHggKiAoeCAqICh4ICogNiAtIDE1KSArIDEwKTsgLy8gc21vb3RoZXJzdGVwXG4gICAgcmV0dXJuIEtleS5saW5lYXIocGVyYywgdGhpcywga2V5Mik7XG59O1xuXG5LZXkucHJvdG90eXBlLnNldEVhc2luZyA9IGZ1bmN0aW9uIChlKVxue1xuICAgIHRoaXMuX2Vhc2luZyA9IGU7XG5cbiAgICBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19MSU5FQVIpIHRoaXMuZWFzZSA9IEtleS5lYXNlTGluZWFyO1xuICAgIGVsc2UgaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQUJTT0xVVEUpIHRoaXMuZWFzZSA9IEtleS5lYXNlQWJzb2x1dGU7XG4gICAgZWxzZSBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19TTU9PVEhTVEVQKSB0aGlzLmVhc2UgPSBLZXkuZWFzZVNtb290aFN0ZXA7XG4gICAgZWxzZSBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19TTU9PVEhFUlNURVApIHRoaXMuZWFzZSA9IEtleS5lYXNlU21vb3RoZXJTdGVwO1xuICAgIGVsc2UgaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQ1VCSUNfSU4pIHRoaXMuZWFzZSA9IEtleS5lYXNlQ3ViaWNJbjtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0NVQklDX09VVCkgdGhpcy5lYXNlID0gS2V5LmVhc2VDdWJpY091dDtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0NVQklDX0lOT1VUKSB0aGlzLmVhc2UgPSBLZXkuZWFzZUN1YmljSW5PdXQ7XG4gICAgZWxzZSBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19FWFBPX0lOKSB0aGlzLmVhc2UgPSBLZXkuZWFzZUV4cG9JbjtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0VYUE9fT1VUKSB0aGlzLmVhc2UgPSBLZXkuZWFzZUV4cG9PdXQ7XG4gICAgZWxzZSBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19FWFBPX0lOT1VUKSB0aGlzLmVhc2UgPSBLZXkuZWFzZUV4cG9Jbk91dDtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1NJTl9JTikgdGhpcy5lYXNlID0gS2V5LmVhc2VTaW5JbjtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1NJTl9PVVQpIHRoaXMuZWFzZSA9IEtleS5lYXNlU2luT3V0O1xuICAgIGVsc2UgaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfU0lOX0lOT1VUKSB0aGlzLmVhc2UgPSBLZXkuZWFzZVNpbkluT3V0O1xuICAgIGVsc2UgaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQkFDS19PVVQpIHRoaXMuZWFzZSA9IEtleS5lYXNlT3V0QmFjaztcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0JBQ0tfSU4pIHRoaXMuZWFzZSA9IEtleS5lYXNlSW5CYWNrO1xuICAgIGVsc2UgaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQkFDS19JTk9VVCkgdGhpcy5lYXNlID0gS2V5LmVhc2VJbk91dEJhY2s7XG4gICAgZWxzZSBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19FTEFTVElDX0lOKSB0aGlzLmVhc2UgPSBLZXkuZWFzZUluRWxhc3RpYztcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0VMQVNUSUNfT1VUKSB0aGlzLmVhc2UgPSBLZXkuZWFzZU91dEVsYXN0aWM7XG4gICAgZWxzZSBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19FTEFTVElDX0lOT1VUKSB0aGlzLmVhc2UgPSBLZXkuZWFzZUVsYXN0aWNJbk91dDtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0JPVU5DRV9JTikgdGhpcy5lYXNlID0gS2V5LmVhc2VJbkJvdW5jZTtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0JPVU5DRV9PVVQpIHRoaXMuZWFzZSA9IEtleS5lYXNlT3V0Qm91bmNlO1xuICAgIGVsc2UgaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfUVVBUlRfT1VUKSB0aGlzLmVhc2UgPSBLZXkuZWFzZU91dFF1YXJ0O1xuICAgIGVsc2UgaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfUVVBUlRfSU4pIHRoaXMuZWFzZSA9IEtleS5lYXNlSW5RdWFydDtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX1FVQVJUX0lOT1VUKSB0aGlzLmVhc2UgPSBLZXkuZWFzZUluT3V0UXVhcnQ7XG4gICAgZWxzZSBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19RVUlOVF9PVVQpIHRoaXMuZWFzZSA9IEtleS5lYXNlT3V0UXVpbnQ7XG4gICAgZWxzZSBpZiAodGhpcy5fZWFzaW5nID09IENPTlNUQU5UUy5BTklNLkVBU0lOR19RVUlOVF9JTikgdGhpcy5lYXNlID0gS2V5LmVhc2VJblF1aW50O1xuICAgIGVsc2UgaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfUVVJTlRfSU5PVVQpIHRoaXMuZWFzZSA9IEtleS5lYXNlSW5PdXRRdWludDtcbiAgICBlbHNlIGlmICh0aGlzLl9lYXNpbmcgPT0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0NVQklDU1BMSU5FKVxuICAgIHtcbiAgICAgICAgLy8gdGhpcy5fdXBkYXRlQmV6aWVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lYXNlID0gS2V5LmVhc2VDdWJpY1NwbGluZTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5fZWFzaW5nID0gQ09OU1RBTlRTLkFOSU0uRUFTSU5HX0xJTkVBUjtcbiAgICAgICAgdGhpcy5lYXNlID0gS2V5LmVhc2VMaW5lYXI7XG4gICAgfVxufTtcblxuS2V5LnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLmNiKCk7XG4gICAgdGhpcy5jYlRyaWdnZXJlZCA9IHRydWU7XG59O1xuXG5LZXkucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHYpXG57XG4gICAgdGhpcy52YWx1ZSA9IHY7XG4gICAgLy8gdGhpcy5fdXBkYXRlQmV6aWVyID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5vbkNoYW5nZSAhPT0gbnVsbCkgdGhpcy5vbkNoYW5nZSgpO1xufTtcblxuS2V5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2JqKVxue1xuICAgIGlmIChvYmopXG4gICAge1xuICAgICAgICBpZiAob2JqLmUpIHRoaXMuc2V0RWFzaW5nKG9iai5lKTtcbiAgICAgICAgaWYgKG9iai5jYilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jYiA9IG9iai5jYjtcbiAgICAgICAgICAgIHRoaXMuY2JUcmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmouYilcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gdGhpcy5iZXpUaW1lID0gb2JqLmJbMF07XG4gICAgICAgICAgICAvLyB0aGlzLmJlelZhbHVlID0gb2JqLmJbMV07XG4gICAgICAgICAgICAvLyB0aGlzLmJlelRpbWVJbiA9IG9iai5iWzJdO1xuICAgICAgICAgICAgLy8gdGhpcy5iZXpWYWx1ZUluID0gb2JqLmJbM107XG4gICAgICAgICAgICAvLyB0aGlzLl91cGRhdGVCZXppZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShcInRcIikpIHRoaXMudGltZSA9IG9iai50O1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KFwidGltZVwiKSkgdGhpcy50aW1lID0gb2JqLnRpbWU7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoXCJ2XCIpKSB0aGlzLnZhbHVlID0gb2JqLnY7XG4gICAgICAgIGVsc2UgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKSB0aGlzLnZhbHVlID0gb2JqLnZhbHVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5vbkNoYW5nZSAhPT0gbnVsbCkgdGhpcy5vbkNoYW5nZSgpO1xufTtcblxuS2V5LnByb3RvdHlwZS5nZXRTZXJpYWxpemVkID0gZnVuY3Rpb24gKClcbntcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBvYmoudCA9IHRoaXMudGltZTtcbiAgICBvYmoudiA9IHRoaXMudmFsdWU7XG4gICAgb2JqLmUgPSB0aGlzLl9lYXNpbmc7XG4gICAgLy8gaWYgKHRoaXMuX2Vhc2luZyA9PSBDT05TVEFOVFMuQU5JTS5FQVNJTkdfQ1VCSUNTUExJTkUpIG9iai5iID0gW3RoaXMuYmV6VGltZSwgdGhpcy5iZXpWYWx1ZSwgdGhpcy5iZXpUaW1lSW4sIHRoaXMuYmV6VmFsdWVJbl07XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuS2V5LnByb3RvdHlwZS5nZXRFYXNpbmcgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9lYXNpbmc7XG59O1xuXG5leHBvcnQgeyBLZXkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/anim_key.js\n");

/***/ }),

/***/ "./src/core/banchprofiler.js":
/*!***********************************!*\
  !*** ./src/core/banchprofiler.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Branch\": () => (/* binding */ Branch),\n/* harmony export */   \"BranchStack\": () => (/* binding */ BranchStack)\n/* harmony export */ });\nclass Branch\n{\n    constructor(name)\n    {\n        this.name = name;\n        this.dur = 0;\n        this._startTime = 0;\n        this.childs = [];\n    }\n\n    start()\n    {\n        this._startTime = performance.now();\n    }\n\n    end()\n    {\n        this.dur = performance.now() - this._startTime;\n    }\n\n    push(name)\n    {\n        const b = new Branch(name);\n        this.childs.push(b);\n        b.start();\n        return b;\n    }\n\n    print(level)\n    {\n        level = level || 0;\n\n        let str = \"\";\n        for (let i = 0; i < level; i++) str += \"  \";\n\n        for (let i = 0; i < this.childs.length; i++)\n        {\n            this.childs[i].print(level + 1);\n        }\n    }\n}\n\n// //////////////////////////////////////////\n\nclass BranchStack\n{\n    constructor()\n    {\n    }\n\n    start()\n    {\n        this.root = new Branch(\"Root\");\n        this.root.start();\n\n        this.current = this.root;\n    }\n\n    push(name)\n    {\n        if (!this.current) this.start();\n\n        const prev = this.current;\n        this.current = this.current.push(name);\n        this.current.prev = prev;\n        this.current.start();\n        return this.current;\n    }\n\n    pop()\n    {\n        if (!this.current) return;\n        this.current.end();\n        this.current = this.current.prev;\n    }\n\n    finish()\n    {\n        this.current.end();\n        this.root.print();\n        this.current = null;\n    }\n}\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9iYW5jaHByb2ZpbGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvYmFuY2hwcm9maWxlci5qcz9iNmVmIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEJyYW5jaFxue1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpXG4gICAge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmR1ciA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMuY2hpbGRzID0gW107XG4gICAgfVxuXG4gICAgc3RhcnQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuXG4gICAgZW5kKClcbiAgICB7XG4gICAgICAgIHRoaXMuZHVyID0gcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLl9zdGFydFRpbWU7XG4gICAgfVxuXG4gICAgcHVzaChuYW1lKVxuICAgIHtcbiAgICAgICAgY29uc3QgYiA9IG5ldyBCcmFuY2gobmFtZSk7XG4gICAgICAgIHRoaXMuY2hpbGRzLnB1c2goYik7XG4gICAgICAgIGIuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxuXG4gICAgcHJpbnQobGV2ZWwpXG4gICAge1xuICAgICAgICBsZXZlbCA9IGxldmVsIHx8IDA7XG5cbiAgICAgICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWw7IGkrKykgc3RyICs9IFwiICBcIjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkc1tpXS5wcmludChsZXZlbCArIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuY2xhc3MgQnJhbmNoU3RhY2tcbntcbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgIH1cblxuICAgIHN0YXJ0KClcbiAgICB7XG4gICAgICAgIHRoaXMucm9vdCA9IG5ldyBCcmFuY2goXCJSb290XCIpO1xuICAgICAgICB0aGlzLnJvb3Quc3RhcnQoKTtcblxuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnJvb3Q7XG4gICAgfVxuXG4gICAgcHVzaChuYW1lKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnQpIHRoaXMuc3RhcnQoKTtcblxuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5jdXJyZW50O1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmN1cnJlbnQucHVzaChuYW1lKTtcbiAgICAgICAgdGhpcy5jdXJyZW50LnByZXYgPSBwcmV2O1xuICAgICAgICB0aGlzLmN1cnJlbnQuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgICB9XG5cbiAgICBwb3AoKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnQpIHJldHVybjtcbiAgICAgICAgdGhpcy5jdXJyZW50LmVuZCgpO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmN1cnJlbnQucHJldjtcbiAgICB9XG5cbiAgICBmaW5pc2goKVxuICAgIHtcbiAgICAgICAgdGhpcy5jdXJyZW50LmVuZCgpO1xuICAgICAgICB0aGlzLnJvb3QucHJpbnQoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEJyYW5jaFN0YWNrIH07XG5leHBvcnQgeyBCcmFuY2ggfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/banchprofiler.js\n");

/***/ }),

/***/ "./src/core/base64.js":
/*!****************************!*\
  !*** ./src/core/base64.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"b64decTypedArray\": () => (/* binding */ b64decTypedArray),\n/* harmony export */   \"b64encTypesArray\": () => (/* binding */ b64encTypesArray),\n/* harmony export */   \"base64Chars\": () => (/* binding */ base64Chars),\n/* harmony export */   \"base64lookup\": () => (/* binding */ base64lookup)\n/* harmony export */ });\nconst base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n// Use a lookup table to find the index.\nconst _base64lookup = new Uint8Array(256);\nfor (let i = 0; i < base64Chars.length; i++) _base64lookup[base64Chars.charCodeAt(i)] = i;\n\nconst base64lookup = _base64lookup;\n\nconst b64encTypesArray = function (arraybuffer)\n{\n    if (arraybuffer.buffer) arraybuffer = arraybuffer.buffer;\n    let bytes = new Uint8Array(arraybuffer),\n        i,\n        len = bytes.length,\n        base64 = \"\";\n\n    for (i = 0; i < len; i += 3)\n    {\n        base64 += base64Chars[bytes[i] >> 2];\n        base64 += base64Chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += base64Chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += base64Chars[bytes[i + 2] & 63];\n    }\n\n    if (len % 3 === 2) base64 = base64.substring(0, base64.length - 1) + \"=\";\n    else if (len % 3 === 1) base64 = base64.substring(0, base64.length - 2) + \"==\";\n\n    return base64;\n};\n\nconst b64decTypedArray = function (base64)\n{\n    let bufferLength = base64.length * 0.75,\n        len = base64.length,\n        i,\n        p = 0,\n        encoded1,\n        encoded2,\n        encoded3,\n        encoded4;\n\n    if (base64[base64.length - 1] === \"=\")\n    {\n        bufferLength--;\n        if (base64[base64.length - 2] === \"=\") bufferLength--;\n    }\n\n    let arraybuffer = new ArrayBuffer(bufferLength),\n        bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i += 4)\n    {\n        encoded1 = base64lookup[base64.charCodeAt(i)];\n        encoded2 = base64lookup[base64.charCodeAt(i + 1)];\n        encoded3 = base64lookup[base64.charCodeAt(i + 2)];\n        encoded4 = base64lookup[base64.charCodeAt(i + 3)];\n\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9iYXNlNjQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvYmFzZTY0LmpzPzQ5MDMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGJhc2U2NENoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG5cbi8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cbmNvbnN0IF9iYXNlNjRsb29rdXAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBiYXNlNjRDaGFycy5sZW5ndGg7IGkrKykgX2Jhc2U2NGxvb2t1cFtiYXNlNjRDaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG5cbmV4cG9ydCBjb25zdCBiYXNlNjRsb29rdXAgPSBfYmFzZTY0bG9va3VwO1xuXG5leHBvcnQgY29uc3QgYjY0ZW5jVHlwZXNBcnJheSA9IGZ1bmN0aW9uIChhcnJheWJ1ZmZlcilcbntcbiAgICBpZiAoYXJyYXlidWZmZXIuYnVmZmVyKSBhcnJheWJ1ZmZlciA9IGFycmF5YnVmZmVyLmJ1ZmZlcjtcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG4gICAgICAgIGksXG4gICAgICAgIGxlbiA9IGJ5dGVzLmxlbmd0aCxcbiAgICAgICAgYmFzZTY0ID0gXCJcIjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMylcbiAgICB7XG4gICAgICAgIGJhc2U2NCArPSBiYXNlNjRDaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgICAgYmFzZTY0ICs9IGJhc2U2NENoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgICBiYXNlNjQgKz0gYmFzZTY0Q2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgICAgYmFzZTY0ICs9IGJhc2U2NENoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG5cbiAgICBpZiAobGVuICUgMyA9PT0gMikgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICBlbHNlIGlmIChsZW4gJSAzID09PSAxKSBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcblxuICAgIHJldHVybiBiYXNlNjQ7XG59O1xuXG5leHBvcnQgY29uc3QgYjY0ZGVjVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChiYXNlNjQpXG57XG4gICAgbGV0IGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LFxuICAgICAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLFxuICAgICAgICBpLFxuICAgICAgICBwID0gMCxcbiAgICAgICAgZW5jb2RlZDEsXG4gICAgICAgIGVuY29kZWQyLFxuICAgICAgICBlbmNvZGVkMyxcbiAgICAgICAgZW5jb2RlZDQ7XG5cbiAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gXCI9XCIpXG4gICAge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSBidWZmZXJMZW5ndGgtLTtcbiAgICB9XG5cbiAgICBsZXQgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcbiAgICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpXG4gICAge1xuICAgICAgICBlbmNvZGVkMSA9IGJhc2U2NGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKV07XG4gICAgICAgIGVuY29kZWQyID0gYmFzZTY0bG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAxKV07XG4gICAgICAgIGVuY29kZWQzID0gYmFzZTY0bG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAyKV07XG4gICAgICAgIGVuY29kZWQ0ID0gYmFzZTY0bG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG5cbiAgICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5YnVmZmVyO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/base64.js\n");

/***/ }),

/***/ "./src/core/cg/cg_boundingbox.js":
/*!***************************************!*\
  !*** ./src/core/cg/cg_boundingbox.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BoundingBox\": () => (/* binding */ BoundingBox)\n/* harmony export */ });\n\n\n/**\n * bounding box\n * @class\n * @external CGL\n * @namespace BoundingBox\n * @param {Geometry} geometry or bounding box\n */\nclass BoundingBox\n{\n    constructor(geom)\n    {\n        this._init();\n        this._first = true;\n        this._wireMesh = null;\n\n        if (geom) this.apply(geom);\n    }\n\n    _init()\n    {\n        this._max = [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE];\n        this._min = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE];\n        this._center = [0, 0, 0];\n        this._size = [0, 0, 0];\n        this._maxAxis = 0.0;\n        this._first = true;\n    }\n\n    /**\n     * get biggest number of maxX,maxY,maxZ\n     * @type {Number}\n     */\n    get maxAxis() { return this._maxAxis || 1; }\n\n    /**\n     * size of bounding box\n     * @type {vec3}\n     */\n    get size() { return this._size; }\n\n    /**\n     * center of bounding box\n     * @type {vec3}\n     */\n    get center() { return this._center; }\n\n    /**\n     * center x\n     * @type {Number}\n     */\n    get x() { return this._center[0]; }\n\n    /**\n     * center y\n     * @type {Number}\n     */\n    get y() { return this._center[1]; }\n\n    /**\n     * center z\n     * @type {Number}\n     */\n    get z() { return this._center[2]; }\n\n\n    /**\n     * minimum x\n     * @type {Number}\n     */\n    get minX() { return this._min[0]; }\n\n    /**\n     * minimum y\n     * @type {Number}\n     */\n    get minY() { return this._min[1]; }\n\n    /**\n     * minimum z\n     * @type {Number}\n     */\n    get minZ() { return this._min[2]; }\n\n    /**\n     * maximum x\n     * @type {Number}\n     */\n    get maxX() { return this._max[0]; }\n\n    /**\n     * maximum y\n     * @type {Number}\n     */\n    get maxY() { return this._max[1]; }\n\n    /**\n     * maximum z\n     * @type {Number}\n     */\n    get maxZ() { return this._max[2]; }\n\n\n    apply(geom, mat)\n    {\n        if (!geom)\n        {\n            // console.warn(\"[boundingbox] no geom/vertices\", geom);\n            return;\n        }\n\n        if (geom instanceof BoundingBox)\n        {\n            const bb = geom;\n\n            this.applyPos(bb.maxX, bb.maxY, bb.maxZ);\n            this.applyPos(bb.minX, bb.minY, bb.minZ);\n        }\n        else\n        {\n            for (let i = 0; i < geom.vertices.length; i += 3)\n                // if (geom.vertices[i] == geom.vertices[i] || geom.vertices[i] != null)\n                // {\n            // if(mat)\n            // {\n                this.applyPos(geom.vertices[i], geom.vertices[i + 1], geom.vertices[i + 2]);\n            // }\n            // else\n            // {\n            //     this.applyPos(geom.vertices[i + 0],geom.vertices[i + 1],geom.vertices[i + 2]);\n            // }\n                // }\n        }\n        this.calcCenterSize();\n    }\n\n    /**\n     * returns a copy of the bounding box\n     * @function copy\n     * @memberof BoundingBox\n     * @instance\n     */\n    copy()\n    {\n        return new BoundingBox(this);\n    }\n\n    get changed()\n    {\n        return !(this._max[0] == -Number.MAX_VALUE && this._max[1] == -Number.MAX_VALUE && this._max[2] == -Number.MAX_VALUE);\n    }\n\n    applyPos(x, y, z)\n    {\n        if (x == Number.MAX_VALUE || x == -Number.MAX_VALUE ||\n            y == Number.MAX_VALUE || y == -Number.MAX_VALUE ||\n            z == Number.MAX_VALUE || z == -Number.MAX_VALUE) return;\n\n        if (!CABLES.UTILS.isNumeric(x) || !CABLES.UTILS.isNumeric(y) || !CABLES.UTILS.isNumeric(z)) return;\n\n        if (this._first)\n        {\n            this._max[0] = x;\n            this._max[1] = y;\n            this._max[2] = z;\n\n            this._min[0] = x;\n            this._min[1] = y;\n            this._min[2] = z;\n            this._first = false;\n            return;\n        }\n\n        this._max[0] = Math.max(this._max[0], x);\n        this._max[1] = Math.max(this._max[1], y);\n        this._max[2] = Math.max(this._max[2], z);\n\n        this._min[0] = Math.min(this._min[0], x);\n        this._min[1] = Math.min(this._min[1], y);\n        this._min[2] = Math.min(this._min[2], z);\n    }\n\n    calcCenterSize()\n    {\n        if (this._first) return;\n        // this._size[0]=Math.abs(this._min[0])+Math.abs(this._max[0]);\n        // this._size[1]=Math.abs(this._min[1])+Math.abs(this._max[1]);\n        // this._size[2]=Math.abs(this._min[2])+Math.abs(this._max[2]);\n        this._size[0] = this._max[0] - this._min[0];\n        this._size[1] = this._max[1] - this._min[1];\n        this._size[2] = this._max[2] - this._min[2];\n\n        this._center[0] = (this._min[0] + this._max[0]) / 2;\n        this._center[1] = (this._min[1] + this._max[1]) / 2;\n        this._center[2] = (this._min[2] + this._max[2]) / 2;\n\n        this._maxAxis = Math.max(this._size[2], Math.max(this._size[0], this._size[1]));\n    }\n\n    mulMat4(m)\n    {\n        if (this._first)\n        {\n            this._max[0] = 0;\n            this._max[1] = 0;\n            this._max[2] = 0;\n\n            this._min[0] = 0;\n            this._min[1] = 0;\n            this._min[2] = 0;\n            this._first = false;\n        }\n        vec3.transformMat4(this._max, this._max, m);\n        vec3.transformMat4(this._min, this._min, m);\n        this.calcCenterSize();\n    }\n\n    render(cgl, shader)\n    {\n        if (!this._wireMesh) this._wireMesh = new CGL.WireCube(cgl);\n\n        cgl.pushModelMatrix();\n        mat4.translate(cgl.mMatrix, cgl.mMatrix, this._center);\n        this._wireMesh.render(cgl, this._size[0] / 2, this._size[1] / 2, this._size[2] / 2);\n        cgl.popModelMatrix();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9jZ19ib3VuZGluZ2JveC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZy9jZ19ib3VuZGluZ2JveC5qcz9jMjQ5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IEJvdW5kaW5nQm94IH07XG5cbi8qKlxuICogYm91bmRpbmcgYm94XG4gKiBAY2xhc3NcbiAqIEBleHRlcm5hbCBDR0xcbiAqIEBuYW1lc3BhY2UgQm91bmRpbmdCb3hcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5IG9yIGJvdW5kaW5nIGJveFxuICovXG5jbGFzcyBCb3VuZGluZ0JveFxue1xuICAgIGNvbnN0cnVjdG9yKGdlb20pXG4gICAge1xuICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fd2lyZU1lc2ggPSBudWxsO1xuXG4gICAgICAgIGlmIChnZW9tKSB0aGlzLmFwcGx5KGdlb20pO1xuICAgIH1cblxuICAgIF9pbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMuX21heCA9IFstTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFXTtcbiAgICAgICAgdGhpcy5fbWluID0gW051bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUVdO1xuICAgICAgICB0aGlzLl9jZW50ZXIgPSBbMCwgMCwgMF07XG4gICAgICAgIHRoaXMuX3NpemUgPSBbMCwgMCwgMF07XG4gICAgICAgIHRoaXMuX21heEF4aXMgPSAwLjA7XG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgYmlnZ2VzdCBudW1iZXIgb2YgbWF4WCxtYXhZLG1heFpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBtYXhBeGlzKCkgeyByZXR1cm4gdGhpcy5fbWF4QXhpcyB8fCAxOyB9XG5cbiAgICAvKipcbiAgICAgKiBzaXplIG9mIGJvdW5kaW5nIGJveFxuICAgICAqIEB0eXBlIHt2ZWMzfVxuICAgICAqL1xuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5fc2l6ZTsgfVxuXG4gICAgLyoqXG4gICAgICogY2VudGVyIG9mIGJvdW5kaW5nIGJveFxuICAgICAqIEB0eXBlIHt2ZWMzfVxuICAgICAqL1xuICAgIGdldCBjZW50ZXIoKSB7IHJldHVybiB0aGlzLl9jZW50ZXI7IH1cblxuICAgIC8qKlxuICAgICAqIGNlbnRlciB4XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgeCgpIHsgcmV0dXJuIHRoaXMuX2NlbnRlclswXTsgfVxuXG4gICAgLyoqXG4gICAgICogY2VudGVyIHlcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB5KCkgeyByZXR1cm4gdGhpcy5fY2VudGVyWzFdOyB9XG5cbiAgICAvKipcbiAgICAgKiBjZW50ZXIgelxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHooKSB7IHJldHVybiB0aGlzLl9jZW50ZXJbMl07IH1cblxuXG4gICAgLyoqXG4gICAgICogbWluaW11bSB4XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbWluWCgpIHsgcmV0dXJuIHRoaXMuX21pblswXTsgfVxuXG4gICAgLyoqXG4gICAgICogbWluaW11bSB5XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbWluWSgpIHsgcmV0dXJuIHRoaXMuX21pblsxXTsgfVxuXG4gICAgLyoqXG4gICAgICogbWluaW11bSB6XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbWluWigpIHsgcmV0dXJuIHRoaXMuX21pblsyXTsgfVxuXG4gICAgLyoqXG4gICAgICogbWF4aW11bSB4XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbWF4WCgpIHsgcmV0dXJuIHRoaXMuX21heFswXTsgfVxuXG4gICAgLyoqXG4gICAgICogbWF4aW11bSB5XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbWF4WSgpIHsgcmV0dXJuIHRoaXMuX21heFsxXTsgfVxuXG4gICAgLyoqXG4gICAgICogbWF4aW11bSB6XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbWF4WigpIHsgcmV0dXJuIHRoaXMuX21heFsyXTsgfVxuXG5cbiAgICBhcHBseShnZW9tLCBtYXQpXG4gICAge1xuICAgICAgICBpZiAoIWdlb20pXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihcIltib3VuZGluZ2JveF0gbm8gZ2VvbS92ZXJ0aWNlc1wiLCBnZW9tKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZW9tIGluc3RhbmNlb2YgQm91bmRpbmdCb3gpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGJiID0gZ2VvbTtcblxuICAgICAgICAgICAgdGhpcy5hcHBseVBvcyhiYi5tYXhYLCBiYi5tYXhZLCBiYi5tYXhaKTtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlQb3MoYmIubWluWCwgYmIubWluWSwgYmIubWluWik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdlb20udmVydGljZXMubGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICAgICAgLy8gaWYgKGdlb20udmVydGljZXNbaV0gPT0gZ2VvbS52ZXJ0aWNlc1tpXSB8fCBnZW9tLnZlcnRpY2VzW2ldICE9IG51bGwpXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgLy8gaWYobWF0KVxuICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlQb3MoZ2VvbS52ZXJ0aWNlc1tpXSwgZ2VvbS52ZXJ0aWNlc1tpICsgMV0sIGdlb20udmVydGljZXNbaSArIDJdKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIGVsc2VcbiAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLmFwcGx5UG9zKGdlb20udmVydGljZXNbaSArIDBdLGdlb20udmVydGljZXNbaSArIDFdLGdlb20udmVydGljZXNbaSArIDJdKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxjQ2VudGVyU2l6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgYSBjb3B5IG9mIHRoZSBib3VuZGluZyBib3hcbiAgICAgKiBAZnVuY3Rpb24gY29weVxuICAgICAqIEBtZW1iZXJvZiBCb3VuZGluZ0JveFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvcHkoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXQgY2hhbmdlZCgpXG4gICAge1xuICAgICAgICByZXR1cm4gISh0aGlzLl9tYXhbMF0gPT0gLU51bWJlci5NQVhfVkFMVUUgJiYgdGhpcy5fbWF4WzFdID09IC1OdW1iZXIuTUFYX1ZBTFVFICYmIHRoaXMuX21heFsyXSA9PSAtTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgfVxuXG4gICAgYXBwbHlQb3MoeCwgeSwgeilcbiAgICB7XG4gICAgICAgIGlmICh4ID09IE51bWJlci5NQVhfVkFMVUUgfHwgeCA9PSAtTnVtYmVyLk1BWF9WQUxVRSB8fFxuICAgICAgICAgICAgeSA9PSBOdW1iZXIuTUFYX1ZBTFVFIHx8IHkgPT0gLU51bWJlci5NQVhfVkFMVUUgfHxcbiAgICAgICAgICAgIHogPT0gTnVtYmVyLk1BWF9WQUxVRSB8fCB6ID09IC1OdW1iZXIuTUFYX1ZBTFVFKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCFDQUJMRVMuVVRJTFMuaXNOdW1lcmljKHgpIHx8ICFDQUJMRVMuVVRJTFMuaXNOdW1lcmljKHkpIHx8ICFDQUJMRVMuVVRJTFMuaXNOdW1lcmljKHopKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZpcnN0KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9tYXhbMF0gPSB4O1xuICAgICAgICAgICAgdGhpcy5fbWF4WzFdID0geTtcbiAgICAgICAgICAgIHRoaXMuX21heFsyXSA9IHo7XG5cbiAgICAgICAgICAgIHRoaXMuX21pblswXSA9IHg7XG4gICAgICAgICAgICB0aGlzLl9taW5bMV0gPSB5O1xuICAgICAgICAgICAgdGhpcy5fbWluWzJdID0gejtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tYXhbMF0gPSBNYXRoLm1heCh0aGlzLl9tYXhbMF0sIHgpO1xuICAgICAgICB0aGlzLl9tYXhbMV0gPSBNYXRoLm1heCh0aGlzLl9tYXhbMV0sIHkpO1xuICAgICAgICB0aGlzLl9tYXhbMl0gPSBNYXRoLm1heCh0aGlzLl9tYXhbMl0sIHopO1xuXG4gICAgICAgIHRoaXMuX21pblswXSA9IE1hdGgubWluKHRoaXMuX21pblswXSwgeCk7XG4gICAgICAgIHRoaXMuX21pblsxXSA9IE1hdGgubWluKHRoaXMuX21pblsxXSwgeSk7XG4gICAgICAgIHRoaXMuX21pblsyXSA9IE1hdGgubWluKHRoaXMuX21pblsyXSwgeik7XG4gICAgfVxuXG4gICAgY2FsY0NlbnRlclNpemUoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZpcnN0KSByZXR1cm47XG4gICAgICAgIC8vIHRoaXMuX3NpemVbMF09TWF0aC5hYnModGhpcy5fbWluWzBdKStNYXRoLmFicyh0aGlzLl9tYXhbMF0pO1xuICAgICAgICAvLyB0aGlzLl9zaXplWzFdPU1hdGguYWJzKHRoaXMuX21pblsxXSkrTWF0aC5hYnModGhpcy5fbWF4WzFdKTtcbiAgICAgICAgLy8gdGhpcy5fc2l6ZVsyXT1NYXRoLmFicyh0aGlzLl9taW5bMl0pK01hdGguYWJzKHRoaXMuX21heFsyXSk7XG4gICAgICAgIHRoaXMuX3NpemVbMF0gPSB0aGlzLl9tYXhbMF0gLSB0aGlzLl9taW5bMF07XG4gICAgICAgIHRoaXMuX3NpemVbMV0gPSB0aGlzLl9tYXhbMV0gLSB0aGlzLl9taW5bMV07XG4gICAgICAgIHRoaXMuX3NpemVbMl0gPSB0aGlzLl9tYXhbMl0gLSB0aGlzLl9taW5bMl07XG5cbiAgICAgICAgdGhpcy5fY2VudGVyWzBdID0gKHRoaXMuX21pblswXSArIHRoaXMuX21heFswXSkgLyAyO1xuICAgICAgICB0aGlzLl9jZW50ZXJbMV0gPSAodGhpcy5fbWluWzFdICsgdGhpcy5fbWF4WzFdKSAvIDI7XG4gICAgICAgIHRoaXMuX2NlbnRlclsyXSA9ICh0aGlzLl9taW5bMl0gKyB0aGlzLl9tYXhbMl0pIC8gMjtcblxuICAgICAgICB0aGlzLl9tYXhBeGlzID0gTWF0aC5tYXgodGhpcy5fc2l6ZVsyXSwgTWF0aC5tYXgodGhpcy5fc2l6ZVswXSwgdGhpcy5fc2l6ZVsxXSkpO1xuICAgIH1cblxuICAgIG11bE1hdDQobSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9maXJzdClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbWF4WzBdID0gMDtcbiAgICAgICAgICAgIHRoaXMuX21heFsxXSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9tYXhbMl0gPSAwO1xuXG4gICAgICAgICAgICB0aGlzLl9taW5bMF0gPSAwO1xuICAgICAgICAgICAgdGhpcy5fbWluWzFdID0gMDtcbiAgICAgICAgICAgIHRoaXMuX21pblsyXSA9IDA7XG4gICAgICAgICAgICB0aGlzLl9maXJzdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZlYzMudHJhbnNmb3JtTWF0NCh0aGlzLl9tYXgsIHRoaXMuX21heCwgbSk7XG4gICAgICAgIHZlYzMudHJhbnNmb3JtTWF0NCh0aGlzLl9taW4sIHRoaXMuX21pbiwgbSk7XG4gICAgICAgIHRoaXMuY2FsY0NlbnRlclNpemUoKTtcbiAgICB9XG5cbiAgICByZW5kZXIoY2dsLCBzaGFkZXIpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX3dpcmVNZXNoKSB0aGlzLl93aXJlTWVzaCA9IG5ldyBDR0wuV2lyZUN1YmUoY2dsKTtcblxuICAgICAgICBjZ2wucHVzaE1vZGVsTWF0cml4KCk7XG4gICAgICAgIG1hdDQudHJhbnNsYXRlKGNnbC5tTWF0cml4LCBjZ2wubU1hdHJpeCwgdGhpcy5fY2VudGVyKTtcbiAgICAgICAgdGhpcy5fd2lyZU1lc2gucmVuZGVyKGNnbCwgdGhpcy5fc2l6ZVswXSAvIDIsIHRoaXMuX3NpemVbMV0gLyAyLCB0aGlzLl9zaXplWzJdIC8gMik7XG4gICAgICAgIGNnbC5wb3BNb2RlbE1hdHJpeCgpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cg/cg_boundingbox.js\n");

/***/ }),

/***/ "./src/core/cg/cg_canvas.js":
/*!**********************************!*\
  !*** ./src/core/cg/cg_canvas.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CgCanvas\": () => (/* binding */ CgCanvas)\n/* harmony export */ });\nclass CgCanvas\n{\n    constructor(options)\n    {\n        if (!options)\n        {\n            console.error(\"CgCanvas no options\");\n        }\n        else\n        {\n            this._canvasEle = options.canvasEle;\n        }\n\n        if (!options.cg)console.error(\"CgCanvas options has no cg\");\n        if (!options.canvasEle)console.error(\"CgCanvas options has no canvasEle\");\n\n        this._cg = options.cg;\n        this.pixelDensity = 1;\n        this.canvasWidth = this.canvasEle.clientWidth;\n        this.canvasHeight = this.canvasEle.clientHeight;\n\n        this._oldWidthRp = -1;\n        this._oldHeightRp = -1;\n\n        this.setSize(this.canvasWidth, this.canvasHeight);\n    }\n\n    get canvasEle() { return this._canvasEle; }\n\n\n    setSize(w, h, ignorestyle)\n    {\n        if (this._oldWidthRp != w * this.pixelDensity || this._oldHeightRp != h * this.pixelDensity)\n        {\n            this._oldWidthRp = this.canvasEle.width = w * this.pixelDensity;\n            this._oldHeightRp = this.canvasEle.height = h * this.pixelDensity;\n\n            if (!ignorestyle)\n            {\n                this.canvasEle.style.width = w + \"px\";\n                this.canvasEle.style.height = h + \"px\";\n            }\n\n            this.updateSize();\n\n            this._cg.emitEvent(\"resize\");\n        }\n    }\n\n    updateSize()\n    {\n        this.canvasEle.width = this.canvasWidth = this.canvasEle.clientWidth * this.pixelDensity;\n        this.canvasEle.height = this.canvasHeight = this.canvasEle.clientHeight * this.pixelDensity;\n    }\n\n    dispose()\n    {\n        this._canvasEle.remove();\n        this._canvasEle = null;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9jZ19jYW52YXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2cvY2dfY2FudmFzLmpzPzdlZmMiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgQ2dDYW52YXNcbntcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKVxuICAgIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2dDYW52YXMgbm8gb3B0aW9uc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhc0VsZSA9IG9wdGlvbnMuY2FudmFzRWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmNnKWNvbnNvbGUuZXJyb3IoXCJDZ0NhbnZhcyBvcHRpb25zIGhhcyBubyBjZ1wiKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmNhbnZhc0VsZSljb25zb2xlLmVycm9yKFwiQ2dDYW52YXMgb3B0aW9ucyBoYXMgbm8gY2FudmFzRWxlXCIpO1xuXG4gICAgICAgIHRoaXMuX2NnID0gb3B0aW9ucy5jZztcbiAgICAgICAgdGhpcy5waXhlbERlbnNpdHkgPSAxO1xuICAgICAgICB0aGlzLmNhbnZhc1dpZHRoID0gdGhpcy5jYW52YXNFbGUuY2xpZW50V2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzSGVpZ2h0ID0gdGhpcy5jYW52YXNFbGUuY2xpZW50SGVpZ2h0O1xuXG4gICAgICAgIHRoaXMuX29sZFdpZHRoUnAgPSAtMTtcbiAgICAgICAgdGhpcy5fb2xkSGVpZ2h0UnAgPSAtMTtcblxuICAgICAgICB0aGlzLnNldFNpemUodGhpcy5jYW52YXNXaWR0aCwgdGhpcy5jYW52YXNIZWlnaHQpO1xuICAgIH1cblxuICAgIGdldCBjYW52YXNFbGUoKSB7IHJldHVybiB0aGlzLl9jYW52YXNFbGU7IH1cblxuXG4gICAgc2V0U2l6ZSh3LCBoLCBpZ25vcmVzdHlsZSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9vbGRXaWR0aFJwICE9IHcgKiB0aGlzLnBpeGVsRGVuc2l0eSB8fCB0aGlzLl9vbGRIZWlnaHRScCAhPSBoICogdGhpcy5waXhlbERlbnNpdHkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX29sZFdpZHRoUnAgPSB0aGlzLmNhbnZhc0VsZS53aWR0aCA9IHcgKiB0aGlzLnBpeGVsRGVuc2l0eTtcbiAgICAgICAgICAgIHRoaXMuX29sZEhlaWdodFJwID0gdGhpcy5jYW52YXNFbGUuaGVpZ2h0ID0gaCAqIHRoaXMucGl4ZWxEZW5zaXR5O1xuXG4gICAgICAgICAgICBpZiAoIWlnbm9yZXN0eWxlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzRWxlLnN0eWxlLndpZHRoID0gdyArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0VsZS5zdHlsZS5oZWlnaHQgPSBoICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcblxuICAgICAgICAgICAgdGhpcy5fY2cuZW1pdEV2ZW50KFwicmVzaXplXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlU2l6ZSgpXG4gICAge1xuICAgICAgICB0aGlzLmNhbnZhc0VsZS53aWR0aCA9IHRoaXMuY2FudmFzV2lkdGggPSB0aGlzLmNhbnZhc0VsZS5jbGllbnRXaWR0aCAqIHRoaXMucGl4ZWxEZW5zaXR5O1xuICAgICAgICB0aGlzLmNhbnZhc0VsZS5oZWlnaHQgPSB0aGlzLmNhbnZhc0hlaWdodCA9IHRoaXMuY2FudmFzRWxlLmNsaWVudEhlaWdodCAqIHRoaXMucGl4ZWxEZW5zaXR5O1xuICAgIH1cblxuICAgIGRpc3Bvc2UoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2FudmFzRWxlLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLl9jYW52YXNFbGUgPSBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQ2dDYW52YXMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cg/cg_canvas.js\n");

/***/ }),

/***/ "./src/core/cg/cg_constants.js":
/*!*************************************!*\
  !*** ./src/core/cg/cg_constants.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CG\": () => (/* binding */ CG)\n/* harmony export */ });\n/* harmony import */ var _cg_boundingbox_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cg_boundingbox.js */ \"./src/core/cg/cg_boundingbox.js\");\n/* harmony import */ var _cg_canvas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cg_canvas.js */ \"./src/core/cg/cg_canvas.js\");\n/* harmony import */ var _cg_geom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cg_geom.js */ \"./src/core/cg/cg_geom.js\");\n/* harmony import */ var _sg_fpscounter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sg_fpscounter.js */ \"./src/core/cg/sg_fpscounter.js\");\n\n\n\n\n\nconst CG = {\n\n    \"GAPI_WEBGL\": 0,\n    \"GAPI_WEBGPU\": 1,\n\n    \"DEPTH_COMPARE_NEVER\": 0,\n    \"DEPTH_COMPARE_LESS\": 1,\n    \"DEPTH_COMPARE_EQUAL\": 2,\n    \"DEPTH_COMPARE_LESSEQUAL\": 3,\n    \"DEPTH_COMPARE_GREATER\": 4,\n    \"DEPTH_COMPARE_NOTEQUAL\": 5,\n    \"DEPTH_COMPARE_GREATEREQUAL\": 6,\n    \"DEPTH_COMPARE_ALWAYS\": 7,\n\n    \"CULL_NONE\": 0,\n    \"CULL_BACK\": 1,\n    \"CULL_FRONT\": 2,\n    \"CULL_BOTH\": 3,\n\n\n    \"Geometry\": _cg_geom_js__WEBPACK_IMPORTED_MODULE_0__.Geometry,\n    \"BoundingBox\": _cg_boundingbox_js__WEBPACK_IMPORTED_MODULE_1__.BoundingBox,\n    \"FpsCounter\": _sg_fpscounter_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n\n    \"CgCanvas\": _cg_canvas_js__WEBPACK_IMPORTED_MODULE_3__.CgCanvas\n};\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9jZ19jb25zdGFudHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2cvY2dfY29uc3RhbnRzLmpzP2Y3MmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQm91bmRpbmdCb3ggfSBmcm9tIFwiLi9jZ19ib3VuZGluZ2JveC5qc1wiO1xuaW1wb3J0IHsgQ2dDYW52YXMgfSBmcm9tIFwiLi9jZ19jYW52YXMuanNcIjtcbmltcG9ydCB7IEdlb21ldHJ5IH0gZnJvbSBcIi4vY2dfZ2VvbS5qc1wiO1xuaW1wb3J0IEZwc0NvdW50ZXIgZnJvbSBcIi4vc2dfZnBzY291bnRlci5qc1wiO1xuXG5jb25zdCBDRyA9IHtcblxuICAgIFwiR0FQSV9XRUJHTFwiOiAwLFxuICAgIFwiR0FQSV9XRUJHUFVcIjogMSxcblxuICAgIFwiREVQVEhfQ09NUEFSRV9ORVZFUlwiOiAwLFxuICAgIFwiREVQVEhfQ09NUEFSRV9MRVNTXCI6IDEsXG4gICAgXCJERVBUSF9DT01QQVJFX0VRVUFMXCI6IDIsXG4gICAgXCJERVBUSF9DT01QQVJFX0xFU1NFUVVBTFwiOiAzLFxuICAgIFwiREVQVEhfQ09NUEFSRV9HUkVBVEVSXCI6IDQsXG4gICAgXCJERVBUSF9DT01QQVJFX05PVEVRVUFMXCI6IDUsXG4gICAgXCJERVBUSF9DT01QQVJFX0dSRUFURVJFUVVBTFwiOiA2LFxuICAgIFwiREVQVEhfQ09NUEFSRV9BTFdBWVNcIjogNyxcblxuICAgIFwiQ1VMTF9OT05FXCI6IDAsXG4gICAgXCJDVUxMX0JBQ0tcIjogMSxcbiAgICBcIkNVTExfRlJPTlRcIjogMixcbiAgICBcIkNVTExfQk9USFwiOiAzLFxuXG5cbiAgICBcIkdlb21ldHJ5XCI6IEdlb21ldHJ5LFxuICAgIFwiQm91bmRpbmdCb3hcIjogQm91bmRpbmdCb3gsXG4gICAgXCJGcHNDb3VudGVyXCI6IEZwc0NvdW50ZXIsXG5cbiAgICBcIkNnQ2FudmFzXCI6IENnQ2FudmFzXG59O1xuXG5cbmV4cG9ydCB7IENHIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cg/cg_constants.js\n");

/***/ }),

/***/ "./src/core/cg/cg_geom.js":
/*!********************************!*\
  !*** ./src/core/cg/cg_geom.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Geometry\": () => (/* binding */ Geometry)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"./src/core/utils.js\");\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base64.js */ \"./src/core/base64.js\");\n/* harmony import */ var _cg_boundingbox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cg_boundingbox.js */ \"./src/core/cg/cg_boundingbox.js\");\n// import { vec2, vec3 } from \"gl-matrix\";\n\n\n\n\n\n/**\n * a geometry contains all information about a mesh, vertices, texturecoordinates etc. etc.\n * @external CGL\n * @namespace Geometry\n * @param {String} name\n * @class\n * @example\n * // create a triangle with all attributes\n * const geom=new Geometry(\"triangle\"),\n *\n * geom.vertices = [\n *      0.0,           sizeH.get(),  0.0,\n *     -sizeW.get(),  -sizeH.get(),  0.0,\n *      sizeW.get(),  -sizeH.get(),  0.0 ];\n *\n * geom.vertexNormals = [\n *      0.0,  0.0,  1.0,\n *      0.0,  0.0,  1.0,\n *      0.0,  0.0,  1.0 ];\n *\n * geom.tangents = [\n *     1,0,0,\n *     1,0,0,\n *     1,0,0 ];\n *\n * geom.biTangents = [\n *     0,1,0,\n *     0,1,0,\n *     0,1,0 ];\n *\n * geom.texCoords = [\n *      0.5,  0.0,\n *      1.0,  1.0,\n *      0.0,  1.0, ];\n *\n * geom.verticesIndices = [\n *     0, 1, 2 ];\n *\n */\nconst Geometry = function (name)\n{\n    this.name = name || \"unknown\";\n    this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"cgl_geometry\");\n\n    this.faceVertCount = 3;\n    this.glPrimitive = null;\n    this._attributes = {};\n\n    this._vertices = [];\n    this.verticesIndices = [];\n\n    this.isGeometry = true;\n\n    this.morphTargets = [];\n\n    Object.defineProperty(this, \"vertices\", {\n        get()\n        {\n            return this._vertices;\n        },\n        set(v)\n        {\n            this.setVertices(v);\n        },\n    });\n\n    Object.defineProperty(this, \"texCoords\", {\n        get()\n        {\n            const att = this.getAttribute(\"texCoords\");\n            if (!att) return [];\n            return att.data;\n        },\n        set(v)\n        {\n            this.setAttribute(\"texCoords\", v, 2);\n        },\n    });\n\n    Object.defineProperty(this, \"vertexNormals\", {\n        get()\n        {\n            const att = this.getAttribute(\"vertexNormals\");\n            if (!att) return [];\n            return att.data;\n        },\n        set(v)\n        {\n            this.setAttribute(\"vertexNormals\", v, 3);\n        },\n    });\n\n    Object.defineProperty(this, \"tangents\", {\n        get()\n        {\n            const att = this.getAttribute(\"tangents\");\n            if (!att) return [];\n            return att.data;\n        },\n        set(v)\n        {\n            this.setAttribute(\"tangents\", v, 3);\n        },\n    });\n\n    Object.defineProperty(this, \"biTangents\", {\n        get()\n        {\n            const att = this.getAttribute(\"biTangents\");\n            if (!att) return [];\n            return att.data;\n        },\n        set(v)\n        {\n            this.setAttribute(\"biTangents\", v, 3);\n        },\n    });\n\n    Object.defineProperty(this, \"vertexColors\", {\n        get()\n        {\n            const att = this.getAttribute(\"vertexColors\");\n            if (!att) return [];\n            return att.data;\n        },\n        set(v)\n        {\n            this.setAttribute(\"vertexColors\", v, 4);\n        },\n    });\n};\n\n/**\n * @function clear\n * @memberof Geometry\n * @instance\n * @description clear all buffers/set them to length 0\n */\nGeometry.prototype.clear = function ()\n{\n    this._vertices = new Float32Array([]);\n    this.verticesIndices = [];\n    this.texCoords = new Float32Array([]);\n    this.vertexNormals = new Float32Array([]);\n    this.tangents = [];\n    this.biTangents = [];\n    this._attributes = {};\n};\n\n\n\n/**\n * @function getAttributes\n   @memberof Geometry\n * @instance\n * @return {Array<Object>} returns array of attribute objects\n */\nGeometry.prototype.getAttributes = function ()\n{\n    return this._attributes;\n};\n\n/**\n * @function getAttribute\n * @memberof Geometry\n * @instance\n * @param {String} name\n * @return {Object}\n */\nGeometry.prototype.getAttribute = function (name)\n{\n    for (const i in this._attributes)\n    {\n        if (this._attributes[i].name == name) return this._attributes[i];\n    }\n    return null;\n};\n\n/**\n * @function setAttribute\n * @description create an attribute\n * @memberof Geometry\n * @instance\n * @param {String} name\n * @param {Array} data\n * @param {Number} itemsize\n */\nGeometry.prototype.setAttribute = function (name, arr, itemSize)\n{\n    let attrType = \"\";\n    if (!itemSize || itemSize > 4)\n    {\n        console.log(\"itemsize wrong?\", itemSize, name);\n        this._log.stack(\"itemsize\");\n\n        itemSize = 3;\n    }\n\n    if (itemSize == 1) attrType = \"float\";\n    else if (itemSize == 2) attrType = \"vec2\";\n    else if (itemSize == 3) attrType = \"vec3\";\n    else if (itemSize == 4) attrType = \"vec4\";\n\n\n    const attr = {\n        \"name\": name,\n        \"data\": arr,\n        \"itemSize\": itemSize,\n        \"type\": attrType,\n    };\n\n    this._attributes[name] = attr;\n};\n\nGeometry.prototype.copyAttribute = function (name, newgeom)\n{\n    const attr = this.getAttribute(name);\n    newgeom.setAttribute(name, new Float32Array(attr.data), attr.itemSize);\n};\n\n\n/**\n * @function setVertices\n * @memberof Geometry\n * @instance\n * @description set vertices\n * @param {Array|Float32Array} data [x,y,z,x,y,z,...]\n */\nGeometry.prototype.setVertices = function (arr)\n{\n    if (arr instanceof Float32Array) this._vertices = arr;\n    else this._vertices = new Float32Array(arr);\n};\n\n/**\n * @function setTexCoords\n * @memberof Geometry\n * @instance\n * @description set texcoords\n * @param {Array|Float32Array} data [u,v,u,v,...]\n */\nGeometry.prototype.setTexCoords = function (arr)\n{\n    if (arr instanceof Float32Array) this.texCoords = arr;\n    else this.texCoords = new Float32Array(arr);\n};\n\n// Geometry.prototype.testIndices = function ()\n// {\n//     var foundError = false;\n//     for (var i = 0; i < this.verticesIndices.length; i++)\n//     {\n//         if (this.verticesIndices[i * 3 + 0] >= this._vertices.length / 3 || this.verticesIndices[i * 3 + 1] >= this._vertices.length / 3 || this.verticesIndices[i * 3 + 2] >= this._vertices.length / 3)\n//         {\n//             foundError = true;\n//             console.log(\"index error!\");\n//         }\n//     }\n// };\n\n// deprecated\nGeometry.prototype.calcNormals = function (smooth)\n{\n    const options = { \"smooth\": smooth };\n\n\n    this.calculateNormals(options);\n};\n\n/**\n * @function flipNormals\n * @memberof Geometry\n * @description flip normals\n */\nGeometry.prototype.flipNormals = function (x, y, z)\n{\n    let vec = vec3.create();\n\n    if (x == undefined)x = 1;\n    if (y == undefined)y = 1;\n    if (z == undefined)z = 1;\n\n\n    for (let i = 0; i < this.vertexNormals.length; i += 3)\n    {\n        vec3.set(vec,\n            this.vertexNormals[i + 0],\n            this.vertexNormals[i + 1],\n            this.vertexNormals[i + 2]);\n\n        vec[0] *= -x;\n        vec[1] *= -y;\n        vec[2] *= -z;\n\n        vec3.normalize(vec, vec);\n\n        this.vertexNormals[i + 0] = vec[0];\n        this.vertexNormals[i + 1] = vec[1];\n        this.vertexNormals[i + 2] = vec[2];\n    }\n};\n\nGeometry.prototype.getNumTriangles = function ()\n{\n    if (this.verticesIndices && this.verticesIndices.length) return this.verticesIndices.length / 3;\n    return this.vertices.length / 3;\n};\n\n\n/**\n * @function flipVertDir\n * @memberof Geometry\n * @description flip order of vertices in geom faces\n */\nGeometry.prototype.flipVertDir = function ()\n{\n    const newInd = [];\n    newInd.length = this.verticesIndices.length;\n    for (let i = 0; i < this.verticesIndices.length; i += 3)\n    {\n        newInd[i] = this.verticesIndices[i + 2];\n        newInd[i + 1] = this.verticesIndices[i + 1];\n        newInd[i + 2] = this.verticesIndices[i];\n    }\n    this.verticesIndices = newInd;\n};\n\n\nGeometry.prototype.setPointVertices = function (verts)\n{\n    if (verts.length % 3 !== 0)\n    {\n        this._log.error(\"SetPointVertices: Array must be multiple of three.\");\n        return;\n    }\n\n    if (!(verts instanceof Float32Array)) this.vertices = new Float32Array(verts);\n    else this.vertices = verts;\n\n    if (!(this.texCoords instanceof Float32Array)) this.texCoords = new Float32Array((verts.length / 3) * 2);\n\n    // this.texCoords.length=verts.length/3*2;\n    this.verticesIndices.length = verts.length / 3;\n    // this.verticesIndices=[];\n\n    for (let i = 0; i < verts.length / 3; i++)\n    {\n        this.verticesIndices[i] = i;\n        this.texCoords[i * 2] = 0;\n        this.texCoords[i * 2 + 1] = 0;\n    }\n};\n\n/**\n * merge a different geometry into the this geometry\n * @function merge\n * @param {Geometry} geom\n * @memberof Geometry\n * @instance\n */\nGeometry.prototype.merge = function (geom)\n{\n    if (!geom) return;\n\n    if (this.isIndexed() != geom.isIndexed())\n    {\n        if (this.isIndexed())\n        {\n            this.unIndex(false, true);\n        }\n        if (geom.isIndexed())\n        {\n            const g = geom.copy();\n            g.unIndex(false, true);\n            geom = g;\n        }\n    }\n\n    const oldIndizesLength = this.verticesIndices.length;\n    const vertLength = this._vertices.length / 3;\n\n    this.verticesIndices.length = this.verticesIndices.length + geom.verticesIndices.length;\n    for (let i = 0; i < geom.verticesIndices.length; i++)\n        this.verticesIndices[oldIndizesLength + i] = geom.verticesIndices[i] + vertLength;\n\n    this.vertices = _utils_js__WEBPACK_IMPORTED_MODULE_1__.UTILS.float32Concat(this._vertices, geom.vertices);\n    this.texCoords = _utils_js__WEBPACK_IMPORTED_MODULE_1__.UTILS.float32Concat(this.texCoords, geom.texCoords);\n    this.vertexNormals = _utils_js__WEBPACK_IMPORTED_MODULE_1__.UTILS.float32Concat(this.vertexNormals, geom.vertexNormals);\n    this.tangents = _utils_js__WEBPACK_IMPORTED_MODULE_1__.UTILS.float32Concat(this.tangents, geom.tangents);\n    this.biTangents = _utils_js__WEBPACK_IMPORTED_MODULE_1__.UTILS.float32Concat(this.biTangents, geom.biTangents);\n};\n\n/**\n * create a copy of the geometry\n * @function copy\n * @memberof Geometry\n * @instance\n */\nGeometry.prototype.copy = function ()\n{\n    const geom = new Geometry(this.name + \" copy\");\n    geom.faceVertCount = this.faceVertCount;\n    geom.glPrimitive = this.glPrimitive;\n\n    geom.setVertices(this._vertices.slice(0));\n\n    if (this.verticesIndices)\n    {\n        geom.verticesIndices.length = this.verticesIndices.length;\n        for (let i = 0; i < this.verticesIndices.length; i++) geom.verticesIndices[i] = this.verticesIndices[i];\n    }\n\n    for (let i in this._attributes) this.copyAttribute(i, geom);\n\n    geom.morphTargets.length = this.morphTargets.length;\n    for (let i = 0; i < this.morphTargets.length; i++) geom.morphTargets[i] = this.morphTargets[i];\n\n    return geom;\n};\n\n/**\n * Calculaten normals\n * @function calculateNormals\n * @memberof Geometry\n * @instance\n */\nGeometry.prototype.calculateNormals = function (options)\n{\n    // todo: should check angle of normals to get edges    https://community.khronos.org/t/calculating-accurate-vertex-normals/28152\n    options = options || {};\n    if (options.smooth === false) this.unIndex();\n\n    const u = vec3.create();\n    const v = vec3.create();\n    const n = vec3.create();\n\n    function calcNormal(triangle)\n    {\n        vec3.subtract(u, triangle[0], triangle[1]);\n        vec3.subtract(v, triangle[0], triangle[2]);\n        vec3.cross(n, u, v);\n        vec3.normalize(n, n);\n\n        if (options && options.forceZUp)\n        {\n            if (n[2] < 0)\n            {\n                n[0] *= -1;\n                n[1] *= -1;\n                n[2] *= -1;\n            }\n        }\n        return n;\n    }\n\n    this.getVertexVec = function (which)\n    {\n        const vec = [0, 0, 0];\n        vec[0] = this.vertices[which * 3 + 0];\n        vec[1] = this.vertices[which * 3 + 1];\n        vec[2] = this.vertices[which * 3 + 2];\n        return vec;\n    };\n\n    if (!(this.vertexNormals instanceof Float32Array) || this.vertexNormals.length != this.vertices.length) this.vertexNormals = new Float32Array(this.vertices.length);\n\n    for (let i = 0; i < this.vertices.length; i++)\n    {\n        this.vertexNormals[i] = 0;\n    }\n\n    if (!this.isIndexed())\n    {\n        const norms = [];\n        for (let i = 0; i < this.vertices.length; i += 9)\n        {\n            const triangle = [[this.vertices[i + 0], this.vertices[i + 1], this.vertices[i + 2]], [this.vertices[i + 3], this.vertices[i + 4], this.vertices[i + 5]], [this.vertices[i + 6], this.vertices[i + 7], this.vertices[i + 8]]];\n            const nn = calcNormal(triangle);\n            norms.push(nn[0], nn[1], nn[2], nn[0], nn[1], nn[2], nn[0], nn[1], nn[2]);\n        }\n        this.vertexNormals = norms;\n    }\n    else\n    {\n        const faceNormals = [];\n\n        faceNormals.length = Math.floor(this.verticesIndices.length / 3);\n\n        for (let i = 0; i < this.verticesIndices.length; i += 3)\n        {\n            const triangle = [this.getVertexVec(this.verticesIndices[i + 0]), this.getVertexVec(this.verticesIndices[i + 1]), this.getVertexVec(this.verticesIndices[i + 2])];\n\n            faceNormals[i / 3] = calcNormal(triangle);\n\n            this.vertexNormals[this.verticesIndices[i + 0] * 3 + 0] += faceNormals[i / 3][0];\n            this.vertexNormals[this.verticesIndices[i + 0] * 3 + 1] += faceNormals[i / 3][1];\n            this.vertexNormals[this.verticesIndices[i + 0] * 3 + 2] += faceNormals[i / 3][2];\n\n            this.vertexNormals[this.verticesIndices[i + 1] * 3 + 0] += faceNormals[i / 3][0];\n            this.vertexNormals[this.verticesIndices[i + 1] * 3 + 1] += faceNormals[i / 3][1];\n            this.vertexNormals[this.verticesIndices[i + 1] * 3 + 2] += faceNormals[i / 3][2];\n\n            this.vertexNormals[this.verticesIndices[i + 2] * 3 + 0] += faceNormals[i / 3][0];\n            this.vertexNormals[this.verticesIndices[i + 2] * 3 + 1] += faceNormals[i / 3][1];\n            this.vertexNormals[this.verticesIndices[i + 2] * 3 + 2] += faceNormals[i / 3][2];\n        }\n\n\n        for (let i = 0; i < this.verticesIndices.length; i += 3) // faces\n        {\n            for (let k = 0; k < 3; k++) // triangles\n            {\n                const vv = [this.vertexNormals[this.verticesIndices[i + k] * 3 + 0], this.vertexNormals[this.verticesIndices[i + k] * 3 + 1], this.vertexNormals[this.verticesIndices[i + k] * 3 + 2]];\n                vec3.normalize(vv, vv);\n                this.vertexNormals[this.verticesIndices[i + k] * 3 + 0] = vv[0];\n                this.vertexNormals[this.verticesIndices[i + k] * 3 + 1] = vv[1];\n                this.vertexNormals[this.verticesIndices[i + k] * 3 + 2] = vv[2];\n            }\n        }\n    }\n};\n\n/**\n * Calculates tangents & bitangents with the help of uv-coordinates. Adapted from\n * Lengyel, Eric. “Computing Tangent Space Basis Vectors for an Arbitrary Mesh”.\n * Terathon Software 3D Graphics Library.\n * https://fenix.tecnico.ulisboa.pt/downloadFile/845043405449073/Tangent%20Space%20Calculation.pdf\n *\n * @function calcTangentsBitangents\n * @memberof Geometry\n * @instance\n */\nGeometry.prototype.calcTangentsBitangents = function ()\n{\n    if (!this.vertices.length)\n    {\n        // this._log.error(\"Cannot calculate tangents/bitangents without vertices.\");\n        return;\n    }\n    if (!this.vertexNormals.length)\n    {\n        // this._log.error(\"Cannot calculate tangents/bitangents without normals.\");\n        return;\n    }\n    if (!this.texCoords.length)\n    {\n        // console.warn(\"No texcoords. Replacing with default values [0, 0].\");\n        const texCoordLength = (this.vertices.length / 3) * 2;\n        this.texCoords = new Float32Array(texCoordLength);\n        for (let i = 0; i < texCoordLength; i += 1) this.texCoords[i] = 0;\n    }\n    if (!this.verticesIndices || !this.verticesIndices.length)\n    {\n        // this._log.error(\"Cannot calculate tangents/bitangents without vertex indices.\");\n        return;\n    }\n    // this code assumes that we have three indices per triangle\n    if (this.verticesIndices.length % 3 !== 0)\n    {\n        this._log.error(\"Vertex indices mismatch!\");\n        return;\n    }\n\n    const triangleCount = this.verticesIndices.length / 3;\n    const vertexCount = this.vertices.length / 3;\n\n    this.tangents = new Float32Array(this.vertexNormals.length);\n    this.biTangents = new Float32Array(this.vertexNormals.length);\n\n    // temporary buffers\n    const tempVertices = [];\n    tempVertices.length = vertexCount * 2;\n    const v1 = vec3.create();\n    const v2 = vec3.create();\n    const v3 = vec3.create();\n\n    const w1 = vec2.create();\n    const w2 = vec2.create();\n    const w3 = vec2.create();\n\n    const sdir = vec3.create();\n    const tdir = vec3.create();\n\n    // for details on calculation, see article referenced above\n    for (let tri = 0; tri < triangleCount; tri += 1)\n    {\n        // indices of the three vertices for a triangle\n        const i1 = this.verticesIndices[tri * 3];\n        const i2 = this.verticesIndices[tri * 3 + 1];\n        const i3 = this.verticesIndices[tri * 3 + 2];\n\n        // vertex position as vec3\n        vec3.set(v1, this.vertices[i1 * 3], this.vertices[i1 * 3 + 1], this.vertices[i1 * 3 + 2]);\n        vec3.set(v2, this.vertices[i2 * 3], this.vertices[i2 * 3 + 1], this.vertices[i2 * 3 + 2]);\n        vec3.set(v3, this.vertices[i3 * 3], this.vertices[i3 * 3 + 1], this.vertices[i3 * 3 + 2]);\n\n        // texture coordinate as vec2\n        vec2.set(w1, this.texCoords[i1 * 2], this.texCoords[i1 * 2 + 1]);\n        vec2.set(w2, this.texCoords[i2 * 2], this.texCoords[i2 * 2 + 1]);\n        vec2.set(w3, this.texCoords[i3 * 2], this.texCoords[i3 * 2 + 1]);\n\n        const x1 = v2[0] - v1[0];\n        const x2 = v3[0] - v1[0];\n        const y1 = v2[1] - v1[1];\n        const y2 = v3[1] - v1[1];\n        const z1 = v2[2] - v1[2];\n        const z2 = v3[2] - v1[2];\n\n        const s1 = w2[0] - w1[0];\n        const s2 = w3[0] - w1[0];\n        const t1 = w2[1] - w1[1];\n        const t2 = w3[1] - w1[1];\n\n        const r = 1.0 / (s1 * t2 - s2 * t1);\n\n        vec3.set(sdir, (t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);\n        vec3.set(tdir, (s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);\n\n        tempVertices[i1] = sdir;\n        tempVertices[i2] = sdir;\n        tempVertices[i3] = sdir;\n\n        tempVertices[i1 + vertexCount] = tdir;\n        tempVertices[i2 + vertexCount] = tdir;\n        tempVertices[i3 + vertexCount] = tdir;\n    }\n\n    const normal = vec3.create();\n    const tempVert = vec3.create();\n    const tan = vec3.create();\n    const bitan = vec3.create();\n    const temp1 = vec3.create();\n    const temp2 = vec3.create();\n    const crossPd = vec3.create();\n    const normalized = vec3.create();\n\n    for (let vert = 0; vert < vertexCount; vert += 1)\n    {\n        // NOTE: some meshes don't have index 0 - n in their indexbuffer, if this is the case, skip calculation of this vertex\n        if (!tempVertices[vert]) continue;\n\n        vec3.set(normal, this.vertexNormals[vert * 3], this.vertexNormals[vert * 3 + 1], this.vertexNormals[vert * 3 + 2]);\n        vec3.set(tempVert, tempVertices[vert][0], tempVertices[vert][1], tempVertices[vert][2]);\n\n        // Gram-Schmidt orthagonalize\n        const _dp = vec3.dot(normal, tempVert);\n        vec3.scale(temp1, normal, _dp);\n        vec3.subtract(temp2, tempVert, temp1);\n\n        vec3.normalize(normalized, temp2);\n        vec3.cross(crossPd, normal, tempVert);\n\n        // const intermDot = vec3.dot(crossPd, tempVertices[vert + vertexCount]);\n        const w = 1.0;// intermDot < 0.0 ? -1.0 : 1.0;\n\n        vec3.scale(tan, normalized, 1 / w);\n        vec3.cross(bitan, normal, tan);\n\n        this.tangents[vert * 3 + 0] = tan[0];\n        this.tangents[vert * 3 + 1] = tan[1];\n        this.tangents[vert * 3 + 2] = tan[2];\n        this.biTangents[vert * 3 + 0] = bitan[0];\n        this.biTangents[vert * 3 + 1] = bitan[1];\n        this.biTangents[vert * 3 + 2] = bitan[2];\n    }\n};\n\nGeometry.prototype.isIndexed = function ()\n{\n    if (this._vertices.length == 0) return true;\n    return this.verticesIndices.length != 0;\n};\n\n/**\n * @function unIndex\n * @memberof Geometry\n * @instance\n * @param {Boolean}\n * @description remove all vertex indizes, vertices array will contain 3*XYZ for every triangle\n */\nGeometry.prototype.unIndex = function (reIndex, dontCalcNormals)\n{\n    const newVerts = [];\n    const newIndizes = [];\n    let count = 0;\n\n    for (let j in this._attributes)\n    {\n        const attr = this._attributes[j];\n        let na = [];\n\n        for (let i = 0; i < this.verticesIndices.length; i += 3)\n        {\n            for (let s = 0; s < 3; s++)\n            {\n                if (attr.itemSize == 3)\n                    na.push(\n                        attr.data[this.verticesIndices[i + s] * 3 + 0],\n                        attr.data[this.verticesIndices[i + s] * 3 + 1],\n                        attr.data[this.verticesIndices[i + s] * 3 + 2]);\n                else if (attr.itemSize == 4)\n                    na.push(\n                        attr.data[this.verticesIndices[i + s] * 4 + 0],\n                        attr.data[this.verticesIndices[i + s] * 4 + 1],\n                        attr.data[this.verticesIndices[i + s] * 4 + 2],\n                        attr.data[this.verticesIndices[i + s] * 4 + 3]);\n                else if (attr.itemSize == 2)\n                    na.push(\n                        attr.data[this.verticesIndices[i + s] * 2 + 0],\n                        attr.data[this.verticesIndices[i + s] * 2 + 1]);\n                else if (attr.itemSize == 1)\n                    na.push(\n                        attr.data[this.verticesIndices[i + s]]);\n                else console.log(\"unknown attr\", attr);\n            }\n        }\n        this.setAttribute(attr.name, na, attr.itemSize);\n    }\n\n    for (let i = 0; i < this.verticesIndices.length; i += 3)\n    {\n        newVerts.push(\n            this.vertices[this.verticesIndices[i + 0] * 3 + 0],\n            this.vertices[this.verticesIndices[i + 0] * 3 + 1],\n            this.vertices[this.verticesIndices[i + 0] * 3 + 2]);\n\n        newIndizes.push(count);\n        count++;\n\n        newVerts.push(\n            this.vertices[this.verticesIndices[i + 1] * 3 + 0],\n            this.vertices[this.verticesIndices[i + 1] * 3 + 1],\n            this.vertices[this.verticesIndices[i + 1] * 3 + 2]);\n\n        newIndizes.push(count);\n        count++;\n\n        newVerts.push(\n            this.vertices[this.verticesIndices[i + 2] * 3 + 0],\n            this.vertices[this.verticesIndices[i + 2] * 3 + 1],\n            this.vertices[this.verticesIndices[i + 2] * 3 + 2]);\n\n        newIndizes.push(count);\n        count++;\n    }\n\n    this.vertices = newVerts;\n\n    this.verticesIndices = [];\n    if (reIndex) this.verticesIndices = newIndizes;\n\n    if (!dontCalcNormals) this.calculateNormals();\n};\n\nGeometry.prototype.calcBarycentric = function ()\n{\n    let barycentrics = [];\n    barycentrics.length = this.vertices.length;\n    for (let i = 0; i < this.vertices.length; i++) barycentrics[i] = 0;\n\n    let count = 0;\n    for (let i = 0; i < this.vertices.length; i += 3)\n    {\n        barycentrics[i + count] = 1;\n        count++;\n        if (count == 3) count = 0;\n    }\n\n    this.setAttribute(\"attrBarycentric\", barycentrics, 3);\n};\n\nGeometry.prototype.getBounds = function ()\n{\n    return new _cg_boundingbox_js__WEBPACK_IMPORTED_MODULE_2__.BoundingBox(this);\n};\n\nGeometry.prototype.center = function (x, y, z)\n{\n    if (x === undefined)\n    {\n        x = true;\n        y = true;\n        z = true;\n    }\n\n    let i = 0;\n    const bounds = this.getBounds();\n    const offset = [bounds.minX + (bounds.maxX - bounds.minX) / 2, bounds.minY + (bounds.maxY - bounds.minY) / 2, bounds.minZ + (bounds.maxZ - bounds.minZ) / 2];\n\n    for (i = 0; i < this.vertices.length; i += 3)\n    {\n        if (this.vertices[i + 0] == this.vertices[i + 0])\n        {\n            if (x) this.vertices[i + 0] -= offset[0];\n            if (y) this.vertices[i + 1] -= offset[1];\n            if (z) this.vertices[i + 2] -= offset[2];\n        }\n    }\n\n    return offset;\n};\n\nGeometry.prototype.mapTexCoords2d = function ()\n{\n    const bounds = this.getBounds();\n    const num = this.vertices.length / 3;\n\n    this.texCoords = new Float32Array(num * 2);\n\n    for (let i = 0; i < num; i++)\n    {\n        const vertX = this.vertices[i * 3 + 0];\n        const vertY = this.vertices[i * 3 + 1];\n        this.texCoords[i * 2 + 0] = vertX / (bounds.maxX - bounds.minX) + 0.5;\n        this.texCoords[i * 2 + 1] = 1.0 - vertY / (bounds.maxY - bounds.minY) + 0.5;\n    }\n};\n\n\nGeometry.prototype.getInfoOneLine = function ()\n{\n    let txt = \"\";\n    if (this.faceVertCount == 3 && this.verticesIndices)txt += this.verticesIndices.length / 3;\n    else txt += 0;\n\n    txt += \" tris \";\n\n    if (this.vertices)txt += this.vertices.length / 3;\n    else txt += 0;\n\n    txt += \" verts\";\n\n    return txt;\n};\n\nGeometry.prototype.getInfo = function ()\n{\n    const info = {};\n\n    if (this.faceVertCount == 3 && this.verticesIndices)info.numFaces = this.verticesIndices.length / 3;\n    else info.numFaces = 0;\n\n    if (this.verticesIndices && this.verticesIndices.length)info.indices = this.verticesIndices.length;\n\n    if (this.vertices)info.numVerts = this.vertices.length / 3;\n    else info.numVerts = 0;\n\n    if (this.vertexNormals) info.numNormals = this.vertexNormals.length / 3;\n    else info.numNormals = 0;\n\n    if (this.texCoords) info.numTexCoords = this.texCoords.length / 2;\n    else info.numTexCoords = 0;\n\n    if (this.tangents) info.numTangents = this.tangents.length / 3;\n    else info.numTangents = 0;\n\n    if (this.biTangents) info.numBiTangents = this.biTangents.length / 3;\n    else info.numBiTangents = 0;\n\n    if (this.biTangents) info.numBiTangents = this.biTangents.length / 3;\n    else info.numBiTangents = 0;\n\n    if (this.vertexColors) info.numVertexColors = this.vertexColors.length / 4;\n    else info.numVertexColors = 0;\n\n    if (this.getAttributes()) info.numAttribs = Object.keys(this.getAttributes()).length;\n    else info.numAttribs = 0;\n\n    info.isIndexed = this.isIndexed();\n\n    return info;\n};\n\n// -----------------\n\n// TODO : move this into \"old\" circle op\nGeometry.buildFromFaces = function (arr, name, optimize)\n{\n    const vertices = [];\n    const verticesIndices = [];\n\n    for (let i = 0; i < arr.length; i += 3)\n    {\n        const a = arr[i + 0];\n        const b = arr[i + 1];\n        const c = arr[i + 2];\n        const face = [-1, -1, -1];\n\n        if (optimize)\n            for (let iv = 0; iv < vertices.length; iv += 3)\n            {\n                if (vertices[iv + 0] == a[0] && vertices[iv + 1] == a[1] && vertices[iv + 2] == a[2]) face[0] = iv / 3;\n                if (vertices[iv + 0] == b[0] && vertices[iv + 1] == b[1] && vertices[iv + 2] == b[2]) face[1] = iv / 3;\n                if (vertices[iv + 0] == c[0] && vertices[iv + 1] == c[1] && vertices[iv + 2] == c[2]) face[2] = iv / 3;\n            }\n\n        if (face[0] == -1)\n        {\n            vertices.push(a[0], a[1], a[2]);\n            face[0] = (vertices.length - 1) / 3;\n        }\n\n        if (face[1] == -1)\n        {\n            vertices.push(b[0], b[1], b[2]);\n            face[1] = (vertices.length - 1) / 3;\n        }\n\n        if (face[2] == -1)\n        {\n            vertices.push(c[0], c[1], c[2]);\n            face[2] = (vertices.length - 1) / 3;\n        }\n\n        verticesIndices.push(parseInt(face[0], 10));\n        verticesIndices.push(parseInt(face[1], 10));\n        verticesIndices.push(parseInt(face[2], 10));\n    }\n\n    const geom = new Geometry(name);\n    geom.name = name;\n    geom.vertices = vertices;\n    geom.verticesIndices = verticesIndices;\n\n    return geom;\n};\n\n// TODO: not needed anymore ?! move to deprecated ops?\nGeometry.json2geom = function (jsonMesh)\n{\n    const geom = new Geometry(\"jsonMeshGeom\");\n    geom.verticesIndices = [];\n\n    geom.vertices = jsonMesh.vertices || [];\n    geom.vertexNormals = jsonMesh.normals || [];\n    geom.vertexColors = jsonMesh.colors || [];\n    geom.tangents = jsonMesh.tangents || [];\n    geom.biTangents = jsonMesh.bitangents || [];\n    if (jsonMesh.texturecoords) geom.setTexCoords(jsonMesh.texturecoords[0]);\n\n    if (jsonMesh.vertices_b64)geom.vertices = new Float32Array((0,_base64_js__WEBPACK_IMPORTED_MODULE_3__.b64decTypedArray)(jsonMesh.vertices_b64));\n    if (jsonMesh.normals_b64) geom.vertexNormals = new Float32Array((0,_base64_js__WEBPACK_IMPORTED_MODULE_3__.b64decTypedArray)(jsonMesh.normals_b64));\n    if (jsonMesh.tangents_b64) geom.tangents = new Float32Array((0,_base64_js__WEBPACK_IMPORTED_MODULE_3__.b64decTypedArray)(jsonMesh.tangents_b64));\n    if (jsonMesh.bitangents_b64) geom.biTangents = new Float32Array((0,_base64_js__WEBPACK_IMPORTED_MODULE_3__.b64decTypedArray)(jsonMesh.bitangents_b64));\n    if (jsonMesh.texturecoords_b64) geom.setTexCoords(new Float32Array((0,_base64_js__WEBPACK_IMPORTED_MODULE_3__.b64decTypedArray)(jsonMesh.texturecoords_b64[0])));\n\n    if (jsonMesh.faces_b64)\n    {\n        geom.verticesIndices = new Uint32Array((0,_base64_js__WEBPACK_IMPORTED_MODULE_3__.b64decTypedArray)(jsonMesh.faces_b64));\n    }\n    else\n    {\n        geom.verticesIndices.length = jsonMesh.faces.length * 3;\n        for (let i = 0; i < jsonMesh.faces.length; i++)\n        {\n            geom.verticesIndices[i * 3] = jsonMesh.faces[i][0];\n            geom.verticesIndices[i * 3 + 1] = jsonMesh.faces[i][1];\n            geom.verticesIndices[i * 3 + 2] = jsonMesh.faces[i][2];\n        }\n    }\n\n    return geom;\n};\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9jZ19nZW9tLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZy9jZ19nZW9tLmpzPzFlNTMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IHsgdmVjMiwgdmVjMyB9IGZyb20gXCJnbC1tYXRyaXhcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJjYWJsZXMtc2hhcmVkLWNsaWVudFwiO1xuaW1wb3J0IHsgVVRJTFMgfSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IGI2NGRlY1R5cGVkQXJyYXkgfSBmcm9tIFwiLi4vYmFzZTY0LmpzXCI7XG5pbXBvcnQgeyBCb3VuZGluZ0JveCB9IGZyb20gXCIuL2NnX2JvdW5kaW5nYm94LmpzXCI7XG5cbi8qKlxuICogYSBnZW9tZXRyeSBjb250YWlucyBhbGwgaW5mb3JtYXRpb24gYWJvdXQgYSBtZXNoLCB2ZXJ0aWNlcywgdGV4dHVyZWNvb3JkaW5hdGVzIGV0Yy4gZXRjLlxuICogQGV4dGVybmFsIENHTFxuICogQG5hbWVzcGFjZSBHZW9tZXRyeVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBjbGFzc1xuICogQGV4YW1wbGVcbiAqIC8vIGNyZWF0ZSBhIHRyaWFuZ2xlIHdpdGggYWxsIGF0dHJpYnV0ZXNcbiAqIGNvbnN0IGdlb209bmV3IEdlb21ldHJ5KFwidHJpYW5nbGVcIiksXG4gKlxuICogZ2VvbS52ZXJ0aWNlcyA9IFtcbiAqICAgICAgMC4wLCAgICAgICAgICAgc2l6ZUguZ2V0KCksICAwLjAsXG4gKiAgICAgLXNpemVXLmdldCgpLCAgLXNpemVILmdldCgpLCAgMC4wLFxuICogICAgICBzaXplVy5nZXQoKSwgIC1zaXplSC5nZXQoKSwgIDAuMCBdO1xuICpcbiAqIGdlb20udmVydGV4Tm9ybWFscyA9IFtcbiAqICAgICAgMC4wLCAgMC4wLCAgMS4wLFxuICogICAgICAwLjAsICAwLjAsICAxLjAsXG4gKiAgICAgIDAuMCwgIDAuMCwgIDEuMCBdO1xuICpcbiAqIGdlb20udGFuZ2VudHMgPSBbXG4gKiAgICAgMSwwLDAsXG4gKiAgICAgMSwwLDAsXG4gKiAgICAgMSwwLDAgXTtcbiAqXG4gKiBnZW9tLmJpVGFuZ2VudHMgPSBbXG4gKiAgICAgMCwxLDAsXG4gKiAgICAgMCwxLDAsXG4gKiAgICAgMCwxLDAgXTtcbiAqXG4gKiBnZW9tLnRleENvb3JkcyA9IFtcbiAqICAgICAgMC41LCAgMC4wLFxuICogICAgICAxLjAsICAxLjAsXG4gKiAgICAgIDAuMCwgIDEuMCwgXTtcbiAqXG4gKiBnZW9tLnZlcnRpY2VzSW5kaWNlcyA9IFtcbiAqICAgICAwLCAxLCAyIF07XG4gKlxuICovXG5jb25zdCBHZW9tZXRyeSA9IGZ1bmN0aW9uIChuYW1lKVxue1xuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgXCJ1bmtub3duXCI7XG4gICAgdGhpcy5fbG9nID0gbmV3IExvZ2dlcihcImNnbF9nZW9tZXRyeVwiKTtcblxuICAgIHRoaXMuZmFjZVZlcnRDb3VudCA9IDM7XG4gICAgdGhpcy5nbFByaW1pdGl2ZSA9IG51bGw7XG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IHt9O1xuXG4gICAgdGhpcy5fdmVydGljZXMgPSBbXTtcbiAgICB0aGlzLnZlcnRpY2VzSW5kaWNlcyA9IFtdO1xuXG4gICAgdGhpcy5pc0dlb21ldHJ5ID0gdHJ1ZTtcblxuICAgIHRoaXMubW9ycGhUYXJnZXRzID0gW107XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJ0aWNlc1wiLCB7XG4gICAgICAgIGdldCgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92ZXJ0aWNlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHYpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmVydGljZXModik7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZXhDb29yZHNcIiwge1xuICAgICAgICBnZXQoKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBhdHQgPSB0aGlzLmdldEF0dHJpYnV0ZShcInRleENvb3Jkc1wiKTtcbiAgICAgICAgICAgIGlmICghYXR0KSByZXR1cm4gW107XG4gICAgICAgICAgICByZXR1cm4gYXR0LmRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShcInRleENvb3Jkc1wiLCB2LCAyKTtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnRleE5vcm1hbHNcIiwge1xuICAgICAgICBnZXQoKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBhdHQgPSB0aGlzLmdldEF0dHJpYnV0ZShcInZlcnRleE5vcm1hbHNcIik7XG4gICAgICAgICAgICBpZiAoIWF0dCkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgcmV0dXJuIGF0dC5kYXRhO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ2ZXJ0ZXhOb3JtYWxzXCIsIHYsIDMpO1xuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFuZ2VudHNcIiwge1xuICAgICAgICBnZXQoKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBhdHQgPSB0aGlzLmdldEF0dHJpYnV0ZShcInRhbmdlbnRzXCIpO1xuICAgICAgICAgICAgaWYgKCFhdHQpIHJldHVybiBbXTtcbiAgICAgICAgICAgIHJldHVybiBhdHQuZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHYpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwidGFuZ2VudHNcIiwgdiwgMyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiaVRhbmdlbnRzXCIsIHtcbiAgICAgICAgZ2V0KClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgYXR0ID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJiaVRhbmdlbnRzXCIpO1xuICAgICAgICAgICAgaWYgKCFhdHQpIHJldHVybiBbXTtcbiAgICAgICAgICAgIHJldHVybiBhdHQuZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHYpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiYmlUYW5nZW50c1wiLCB2LCAzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnRleENvbG9yc1wiLCB7XG4gICAgICAgIGdldCgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dCA9IHRoaXMuZ2V0QXR0cmlidXRlKFwidmVydGV4Q29sb3JzXCIpO1xuICAgICAgICAgICAgaWYgKCFhdHQpIHJldHVybiBbXTtcbiAgICAgICAgICAgIHJldHVybiBhdHQuZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHYpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwidmVydGV4Q29sb3JzXCIsIHYsIDQpO1xuICAgICAgICB9LFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gY2xlYXJcbiAqIEBtZW1iZXJvZiBHZW9tZXRyeVxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gY2xlYXIgYWxsIGJ1ZmZlcnMvc2V0IHRoZW0gdG8gbGVuZ3RoIDBcbiAqL1xuR2VvbWV0cnkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl92ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoW10pO1xuICAgIHRoaXMudmVydGljZXNJbmRpY2VzID0gW107XG4gICAgdGhpcy50ZXhDb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KFtdKTtcbiAgICB0aGlzLnZlcnRleE5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KFtdKTtcbiAgICB0aGlzLnRhbmdlbnRzID0gW107XG4gICAgdGhpcy5iaVRhbmdlbnRzID0gW107XG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IHt9O1xufTtcblxuXG5cbi8qKlxuICogQGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXNcbiAgIEBtZW1iZXJvZiBHZW9tZXRyeVxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+fSByZXR1cm5zIGFycmF5IG9mIGF0dHJpYnV0ZSBvYmplY3RzXG4gKi9cbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fYXR0cmlidXRlcztcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGdldEF0dHJpYnV0ZVxuICogQG1lbWJlcm9mIEdlb21ldHJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSlcbntcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5fYXR0cmlidXRlcylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzW2ldLm5hbWUgPT0gbmFtZSkgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXNbaV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gc2V0QXR0cmlidXRlXG4gKiBAZGVzY3JpcHRpb24gY3JlYXRlIGFuIGF0dHJpYnV0ZVxuICogQG1lbWJlcm9mIEdlb21ldHJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gaXRlbXNpemVcbiAqL1xuR2VvbWV0cnkucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLCBhcnIsIGl0ZW1TaXplKVxue1xuICAgIGxldCBhdHRyVHlwZSA9IFwiXCI7XG4gICAgaWYgKCFpdGVtU2l6ZSB8fCBpdGVtU2l6ZSA+IDQpXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZyhcIml0ZW1zaXplIHdyb25nP1wiLCBpdGVtU2l6ZSwgbmFtZSk7XG4gICAgICAgIHRoaXMuX2xvZy5zdGFjayhcIml0ZW1zaXplXCIpO1xuXG4gICAgICAgIGl0ZW1TaXplID0gMztcbiAgICB9XG5cbiAgICBpZiAoaXRlbVNpemUgPT0gMSkgYXR0clR5cGUgPSBcImZsb2F0XCI7XG4gICAgZWxzZSBpZiAoaXRlbVNpemUgPT0gMikgYXR0clR5cGUgPSBcInZlYzJcIjtcbiAgICBlbHNlIGlmIChpdGVtU2l6ZSA9PSAzKSBhdHRyVHlwZSA9IFwidmVjM1wiO1xuICAgIGVsc2UgaWYgKGl0ZW1TaXplID09IDQpIGF0dHJUeXBlID0gXCJ2ZWM0XCI7XG5cblxuICAgIGNvbnN0IGF0dHIgPSB7XG4gICAgICAgIFwibmFtZVwiOiBuYW1lLFxuICAgICAgICBcImRhdGFcIjogYXJyLFxuICAgICAgICBcIml0ZW1TaXplXCI6IGl0ZW1TaXplLFxuICAgICAgICBcInR5cGVcIjogYXR0clR5cGUsXG4gICAgfTtcblxuICAgIHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV0gPSBhdHRyO1xufTtcblxuR2VvbWV0cnkucHJvdG90eXBlLmNvcHlBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSwgbmV3Z2VvbSlcbntcbiAgICBjb25zdCBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgbmV3Z2VvbS5zZXRBdHRyaWJ1dGUobmFtZSwgbmV3IEZsb2F0MzJBcnJheShhdHRyLmRhdGEpLCBhdHRyLml0ZW1TaXplKTtcbn07XG5cblxuLyoqXG4gKiBAZnVuY3Rpb24gc2V0VmVydGljZXNcbiAqIEBtZW1iZXJvZiBHZW9tZXRyeVxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gc2V0IHZlcnRpY2VzXG4gKiBAcGFyYW0ge0FycmF5fEZsb2F0MzJBcnJheX0gZGF0YSBbeCx5LHoseCx5LHosLi4uXVxuICovXG5HZW9tZXRyeS5wcm90b3R5cGUuc2V0VmVydGljZXMgPSBmdW5jdGlvbiAoYXJyKVxue1xuICAgIGlmIChhcnIgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHRoaXMuX3ZlcnRpY2VzID0gYXJyO1xuICAgIGVsc2UgdGhpcy5fdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KGFycik7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBzZXRUZXhDb29yZHNcbiAqIEBtZW1iZXJvZiBHZW9tZXRyeVxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gc2V0IHRleGNvb3Jkc1xuICogQHBhcmFtIHtBcnJheXxGbG9hdDMyQXJyYXl9IGRhdGEgW3Usdix1LHYsLi4uXVxuICovXG5HZW9tZXRyeS5wcm90b3R5cGUuc2V0VGV4Q29vcmRzID0gZnVuY3Rpb24gKGFycilcbntcbiAgICBpZiAoYXJyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB0aGlzLnRleENvb3JkcyA9IGFycjtcbiAgICBlbHNlIHRoaXMudGV4Q29vcmRzID0gbmV3IEZsb2F0MzJBcnJheShhcnIpO1xufTtcblxuLy8gR2VvbWV0cnkucHJvdG90eXBlLnRlc3RJbmRpY2VzID0gZnVuY3Rpb24gKClcbi8vIHtcbi8vICAgICB2YXIgZm91bmRFcnJvciA9IGZhbHNlO1xuLy8gICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoOyBpKyspXG4vLyAgICAge1xuLy8gICAgICAgICBpZiAodGhpcy52ZXJ0aWNlc0luZGljZXNbaSAqIDMgKyAwXSA+PSB0aGlzLl92ZXJ0aWNlcy5sZW5ndGggLyAzIHx8IHRoaXMudmVydGljZXNJbmRpY2VzW2kgKiAzICsgMV0gPj0gdGhpcy5fdmVydGljZXMubGVuZ3RoIC8gMyB8fCB0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICogMyArIDJdID49IHRoaXMuX3ZlcnRpY2VzLmxlbmd0aCAvIDMpXG4vLyAgICAgICAgIHtcbi8vICAgICAgICAgICAgIGZvdW5kRXJyb3IgPSB0cnVlO1xuLy8gICAgICAgICAgICAgY29uc29sZS5sb2coXCJpbmRleCBlcnJvciFcIik7XG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vLyB9O1xuXG4vLyBkZXByZWNhdGVkXG5HZW9tZXRyeS5wcm90b3R5cGUuY2FsY05vcm1hbHMgPSBmdW5jdGlvbiAoc21vb3RoKVxue1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IFwic21vb3RoXCI6IHNtb290aCB9O1xuXG5cbiAgICB0aGlzLmNhbGN1bGF0ZU5vcm1hbHMob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBmbGlwTm9ybWFsc1xuICogQG1lbWJlcm9mIEdlb21ldHJ5XG4gKiBAZGVzY3JpcHRpb24gZmxpcCBub3JtYWxzXG4gKi9cbkdlb21ldHJ5LnByb3RvdHlwZS5mbGlwTm9ybWFscyA9IGZ1bmN0aW9uICh4LCB5LCB6KVxue1xuICAgIGxldCB2ZWMgPSB2ZWMzLmNyZWF0ZSgpO1xuXG4gICAgaWYgKHggPT0gdW5kZWZpbmVkKXggPSAxO1xuICAgIGlmICh5ID09IHVuZGVmaW5lZCl5ID0gMTtcbiAgICBpZiAoeiA9PSB1bmRlZmluZWQpeiA9IDE7XG5cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSArPSAzKVxuICAgIHtcbiAgICAgICAgdmVjMy5zZXQodmVjLFxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzW2kgKyAwXSxcbiAgICAgICAgICAgIHRoaXMudmVydGV4Tm9ybWFsc1tpICsgMV0sXG4gICAgICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbaSArIDJdKTtcblxuICAgICAgICB2ZWNbMF0gKj0gLXg7XG4gICAgICAgIHZlY1sxXSAqPSAteTtcbiAgICAgICAgdmVjWzJdICo9IC16O1xuXG4gICAgICAgIHZlYzMubm9ybWFsaXplKHZlYywgdmVjKTtcblxuICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbaSArIDBdID0gdmVjWzBdO1xuICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbaSArIDFdID0gdmVjWzFdO1xuICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbaSArIDJdID0gdmVjWzJdO1xuICAgIH1cbn07XG5cbkdlb21ldHJ5LnByb3RvdHlwZS5nZXROdW1UcmlhbmdsZXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLnZlcnRpY2VzSW5kaWNlcyAmJiB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGgpIHJldHVybiB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggLyAzO1xuICAgIHJldHVybiB0aGlzLnZlcnRpY2VzLmxlbmd0aCAvIDM7XG59O1xuXG5cbi8qKlxuICogQGZ1bmN0aW9uIGZsaXBWZXJ0RGlyXG4gKiBAbWVtYmVyb2YgR2VvbWV0cnlcbiAqIEBkZXNjcmlwdGlvbiBmbGlwIG9yZGVyIG9mIHZlcnRpY2VzIGluIGdlb20gZmFjZXNcbiAqL1xuR2VvbWV0cnkucHJvdG90eXBlLmZsaXBWZXJ0RGlyID0gZnVuY3Rpb24gKClcbntcbiAgICBjb25zdCBuZXdJbmQgPSBbXTtcbiAgICBuZXdJbmQubGVuZ3RoID0gdGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoOyBpICs9IDMpXG4gICAge1xuICAgICAgICBuZXdJbmRbaV0gPSB0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMl07XG4gICAgICAgIG5ld0luZFtpICsgMV0gPSB0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMV07XG4gICAgICAgIG5ld0luZFtpICsgMl0gPSB0aGlzLnZlcnRpY2VzSW5kaWNlc1tpXTtcbiAgICB9XG4gICAgdGhpcy52ZXJ0aWNlc0luZGljZXMgPSBuZXdJbmQ7XG59O1xuXG5cbkdlb21ldHJ5LnByb3RvdHlwZS5zZXRQb2ludFZlcnRpY2VzID0gZnVuY3Rpb24gKHZlcnRzKVxue1xuICAgIGlmICh2ZXJ0cy5sZW5ndGggJSAzICE9PSAwKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwiU2V0UG9pbnRWZXJ0aWNlczogQXJyYXkgbXVzdCBiZSBtdWx0aXBsZSBvZiB0aHJlZS5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoISh2ZXJ0cyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpIHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRzKTtcbiAgICBlbHNlIHRoaXMudmVydGljZXMgPSB2ZXJ0cztcblxuICAgIGlmICghKHRoaXMudGV4Q29vcmRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkgdGhpcy50ZXhDb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCh2ZXJ0cy5sZW5ndGggLyAzKSAqIDIpO1xuXG4gICAgLy8gdGhpcy50ZXhDb29yZHMubGVuZ3RoPXZlcnRzLmxlbmd0aC8zKjI7XG4gICAgdGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoID0gdmVydHMubGVuZ3RoIC8gMztcbiAgICAvLyB0aGlzLnZlcnRpY2VzSW5kaWNlcz1bXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydHMubGVuZ3RoIC8gMzsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy52ZXJ0aWNlc0luZGljZXNbaV0gPSBpO1xuICAgICAgICB0aGlzLnRleENvb3Jkc1tpICogMl0gPSAwO1xuICAgICAgICB0aGlzLnRleENvb3Jkc1tpICogMiArIDFdID0gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIG1lcmdlIGEgZGlmZmVyZW50IGdlb21ldHJ5IGludG8gdGhlIHRoaXMgZ2VvbWV0cnlcbiAqIEBmdW5jdGlvbiBtZXJnZVxuICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbVxuICogQG1lbWJlcm9mIEdlb21ldHJ5XG4gKiBAaW5zdGFuY2VcbiAqL1xuR2VvbWV0cnkucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKGdlb20pXG57XG4gICAgaWYgKCFnZW9tKSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5pc0luZGV4ZWQoKSAhPSBnZW9tLmlzSW5kZXhlZCgpKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaXNJbmRleGVkKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudW5JbmRleChmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlb20uaXNJbmRleGVkKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGcgPSBnZW9tLmNvcHkoKTtcbiAgICAgICAgICAgIGcudW5JbmRleChmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBnZW9tID0gZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9sZEluZGl6ZXNMZW5ndGggPSB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGg7XG4gICAgY29uc3QgdmVydExlbmd0aCA9IHRoaXMuX3ZlcnRpY2VzLmxlbmd0aCAvIDM7XG5cbiAgICB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggPSB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggKyBnZW9tLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZW9tLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgdGhpcy52ZXJ0aWNlc0luZGljZXNbb2xkSW5kaXplc0xlbmd0aCArIGldID0gZ2VvbS52ZXJ0aWNlc0luZGljZXNbaV0gKyB2ZXJ0TGVuZ3RoO1xuXG4gICAgdGhpcy52ZXJ0aWNlcyA9IFVUSUxTLmZsb2F0MzJDb25jYXQodGhpcy5fdmVydGljZXMsIGdlb20udmVydGljZXMpO1xuICAgIHRoaXMudGV4Q29vcmRzID0gVVRJTFMuZmxvYXQzMkNvbmNhdCh0aGlzLnRleENvb3JkcywgZ2VvbS50ZXhDb29yZHMpO1xuICAgIHRoaXMudmVydGV4Tm9ybWFscyA9IFVUSUxTLmZsb2F0MzJDb25jYXQodGhpcy52ZXJ0ZXhOb3JtYWxzLCBnZW9tLnZlcnRleE5vcm1hbHMpO1xuICAgIHRoaXMudGFuZ2VudHMgPSBVVElMUy5mbG9hdDMyQ29uY2F0KHRoaXMudGFuZ2VudHMsIGdlb20udGFuZ2VudHMpO1xuICAgIHRoaXMuYmlUYW5nZW50cyA9IFVUSUxTLmZsb2F0MzJDb25jYXQodGhpcy5iaVRhbmdlbnRzLCBnZW9tLmJpVGFuZ2VudHMpO1xufTtcblxuLyoqXG4gKiBjcmVhdGUgYSBjb3B5IG9mIHRoZSBnZW9tZXRyeVxuICogQGZ1bmN0aW9uIGNvcHlcbiAqIEBtZW1iZXJvZiBHZW9tZXRyeVxuICogQGluc3RhbmNlXG4gKi9cbkdlb21ldHJ5LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKClcbntcbiAgICBjb25zdCBnZW9tID0gbmV3IEdlb21ldHJ5KHRoaXMubmFtZSArIFwiIGNvcHlcIik7XG4gICAgZ2VvbS5mYWNlVmVydENvdW50ID0gdGhpcy5mYWNlVmVydENvdW50O1xuICAgIGdlb20uZ2xQcmltaXRpdmUgPSB0aGlzLmdsUHJpbWl0aXZlO1xuXG4gICAgZ2VvbS5zZXRWZXJ0aWNlcyh0aGlzLl92ZXJ0aWNlcy5zbGljZSgwKSk7XG5cbiAgICBpZiAodGhpcy52ZXJ0aWNlc0luZGljZXMpXG4gICAge1xuICAgICAgICBnZW9tLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggPSB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoOyBpKyspIGdlb20udmVydGljZXNJbmRpY2VzW2ldID0gdGhpcy52ZXJ0aWNlc0luZGljZXNbaV07XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSBpbiB0aGlzLl9hdHRyaWJ1dGVzKSB0aGlzLmNvcHlBdHRyaWJ1dGUoaSwgZ2VvbSk7XG5cbiAgICBnZW9tLm1vcnBoVGFyZ2V0cy5sZW5ndGggPSB0aGlzLm1vcnBoVGFyZ2V0cy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkrKykgZ2VvbS5tb3JwaFRhcmdldHNbaV0gPSB0aGlzLm1vcnBoVGFyZ2V0c1tpXTtcblxuICAgIHJldHVybiBnZW9tO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVuIG5vcm1hbHNcbiAqIEBmdW5jdGlvbiBjYWxjdWxhdGVOb3JtYWxzXG4gKiBAbWVtYmVyb2YgR2VvbWV0cnlcbiAqIEBpbnN0YW5jZVxuICovXG5HZW9tZXRyeS5wcm90b3R5cGUuY2FsY3VsYXRlTm9ybWFscyA9IGZ1bmN0aW9uIChvcHRpb25zKVxue1xuICAgIC8vIHRvZG86IHNob3VsZCBjaGVjayBhbmdsZSBvZiBub3JtYWxzIHRvIGdldCBlZGdlcyAgICBodHRwczovL2NvbW11bml0eS5raHJvbm9zLm9yZy90L2NhbGN1bGF0aW5nLWFjY3VyYXRlLXZlcnRleC1ub3JtYWxzLzI4MTUyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKG9wdGlvbnMuc21vb3RoID09PSBmYWxzZSkgdGhpcy51bkluZGV4KCk7XG5cbiAgICBjb25zdCB1ID0gdmVjMy5jcmVhdGUoKTtcbiAgICBjb25zdCB2ID0gdmVjMy5jcmVhdGUoKTtcbiAgICBjb25zdCBuID0gdmVjMy5jcmVhdGUoKTtcblxuICAgIGZ1bmN0aW9uIGNhbGNOb3JtYWwodHJpYW5nbGUpXG4gICAge1xuICAgICAgICB2ZWMzLnN1YnRyYWN0KHUsIHRyaWFuZ2xlWzBdLCB0cmlhbmdsZVsxXSk7XG4gICAgICAgIHZlYzMuc3VidHJhY3QodiwgdHJpYW5nbGVbMF0sIHRyaWFuZ2xlWzJdKTtcbiAgICAgICAgdmVjMy5jcm9zcyhuLCB1LCB2KTtcbiAgICAgICAgdmVjMy5ub3JtYWxpemUobiwgbik7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mb3JjZVpVcClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5bMl0gPCAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5bMF0gKj0gLTE7XG4gICAgICAgICAgICAgICAgblsxXSAqPSAtMTtcbiAgICAgICAgICAgICAgICBuWzJdICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0VmVydGV4VmVjID0gZnVuY3Rpb24gKHdoaWNoKVxuICAgIHtcbiAgICAgICAgY29uc3QgdmVjID0gWzAsIDAsIDBdO1xuICAgICAgICB2ZWNbMF0gPSB0aGlzLnZlcnRpY2VzW3doaWNoICogMyArIDBdO1xuICAgICAgICB2ZWNbMV0gPSB0aGlzLnZlcnRpY2VzW3doaWNoICogMyArIDFdO1xuICAgICAgICB2ZWNbMl0gPSB0aGlzLnZlcnRpY2VzW3doaWNoICogMyArIDJdO1xuICAgICAgICByZXR1cm4gdmVjO1xuICAgIH07XG5cbiAgICBpZiAoISh0aGlzLnZlcnRleE5vcm1hbHMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHx8IHRoaXMudmVydGV4Tm9ybWFscy5sZW5ndGggIT0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgpIHRoaXMudmVydGV4Tm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy52ZXJ0aWNlcy5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzW2ldID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNJbmRleGVkKCkpXG4gICAge1xuICAgICAgICBjb25zdCBub3JtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpICs9IDkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHRyaWFuZ2xlID0gW1t0aGlzLnZlcnRpY2VzW2kgKyAwXSwgdGhpcy52ZXJ0aWNlc1tpICsgMV0sIHRoaXMudmVydGljZXNbaSArIDJdXSwgW3RoaXMudmVydGljZXNbaSArIDNdLCB0aGlzLnZlcnRpY2VzW2kgKyA0XSwgdGhpcy52ZXJ0aWNlc1tpICsgNV1dLCBbdGhpcy52ZXJ0aWNlc1tpICsgNl0sIHRoaXMudmVydGljZXNbaSArIDddLCB0aGlzLnZlcnRpY2VzW2kgKyA4XV1dO1xuICAgICAgICAgICAgY29uc3Qgbm4gPSBjYWxjTm9ybWFsKHRyaWFuZ2xlKTtcbiAgICAgICAgICAgIG5vcm1zLnB1c2gobm5bMF0sIG5uWzFdLCBublsyXSwgbm5bMF0sIG5uWzFdLCBublsyXSwgbm5bMF0sIG5uWzFdLCBublsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzID0gbm9ybXM7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGNvbnN0IGZhY2VOb3JtYWxzID0gW107XG5cbiAgICAgICAgZmFjZU5vcm1hbHMubGVuZ3RoID0gTWF0aC5mbG9vcih0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggLyAzKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydGljZXNJbmRpY2VzLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCB0cmlhbmdsZSA9IFt0aGlzLmdldFZlcnRleFZlYyh0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMF0pLCB0aGlzLmdldFZlcnRleFZlYyh0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMV0pLCB0aGlzLmdldFZlcnRleFZlYyh0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMl0pXTtcblxuICAgICAgICAgICAgZmFjZU5vcm1hbHNbaSAvIDNdID0gY2FsY05vcm1hbCh0cmlhbmdsZSk7XG5cbiAgICAgICAgICAgIHRoaXMudmVydGV4Tm9ybWFsc1t0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMF0gKiAzICsgMF0gKz0gZmFjZU5vcm1hbHNbaSAvIDNdWzBdO1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyAwXSAqIDMgKyAxXSArPSBmYWNlTm9ybWFsc1tpIC8gM11bMV07XG4gICAgICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIDBdICogMyArIDJdICs9IGZhY2VOb3JtYWxzW2kgLyAzXVsyXTtcblxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyAxXSAqIDMgKyAwXSArPSBmYWNlTm9ybWFsc1tpIC8gM11bMF07XG4gICAgICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIDFdICogMyArIDFdICs9IGZhY2VOb3JtYWxzW2kgLyAzXVsxXTtcbiAgICAgICAgICAgIHRoaXMudmVydGV4Tm9ybWFsc1t0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMV0gKiAzICsgMl0gKz0gZmFjZU5vcm1hbHNbaSAvIDNdWzJdO1xuXG4gICAgICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIDJdICogMyArIDBdICs9IGZhY2VOb3JtYWxzW2kgLyAzXVswXTtcbiAgICAgICAgICAgIHRoaXMudmVydGV4Tm9ybWFsc1t0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMl0gKiAzICsgMV0gKz0gZmFjZU5vcm1hbHNbaSAvIDNdWzFdO1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyAyXSAqIDMgKyAyXSArPSBmYWNlTm9ybWFsc1tpIC8gM11bMl07XG4gICAgICAgIH1cblxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoOyBpICs9IDMpIC8vIGZhY2VzXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgMzsgaysrKSAvLyB0cmlhbmdsZXNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2diA9IFt0aGlzLnZlcnRleE5vcm1hbHNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIGtdICogMyArIDBdLCB0aGlzLnZlcnRleE5vcm1hbHNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIGtdICogMyArIDFdLCB0aGlzLnZlcnRleE5vcm1hbHNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIGtdICogMyArIDJdXTtcbiAgICAgICAgICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh2diwgdnYpO1xuICAgICAgICAgICAgICAgIHRoaXMudmVydGV4Tm9ybWFsc1t0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsga10gKiAzICsgMF0gPSB2dlswXTtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleE5vcm1hbHNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIGtdICogMyArIDFdID0gdnZbMV07XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhOb3JtYWxzW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyBrXSAqIDMgKyAyXSA9IHZ2WzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRhbmdlbnRzICYgYml0YW5nZW50cyB3aXRoIHRoZSBoZWxwIG9mIHV2LWNvb3JkaW5hdGVzLiBBZGFwdGVkIGZyb21cbiAqIExlbmd5ZWwsIEVyaWMuIOKAnENvbXB1dGluZyBUYW5nZW50IFNwYWNlIEJhc2lzIFZlY3RvcnMgZm9yIGFuIEFyYml0cmFyeSBNZXNo4oCdLlxuICogVGVyYXRob24gU29mdHdhcmUgM0QgR3JhcGhpY3MgTGlicmFyeS5cbiAqIGh0dHBzOi8vZmVuaXgudGVjbmljby51bGlzYm9hLnB0L2Rvd25sb2FkRmlsZS84NDUwNDM0MDU0NDkwNzMvVGFuZ2VudCUyMFNwYWNlJTIwQ2FsY3VsYXRpb24ucGRmXG4gKlxuICogQGZ1bmN0aW9uIGNhbGNUYW5nZW50c0JpdGFuZ2VudHNcbiAqIEBtZW1iZXJvZiBHZW9tZXRyeVxuICogQGluc3RhbmNlXG4gKi9cbkdlb21ldHJ5LnByb3RvdHlwZS5jYWxjVGFuZ2VudHNCaXRhbmdlbnRzID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoIXRoaXMudmVydGljZXMubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgLy8gdGhpcy5fbG9nLmVycm9yKFwiQ2Fubm90IGNhbGN1bGF0ZSB0YW5nZW50cy9iaXRhbmdlbnRzIHdpdGhvdXQgdmVydGljZXMuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy52ZXJ0ZXhOb3JtYWxzLmxlbmd0aClcbiAgICB7XG4gICAgICAgIC8vIHRoaXMuX2xvZy5lcnJvcihcIkNhbm5vdCBjYWxjdWxhdGUgdGFuZ2VudHMvYml0YW5nZW50cyB3aXRob3V0IG5vcm1hbHMuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy50ZXhDb29yZHMubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKFwiTm8gdGV4Y29vcmRzLiBSZXBsYWNpbmcgd2l0aCBkZWZhdWx0IHZhbHVlcyBbMCwgMF0uXCIpO1xuICAgICAgICBjb25zdCB0ZXhDb29yZExlbmd0aCA9ICh0aGlzLnZlcnRpY2VzLmxlbmd0aCAvIDMpICogMjtcbiAgICAgICAgdGhpcy50ZXhDb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KHRleENvb3JkTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXhDb29yZExlbmd0aDsgaSArPSAxKSB0aGlzLnRleENvb3Jkc1tpXSA9IDA7XG4gICAgfVxuICAgIGlmICghdGhpcy52ZXJ0aWNlc0luZGljZXMgfHwgIXRoaXMudmVydGljZXNJbmRpY2VzLmxlbmd0aClcbiAgICB7XG4gICAgICAgIC8vIHRoaXMuX2xvZy5lcnJvcihcIkNhbm5vdCBjYWxjdWxhdGUgdGFuZ2VudHMvYml0YW5nZW50cyB3aXRob3V0IHZlcnRleCBpbmRpY2VzLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB0aGlzIGNvZGUgYXNzdW1lcyB0aGF0IHdlIGhhdmUgdGhyZWUgaW5kaWNlcyBwZXIgdHJpYW5nbGVcbiAgICBpZiAodGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoICUgMyAhPT0gMClcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy5lcnJvcihcIlZlcnRleCBpbmRpY2VzIG1pc21hdGNoIVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRyaWFuZ2xlQ291bnQgPSB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggLyAzO1xuICAgIGNvbnN0IHZlcnRleENvdW50ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLyAzO1xuXG4gICAgdGhpcy50YW5nZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCk7XG4gICAgdGhpcy5iaVRhbmdlbnRzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnZlcnRleE5vcm1hbHMubGVuZ3RoKTtcblxuICAgIC8vIHRlbXBvcmFyeSBidWZmZXJzXG4gICAgY29uc3QgdGVtcFZlcnRpY2VzID0gW107XG4gICAgdGVtcFZlcnRpY2VzLmxlbmd0aCA9IHZlcnRleENvdW50ICogMjtcbiAgICBjb25zdCB2MSA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgdjIgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIGNvbnN0IHYzID0gdmVjMy5jcmVhdGUoKTtcblxuICAgIGNvbnN0IHcxID0gdmVjMi5jcmVhdGUoKTtcbiAgICBjb25zdCB3MiA9IHZlYzIuY3JlYXRlKCk7XG4gICAgY29uc3QgdzMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgY29uc3Qgc2RpciA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgdGRpciA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgICAvLyBmb3IgZGV0YWlscyBvbiBjYWxjdWxhdGlvbiwgc2VlIGFydGljbGUgcmVmZXJlbmNlZCBhYm92ZVxuICAgIGZvciAobGV0IHRyaSA9IDA7IHRyaSA8IHRyaWFuZ2xlQ291bnQ7IHRyaSArPSAxKVxuICAgIHtcbiAgICAgICAgLy8gaW5kaWNlcyBvZiB0aGUgdGhyZWUgdmVydGljZXMgZm9yIGEgdHJpYW5nbGVcbiAgICAgICAgY29uc3QgaTEgPSB0aGlzLnZlcnRpY2VzSW5kaWNlc1t0cmkgKiAzXTtcbiAgICAgICAgY29uc3QgaTIgPSB0aGlzLnZlcnRpY2VzSW5kaWNlc1t0cmkgKiAzICsgMV07XG4gICAgICAgIGNvbnN0IGkzID0gdGhpcy52ZXJ0aWNlc0luZGljZXNbdHJpICogMyArIDJdO1xuXG4gICAgICAgIC8vIHZlcnRleCBwb3NpdGlvbiBhcyB2ZWMzXG4gICAgICAgIHZlYzMuc2V0KHYxLCB0aGlzLnZlcnRpY2VzW2kxICogM10sIHRoaXMudmVydGljZXNbaTEgKiAzICsgMV0sIHRoaXMudmVydGljZXNbaTEgKiAzICsgMl0pO1xuICAgICAgICB2ZWMzLnNldCh2MiwgdGhpcy52ZXJ0aWNlc1tpMiAqIDNdLCB0aGlzLnZlcnRpY2VzW2kyICogMyArIDFdLCB0aGlzLnZlcnRpY2VzW2kyICogMyArIDJdKTtcbiAgICAgICAgdmVjMy5zZXQodjMsIHRoaXMudmVydGljZXNbaTMgKiAzXSwgdGhpcy52ZXJ0aWNlc1tpMyAqIDMgKyAxXSwgdGhpcy52ZXJ0aWNlc1tpMyAqIDMgKyAyXSk7XG5cbiAgICAgICAgLy8gdGV4dHVyZSBjb29yZGluYXRlIGFzIHZlYzJcbiAgICAgICAgdmVjMi5zZXQodzEsIHRoaXMudGV4Q29vcmRzW2kxICogMl0sIHRoaXMudGV4Q29vcmRzW2kxICogMiArIDFdKTtcbiAgICAgICAgdmVjMi5zZXQodzIsIHRoaXMudGV4Q29vcmRzW2kyICogMl0sIHRoaXMudGV4Q29vcmRzW2kyICogMiArIDFdKTtcbiAgICAgICAgdmVjMi5zZXQodzMsIHRoaXMudGV4Q29vcmRzW2kzICogMl0sIHRoaXMudGV4Q29vcmRzW2kzICogMiArIDFdKTtcblxuICAgICAgICBjb25zdCB4MSA9IHYyWzBdIC0gdjFbMF07XG4gICAgICAgIGNvbnN0IHgyID0gdjNbMF0gLSB2MVswXTtcbiAgICAgICAgY29uc3QgeTEgPSB2MlsxXSAtIHYxWzFdO1xuICAgICAgICBjb25zdCB5MiA9IHYzWzFdIC0gdjFbMV07XG4gICAgICAgIGNvbnN0IHoxID0gdjJbMl0gLSB2MVsyXTtcbiAgICAgICAgY29uc3QgejIgPSB2M1syXSAtIHYxWzJdO1xuXG4gICAgICAgIGNvbnN0IHMxID0gdzJbMF0gLSB3MVswXTtcbiAgICAgICAgY29uc3QgczIgPSB3M1swXSAtIHcxWzBdO1xuICAgICAgICBjb25zdCB0MSA9IHcyWzFdIC0gdzFbMV07XG4gICAgICAgIGNvbnN0IHQyID0gdzNbMV0gLSB3MVsxXTtcblxuICAgICAgICBjb25zdCByID0gMS4wIC8gKHMxICogdDIgLSBzMiAqIHQxKTtcblxuICAgICAgICB2ZWMzLnNldChzZGlyLCAodDIgKiB4MSAtIHQxICogeDIpICogciwgKHQyICogeTEgLSB0MSAqIHkyKSAqIHIsICh0MiAqIHoxIC0gdDEgKiB6MikgKiByKTtcbiAgICAgICAgdmVjMy5zZXQodGRpciwgKHMxICogeDIgLSBzMiAqIHgxKSAqIHIsIChzMSAqIHkyIC0gczIgKiB5MSkgKiByLCAoczEgKiB6MiAtIHMyICogejEpICogcik7XG5cbiAgICAgICAgdGVtcFZlcnRpY2VzW2kxXSA9IHNkaXI7XG4gICAgICAgIHRlbXBWZXJ0aWNlc1tpMl0gPSBzZGlyO1xuICAgICAgICB0ZW1wVmVydGljZXNbaTNdID0gc2RpcjtcblxuICAgICAgICB0ZW1wVmVydGljZXNbaTEgKyB2ZXJ0ZXhDb3VudF0gPSB0ZGlyO1xuICAgICAgICB0ZW1wVmVydGljZXNbaTIgKyB2ZXJ0ZXhDb3VudF0gPSB0ZGlyO1xuICAgICAgICB0ZW1wVmVydGljZXNbaTMgKyB2ZXJ0ZXhDb3VudF0gPSB0ZGlyO1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbCA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgdGVtcFZlcnQgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIGNvbnN0IHRhbiA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgYml0YW4gPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIGNvbnN0IHRlbXAxID0gdmVjMy5jcmVhdGUoKTtcbiAgICBjb25zdCB0ZW1wMiA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgY3Jvc3NQZCA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgICBmb3IgKGxldCB2ZXJ0ID0gMDsgdmVydCA8IHZlcnRleENvdW50OyB2ZXJ0ICs9IDEpXG4gICAge1xuICAgICAgICAvLyBOT1RFOiBzb21lIG1lc2hlcyBkb24ndCBoYXZlIGluZGV4IDAgLSBuIGluIHRoZWlyIGluZGV4YnVmZmVyLCBpZiB0aGlzIGlzIHRoZSBjYXNlLCBza2lwIGNhbGN1bGF0aW9uIG9mIHRoaXMgdmVydGV4XG4gICAgICAgIGlmICghdGVtcFZlcnRpY2VzW3ZlcnRdKSBjb250aW51ZTtcblxuICAgICAgICB2ZWMzLnNldChub3JtYWwsIHRoaXMudmVydGV4Tm9ybWFsc1t2ZXJ0ICogM10sIHRoaXMudmVydGV4Tm9ybWFsc1t2ZXJ0ICogMyArIDFdLCB0aGlzLnZlcnRleE5vcm1hbHNbdmVydCAqIDMgKyAyXSk7XG4gICAgICAgIHZlYzMuc2V0KHRlbXBWZXJ0LCB0ZW1wVmVydGljZXNbdmVydF1bMF0sIHRlbXBWZXJ0aWNlc1t2ZXJ0XVsxXSwgdGVtcFZlcnRpY2VzW3ZlcnRdWzJdKTtcblxuICAgICAgICAvLyBHcmFtLVNjaG1pZHQgb3J0aGFnb25hbGl6ZVxuICAgICAgICBjb25zdCBfZHAgPSB2ZWMzLmRvdChub3JtYWwsIHRlbXBWZXJ0KTtcbiAgICAgICAgdmVjMy5zY2FsZSh0ZW1wMSwgbm9ybWFsLCBfZHApO1xuICAgICAgICB2ZWMzLnN1YnRyYWN0KHRlbXAyLCB0ZW1wVmVydCwgdGVtcDEpO1xuXG4gICAgICAgIHZlYzMubm9ybWFsaXplKG5vcm1hbGl6ZWQsIHRlbXAyKTtcbiAgICAgICAgdmVjMy5jcm9zcyhjcm9zc1BkLCBub3JtYWwsIHRlbXBWZXJ0KTtcblxuICAgICAgICAvLyBjb25zdCBpbnRlcm1Eb3QgPSB2ZWMzLmRvdChjcm9zc1BkLCB0ZW1wVmVydGljZXNbdmVydCArIHZlcnRleENvdW50XSk7XG4gICAgICAgIGNvbnN0IHcgPSAxLjA7Ly8gaW50ZXJtRG90IDwgMC4wID8gLTEuMCA6IDEuMDtcblxuICAgICAgICB2ZWMzLnNjYWxlKHRhbiwgbm9ybWFsaXplZCwgMSAvIHcpO1xuICAgICAgICB2ZWMzLmNyb3NzKGJpdGFuLCBub3JtYWwsIHRhbik7XG5cbiAgICAgICAgdGhpcy50YW5nZW50c1t2ZXJ0ICogMyArIDBdID0gdGFuWzBdO1xuICAgICAgICB0aGlzLnRhbmdlbnRzW3ZlcnQgKiAzICsgMV0gPSB0YW5bMV07XG4gICAgICAgIHRoaXMudGFuZ2VudHNbdmVydCAqIDMgKyAyXSA9IHRhblsyXTtcbiAgICAgICAgdGhpcy5iaVRhbmdlbnRzW3ZlcnQgKiAzICsgMF0gPSBiaXRhblswXTtcbiAgICAgICAgdGhpcy5iaVRhbmdlbnRzW3ZlcnQgKiAzICsgMV0gPSBiaXRhblsxXTtcbiAgICAgICAgdGhpcy5iaVRhbmdlbnRzW3ZlcnQgKiAzICsgMl0gPSBiaXRhblsyXTtcbiAgICB9XG59O1xuXG5HZW9tZXRyeS5wcm90b3R5cGUuaXNJbmRleGVkID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fdmVydGljZXMubGVuZ3RoID09IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggIT0gMDtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIHVuSW5kZXhcbiAqIEBtZW1iZXJvZiBHZW9tZXRyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge0Jvb2xlYW59XG4gKiBAZGVzY3JpcHRpb24gcmVtb3ZlIGFsbCB2ZXJ0ZXggaW5kaXplcywgdmVydGljZXMgYXJyYXkgd2lsbCBjb250YWluIDMqWFlaIGZvciBldmVyeSB0cmlhbmdsZVxuICovXG5HZW9tZXRyeS5wcm90b3R5cGUudW5JbmRleCA9IGZ1bmN0aW9uIChyZUluZGV4LCBkb250Q2FsY05vcm1hbHMpXG57XG4gICAgY29uc3QgbmV3VmVydHMgPSBbXTtcbiAgICBjb25zdCBuZXdJbmRpemVzID0gW107XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIGZvciAobGV0IGogaW4gdGhpcy5fYXR0cmlidXRlcylcbiAgICB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSB0aGlzLl9hdHRyaWJ1dGVzW2pdO1xuICAgICAgICBsZXQgbmEgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydGljZXNJbmRpY2VzLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IDM7IHMrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5pdGVtU2l6ZSA9PSAzKVxuICAgICAgICAgICAgICAgICAgICBuYS5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci5kYXRhW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyBzXSAqIDMgKyAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIuZGF0YVt0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgc10gKiAzICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmRhdGFbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIHNdICogMyArIDJdKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyLml0ZW1TaXplID09IDQpXG4gICAgICAgICAgICAgICAgICAgIG5hLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmRhdGFbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIHNdICogNCArIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci5kYXRhW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyBzXSAqIDQgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIuZGF0YVt0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgc10gKiA0ICsgMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmRhdGFbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIHNdICogNCArIDNdKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyLml0ZW1TaXplID09IDIpXG4gICAgICAgICAgICAgICAgICAgIG5hLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmRhdGFbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIHNdICogMiArIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci5kYXRhW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyBzXSAqIDIgKyAxXSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0ci5pdGVtU2l6ZSA9PSAxKVxuICAgICAgICAgICAgICAgICAgICBuYS5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci5kYXRhW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyBzXV0pO1xuICAgICAgICAgICAgICAgIGVsc2UgY29uc29sZS5sb2coXCJ1bmtub3duIGF0dHJcIiwgYXR0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBuYSwgYXR0ci5pdGVtU2l6ZSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGg7IGkgKz0gMylcbiAgICB7XG4gICAgICAgIG5ld1ZlcnRzLnB1c2goXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyAwXSAqIDMgKyAwXSxcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIDBdICogMyArIDFdLFxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1t0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMF0gKiAzICsgMl0pO1xuXG4gICAgICAgIG5ld0luZGl6ZXMucHVzaChjb3VudCk7XG4gICAgICAgIGNvdW50Kys7XG5cbiAgICAgICAgbmV3VmVydHMucHVzaChcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIDFdICogMyArIDBdLFxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1t0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMV0gKiAzICsgMV0sXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyAxXSAqIDMgKyAyXSk7XG5cbiAgICAgICAgbmV3SW5kaXplcy5wdXNoKGNvdW50KTtcbiAgICAgICAgY291bnQrKztcblxuICAgICAgICBuZXdWZXJ0cy5wdXNoKFxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1t0aGlzLnZlcnRpY2VzSW5kaWNlc1tpICsgMl0gKiAzICsgMF0sXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW3RoaXMudmVydGljZXNJbmRpY2VzW2kgKyAyXSAqIDMgKyAxXSxcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbdGhpcy52ZXJ0aWNlc0luZGljZXNbaSArIDJdICogMyArIDJdKTtcblxuICAgICAgICBuZXdJbmRpemVzLnB1c2goY291bnQpO1xuICAgICAgICBjb3VudCsrO1xuICAgIH1cblxuICAgIHRoaXMudmVydGljZXMgPSBuZXdWZXJ0cztcblxuICAgIHRoaXMudmVydGljZXNJbmRpY2VzID0gW107XG4gICAgaWYgKHJlSW5kZXgpIHRoaXMudmVydGljZXNJbmRpY2VzID0gbmV3SW5kaXplcztcblxuICAgIGlmICghZG9udENhbGNOb3JtYWxzKSB0aGlzLmNhbGN1bGF0ZU5vcm1hbHMoKTtcbn07XG5cbkdlb21ldHJ5LnByb3RvdHlwZS5jYWxjQmFyeWNlbnRyaWMgPSBmdW5jdGlvbiAoKVxue1xuICAgIGxldCBiYXJ5Y2VudHJpY3MgPSBbXTtcbiAgICBiYXJ5Y2VudHJpY3MubGVuZ3RoID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSBiYXJ5Y2VudHJpY3NbaV0gPSAwO1xuXG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpICs9IDMpXG4gICAge1xuICAgICAgICBiYXJ5Y2VudHJpY3NbaSArIGNvdW50XSA9IDE7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIGlmIChjb3VudCA9PSAzKSBjb3VudCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJhdHRyQmFyeWNlbnRyaWNcIiwgYmFyeWNlbnRyaWNzLCAzKTtcbn07XG5cbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3godGhpcyk7XG59O1xuXG5HZW9tZXRyeS5wcm90b3R5cGUuY2VudGVyID0gZnVuY3Rpb24gKHgsIHksIHopXG57XG4gICAgaWYgKHggPT09IHVuZGVmaW5lZClcbiAgICB7XG4gICAgICAgIHggPSB0cnVlO1xuICAgICAgICB5ID0gdHJ1ZTtcbiAgICAgICAgeiA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gW2JvdW5kcy5taW5YICsgKGJvdW5kcy5tYXhYIC0gYm91bmRzLm1pblgpIC8gMiwgYm91bmRzLm1pblkgKyAoYm91bmRzLm1heFkgLSBib3VuZHMubWluWSkgLyAyLCBib3VuZHMubWluWiArIChib3VuZHMubWF4WiAtIGJvdW5kcy5taW5aKSAvIDJdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpICs9IDMpXG4gICAge1xuICAgICAgICBpZiAodGhpcy52ZXJ0aWNlc1tpICsgMF0gPT0gdGhpcy52ZXJ0aWNlc1tpICsgMF0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh4KSB0aGlzLnZlcnRpY2VzW2kgKyAwXSAtPSBvZmZzZXRbMF07XG4gICAgICAgICAgICBpZiAoeSkgdGhpcy52ZXJ0aWNlc1tpICsgMV0gLT0gb2Zmc2V0WzFdO1xuICAgICAgICAgICAgaWYgKHopIHRoaXMudmVydGljZXNbaSArIDJdIC09IG9mZnNldFsyXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQ7XG59O1xuXG5HZW9tZXRyeS5wcm90b3R5cGUubWFwVGV4Q29vcmRzMmQgPSBmdW5jdGlvbiAoKVxue1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgY29uc3QgbnVtID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLyAzO1xuXG4gICAgdGhpcy50ZXhDb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KG51bSAqIDIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW07IGkrKylcbiAgICB7XG4gICAgICAgIGNvbnN0IHZlcnRYID0gdGhpcy52ZXJ0aWNlc1tpICogMyArIDBdO1xuICAgICAgICBjb25zdCB2ZXJ0WSA9IHRoaXMudmVydGljZXNbaSAqIDMgKyAxXTtcbiAgICAgICAgdGhpcy50ZXhDb29yZHNbaSAqIDIgKyAwXSA9IHZlcnRYIC8gKGJvdW5kcy5tYXhYIC0gYm91bmRzLm1pblgpICsgMC41O1xuICAgICAgICB0aGlzLnRleENvb3Jkc1tpICogMiArIDFdID0gMS4wIC0gdmVydFkgLyAoYm91bmRzLm1heFkgLSBib3VuZHMubWluWSkgKyAwLjU7XG4gICAgfVxufTtcblxuXG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0SW5mb09uZUxpbmUgPSBmdW5jdGlvbiAoKVxue1xuICAgIGxldCB0eHQgPSBcIlwiO1xuICAgIGlmICh0aGlzLmZhY2VWZXJ0Q291bnQgPT0gMyAmJiB0aGlzLnZlcnRpY2VzSW5kaWNlcyl0eHQgKz0gdGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoIC8gMztcbiAgICBlbHNlIHR4dCArPSAwO1xuXG4gICAgdHh0ICs9IFwiIHRyaXMgXCI7XG5cbiAgICBpZiAodGhpcy52ZXJ0aWNlcyl0eHQgKz0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLyAzO1xuICAgIGVsc2UgdHh0ICs9IDA7XG5cbiAgICB0eHQgKz0gXCIgdmVydHNcIjtcblxuICAgIHJldHVybiB0eHQ7XG59O1xuXG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0SW5mbyA9IGZ1bmN0aW9uICgpXG57XG4gICAgY29uc3QgaW5mbyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuZmFjZVZlcnRDb3VudCA9PSAzICYmIHRoaXMudmVydGljZXNJbmRpY2VzKWluZm8ubnVtRmFjZXMgPSB0aGlzLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggLyAzO1xuICAgIGVsc2UgaW5mby5udW1GYWNlcyA9IDA7XG5cbiAgICBpZiAodGhpcy52ZXJ0aWNlc0luZGljZXMgJiYgdGhpcy52ZXJ0aWNlc0luZGljZXMubGVuZ3RoKWluZm8uaW5kaWNlcyA9IHRoaXMudmVydGljZXNJbmRpY2VzLmxlbmd0aDtcblxuICAgIGlmICh0aGlzLnZlcnRpY2VzKWluZm8ubnVtVmVydHMgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAvIDM7XG4gICAgZWxzZSBpbmZvLm51bVZlcnRzID0gMDtcblxuICAgIGlmICh0aGlzLnZlcnRleE5vcm1hbHMpIGluZm8ubnVtTm9ybWFscyA9IHRoaXMudmVydGV4Tm9ybWFscy5sZW5ndGggLyAzO1xuICAgIGVsc2UgaW5mby5udW1Ob3JtYWxzID0gMDtcblxuICAgIGlmICh0aGlzLnRleENvb3JkcykgaW5mby5udW1UZXhDb29yZHMgPSB0aGlzLnRleENvb3Jkcy5sZW5ndGggLyAyO1xuICAgIGVsc2UgaW5mby5udW1UZXhDb29yZHMgPSAwO1xuXG4gICAgaWYgKHRoaXMudGFuZ2VudHMpIGluZm8ubnVtVGFuZ2VudHMgPSB0aGlzLnRhbmdlbnRzLmxlbmd0aCAvIDM7XG4gICAgZWxzZSBpbmZvLm51bVRhbmdlbnRzID0gMDtcblxuICAgIGlmICh0aGlzLmJpVGFuZ2VudHMpIGluZm8ubnVtQmlUYW5nZW50cyA9IHRoaXMuYmlUYW5nZW50cy5sZW5ndGggLyAzO1xuICAgIGVsc2UgaW5mby5udW1CaVRhbmdlbnRzID0gMDtcblxuICAgIGlmICh0aGlzLmJpVGFuZ2VudHMpIGluZm8ubnVtQmlUYW5nZW50cyA9IHRoaXMuYmlUYW5nZW50cy5sZW5ndGggLyAzO1xuICAgIGVsc2UgaW5mby5udW1CaVRhbmdlbnRzID0gMDtcblxuICAgIGlmICh0aGlzLnZlcnRleENvbG9ycykgaW5mby5udW1WZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycy5sZW5ndGggLyA0O1xuICAgIGVsc2UgaW5mby5udW1WZXJ0ZXhDb2xvcnMgPSAwO1xuXG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlcygpKSBpbmZvLm51bUF0dHJpYnMgPSBPYmplY3Qua2V5cyh0aGlzLmdldEF0dHJpYnV0ZXMoKSkubGVuZ3RoO1xuICAgIGVsc2UgaW5mby5udW1BdHRyaWJzID0gMDtcblxuICAgIGluZm8uaXNJbmRleGVkID0gdGhpcy5pc0luZGV4ZWQoKTtcblxuICAgIHJldHVybiBpbmZvO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gVE9ETyA6IG1vdmUgdGhpcyBpbnRvIFwib2xkXCIgY2lyY2xlIG9wXG5HZW9tZXRyeS5idWlsZEZyb21GYWNlcyA9IGZ1bmN0aW9uIChhcnIsIG5hbWUsIG9wdGltaXplKVxue1xuICAgIGNvbnN0IHZlcnRpY2VzID0gW107XG4gICAgY29uc3QgdmVydGljZXNJbmRpY2VzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMylcbiAgICB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJbaSArIDBdO1xuICAgICAgICBjb25zdCBiID0gYXJyW2kgKyAxXTtcbiAgICAgICAgY29uc3QgYyA9IGFycltpICsgMl07XG4gICAgICAgIGNvbnN0IGZhY2UgPSBbLTEsIC0xLCAtMV07XG5cbiAgICAgICAgaWYgKG9wdGltaXplKVxuICAgICAgICAgICAgZm9yIChsZXQgaXYgPSAwOyBpdiA8IHZlcnRpY2VzLmxlbmd0aDsgaXYgKz0gMylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAodmVydGljZXNbaXYgKyAwXSA9PSBhWzBdICYmIHZlcnRpY2VzW2l2ICsgMV0gPT0gYVsxXSAmJiB2ZXJ0aWNlc1tpdiArIDJdID09IGFbMl0pIGZhY2VbMF0gPSBpdiAvIDM7XG4gICAgICAgICAgICAgICAgaWYgKHZlcnRpY2VzW2l2ICsgMF0gPT0gYlswXSAmJiB2ZXJ0aWNlc1tpdiArIDFdID09IGJbMV0gJiYgdmVydGljZXNbaXYgKyAyXSA9PSBiWzJdKSBmYWNlWzFdID0gaXYgLyAzO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNlc1tpdiArIDBdID09IGNbMF0gJiYgdmVydGljZXNbaXYgKyAxXSA9PSBjWzFdICYmIHZlcnRpY2VzW2l2ICsgMl0gPT0gY1syXSkgZmFjZVsyXSA9IGl2IC8gMztcbiAgICAgICAgICAgIH1cblxuICAgICAgICBpZiAoZmFjZVswXSA9PSAtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmVydGljZXMucHVzaChhWzBdLCBhWzFdLCBhWzJdKTtcbiAgICAgICAgICAgIGZhY2VbMF0gPSAodmVydGljZXMubGVuZ3RoIC0gMSkgLyAzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZhY2VbMV0gPT0gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goYlswXSwgYlsxXSwgYlsyXSk7XG4gICAgICAgICAgICBmYWNlWzFdID0gKHZlcnRpY2VzLmxlbmd0aCAtIDEpIC8gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmYWNlWzJdID09IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKGNbMF0sIGNbMV0sIGNbMl0pO1xuICAgICAgICAgICAgZmFjZVsyXSA9ICh2ZXJ0aWNlcy5sZW5ndGggLSAxKSAvIDM7XG4gICAgICAgIH1cblxuICAgICAgICB2ZXJ0aWNlc0luZGljZXMucHVzaChwYXJzZUludChmYWNlWzBdLCAxMCkpO1xuICAgICAgICB2ZXJ0aWNlc0luZGljZXMucHVzaChwYXJzZUludChmYWNlWzFdLCAxMCkpO1xuICAgICAgICB2ZXJ0aWNlc0luZGljZXMucHVzaChwYXJzZUludChmYWNlWzJdLCAxMCkpO1xuICAgIH1cblxuICAgIGNvbnN0IGdlb20gPSBuZXcgR2VvbWV0cnkobmFtZSk7XG4gICAgZ2VvbS5uYW1lID0gbmFtZTtcbiAgICBnZW9tLnZlcnRpY2VzID0gdmVydGljZXM7XG4gICAgZ2VvbS52ZXJ0aWNlc0luZGljZXMgPSB2ZXJ0aWNlc0luZGljZXM7XG5cbiAgICByZXR1cm4gZ2VvbTtcbn07XG5cbi8vIFRPRE86IG5vdCBuZWVkZWQgYW55bW9yZSA/ISBtb3ZlIHRvIGRlcHJlY2F0ZWQgb3BzP1xuR2VvbWV0cnkuanNvbjJnZW9tID0gZnVuY3Rpb24gKGpzb25NZXNoKVxue1xuICAgIGNvbnN0IGdlb20gPSBuZXcgR2VvbWV0cnkoXCJqc29uTWVzaEdlb21cIik7XG4gICAgZ2VvbS52ZXJ0aWNlc0luZGljZXMgPSBbXTtcblxuICAgIGdlb20udmVydGljZXMgPSBqc29uTWVzaC52ZXJ0aWNlcyB8fCBbXTtcbiAgICBnZW9tLnZlcnRleE5vcm1hbHMgPSBqc29uTWVzaC5ub3JtYWxzIHx8IFtdO1xuICAgIGdlb20udmVydGV4Q29sb3JzID0ganNvbk1lc2guY29sb3JzIHx8IFtdO1xuICAgIGdlb20udGFuZ2VudHMgPSBqc29uTWVzaC50YW5nZW50cyB8fCBbXTtcbiAgICBnZW9tLmJpVGFuZ2VudHMgPSBqc29uTWVzaC5iaXRhbmdlbnRzIHx8IFtdO1xuICAgIGlmIChqc29uTWVzaC50ZXh0dXJlY29vcmRzKSBnZW9tLnNldFRleENvb3Jkcyhqc29uTWVzaC50ZXh0dXJlY29vcmRzWzBdKTtcblxuICAgIGlmIChqc29uTWVzaC52ZXJ0aWNlc19iNjQpZ2VvbS52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoYjY0ZGVjVHlwZWRBcnJheShqc29uTWVzaC52ZXJ0aWNlc19iNjQpKTtcbiAgICBpZiAoanNvbk1lc2gubm9ybWFsc19iNjQpIGdlb20udmVydGV4Tm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoYjY0ZGVjVHlwZWRBcnJheShqc29uTWVzaC5ub3JtYWxzX2I2NCkpO1xuICAgIGlmIChqc29uTWVzaC50YW5nZW50c19iNjQpIGdlb20udGFuZ2VudHMgPSBuZXcgRmxvYXQzMkFycmF5KGI2NGRlY1R5cGVkQXJyYXkoanNvbk1lc2gudGFuZ2VudHNfYjY0KSk7XG4gICAgaWYgKGpzb25NZXNoLmJpdGFuZ2VudHNfYjY0KSBnZW9tLmJpVGFuZ2VudHMgPSBuZXcgRmxvYXQzMkFycmF5KGI2NGRlY1R5cGVkQXJyYXkoanNvbk1lc2guYml0YW5nZW50c19iNjQpKTtcbiAgICBpZiAoanNvbk1lc2gudGV4dHVyZWNvb3Jkc19iNjQpIGdlb20uc2V0VGV4Q29vcmRzKG5ldyBGbG9hdDMyQXJyYXkoYjY0ZGVjVHlwZWRBcnJheShqc29uTWVzaC50ZXh0dXJlY29vcmRzX2I2NFswXSkpKTtcblxuICAgIGlmIChqc29uTWVzaC5mYWNlc19iNjQpXG4gICAge1xuICAgICAgICBnZW9tLnZlcnRpY2VzSW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheShiNjRkZWNUeXBlZEFycmF5KGpzb25NZXNoLmZhY2VzX2I2NCkpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBnZW9tLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGggPSBqc29uTWVzaC5mYWNlcy5sZW5ndGggKiAzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpzb25NZXNoLmZhY2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBnZW9tLnZlcnRpY2VzSW5kaWNlc1tpICogM10gPSBqc29uTWVzaC5mYWNlc1tpXVswXTtcbiAgICAgICAgICAgIGdlb20udmVydGljZXNJbmRpY2VzW2kgKiAzICsgMV0gPSBqc29uTWVzaC5mYWNlc1tpXVsxXTtcbiAgICAgICAgICAgIGdlb20udmVydGljZXNJbmRpY2VzW2kgKiAzICsgMl0gPSBqc29uTWVzaC5mYWNlc1tpXVsyXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnZW9tO1xufTtcblxuXG5leHBvcnQgeyBHZW9tZXRyeSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cg/cg_geom.js\n");

/***/ }),

/***/ "./src/core/cg/cg_matrixstack.js":
/*!***************************************!*\
  !*** ./src/core/cg/cg_matrixstack.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MatrixStack\": () => (/* binding */ MatrixStack)\n/* harmony export */ });\n\nconst MatrixStack = function ()\n{\n    this._arr = [mat4.create()];\n    this._index = 0;\n    this.stateCounter = 0;\n};\n\nMatrixStack.prototype.push = function (m)\n{\n    this._index++;\n    this.stateCounter++;\n\n    if (this._index == this._arr.length)\n    {\n        const copy = mat4.create();\n        this._arr.push(copy);\n    }\n\n    mat4.copy(this._arr[this._index], m || this._arr[this._index - 1]);\n\n    return this._arr[this._index];\n};\n\nMatrixStack.prototype.pop = function ()\n{\n    this.stateCounter++;\n\n    this._index--;\n    if (this._index < 0) this._index = 0;\n\n    return this._arr[this._index];\n};\n\nMatrixStack.prototype.length = function ()\n{\n    return this._index;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9jZ19tYXRyaXhzdGFjay5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnL2NnX21hdHJpeHN0YWNrLmpzPzNmZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXG5jb25zdCBNYXRyaXhTdGFjayA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fYXJyID0gW21hdDQuY3JlYXRlKCldO1xuICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgICB0aGlzLnN0YXRlQ291bnRlciA9IDA7XG59O1xuXG5NYXRyaXhTdGFjay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChtKVxue1xuICAgIHRoaXMuX2luZGV4Kys7XG4gICAgdGhpcy5zdGF0ZUNvdW50ZXIrKztcblxuICAgIGlmICh0aGlzLl9pbmRleCA9PSB0aGlzLl9hcnIubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgY29uc3QgY29weSA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHRoaXMuX2Fyci5wdXNoKGNvcHkpO1xuICAgIH1cblxuICAgIG1hdDQuY29weSh0aGlzLl9hcnJbdGhpcy5faW5kZXhdLCBtIHx8IHRoaXMuX2Fyclt0aGlzLl9pbmRleCAtIDFdKTtcblxuICAgIHJldHVybiB0aGlzLl9hcnJbdGhpcy5faW5kZXhdO1xufTtcblxuTWF0cml4U3RhY2sucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5zdGF0ZUNvdW50ZXIrKztcblxuICAgIHRoaXMuX2luZGV4LS07XG4gICAgaWYgKHRoaXMuX2luZGV4IDwgMCkgdGhpcy5faW5kZXggPSAwO1xuXG4gICAgcmV0dXJuIHRoaXMuX2Fyclt0aGlzLl9pbmRleF07XG59O1xuXG5NYXRyaXhTdGFjay5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5faW5kZXg7XG59O1xuXG5leHBvcnQgeyBNYXRyaXhTdGFjayB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cg/cg_matrixstack.js\n");

/***/ }),

/***/ "./src/core/cg/cg_state.js":
/*!*********************************!*\
  !*** ./src/core/cg/cg_state.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CGState\": () => (/* binding */ CGState)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/eventtarget.js\");\n/* harmony import */ var _cg_canvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cg_canvas.js */ \"./src/core/cg/cg_canvas.js\");\n/* harmony import */ var _cg_matrixstack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cg_matrixstack.js */ \"./src/core/cg/cg_matrixstack.js\");\n\n\n\n\n\n// const CGState ()\nclass CGState extends cables_shared_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n{\n    constructor(_patch)\n    {\n        super();\n        // this.canvas = null;\n\n        this.fpsCounter = new CABLES.CG.FpsCounter();\n        this._identView = vec3.create();\n        this._ident = vec3.create();\n        vec3.set(this._identView, 0, 0, -2);\n        vec3.set(this._ident, 0, 0, 0);\n\n        this.patch = _patch;\n\n\n\n        this.DEPTH_COMPARE_FUNC_NEVER = 0;\n        this.DEPTH_COMPARE_FUNC_LESS = 1;\n        this.DEPTH_COMPARE_FUNC_EQUAL = 2;\n        this.DEPTH_COMPARE_FUNC_LESSEQUAL = 3;\n        this.DEPTH_COMPARE_FUNC_GREATER = 4;\n        this.DEPTH_COMPARE_FUNC_NOTEQUAL = 5;\n        this.DEPTH_COMPARE_FUNC_GREATEREQUAL = 6;\n        this.DEPTH_COMPARE_FUNC_ALWAYS = 7;\n\n\n        /**\n             * Current projection matrix\n             * @memberof Context\n             * @instance\n             * @type {mat4}\n             */\n        this.pMatrix = mat4.create();\n\n        /**\n             * Current model matrix\n             * @memberof Context\n             * @instance\n             * @type {mat4}\n             */\n        this.mMatrix = mat4.create();\n\n        /**\n             * Current view matrix\n             * @memberof Context\n             * @instance\n             * @type {mat4}\n             */\n        this.vMatrix = mat4.create();\n        this._textureslots = [];\n\n        this._pMatrixStack = new _cg_matrixstack_js__WEBPACK_IMPORTED_MODULE_1__.MatrixStack();\n        this._mMatrixStack = new _cg_matrixstack_js__WEBPACK_IMPORTED_MODULE_1__.MatrixStack();\n        this._vMatrixStack = new _cg_matrixstack_js__WEBPACK_IMPORTED_MODULE_1__.MatrixStack();\n\n        this.canvasScale = 1;\n\n        mat4.identity(this.mMatrix);\n        mat4.identity(this.vMatrix);\n\n\n        window.matchMedia(\"screen and (min-resolution: 2dppx)\")\n            .addEventListener(\"change\", (e) =>\n            {\n                this.emitEvent(\"resize\");\n            });\n    }\n\n    get canvasWidth()\n    {\n        return this.cgCanvas.canvasWidth;\n    }\n\n    get canvasHeight()\n    {\n        return this.cgCanvas.canvasHeight;\n    }\n\n    set pixelDensity(p)\n    {\n        if (this.cgCanvas.pixelDensity != p)\n        {\n            this.cgCanvas.pixelDensity = p;\n            this.cgCanvas.updateSize();\n            this.emitEvent(\"resize\");\n        }\n    }\n\n    get pixelDensity()\n    {\n        return this.cgCanvas.pixelDensity;\n    }\n\n\n    getGApiName()\n    {\n        return [\"WebGL\", \"WebGPU\"][this.gApi];\n    }\n\n    get canvas()\n    {\n        return this.cgCanvas.canvasEle;\n    }\n\n    setCanvas(canvEle)\n    {\n        if (this.cgCanvas && canvEle == this.cgCanvas.canvasEle) return;\n        if (typeof canvEle === \"string\") canvEle = document.getElementById(canvEle);\n\n        this.cgCanvas = new _cg_canvas_js__WEBPACK_IMPORTED_MODULE_2__.CgCanvas({ \"canvasEle\": canvEle, \"cg\": this });\n\n        if (this._setCanvas) this._setCanvas(canvEle);\n\n        this.updateSize();\n    }\n\n    updateSize()\n    {\n        this.cgCanvas.updateSize();\n    }\n\n    setSize(w, h, ignorestyle)\n    {\n        this.cgCanvas.setSize(w, h, ignorestyle);\n    }\n\n    _resizeToWindowSize()\n    {\n        this.setSize(window.innerWidth, window.innerHeight);\n        this.updateSize();\n    }\n\n    _resizeToParentSize()\n    {\n        const p = this.canvas.parentElement;\n        if (!p)\n        {\n            this._log.error(\"cables: can not resize to container element\");\n            return;\n        }\n        this.setSize(p.clientWidth, p.clientHeight);\n\n        this.updateSize();\n    }\n\n    setAutoResize(parent)\n    {\n        window.removeEventListener(\"resize\", this._resizeToWindowSize.bind(this));\n        window.removeEventListener(\"resize\", this._resizeToParentSize.bind(this));\n\n        if (parent == \"window\")\n        {\n            window.addEventListener(\"resize\", this._resizeToWindowSize.bind(this));\n            window.addEventListener(\"orientationchange\", this._resizeToWindowSize.bind(this));\n            this._resizeToWindowSize();\n        }\n        if (parent == \"parent\")\n        {\n            window.addEventListener(\"resize\", this._resizeToParentSize.bind(this));\n            this._resizeToParentSize();\n        }\n    }\n\n\n    /**\n * push a matrix to the projection matrix stack\n * @function pushPMatrix\n * @memberof Context\n * @instance\n * @param {mat4} projectionmatrix\n */\n    pushPMatrix()\n    {\n        this.pMatrix = this._pMatrixStack.push(this.pMatrix);\n    }\n\n    /**\n  * pop projection matrix stack\n  * @function popPMatrix\n  * @memberof Context\n  * @instance\n  * @returns {mat4} current projectionmatrix\n  */\n    popPMatrix()\n    {\n        this.pMatrix = this._pMatrixStack.pop();\n        return this.pMatrix;\n    }\n\n    getProjectionMatrixStateCount()\n    {\n        return this._pMatrixStack.stateCounter;\n    }\n\n    /**\n  * push a matrix to the model matrix stack\n  * @function pushModelMatrix\n  * @memberof Context\n  * @instance\n  * @param {mat4} modelmatrix\n  * @example\n  * // see source code of translate op:\n  * cgl.pushModelMatrix();\n  * mat4.translate(cgl.mMatrix,cgl.mMatrix, vec);\n  * trigger.trigger();\n  * cgl.popModelMatrix();\n  */\n    pushModelMatrix()\n    {\n        this.mMatrix = this._mMatrixStack.push(this.mMatrix);\n    }\n\n    /**\n  * pop model matrix stack\n  * @function popModelMatrix\n  * @memberof Context\n  * @instance\n  * @returns {mat4} current modelmatrix\n  */\n    popModelMatrix()\n    {\n        // todo: DEPRECATE\n        // if (this._mMatrixStack.length === 0) throw \"Invalid modelview popMatrix!\";\n        this.mMatrix = this._mMatrixStack.pop();\n        return this.mMatrix;\n    }\n\n    /**\n  * get model matrix\n  * @function modelMatrix\n  * @memberof Context\n  * @instance\n  * @returns {mat4} current modelmatrix\n  */\n    modelMatrix()\n    {\n        return this.mMatrix;\n    }\n\n\n    /**\n * push a matrix to the view matrix stack\n * @function pushviewMatrix\n * @memberof Context\n * @instance\n * @param {mat4} viewmatrix\n */\n    pushViewMatrix()\n    {\n        this.vMatrix = this._vMatrixStack.push(this.vMatrix);\n    }\n\n    /**\n  * pop view matrix stack\n  * @function popViewMatrix\n  * @memberof Context\n  * @instance\n  * @returns {mat4} current viewmatrix\n  * @function\n  */\n    popViewMatrix()\n    {\n        this.vMatrix = this._vMatrixStack.pop();\n    }\n\n    getViewMatrixStateCount()\n    {\n        return this._vMatrixStack.stateCounter;\n    }\n\n    _startMatrixStacks(identTranslate, identTranslateView)\n    {\n        identTranslate = identTranslate || this._ident;\n        identTranslateView = identTranslateView || this._identView;\n\n        mat4.perspective(this.pMatrix, 45, this.canvasWidth / this.canvasHeight, 0.1, 1000.0);\n\n        mat4.identity(this.mMatrix);\n        mat4.identity(this.vMatrix);\n        mat4.translate(this.mMatrix, this.mMatrix, identTranslate);\n        mat4.translate(this.vMatrix, this.vMatrix, identTranslateView);\n\n        this.pushPMatrix();\n        this.pushModelMatrix();\n        this.pushViewMatrix();\n    }\n\n    _endMatrixStacks()\n    {\n        this.popViewMatrix();\n        this.popModelMatrix();\n        this.popPMatrix();\n    }\n\n    dispose()\n    {\n        this.aborted = true;\n        if (this.cgCanvas) this.cgCanvas.dispose();\n        if (this._dispose) this._dispose();\n    }\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9jZ19zdGF0ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZy9jZ19zdGF0ZS5qcz8zZDJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50cyB9IGZyb20gXCJjYWJsZXMtc2hhcmVkLWNsaWVudFwiO1xuaW1wb3J0IHsgQ2dDYW52YXMgfSBmcm9tIFwiLi9jZ19jYW52YXMuanNcIjtcbmltcG9ydCB7IE1hdHJpeFN0YWNrIH0gZnJvbSBcIi4vY2dfbWF0cml4c3RhY2suanNcIjtcblxuXG4vLyBjb25zdCBDR1N0YXRlICgpXG5jbGFzcyBDR1N0YXRlIGV4dGVuZHMgRXZlbnRzXG57XG4gICAgY29uc3RydWN0b3IoX3BhdGNoKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuZnBzQ291bnRlciA9IG5ldyBDQUJMRVMuQ0cuRnBzQ291bnRlcigpO1xuICAgICAgICB0aGlzLl9pZGVudFZpZXcgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgICAgICB0aGlzLl9pZGVudCA9IHZlYzMuY3JlYXRlKCk7XG4gICAgICAgIHZlYzMuc2V0KHRoaXMuX2lkZW50VmlldywgMCwgMCwgLTIpO1xuICAgICAgICB2ZWMzLnNldCh0aGlzLl9pZGVudCwgMCwgMCwgMCk7XG5cbiAgICAgICAgdGhpcy5wYXRjaCA9IF9wYXRjaDtcblxuXG5cbiAgICAgICAgdGhpcy5ERVBUSF9DT01QQVJFX0ZVTkNfTkVWRVIgPSAwO1xuICAgICAgICB0aGlzLkRFUFRIX0NPTVBBUkVfRlVOQ19MRVNTID0gMTtcbiAgICAgICAgdGhpcy5ERVBUSF9DT01QQVJFX0ZVTkNfRVFVQUwgPSAyO1xuICAgICAgICB0aGlzLkRFUFRIX0NPTVBBUkVfRlVOQ19MRVNTRVFVQUwgPSAzO1xuICAgICAgICB0aGlzLkRFUFRIX0NPTVBBUkVfRlVOQ19HUkVBVEVSID0gNDtcbiAgICAgICAgdGhpcy5ERVBUSF9DT01QQVJFX0ZVTkNfTk9URVFVQUwgPSA1O1xuICAgICAgICB0aGlzLkRFUFRIX0NPTVBBUkVfRlVOQ19HUkVBVEVSRVFVQUwgPSA2O1xuICAgICAgICB0aGlzLkRFUFRIX0NPTVBBUkVfRlVOQ19BTFdBWVMgPSA3O1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDdXJyZW50IHByb2plY3Rpb24gbWF0cml4XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAdHlwZSB7bWF0NH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICB0aGlzLnBNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3VycmVudCBtb2RlbCBtYXRyaXhcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEB0eXBlIHttYXQ0fVxuICAgICAgICAgICAgICovXG4gICAgICAgIHRoaXMubU1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDdXJyZW50IHZpZXcgbWF0cml4XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAdHlwZSB7bWF0NH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICB0aGlzLnZNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICB0aGlzLl90ZXh0dXJlc2xvdHMgPSBbXTtcblxuICAgICAgICB0aGlzLl9wTWF0cml4U3RhY2sgPSBuZXcgTWF0cml4U3RhY2soKTtcbiAgICAgICAgdGhpcy5fbU1hdHJpeFN0YWNrID0gbmV3IE1hdHJpeFN0YWNrKCk7XG4gICAgICAgIHRoaXMuX3ZNYXRyaXhTdGFjayA9IG5ldyBNYXRyaXhTdGFjaygpO1xuXG4gICAgICAgIHRoaXMuY2FudmFzU2NhbGUgPSAxO1xuXG4gICAgICAgIG1hdDQuaWRlbnRpdHkodGhpcy5tTWF0cml4KTtcbiAgICAgICAgbWF0NC5pZGVudGl0eSh0aGlzLnZNYXRyaXgpO1xuXG5cbiAgICAgICAgd2luZG93Lm1hdGNoTWVkaWEoXCJzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMmRwcHgpXCIpXG4gICAgICAgICAgICAuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcInJlc2l6ZVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldCBjYW52YXNXaWR0aCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5jZ0NhbnZhcy5jYW52YXNXaWR0aDtcbiAgICB9XG5cbiAgICBnZXQgY2FudmFzSGVpZ2h0KClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmNnQ2FudmFzLmNhbnZhc0hlaWdodDtcbiAgICB9XG5cbiAgICBzZXQgcGl4ZWxEZW5zaXR5KHApXG4gICAge1xuICAgICAgICBpZiAodGhpcy5jZ0NhbnZhcy5waXhlbERlbnNpdHkgIT0gcClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jZ0NhbnZhcy5waXhlbERlbnNpdHkgPSBwO1xuICAgICAgICAgICAgdGhpcy5jZ0NhbnZhcy51cGRhdGVTaXplKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcInJlc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBwaXhlbERlbnNpdHkoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2dDYW52YXMucGl4ZWxEZW5zaXR5O1xuICAgIH1cblxuXG4gICAgZ2V0R0FwaU5hbWUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIFtcIldlYkdMXCIsIFwiV2ViR1BVXCJdW3RoaXMuZ0FwaV07XG4gICAgfVxuXG4gICAgZ2V0IGNhbnZhcygpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5jZ0NhbnZhcy5jYW52YXNFbGU7XG4gICAgfVxuXG4gICAgc2V0Q2FudmFzKGNhbnZFbGUpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5jZ0NhbnZhcyAmJiBjYW52RWxlID09IHRoaXMuY2dDYW52YXMuY2FudmFzRWxlKSByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgY2FudkVsZSA9PT0gXCJzdHJpbmdcIikgY2FudkVsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZFbGUpO1xuXG4gICAgICAgIHRoaXMuY2dDYW52YXMgPSBuZXcgQ2dDYW52YXMoeyBcImNhbnZhc0VsZVwiOiBjYW52RWxlLCBcImNnXCI6IHRoaXMgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3NldENhbnZhcykgdGhpcy5fc2V0Q2FudmFzKGNhbnZFbGUpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVNpemUoKVxuICAgIHtcbiAgICAgICAgdGhpcy5jZ0NhbnZhcy51cGRhdGVTaXplKCk7XG4gICAgfVxuXG4gICAgc2V0U2l6ZSh3LCBoLCBpZ25vcmVzdHlsZSlcbiAgICB7XG4gICAgICAgIHRoaXMuY2dDYW52YXMuc2V0U2l6ZSh3LCBoLCBpZ25vcmVzdHlsZSk7XG4gICAgfVxuXG4gICAgX3Jlc2l6ZVRvV2luZG93U2l6ZSgpXG4gICAge1xuICAgICAgICB0aGlzLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgIH1cblxuICAgIF9yZXNpemVUb1BhcmVudFNpemUoKVxuICAgIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuY2FudmFzLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGlmICghcClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwiY2FibGVzOiBjYW4gbm90IHJlc2l6ZSB0byBjb250YWluZXIgZWxlbWVudFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNpemUocC5jbGllbnRXaWR0aCwgcC5jbGllbnRIZWlnaHQpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgIH1cblxuICAgIHNldEF1dG9SZXNpemUocGFyZW50KVxuICAgIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplVG9XaW5kb3dTaXplLmJpbmQodGhpcykpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVUb1BhcmVudFNpemUuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgaWYgKHBhcmVudCA9PSBcIndpbmRvd1wiKVxuICAgICAgICB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVUb1dpbmRvd1NpemUuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZVRvV2luZG93U2l6ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZVRvV2luZG93U2l6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnQgPT0gXCJwYXJlbnRcIilcbiAgICAgICAge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplVG9QYXJlbnRTaXplLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplVG9QYXJlbnRTaXplKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICogcHVzaCBhIG1hdHJpeCB0byB0aGUgcHJvamVjdGlvbiBtYXRyaXggc3RhY2tcbiAqIEBmdW5jdGlvbiBwdXNoUE1hdHJpeFxuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHttYXQ0fSBwcm9qZWN0aW9ubWF0cml4XG4gKi9cbiAgICBwdXNoUE1hdHJpeCgpXG4gICAge1xuICAgICAgICB0aGlzLnBNYXRyaXggPSB0aGlzLl9wTWF0cml4U3RhY2sucHVzaCh0aGlzLnBNYXRyaXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAqIHBvcCBwcm9qZWN0aW9uIG1hdHJpeCBzdGFja1xuICAqIEBmdW5jdGlvbiBwb3BQTWF0cml4XG4gICogQG1lbWJlcm9mIENvbnRleHRcbiAgKiBAaW5zdGFuY2VcbiAgKiBAcmV0dXJucyB7bWF0NH0gY3VycmVudCBwcm9qZWN0aW9ubWF0cml4XG4gICovXG4gICAgcG9wUE1hdHJpeCgpXG4gICAge1xuICAgICAgICB0aGlzLnBNYXRyaXggPSB0aGlzLl9wTWF0cml4U3RhY2sucG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBNYXRyaXg7XG4gICAgfVxuXG4gICAgZ2V0UHJvamVjdGlvbk1hdHJpeFN0YXRlQ291bnQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BNYXRyaXhTdGFjay5zdGF0ZUNvdW50ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICogcHVzaCBhIG1hdHJpeCB0byB0aGUgbW9kZWwgbWF0cml4IHN0YWNrXG4gICogQGZ1bmN0aW9uIHB1c2hNb2RlbE1hdHJpeFxuICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICogQGluc3RhbmNlXG4gICogQHBhcmFtIHttYXQ0fSBtb2RlbG1hdHJpeFxuICAqIEBleGFtcGxlXG4gICogLy8gc2VlIHNvdXJjZSBjb2RlIG9mIHRyYW5zbGF0ZSBvcDpcbiAgKiBjZ2wucHVzaE1vZGVsTWF0cml4KCk7XG4gICogbWF0NC50cmFuc2xhdGUoY2dsLm1NYXRyaXgsY2dsLm1NYXRyaXgsIHZlYyk7XG4gICogdHJpZ2dlci50cmlnZ2VyKCk7XG4gICogY2dsLnBvcE1vZGVsTWF0cml4KCk7XG4gICovXG4gICAgcHVzaE1vZGVsTWF0cml4KClcbiAgICB7XG4gICAgICAgIHRoaXMubU1hdHJpeCA9IHRoaXMuX21NYXRyaXhTdGFjay5wdXNoKHRoaXMubU1hdHJpeCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICogcG9wIG1vZGVsIG1hdHJpeCBzdGFja1xuICAqIEBmdW5jdGlvbiBwb3BNb2RlbE1hdHJpeFxuICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICogQGluc3RhbmNlXG4gICogQHJldHVybnMge21hdDR9IGN1cnJlbnQgbW9kZWxtYXRyaXhcbiAgKi9cbiAgICBwb3BNb2RlbE1hdHJpeCgpXG4gICAge1xuICAgICAgICAvLyB0b2RvOiBERVBSRUNBVEVcbiAgICAgICAgLy8gaWYgKHRoaXMuX21NYXRyaXhTdGFjay5sZW5ndGggPT09IDApIHRocm93IFwiSW52YWxpZCBtb2RlbHZpZXcgcG9wTWF0cml4IVwiO1xuICAgICAgICB0aGlzLm1NYXRyaXggPSB0aGlzLl9tTWF0cml4U3RhY2sucG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm1NYXRyaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICogZ2V0IG1vZGVsIG1hdHJpeFxuICAqIEBmdW5jdGlvbiBtb2RlbE1hdHJpeFxuICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICogQGluc3RhbmNlXG4gICogQHJldHVybnMge21hdDR9IGN1cnJlbnQgbW9kZWxtYXRyaXhcbiAgKi9cbiAgICBtb2RlbE1hdHJpeCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5tTWF0cml4O1xuICAgIH1cblxuXG4gICAgLyoqXG4gKiBwdXNoIGEgbWF0cml4IHRvIHRoZSB2aWV3IG1hdHJpeCBzdGFja1xuICogQGZ1bmN0aW9uIHB1c2h2aWV3TWF0cml4XG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge21hdDR9IHZpZXdtYXRyaXhcbiAqL1xuICAgIHB1c2hWaWV3TWF0cml4KClcbiAgICB7XG4gICAgICAgIHRoaXMudk1hdHJpeCA9IHRoaXMuX3ZNYXRyaXhTdGFjay5wdXNoKHRoaXMudk1hdHJpeCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICogcG9wIHZpZXcgbWF0cml4IHN0YWNrXG4gICogQGZ1bmN0aW9uIHBvcFZpZXdNYXRyaXhcbiAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAqIEBpbnN0YW5jZVxuICAqIEByZXR1cm5zIHttYXQ0fSBjdXJyZW50IHZpZXdtYXRyaXhcbiAgKiBAZnVuY3Rpb25cbiAgKi9cbiAgICBwb3BWaWV3TWF0cml4KClcbiAgICB7XG4gICAgICAgIHRoaXMudk1hdHJpeCA9IHRoaXMuX3ZNYXRyaXhTdGFjay5wb3AoKTtcbiAgICB9XG5cbiAgICBnZXRWaWV3TWF0cml4U3RhdGVDb3VudCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdk1hdHJpeFN0YWNrLnN0YXRlQ291bnRlcjtcbiAgICB9XG5cbiAgICBfc3RhcnRNYXRyaXhTdGFja3MoaWRlbnRUcmFuc2xhdGUsIGlkZW50VHJhbnNsYXRlVmlldylcbiAgICB7XG4gICAgICAgIGlkZW50VHJhbnNsYXRlID0gaWRlbnRUcmFuc2xhdGUgfHwgdGhpcy5faWRlbnQ7XG4gICAgICAgIGlkZW50VHJhbnNsYXRlVmlldyA9IGlkZW50VHJhbnNsYXRlVmlldyB8fCB0aGlzLl9pZGVudFZpZXc7XG5cbiAgICAgICAgbWF0NC5wZXJzcGVjdGl2ZSh0aGlzLnBNYXRyaXgsIDQ1LCB0aGlzLmNhbnZhc1dpZHRoIC8gdGhpcy5jYW52YXNIZWlnaHQsIDAuMSwgMTAwMC4wKTtcblxuICAgICAgICBtYXQ0LmlkZW50aXR5KHRoaXMubU1hdHJpeCk7XG4gICAgICAgIG1hdDQuaWRlbnRpdHkodGhpcy52TWF0cml4KTtcbiAgICAgICAgbWF0NC50cmFuc2xhdGUodGhpcy5tTWF0cml4LCB0aGlzLm1NYXRyaXgsIGlkZW50VHJhbnNsYXRlKTtcbiAgICAgICAgbWF0NC50cmFuc2xhdGUodGhpcy52TWF0cml4LCB0aGlzLnZNYXRyaXgsIGlkZW50VHJhbnNsYXRlVmlldyk7XG5cbiAgICAgICAgdGhpcy5wdXNoUE1hdHJpeCgpO1xuICAgICAgICB0aGlzLnB1c2hNb2RlbE1hdHJpeCgpO1xuICAgICAgICB0aGlzLnB1c2hWaWV3TWF0cml4KCk7XG4gICAgfVxuXG4gICAgX2VuZE1hdHJpeFN0YWNrcygpXG4gICAge1xuICAgICAgICB0aGlzLnBvcFZpZXdNYXRyaXgoKTtcbiAgICAgICAgdGhpcy5wb3BNb2RlbE1hdHJpeCgpO1xuICAgICAgICB0aGlzLnBvcFBNYXRyaXgoKTtcbiAgICB9XG5cbiAgICBkaXNwb3NlKClcbiAgICB7XG4gICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmNnQ2FudmFzKSB0aGlzLmNnQ2FudmFzLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2UpIHRoaXMuX2Rpc3Bvc2UoKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IENHU3RhdGUgfTtcblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cg/cg_state.js\n");

/***/ }),

/***/ "./src/core/cg/cg_uniform.js":
/*!***********************************!*\
  !*** ./src/core/cg/cg_uniform.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n/* harmony import */ var _core_port_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core_port.js */ \"./src/core/core_port.js\");\n\n\n\nclass CgUniform\n{\n    constructor(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)\n    {\n        this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"cg_uniform\");\n        this._type = __type;\n        this._name = __name;\n        this._shader = __shader;\n        this._value = 0.00001;\n        this._oldValue = null;\n        this._port = null;\n        this._structName = _structName;\n        this._structUniformName = _structUniformName;\n        this._propertyName = _propertyName;\n\n        this._shader._addUniform(this);\n        this.needsUpdate = true;\n        this.shaderType = null;\n        this.comment = null;\n\n        if (__type == \"f\")\n        {\n            this.set = this.setValue = this.setValueF.bind(this);\n            this.updateValue = this.updateValueF.bind(this);\n        }\n        else if (__type == \"f[]\")\n        {\n            this.set = this.setValue = this.setValueArrayF.bind(this);\n            this.updateValue = this.updateValueArrayF.bind(this);\n        }\n        else if (__type == \"2f[]\")\n        {\n            this.set = this.setValue = this.setValueArray2F.bind(this);\n            this.updateValue = this.updateValueArray2F.bind(this);\n        }\n        else if (__type == \"3f[]\")\n        {\n            this.set = this.setValue = this.setValueArray3F.bind(this);\n            this.updateValue = this.updateValueArray3F.bind(this);\n        }\n        else if (__type == \"4f[]\")\n        {\n            this.set = this.setValue = this.setValueArray4F.bind(this);\n            this.updateValue = this.updateValueArray4F.bind(this);\n        }\n        else if (__type == \"i\")\n        {\n            this.set = this.setValue = this.setValueI.bind(this);\n            this.updateValue = this.updateValueI.bind(this);\n        }\n        else if (__type == \"2i\")\n        {\n            this.set = this.setValue = this.setValue2I.bind(this);\n            this.updateValue = this.updateValue2I.bind(this);\n        }\n        else if (__type == \"3i\")\n        {\n            this.set = this.setValue = this.setValue3I.bind(this);\n            this.updateValue = this.updateValue3I.bind(this);\n        }\n        else if (__type == \"4i\")\n        {\n            this.set = this.setValue = this.setValue4I.bind(this);\n            this.updateValue = this.updateValue4I.bind(this);\n        }\n        else if (__type == \"b\")\n        {\n            this.set = this.setValue = this.setValueBool.bind(this);\n            this.updateValue = this.updateValueBool.bind(this);\n        }\n        else if (__type == \"4f\")\n        {\n            this.set = this.setValue = this.setValue4F.bind(this);\n            this.updateValue = this.updateValue4F.bind(this);\n        }\n        else if (__type == \"3f\")\n        {\n            this.set = this.setValue = this.setValue3F.bind(this);\n            this.updateValue = this.updateValue3F.bind(this);\n        }\n        else if (__type == \"2f\")\n        {\n            this.set = this.setValue = this.setValue2F.bind(this);\n            this.updateValue = this.updateValue2F.bind(this);\n        }\n        else if (__type == \"t\")\n        {\n            this.set = this.setValue = this.setValueT.bind(this);\n            this.updateValue = this.updateValueT.bind(this);\n        }\n        else if (__type == \"tc\")\n        {\n            this.set = this.setValue = this.setValueT.bind(this);\n            this.updateValue = this.updateValueT.bind(this);\n        }\n        else if (__type == \"t[]\")\n        {\n            this.set = this.setValue = this.setValueArrayT.bind(this);\n            this.updateValue = this.updateValueArrayT.bind(this);\n        }\n        else if (__type == \"m4\" || __type == \"m4[]\")\n        {\n            this.set = this.setValue = this.setValueM4.bind(this);\n            this.updateValue = this.updateValueM4.bind(this);\n        }\n        else throw new Error(\"Unknown uniform type\");\n\n        if (typeof _value == \"object\" && _value instanceof _core_port_js__WEBPACK_IMPORTED_MODULE_1__.Port)\n        {\n            this._port = _value;\n            this._value = this._port.get();\n\n\n            if (_port2 && _port3 && _port4)\n            {\n                if (!(_port2 instanceof _core_port_js__WEBPACK_IMPORTED_MODULE_1__.Port) || !(_port3 instanceof _core_port_js__WEBPACK_IMPORTED_MODULE_1__.Port) || !(_port4 instanceof _core_port_js__WEBPACK_IMPORTED_MODULE_1__.Port))\n                {\n                    this._log.error(\"[cgl_uniform] mixed port/value parameter for vec4 \", this._name);\n                }\n\n                this._value = [0, 0, 0, 0];\n                this._port2 = _port2;\n                this._port3 = _port3;\n                this._port4 = _port4;\n\n                this._port.on(\"change\", this.updateFromPort4f.bind(this));\n                this._port2.on(\"change\", this.updateFromPort4f.bind(this));\n                this._port3.on(\"change\", this.updateFromPort4f.bind(this));\n                this._port4.on(\"change\", this.updateFromPort4f.bind(this));\n\n                // this._port.onChange = this._port2.onChange = this._port3.onChange = this._port4.onChange = this.updateFromPort4f.bind(this);\n                this.updateFromPort4f();\n            }\n            else if (_port2 && _port3)\n            {\n                if (!(_port2 instanceof _core_port_js__WEBPACK_IMPORTED_MODULE_1__.Port) || !(_port3 instanceof _core_port_js__WEBPACK_IMPORTED_MODULE_1__.Port))\n                {\n                    this._log.error(\"[cgl_uniform] mixed port/value parameter for vec4 \", this._name);\n                }\n\n                this._value = [0, 0, 0];\n                this._port2 = _port2;\n                this._port3 = _port3;\n                // this._port.onChange = this._port2.onChange = this._port3.onChange = this.updateFromPort3f.bind(this);\n                this._port.on(\"change\", this.updateFromPort3f.bind(this));\n                this._port2.on(\"change\", this.updateFromPort3f.bind(this));\n                this._port3.on(\"change\", this.updateFromPort3f.bind(this));\n\n                this.updateFromPort3f();\n            }\n            else if (_port2)\n            {\n                if (!(_port2 instanceof _core_port_js__WEBPACK_IMPORTED_MODULE_1__.Port))\n                {\n                    this._log.error(\"[cgl_uniform] mixed port/value parameter for vec4 \", this._name);\n                }\n\n                this._value = [0, 0];\n                this._port2 = _port2;\n                // this._port.onChange = this._port2.onChange = this.updateFromPort2f.bind(this);\n                this._port.on(\"change\", this.updateFromPort2f.bind(this));\n                this._port2.on(\"change\", this.updateFromPort2f.bind(this));\n\n                this.updateFromPort2f();\n            }\n            else\n            {\n                // this._port.on = this.updateFromPort.bind(this);\n                this._port.on(\"change\", this.updateFromPort.bind(this));\n            }\n        }\n        else this._value = _value;\n\n        this.setValue(this._value);\n        this.needsUpdate = true;\n    }\n\n\n    getType()\n    {\n        return this._type;\n    }\n\n    getName()\n    {\n        return this._name;\n    }\n\n    getValue()\n    {\n        return this._value;\n    }\n\n    getShaderType()\n    {\n        return this.shaderType;\n    }\n\n    isStructMember()\n    {\n        return !!this._structName;\n    }\n\n\n    updateFromPort4f()\n    {\n        this._value[0] = this._port.get();\n        this._value[1] = this._port2.get();\n        this._value[2] = this._port3.get();\n        this._value[3] = this._port4.get();\n        this.setValue(this._value);\n    }\n\n    updateFromPort3f()\n    {\n        this._value[0] = this._port.get();\n        this._value[1] = this._port2.get();\n        this._value[2] = this._port3.get();\n        this.setValue(this._value);\n    }\n\n    updateFromPort2f()\n    {\n        this._value[0] = this._port.get();\n        this._value[1] = this._port2.get();\n        this.setValue(this._value);\n    }\n\n    updateFromPort()\n    {\n        this.setValue(this._port.get());\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CgUniform);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9jZ191bmlmb3JtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZy9jZ191bmlmb3JtLmpzP2NjMGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcImNhYmxlcy1zaGFyZWQtY2xpZW50XCI7XG5pbXBvcnQgeyBQb3J0IH0gZnJvbSBcIi4uL2NvcmVfcG9ydC5qc1wiO1xuXG5jbGFzcyBDZ1VuaWZvcm1cbntcbiAgICBjb25zdHJ1Y3RvcihfX3NoYWRlciwgX190eXBlLCBfX25hbWUsIF92YWx1ZSwgX3BvcnQyLCBfcG9ydDMsIF9wb3J0NCwgX3N0cnVjdFVuaWZvcm1OYW1lLCBfc3RydWN0TmFtZSwgX3Byb3BlcnR5TmFtZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZyA9IG5ldyBMb2dnZXIoXCJjZ191bmlmb3JtXCIpO1xuICAgICAgICB0aGlzLl90eXBlID0gX190eXBlO1xuICAgICAgICB0aGlzLl9uYW1lID0gX19uYW1lO1xuICAgICAgICB0aGlzLl9zaGFkZXIgPSBfX3NoYWRlcjtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSAwLjAwMDAxO1xuICAgICAgICB0aGlzLl9vbGRWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BvcnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdHJ1Y3ROYW1lID0gX3N0cnVjdE5hbWU7XG4gICAgICAgIHRoaXMuX3N0cnVjdFVuaWZvcm1OYW1lID0gX3N0cnVjdFVuaWZvcm1OYW1lO1xuICAgICAgICB0aGlzLl9wcm9wZXJ0eU5hbWUgPSBfcHJvcGVydHlOYW1lO1xuXG4gICAgICAgIHRoaXMuX3NoYWRlci5fYWRkVW5pZm9ybSh0aGlzKTtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2hhZGVyVHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tbWVudCA9IG51bGw7XG5cbiAgICAgICAgaWYgKF9fdHlwZSA9PSBcImZcIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZUYuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlRi5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcImZbXVwiKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNldCA9IHRoaXMuc2V0VmFsdWUgPSB0aGlzLnNldFZhbHVlQXJyYXlGLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlID0gdGhpcy51cGRhdGVWYWx1ZUFycmF5Ri5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjJmW11cIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZUFycmF5MkYuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlQXJyYXkyRi5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjNmW11cIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZUFycmF5M0YuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlQXJyYXkzRi5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjRmW11cIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZUFycmF5NEYuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlQXJyYXk0Ri5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcImlcIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZUkuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlSS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjJpXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXRWYWx1ZSA9IHRoaXMuc2V0VmFsdWUySS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUySS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjNpXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXRWYWx1ZSA9IHRoaXMuc2V0VmFsdWUzSS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUzSS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjRpXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXRWYWx1ZSA9IHRoaXMuc2V0VmFsdWU0SS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWU0SS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcImJcIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZUJvb2wuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlQm9vbC5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjRmXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXRWYWx1ZSA9IHRoaXMuc2V0VmFsdWU0Ri5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWU0Ri5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjNmXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXRWYWx1ZSA9IHRoaXMuc2V0VmFsdWUzRi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUzRi5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcIjJmXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXRWYWx1ZSA9IHRoaXMuc2V0VmFsdWUyRi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWUyRi5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcInRcIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZVQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUgPSB0aGlzLnVwZGF0ZVZhbHVlVC5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9fdHlwZSA9PSBcInRjXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXRWYWx1ZSA9IHRoaXMuc2V0VmFsdWVULmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlID0gdGhpcy51cGRhdGVWYWx1ZVQuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfX3R5cGUgPT0gXCJ0W11cIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZUFycmF5VC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSA9IHRoaXMudXBkYXRlVmFsdWVBcnJheVQuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfX3R5cGUgPT0gXCJtNFwiIHx8IF9fdHlwZSA9PSBcIm00W11cIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldFZhbHVlID0gdGhpcy5zZXRWYWx1ZU00LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlID0gdGhpcy51cGRhdGVWYWx1ZU00LmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHVuaWZvcm0gdHlwZVwiKTtcblxuICAgICAgICBpZiAodHlwZW9mIF92YWx1ZSA9PSBcIm9iamVjdFwiICYmIF92YWx1ZSBpbnN0YW5jZW9mIFBvcnQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcnQgPSBfdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX3BvcnQuZ2V0KCk7XG5cblxuICAgICAgICAgICAgaWYgKF9wb3J0MiAmJiBfcG9ydDMgJiYgX3BvcnQ0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICghKF9wb3J0MiBpbnN0YW5jZW9mIFBvcnQpIHx8ICEoX3BvcnQzIGluc3RhbmNlb2YgUG9ydCkgfHwgIShfcG9ydDQgaW5zdGFuY2VvZiBQb3J0KSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihcIltjZ2xfdW5pZm9ybV0gbWl4ZWQgcG9ydC92YWx1ZSBwYXJhbWV0ZXIgZm9yIHZlYzQgXCIsIHRoaXMuX25hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQyID0gX3BvcnQyO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQzID0gX3BvcnQzO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQ0ID0gX3BvcnQ0O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9ydC5vbihcImNoYW5nZVwiLCB0aGlzLnVwZGF0ZUZyb21Qb3J0NGYuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9ydDIub24oXCJjaGFuZ2VcIiwgdGhpcy51cGRhdGVGcm9tUG9ydDRmLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQzLm9uKFwiY2hhbmdlXCIsIHRoaXMudXBkYXRlRnJvbVBvcnQ0Zi5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3J0NC5vbihcImNoYW5nZVwiLCB0aGlzLnVwZGF0ZUZyb21Qb3J0NGYuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9wb3J0Lm9uQ2hhbmdlID0gdGhpcy5fcG9ydDIub25DaGFuZ2UgPSB0aGlzLl9wb3J0My5vbkNoYW5nZSA9IHRoaXMuX3BvcnQ0Lm9uQ2hhbmdlID0gdGhpcy51cGRhdGVGcm9tUG9ydDRmLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9tUG9ydDRmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfcG9ydDIgJiYgX3BvcnQzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICghKF9wb3J0MiBpbnN0YW5jZW9mIFBvcnQpIHx8ICEoX3BvcnQzIGluc3RhbmNlb2YgUG9ydCkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJbY2dsX3VuaWZvcm1dIG1peGVkIHBvcnQvdmFsdWUgcGFyYW1ldGVyIGZvciB2ZWM0IFwiLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IFswLCAwLCAwXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3J0MiA9IF9wb3J0MjtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3J0MyA9IF9wb3J0MztcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9wb3J0Lm9uQ2hhbmdlID0gdGhpcy5fcG9ydDIub25DaGFuZ2UgPSB0aGlzLl9wb3J0My5vbkNoYW5nZSA9IHRoaXMudXBkYXRlRnJvbVBvcnQzZi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQub24oXCJjaGFuZ2VcIiwgdGhpcy51cGRhdGVGcm9tUG9ydDNmLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQyLm9uKFwiY2hhbmdlXCIsIHRoaXMudXBkYXRlRnJvbVBvcnQzZi5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3J0My5vbihcImNoYW5nZVwiLCB0aGlzLnVwZGF0ZUZyb21Qb3J0M2YuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZyb21Qb3J0M2YoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF9wb3J0MilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoIShfcG9ydDIgaW5zdGFuY2VvZiBQb3J0KSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihcIltjZ2xfdW5pZm9ybV0gbWl4ZWQgcG9ydC92YWx1ZSBwYXJhbWV0ZXIgZm9yIHZlYzQgXCIsIHRoaXMuX25hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gWzAsIDBdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQyID0gX3BvcnQyO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX3BvcnQub25DaGFuZ2UgPSB0aGlzLl9wb3J0Mi5vbkNoYW5nZSA9IHRoaXMudXBkYXRlRnJvbVBvcnQyZi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQub24oXCJjaGFuZ2VcIiwgdGhpcy51cGRhdGVGcm9tUG9ydDJmLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnQyLm9uKFwiY2hhbmdlXCIsIHRoaXMudXBkYXRlRnJvbVBvcnQyZi5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRnJvbVBvcnQyZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX3BvcnQub24gPSB0aGlzLnVwZGF0ZUZyb21Qb3J0LmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9ydC5vbihcImNoYW5nZVwiLCB0aGlzLnVwZGF0ZUZyb21Qb3J0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XG5cbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLl92YWx1ZSk7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuXG4gICAgZ2V0VHlwZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG5cbiAgICBnZXROYW1lKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cblxuICAgIGdldFZhbHVlKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG5cbiAgICBnZXRTaGFkZXJUeXBlKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYWRlclR5cGU7XG4gICAgfVxuXG4gICAgaXNTdHJ1Y3RNZW1iZXIoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fc3RydWN0TmFtZTtcbiAgICB9XG5cblxuICAgIHVwZGF0ZUZyb21Qb3J0NGYoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdmFsdWVbMF0gPSB0aGlzLl9wb3J0LmdldCgpO1xuICAgICAgICB0aGlzLl92YWx1ZVsxXSA9IHRoaXMuX3BvcnQyLmdldCgpO1xuICAgICAgICB0aGlzLl92YWx1ZVsyXSA9IHRoaXMuX3BvcnQzLmdldCgpO1xuICAgICAgICB0aGlzLl92YWx1ZVszXSA9IHRoaXMuX3BvcnQ0LmdldCgpO1xuICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuX3ZhbHVlKTtcbiAgICB9XG5cbiAgICB1cGRhdGVGcm9tUG9ydDNmKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3ZhbHVlWzBdID0gdGhpcy5fcG9ydC5nZXQoKTtcbiAgICAgICAgdGhpcy5fdmFsdWVbMV0gPSB0aGlzLl9wb3J0Mi5nZXQoKTtcbiAgICAgICAgdGhpcy5fdmFsdWVbMl0gPSB0aGlzLl9wb3J0My5nZXQoKTtcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLl92YWx1ZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlRnJvbVBvcnQyZigpXG4gICAge1xuICAgICAgICB0aGlzLl92YWx1ZVswXSA9IHRoaXMuX3BvcnQuZ2V0KCk7XG4gICAgICAgIHRoaXMuX3ZhbHVlWzFdID0gdGhpcy5fcG9ydDIuZ2V0KCk7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5fdmFsdWUpO1xuICAgIH1cblxuICAgIHVwZGF0ZUZyb21Qb3J0KClcbiAgICB7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5fcG9ydC5nZXQoKSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDZ1VuaWZvcm07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cg/cg_uniform.js\n");

/***/ }),

/***/ "./src/core/cg/sg_fpscounter.js":
/*!**************************************!*\
  !*** ./src/core/cg/sg_fpscounter.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FpsCounter)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/eventtarget.js\");\n\n\nclass FpsCounter extends cables_shared_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n{\n    constructor()\n    {\n        super();\n        this._timeStartFrame = 0;\n        this._timeStartSecond = 0;\n        this._fpsCounter = 0;\n        this._msCounter = 0;\n        this._frameCount = 0;\n\n        this.stats = { \"ms\": 0, \"fps\": 0 };\n    }\n\n    get frameCount()\n    {\n        return this._frameCount;\n    }\n\n    startFrame()\n    {\n        this._timeStartFrame = CABLES.now();\n    }\n\n    endFrame()\n    {\n        this._frameCount++;\n        this._fpsCounter++;\n\n        const timeFrame = CABLES.now() - this._timeStartFrame;\n        this._msCounter += timeFrame;\n\n        if (CABLES.now() - this._timeStartSecond > 1000)\n        {\n            this.endSecond();\n        }\n    }\n\n    endSecond()\n    {\n        this.stats.fps = this._fpsCounter;\n        this.stats.ms = Math.round(this._msCounter / this._fpsCounter * 100) / 100;\n\n        this.emitEvent(\"performance\", this.stats);\n\n        // reset\n        this._fpsCounter = 0;\n        this._msCounter = 0;\n        this._timeStartSecond = CABLES.now();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZy9zZ19mcHNjb3VudGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2cvc2dfZnBzY291bnRlci5qcz8zNTBkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50cyB9IGZyb20gXCJjYWJsZXMtc2hhcmVkLWNsaWVudFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGcHNDb3VudGVyIGV4dGVuZHMgRXZlbnRzXG57XG4gICAgY29uc3RydWN0b3IoKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdGltZVN0YXJ0RnJhbWUgPSAwO1xuICAgICAgICB0aGlzLl90aW1lU3RhcnRTZWNvbmQgPSAwO1xuICAgICAgICB0aGlzLl9mcHNDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fbXNDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fZnJhbWVDb3VudCA9IDA7XG5cbiAgICAgICAgdGhpcy5zdGF0cyA9IHsgXCJtc1wiOiAwLCBcImZwc1wiOiAwIH07XG4gICAgfVxuXG4gICAgZ2V0IGZyYW1lQ291bnQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lQ291bnQ7XG4gICAgfVxuXG4gICAgc3RhcnRGcmFtZSgpXG4gICAge1xuICAgICAgICB0aGlzLl90aW1lU3RhcnRGcmFtZSA9IENBQkxFUy5ub3coKTtcbiAgICB9XG5cbiAgICBlbmRGcmFtZSgpXG4gICAge1xuICAgICAgICB0aGlzLl9mcmFtZUNvdW50Kys7XG4gICAgICAgIHRoaXMuX2Zwc0NvdW50ZXIrKztcblxuICAgICAgICBjb25zdCB0aW1lRnJhbWUgPSBDQUJMRVMubm93KCkgLSB0aGlzLl90aW1lU3RhcnRGcmFtZTtcbiAgICAgICAgdGhpcy5fbXNDb3VudGVyICs9IHRpbWVGcmFtZTtcblxuICAgICAgICBpZiAoQ0FCTEVTLm5vdygpIC0gdGhpcy5fdGltZVN0YXJ0U2Vjb25kID4gMTAwMClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5lbmRTZWNvbmQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVuZFNlY29uZCgpXG4gICAge1xuICAgICAgICB0aGlzLnN0YXRzLmZwcyA9IHRoaXMuX2Zwc0NvdW50ZXI7XG4gICAgICAgIHRoaXMuc3RhdHMubXMgPSBNYXRoLnJvdW5kKHRoaXMuX21zQ291bnRlciAvIHRoaXMuX2Zwc0NvdW50ZXIgKiAxMDApIC8gMTAwO1xuXG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwicGVyZm9ybWFuY2VcIiwgdGhpcy5zdGF0cyk7XG5cbiAgICAgICAgLy8gcmVzZXRcbiAgICAgICAgdGhpcy5fZnBzQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX21zQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX3RpbWVTdGFydFNlY29uZCA9IENBQkxFUy5ub3coKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cg/sg_fpscounter.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_framebuffer.js":
/*!*****************************************!*\
  !*** ./src/core/cgl/cgl_framebuffer.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Framebuffer\": () => (/* binding */ Framebuffer)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n/* harmony import */ var _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgl_texture.js */ \"./src/core/cgl/cgl_texture.js\");\n\n\n\n// todo: convert to prototyped...\n\n/**\n * a framebuffer\n * @external CGL\n * @namespace Framebuffer\n * @constructor\n * @param {Context} cgl\n * @param {Number} width\n * @param {Number} height\n * @param {Object} [options]\n */\nconst Framebuffer = function (_cgl, _w, _h, options)\n{\n    const cgl = _cgl;\n    this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"Framebuffer\");\n    this.valid = true;\n\n    let depthTextureExt = cgl.gl.DEPTH_TEXTURE;\n    if (!depthTextureExt) depthTextureExt = cgl.enableExtension(\"WEBGL_depth_texture\");\n    if (!depthTextureExt) depthTextureExt = cgl.enableExtension(\"WEBKIT_WEBGL_depth_texture\");\n    if (!depthTextureExt) depthTextureExt = cgl.enableExtension(\"MOZ_WEBGL_depth_texture\");\n\n    if (!depthTextureExt)\n    {\n        cgl.exitError(\"NO_DEPTH_TEXTURE\", \"no depth texture support\");\n        // return;\n    }\n\n    let width = _w || 512;\n    let height = _h || 512;\n\n    options = options || {\n        \"isFloatingPointTexture\": false,\n    };\n\n    if (!options.hasOwnProperty(\"clear\")) options.clear = true;\n    if (!options.hasOwnProperty(\"filter\")) options.filter = _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture.FILTER_LINEAR;\n\n    const texture = new _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(cgl, {\n        \"isFloatingPointTexture\": options.isFloatingPointTexture,\n        \"filter\": options.filter,\n        \"wrap\": options.wrap || _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture.CLAMP_TO_EDGE\n    });\n\n    let textureDepth = null;\n    if (depthTextureExt)\n    {\n        textureDepth = new _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(cgl, {\n            \"isDepthTexture\": true,\n        });\n    }\n    this._options = options;\n\n    const frameBuf = cgl.gl.createFramebuffer();\n    const depthBuffer = cgl.gl.createRenderbuffer();\n\n    this.getWidth = function ()\n    {\n        return width;\n    };\n    this.getHeight = function ()\n    {\n        return height;\n    };\n\n    /**\n     * get native gl framebuffer\n     * @function getGlFrameBuffer\n     * @memberof Framebuffer\n     * @returns {Object} framebuffer\n     */\n    this.getGlFrameBuffer = function ()\n    {\n        return frameBuf;\n    };\n\n    /**\n     * get depth renderbuffer\n     * @function getDepthRenderBuffer\n     * @memberof Framebuffer\n     * @returns {Object} renderbuffer\n     */\n    this.getDepthRenderBuffer = function ()\n    {\n        return depthBuffer;\n    };\n\n    /**\n     * get color texture\n     * @function getTextureColor\n     * @memberof Framebuffer\n     * @returns {Texture} rgba texture\n     */\n    this.getTextureColor = function ()\n    {\n        return texture;\n    };\n\n    /**\n     * get depth texture\n     * @function getTextureDepth\n     * @memberof Framebuffer\n     * @returns {Texture} depth texture\n     */\n    this.getTextureDepth = function ()\n    {\n        return textureDepth;\n    };\n\n    this.setFilter = function (f)\n    {\n        texture.filter = f;\n        texture.setSize(width, height);\n    };\n\n    this.setSize = function (w, h)\n    {\n        if (w < 2) w = 2;\n        if (h < 2) h = 2;\n\n        width = Math.ceil(w);\n        height = Math.ceil(h);\n\n        cgl.profileData.profileFrameBuffercreate++;\n\n        cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, frameBuf);\n        cgl.gl.bindRenderbuffer(cgl.gl.RENDERBUFFER, depthBuffer);\n\n        texture.setSize(width, height);\n        if (textureDepth) textureDepth.setSize(width, height);\n\n        // if(depthTextureExt) cgl.gl.renderbufferStorage(cgl.gl.RENDERBUFFER, cgl.gl.DEPTH_COMPONENT16, width,height);\n        if (depthTextureExt) cgl.gl.renderbufferStorage(cgl.gl.RENDERBUFFER, cgl.gl.DEPTH_COMPONENT16, width, height);\n\n        cgl.gl.framebufferTexture2D(cgl.gl.FRAMEBUFFER, cgl.gl.COLOR_ATTACHMENT0, cgl.gl.TEXTURE_2D, texture.tex, 0);\n\n        if (depthTextureExt)\n        {\n            cgl.gl.framebufferRenderbuffer(cgl.gl.FRAMEBUFFER, cgl.gl.DEPTH_ATTACHMENT, cgl.gl.RENDERBUFFER, depthBuffer);\n            cgl.gl.framebufferTexture2D(\n                cgl.gl.FRAMEBUFFER,\n                cgl.gl.DEPTH_ATTACHMENT, // safari needs DEPTH_ATTACHMENT NOT DEPTH_ATTACHMENT16\n                // cgl.gl.DEPTH_COMPONENT16,\n                cgl.gl.TEXTURE_2D,\n                textureDepth.tex,\n                0,\n            );\n        }\n\n        if (!cgl.gl.isFramebuffer(frameBuf)) throw new Error(\"Invalid framebuffer\");\n        const status = cgl.gl.checkFramebufferStatus(cgl.gl.FRAMEBUFFER);\n\n        switch (status)\n        {\n        case cgl.gl.FRAMEBUFFER_COMPLETE:\n            break;\n        case cgl.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            this._log.warn(\"FRAMEBUFFER_INCOMPLETE_ATTACHMENT...\", width, height, texture.tex, depthBuffer);\n            this.valid = false;\n            throw new Error(\"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT\");\n        case cgl.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            this._log.warn(\"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\");\n            this.valid = false;\n            throw new Error(\"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\");\n        case cgl.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            this._log.warn(\"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\");\n            this.valid = false;\n            throw new Error(\"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS\");\n        case cgl.gl.FRAMEBUFFER_UNSUPPORTED:\n            this._log.warn(\"FRAMEBUFFER_UNSUPPORTED\");\n            this.valid = false;\n            throw new Error(\"Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED\");\n        case 0x8CDB:\n            this._log.warn(\"Incomplete: FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER from ext. Or Safari/iOS undefined behaviour.\");\n            this.valid = false;\n            break;\n        default:\n            this._log.warn(\"incomplete framebuffer\", status);\n            this.valid = false;\n            throw new Error(\"Incomplete framebuffer: \" + status);\n            // throw(\"Incomplete framebuffer: \" + status);\n        }\n\n        cgl.gl.bindTexture(cgl.gl.TEXTURE_2D, null);\n        cgl.gl.bindRenderbuffer(cgl.gl.RENDERBUFFER, null);\n        cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, null);\n    };\n\n    this.renderStart = function ()\n    {\n        cgl.pushModelMatrix();\n        cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, frameBuf);\n        cgl.pushGlFrameBuffer(frameBuf);\n        cgl.pushFrameBuffer(this);\n\n        cgl.pushPMatrix();\n        cgl.gl.viewport(0, 0, width, height);\n\n        if (this._options.clear)\n        {\n            cgl.gl.clearColor(0, 0, 0, 0);\n            cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);\n        }\n    };\n\n    this.renderEnd = function ()\n    {\n        cgl.popPMatrix();\n        cgl.gl.bindFramebuffer(cgl.gl.FRAMEBUFFER, cgl.popGlFrameBuffer());\n        cgl.popFrameBuffer();\n\n        cgl.popModelMatrix();\n        cgl.resetViewPort();\n    };\n\n\n    this.delete = function ()\n    {\n        texture.delete();\n        this.valid = false;\n        if (textureDepth) textureDepth.delete();\n        cgl.gl.deleteRenderbuffer(depthBuffer);\n        cgl.gl.deleteFramebuffer(frameBuf);\n    };\n\n    this.dispose = this.delete;\n\n    this.setSize(width, height);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX2ZyYW1lYnVmZmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZ2wvY2dsX2ZyYW1lYnVmZmVyLmpzP2JlZWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcImNhYmxlcy1zaGFyZWQtY2xpZW50XCI7XG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSBcIi4vY2dsX3RleHR1cmUuanNcIjtcblxuLy8gdG9kbzogY29udmVydCB0byBwcm90b3R5cGVkLi4uXG5cbi8qKlxuICogYSBmcmFtZWJ1ZmZlclxuICogQGV4dGVybmFsIENHTFxuICogQG5hbWVzcGFjZSBGcmFtZWJ1ZmZlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0NvbnRleHR9IGNnbFxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKi9cbmNvbnN0IEZyYW1lYnVmZmVyID0gZnVuY3Rpb24gKF9jZ2wsIF93LCBfaCwgb3B0aW9ucylcbntcbiAgICBjb25zdCBjZ2wgPSBfY2dsO1xuICAgIHRoaXMuX2xvZyA9IG5ldyBMb2dnZXIoXCJGcmFtZWJ1ZmZlclwiKTtcbiAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcblxuICAgIGxldCBkZXB0aFRleHR1cmVFeHQgPSBjZ2wuZ2wuREVQVEhfVEVYVFVSRTtcbiAgICBpZiAoIWRlcHRoVGV4dHVyZUV4dCkgZGVwdGhUZXh0dXJlRXh0ID0gY2dsLmVuYWJsZUV4dGVuc2lvbihcIldFQkdMX2RlcHRoX3RleHR1cmVcIik7XG4gICAgaWYgKCFkZXB0aFRleHR1cmVFeHQpIGRlcHRoVGV4dHVyZUV4dCA9IGNnbC5lbmFibGVFeHRlbnNpb24oXCJXRUJLSVRfV0VCR0xfZGVwdGhfdGV4dHVyZVwiKTtcbiAgICBpZiAoIWRlcHRoVGV4dHVyZUV4dCkgZGVwdGhUZXh0dXJlRXh0ID0gY2dsLmVuYWJsZUV4dGVuc2lvbihcIk1PWl9XRUJHTF9kZXB0aF90ZXh0dXJlXCIpO1xuXG4gICAgaWYgKCFkZXB0aFRleHR1cmVFeHQpXG4gICAge1xuICAgICAgICBjZ2wuZXhpdEVycm9yKFwiTk9fREVQVEhfVEVYVFVSRVwiLCBcIm5vIGRlcHRoIHRleHR1cmUgc3VwcG9ydFwiKTtcbiAgICAgICAgLy8gcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB3aWR0aCA9IF93IHx8IDUxMjtcbiAgICBsZXQgaGVpZ2h0ID0gX2ggfHwgNTEyO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgICBcImlzRmxvYXRpbmdQb2ludFRleHR1cmVcIjogZmFsc2UsXG4gICAgfTtcblxuICAgIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcImNsZWFyXCIpKSBvcHRpb25zLmNsZWFyID0gdHJ1ZTtcbiAgICBpZiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJmaWx0ZXJcIikpIG9wdGlvbnMuZmlsdGVyID0gVGV4dHVyZS5GSUxURVJfTElORUFSO1xuXG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGNnbCwge1xuICAgICAgICBcImlzRmxvYXRpbmdQb2ludFRleHR1cmVcIjogb3B0aW9ucy5pc0Zsb2F0aW5nUG9pbnRUZXh0dXJlLFxuICAgICAgICBcImZpbHRlclwiOiBvcHRpb25zLmZpbHRlcixcbiAgICAgICAgXCJ3cmFwXCI6IG9wdGlvbnMud3JhcCB8fCBUZXh0dXJlLkNMQU1QX1RPX0VER0VcbiAgICB9KTtcblxuICAgIGxldCB0ZXh0dXJlRGVwdGggPSBudWxsO1xuICAgIGlmIChkZXB0aFRleHR1cmVFeHQpXG4gICAge1xuICAgICAgICB0ZXh0dXJlRGVwdGggPSBuZXcgVGV4dHVyZShjZ2wsIHtcbiAgICAgICAgICAgIFwiaXNEZXB0aFRleHR1cmVcIjogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgY29uc3QgZnJhbWVCdWYgPSBjZ2wuZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBjb25zdCBkZXB0aEJ1ZmZlciA9IGNnbC5nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblxuICAgIHRoaXMuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH07XG4gICAgdGhpcy5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZ2V0IG5hdGl2ZSBnbCBmcmFtZWJ1ZmZlclxuICAgICAqIEBmdW5jdGlvbiBnZXRHbEZyYW1lQnVmZmVyXG4gICAgICogQG1lbWJlcm9mIEZyYW1lYnVmZmVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gZnJhbWVidWZmZXJcbiAgICAgKi9cbiAgICB0aGlzLmdldEdsRnJhbWVCdWZmZXIgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZyYW1lQnVmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBnZXQgZGVwdGggcmVuZGVyYnVmZmVyXG4gICAgICogQGZ1bmN0aW9uIGdldERlcHRoUmVuZGVyQnVmZmVyXG4gICAgICogQG1lbWJlcm9mIEZyYW1lYnVmZmVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gcmVuZGVyYnVmZmVyXG4gICAgICovXG4gICAgdGhpcy5nZXREZXB0aFJlbmRlckJ1ZmZlciA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gZGVwdGhCdWZmZXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGdldCBjb2xvciB0ZXh0dXJlXG4gICAgICogQGZ1bmN0aW9uIGdldFRleHR1cmVDb2xvclxuICAgICAqIEBtZW1iZXJvZiBGcmFtZWJ1ZmZlclxuICAgICAqIEByZXR1cm5zIHtUZXh0dXJlfSByZ2JhIHRleHR1cmVcbiAgICAgKi9cbiAgICB0aGlzLmdldFRleHR1cmVDb2xvciA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZ2V0IGRlcHRoIHRleHR1cmVcbiAgICAgKiBAZnVuY3Rpb24gZ2V0VGV4dHVyZURlcHRoXG4gICAgICogQG1lbWJlcm9mIEZyYW1lYnVmZmVyXG4gICAgICogQHJldHVybnMge1RleHR1cmV9IGRlcHRoIHRleHR1cmVcbiAgICAgKi9cbiAgICB0aGlzLmdldFRleHR1cmVEZXB0aCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGV4dHVyZURlcHRoO1xuICAgIH07XG5cbiAgICB0aGlzLnNldEZpbHRlciA9IGZ1bmN0aW9uIChmKVxuICAgIHtcbiAgICAgICAgdGV4dHVyZS5maWx0ZXIgPSBmO1xuICAgICAgICB0ZXh0dXJlLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICh3LCBoKVxuICAgIHtcbiAgICAgICAgaWYgKHcgPCAyKSB3ID0gMjtcbiAgICAgICAgaWYgKGggPCAyKSBoID0gMjtcblxuICAgICAgICB3aWR0aCA9IE1hdGguY2VpbCh3KTtcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGgpO1xuXG4gICAgICAgIGNnbC5wcm9maWxlRGF0YS5wcm9maWxlRnJhbWVCdWZmZXJjcmVhdGUrKztcblxuICAgICAgICBjZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKGNnbC5nbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWYpO1xuICAgICAgICBjZ2wuZ2wuYmluZFJlbmRlcmJ1ZmZlcihjZ2wuZ2wuUkVOREVSQlVGRkVSLCBkZXB0aEJ1ZmZlcik7XG5cbiAgICAgICAgdGV4dHVyZS5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBpZiAodGV4dHVyZURlcHRoKSB0ZXh0dXJlRGVwdGguc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyBpZihkZXB0aFRleHR1cmVFeHQpIGNnbC5nbC5yZW5kZXJidWZmZXJTdG9yYWdlKGNnbC5nbC5SRU5ERVJCVUZGRVIsIGNnbC5nbC5ERVBUSF9DT01QT05FTlQxNiwgd2lkdGgsaGVpZ2h0KTtcbiAgICAgICAgaWYgKGRlcHRoVGV4dHVyZUV4dCkgY2dsLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoY2dsLmdsLlJFTkRFUkJVRkZFUiwgY2dsLmdsLkRFUFRIX0NPTVBPTkVOVDE2LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICBjZ2wuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoY2dsLmdsLkZSQU1FQlVGRkVSLCBjZ2wuZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGNnbC5nbC5URVhUVVJFXzJELCB0ZXh0dXJlLnRleCwgMCk7XG5cbiAgICAgICAgaWYgKGRlcHRoVGV4dHVyZUV4dClcbiAgICAgICAge1xuICAgICAgICAgICAgY2dsLmdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGNnbC5nbC5GUkFNRUJVRkZFUiwgY2dsLmdsLkRFUFRIX0FUVEFDSE1FTlQsIGNnbC5nbC5SRU5ERVJCVUZGRVIsIGRlcHRoQnVmZmVyKTtcbiAgICAgICAgICAgIGNnbC5nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgICAgICAgICBjZ2wuZ2wuRlJBTUVCVUZGRVIsXG4gICAgICAgICAgICAgICAgY2dsLmdsLkRFUFRIX0FUVEFDSE1FTlQsIC8vIHNhZmFyaSBuZWVkcyBERVBUSF9BVFRBQ0hNRU5UIE5PVCBERVBUSF9BVFRBQ0hNRU5UMTZcbiAgICAgICAgICAgICAgICAvLyBjZ2wuZ2wuREVQVEhfQ09NUE9ORU5UMTYsXG4gICAgICAgICAgICAgICAgY2dsLmdsLlRFWFRVUkVfMkQsXG4gICAgICAgICAgICAgICAgdGV4dHVyZURlcHRoLnRleCxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2dsLmdsLmlzRnJhbWVidWZmZXIoZnJhbWVCdWYpKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZyYW1lYnVmZmVyXCIpO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBjZ2wuZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhjZ2wuZ2wuRlJBTUVCVUZGRVIpO1xuXG4gICAgICAgIHN3aXRjaCAoc3RhdHVzKVxuICAgICAgICB7XG4gICAgICAgIGNhc2UgY2dsLmdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgY2dsLmdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDpcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5ULi4uXCIsIHdpZHRoLCBoZWlnaHQsIHRleHR1cmUudGV4LCBkZXB0aEJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRcIik7XG4gICAgICAgIGNhc2UgY2dsLmdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOlxuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVFwiKTtcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXCIpO1xuICAgICAgICBjYXNlIGNnbC5nbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OU1wiKTtcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OU1wiKTtcbiAgICAgICAgY2FzZSBjZ2wuZ2wuRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEXCIpO1xuICAgICAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfVU5TVVBQT1JURURcIik7XG4gICAgICAgIGNhc2UgMHg4Q0RCOlxuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJJbmNvbXBsZXRlOiBGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RSQVdfQlVGRkVSIGZyb20gZXh0LiBPciBTYWZhcmkvaU9TIHVuZGVmaW5lZCBiZWhhdmlvdXIuXCIpO1xuICAgICAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcImluY29tcGxldGUgZnJhbWVidWZmZXJcIiwgc3RhdHVzKTtcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IFwiICsgc3RhdHVzKTtcbiAgICAgICAgICAgIC8vIHRocm93KFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogXCIgKyBzdGF0dXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2dsLmdsLmJpbmRUZXh0dXJlKGNnbC5nbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICAgICAgY2dsLmdsLmJpbmRSZW5kZXJidWZmZXIoY2dsLmdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG4gICAgICAgIGNnbC5nbC5iaW5kRnJhbWVidWZmZXIoY2dsLmdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW5kZXJTdGFydCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBjZ2wucHVzaE1vZGVsTWF0cml4KCk7XG4gICAgICAgIGNnbC5nbC5iaW5kRnJhbWVidWZmZXIoY2dsLmdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1Zik7XG4gICAgICAgIGNnbC5wdXNoR2xGcmFtZUJ1ZmZlcihmcmFtZUJ1Zik7XG4gICAgICAgIGNnbC5wdXNoRnJhbWVCdWZmZXIodGhpcyk7XG5cbiAgICAgICAgY2dsLnB1c2hQTWF0cml4KCk7XG4gICAgICAgIGNnbC5nbC52aWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGVhcilcbiAgICAgICAge1xuICAgICAgICAgICAgY2dsLmdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICBjZ2wuZ2wuY2xlYXIoY2dsLmdsLkNPTE9SX0JVRkZFUl9CSVQgfCBjZ2wuZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5yZW5kZXJFbmQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgY2dsLnBvcFBNYXRyaXgoKTtcbiAgICAgICAgY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcihjZ2wuZ2wuRlJBTUVCVUZGRVIsIGNnbC5wb3BHbEZyYW1lQnVmZmVyKCkpO1xuICAgICAgICBjZ2wucG9wRnJhbWVCdWZmZXIoKTtcblxuICAgICAgICBjZ2wucG9wTW9kZWxNYXRyaXgoKTtcbiAgICAgICAgY2dsLnJlc2V0Vmlld1BvcnQoKTtcbiAgICB9O1xuXG5cbiAgICB0aGlzLmRlbGV0ZSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0ZXh0dXJlLmRlbGV0ZSgpO1xuICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgICAgIGlmICh0ZXh0dXJlRGVwdGgpIHRleHR1cmVEZXB0aC5kZWxldGUoKTtcbiAgICAgICAgY2dsLmdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihkZXB0aEJ1ZmZlcik7XG4gICAgICAgIGNnbC5nbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZUJ1Zik7XG4gICAgfTtcblxuICAgIHRoaXMuZGlzcG9zZSA9IHRoaXMuZGVsZXRlO1xuXG4gICAgdGhpcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xufTtcblxuZXhwb3J0IHsgRnJhbWVidWZmZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_framebuffer.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_framebuffer2.js":
/*!******************************************!*\
  !*** ./src/core/cgl/cgl_framebuffer2.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Framebuffer2\": () => (/* binding */ Framebuffer2)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n/* harmony import */ var _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgl_texture.js */ \"./src/core/cgl/cgl_texture.js\");\n// * see framebuffer1\n\n\n\n\n\n\nconst Framebuffer2 = function (cgl, w, h, options)\n{\n    if (cgl.glVersion == 1) return console.log(\"framebuffer2 used on webgl1\");\n    this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"cgl_framebuffer2\");\n    this.Framebuffer2DrawTargetsDefault = null;\n    this.Framebuffer2BlittingFramebuffer = null;\n    this.Framebuffer2FinalFramebuffer = null;\n    this._cgl = cgl;\n\n    this._cgl.printError(\"before framebuffer2 constructor\");\n\n    this._width = 0;\n    this._height = 0;\n    this.valid = true;\n\n    this._depthRenderbuffer = null;\n    this._frameBuffer = null;\n    this._textureFrameBuffer = null;\n    this._colorRenderbuffers = [];\n    this._drawTargetArray = [];\n    this._disposed = false;\n\n    if (!this.Framebuffer2BlittingFramebuffer) this.Framebuffer2BlittingFramebuffer = cgl.gl.createFramebuffer();\n    if (!this.Framebuffer2FinalFramebuffer) this.Framebuffer2FinalFramebuffer = cgl.gl.createFramebuffer();\n\n    if (!this.Framebuffer2DrawTargetsDefault) this.Framebuffer2DrawTargetsDefault = [cgl.gl.COLOR_ATTACHMENT0];\n\n    this._options = options || {\n        \"isFloatingPointTexture\": false,\n    };\n\n    // this._cgl.printError(\"fb2 before\");\n\n    this.name = this._options.name || \"unknown\";\n\n    this._cgl.profileData.addHeavyEvent(\"framebuffer create\", this.name);\n\n    if (!this._options.hasOwnProperty(\"numRenderBuffers\")) this._options.numRenderBuffers = 1;\n    if (!this._options.hasOwnProperty(\"depth\")) this._options.depth = true;\n    if (!this._options.hasOwnProperty(\"clear\")) this._options.clear = true;\n    if (!this._options.hasOwnProperty(\"multisampling\"))\n    {\n        this._options.multisampling = false;\n        this._options.multisamplingSamples = 0;\n    }\n\n    if (this._options.multisamplingSamples)\n    {\n        if (this._cgl.glSlowRenderer) this._options.multisamplingSamples = 0;\n        if (!this._cgl.gl.MAX_SAMPLES) this._options.multisamplingSamples = 0;\n        else this._options.multisamplingSamples = Math.min(this._cgl.maxSamples, this._options.multisamplingSamples);\n    }\n\n    if (!this._options.hasOwnProperty(\"filter\")) this._options.filter = _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture.FILTER_LINEAR;\n    if (!this._options.hasOwnProperty(\"wrap\")) this._options.wrap = _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture.WRAP_REPEAT;\n\n    this._numRenderBuffers = this._options.numRenderBuffers;\n    this._colorTextures = [];\n\n    this.clearColors = [];\n    for (let i = 0; i < this._numRenderBuffers; i++) this.clearColors.push([0, 0, 0, 1]);\n\n\n    if (!options.pixelFormat)\n    {\n        if (options.isFloatingPointTexture) this._options.pixelFormat = _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture.PFORMATSTR_RGBA32F;\n        else this._options.pixelFormat = _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture.PFORMATSTR_RGBA8UB;\n    }\n\n\n    for (let i = 0; i < this._numRenderBuffers; i++)\n    {\n        this._colorTextures[i] = new _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(cgl, {\n            \"name\": \"fb2 \" + this.name + \" \" + i,\n            \"isFloatingPointTexture\": this._options.isFloatingPointTexture,\n            \"anisotropic\": this._options.anisotropic || 0,\n            \"pixelFormat\": this._options.pixelFormat,\n            \"filter\": this._options.filter,\n            \"wrap\": this._options.wrap,\n        });\n    }\n\n\n\n    let fil = _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture.FILTER_NEAREST;\n    if (this._options.shadowMap) fil = _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture.FILTER_LINEAR;\n\n    const defaultTexSize = 512;\n\n    if (this._options.depth)\n    {\n        this._textureDepth = new _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(cgl,\n            {\n                \"name\": \"fb2 depth \" + this.name,\n                \"isDepthTexture\": true,\n                \"filter\": fil,\n                \"shadowMap\": this._options.shadowMap || false,\n                \"width\": w || defaultTexSize,\n                \"height\": h || defaultTexSize,\n            });\n    }\n\n    if (cgl.aborted) return;\n\n    this.setSize(w || defaultTexSize, h || defaultTexSize);\n\n    this._cgl.printError(\"framebuffer2 constructor\");\n};\n\nFramebuffer2.prototype.getWidth = function ()\n{\n    return this._width;\n};\nFramebuffer2.prototype.getHeight = function ()\n{\n    return this._height;\n};\n\nFramebuffer2.prototype.getGlFrameBuffer = function ()\n{\n    return this._frameBuffer;\n};\n\nFramebuffer2.prototype.getDepthRenderBuffer = function ()\n{\n    return this._depthRenderbuffer;\n};\n\nFramebuffer2.prototype.getTextureColor = function ()\n{\n    return this._colorTextures[0];\n};\n\nFramebuffer2.prototype.getTextureColorNum = function (i)\n{\n    return this._colorTextures[i];\n};\n\nFramebuffer2.prototype.getTextureDepth = function ()\n{\n    return this._textureDepth;\n};\n\nFramebuffer2.prototype.setFilter = function (f)\n{\n    for (let i = 0; i < this._numRenderBuffers; i++)\n    {\n        this._colorTextures[i].filter = f;\n        this._colorTextures[i].setSize(this._width, this._height);\n    }\n};\n\nFramebuffer2.prototype.delete = Framebuffer2.prototype.dispose = function ()\n{\n    this._disposed = true;\n    let i = 0;\n    for (i = 0; i < this._numRenderBuffers; i++) this._colorTextures[i].delete();\n    // this._texture.delete();\n    if (this._textureDepth) this._textureDepth.delete();\n    for (i = 0; i < this._numRenderBuffers; i++) this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);\n    this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer);\n    this._cgl.gl.deleteFramebuffer(this._frameBuffer);\n    this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer);\n};\n\nFramebuffer2.prototype.setSize = function (w, h)\n{\n    if (this._disposed) return this._log.warn(\"disposed framebuffer setsize...\");\n    this._cgl.profileData.addHeavyEvent(\"framebuffer resize\", this.name);\n\n    let i = 0;\n    this._width = Math.floor(w);\n    this._height = Math.floor(h);\n    this._width = Math.min(this._width, this._cgl.maxTexSize);\n    this._height = Math.min(this._height, this._cgl.maxTexSize);\n\n    this._cgl.profileData.profileFrameBuffercreate++;\n\n    if (this._frameBuffer)\n    {\n        for (i = 0; i < this._numRenderBuffers; i++) this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffers[i]);\n        // this._cgl.gl.deleteRenderbuffer(this._colorRenderbuffer);\n        this._cgl.gl.deleteRenderbuffer(this._depthRenderbuffer);\n        this._cgl.gl.deleteFramebuffer(this._frameBuffer);\n        this._cgl.gl.deleteFramebuffer(this._textureFrameBuffer);\n    }\n\n    this._frameBuffer = this._cgl.gl.createFramebuffer();\n    this._textureFrameBuffer = this._cgl.gl.createFramebuffer();\n\n    const depth = this._options.depth;\n\n    for (i = 0; i < this._numRenderBuffers; i++)\n    {\n        this._colorTextures[i].setSize(this._width, this._height);\n    }\n\n\n\n    for (i = 0; i < this._numRenderBuffers; i++)\n    {\n        const renderBuffer = this._cgl.gl.createRenderbuffer();\n\n        // color renderbuffer\n\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);\n        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, renderBuffer);\n\n        const info = _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture.setUpGlPixelFormat(this._cgl, this._options.pixelFormat);\n        let internFormat = info.glInternalFormat;\n\n        // if (this._options.isFloatingPointTexture)\n        // {\n        if (CGL.Texture.isPixelFormatHalfFloat(info.pixelFormat))\n        {\n            if (!this._cgl.enableExtension(\"OES_texture_float_linear\"))\n            {\n                this._options.filter = _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture.FILTER_NEAREST;\n                this.setFilter(this._options.filter);\n            }\n        }\n        else if (CGL.Texture.isPixelFormatFloat(info.pixelFormat))\n        {\n            if (!this._cgl.enableExtension(\"OES_texture_float_linear\"))\n            {\n                console.log(\"no linear pixelformat,using nearest\");\n                this._options.filter = _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture.FILTER_NEAREST;\n                this.setFilter(this._options.filter);\n            }\n        }\n        // else if (info.pixelFormat == Texture.PFORMATSTR_RGBA32F || info.pixelFormat == Texture.PFORMATSTR_R11FG11FB10F\n        // else if (info.pixelFormat == Texture.PFORMATSTR_RGBA32F || info.pixelFormat == Texture.PFORMATSTR_R11FG11FB10F\n        // else if (info.pixelFormat == Texture.PFORMATSTR_RG16F)\n        // {\n        //     const extcb = this._cgl.enableExtension(\"EXT_color_buffer_float\");\n\n        //     if (!this._cgl.enableExtension(\"OES_texture_float_linear\"))\n        //     {\n        //         console.log(\"no linear pixelformat,switching to nearest\");\n        //         this._options.filter = Texture.FILTER_NEAREST;\n        //         this.setFilter(this._options.filter);\n        //     }\n        // }\n        // }\n\n        if (this._options.multisampling && this._options.multisamplingSamples)\n        {\n            this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, internFormat, this._width, this._height);\n        }\n        else\n        {\n            this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, internFormat, this._width, this._height);\n        }\n\n\n\n        this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.RENDERBUFFER, renderBuffer);\n        this._colorRenderbuffers[i] = renderBuffer;\n    }\n\n    // this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);\n    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._textureFrameBuffer);\n\n    for (i = 0; i < this._numRenderBuffers; i++)\n    {\n        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);\n    }\n\n    if (this._options.depth)\n    {\n        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.TEXTURE_2D, this._textureDepth.tex, 0);\n    }\n\n    // depth renderbuffer\n\n    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);\n\n\n    let depthType = this._cgl.gl.DEPTH_COMPONENT32F;\n\n    if (this._cgl.glSlowRenderer) depthType = this._cgl.gl.DEPTH_COMPONENT16;\n    if (depth)\n    {\n        this._textureDepth.setSize(this._width, this._height);\n        this._depthRenderbuffer = this._cgl.gl.createRenderbuffer();\n\n        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);\n        if (this._options.isFloatingPointTexture)\n        {\n            if (this._options.multisampling) this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, depthType, this._width, this._height);\n            else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, depthType, this._width, this._height);\n        }\n        else if (this._options.multisampling)\n        {\n            this._cgl.gl.renderbufferStorageMultisample(this._cgl.gl.RENDERBUFFER, this._options.multisamplingSamples, depthType, this._width, this._height);\n            // this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,depthType, this._width, this._height);\n        }\n        else\n        {\n            this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, depthType, this._width, this._height);\n        }\n\n        this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);\n    }\n\n    // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);\n    // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._textureFrameBuffer);\n\n    this._drawTargetArray.length = 0;\n    for (i = 0; i < this._numRenderBuffers; i++) this._drawTargetArray.push(this._cgl.gl.COLOR_ATTACHMENT0 + i);\n\n    // this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);\n\n\n    if (!this._cgl.gl.isFramebuffer(this._textureFrameBuffer)) this._log.warn(\"invalid framebuffer\");// throw new Error(\"Invalid framebuffer\");\n    const status = this._cgl.gl.checkFramebufferStatus(this._cgl.gl.FRAMEBUFFER);\n\n    if (status != this._cgl.gl.FRAMEBUFFER_COMPLETE)\n    {\n        this._log.error(\"framebuffer incomplete: \" + this.name, this);\n        switch (status)\n        {\n        case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            this._log.warn(\"FRAMEBUFFER_INCOMPLETE_ATTACHMENT...\", this);\n            throw new Error(\"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT\");\n        case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            this._log.warn(\"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\");\n            throw new Error(\"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\");\n        case this._cgl.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            this._log.warn(\"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\");\n            throw new Error(\"Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS\");\n        case this._cgl.gl.FRAMEBUFFER_UNSUPPORTED:\n            this._log.warn(\"FRAMEBUFFER_UNSUPPORTED\");\n            throw new Error(\"Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED\");\n        default:\n            this.valid = false;\n            this._log.warn(\"incomplete framebuffer\", status, this._frameBuffer);\n            this._cgl.printError();\n            this._cgl.exitError(\"Framebuffer incomplete...\");\n\n            this._frameBuffer = null;\n            // debugger;\n            throw new Error(\"Incomplete framebuffer: \" + status);\n        // throw(\"Incomplete framebuffer: \" + status);\n        }\n    }\n\n    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);\n    this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);\n\n    // this._cgl.printError(\"fb setsize\");\n};\n\nFramebuffer2.prototype.renderStart = function ()\n{\n    if (this._disposed) return this._log.warn(\"disposed framebuffer renderStart...\");\n    this._cgl.checkFrameStarted(\"fb2 renderstart\");\n    this._cgl.pushModelMatrix(); // needed ??\n\n    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);\n    this._cgl.pushGlFrameBuffer(this._frameBuffer);\n    this._cgl.pushFrameBuffer(this);\n\n    this._cgl.pushPMatrix();\n    // this._cgl.gl.viewport(0, 0, this._width, this._height);\n    this._cgl.pushViewPort(0, 0, this._width, this._height);\n\n    this._cgl.gl.drawBuffers(this._drawTargetArray);\n\n\n    // for (let i = 0; i <= this._numRenderBuffers; i++)\n    // {\n    //     this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.RENDERBUFFER, this._colorRenderbuffers[i]);\n    //     this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, [1.0, 0.0, 0.0, 0.0]);\n    // }\n\n    // this.clear();\n    if (this._options.clear)\n    {\n        this._cgl.gl.clearColor(0, 0, 0, 0);\n        this._cgl.gl.clear(this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT);\n    }\n};\n\nFramebuffer2.prototype.clear = function ()\n{\n    if (this._numRenderBuffers <= 1)\n    {\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this._frameBuffer);\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);\n    }\n    else this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuffer);\n\n    this._cgl.gl.drawBuffers(this._drawTargetArray);\n\n    for (let i = 0; i < this._numRenderBuffers; i++)\n    {\n        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0 + i, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);\n        this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, this.clearColors[i]);\n    }\n    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);\n};\n\nFramebuffer2.prototype.renderEnd = function ()\n{\n    if (this._disposed) return this._log.warn(\"disposed framebuffer renderEnd...\");\n    this._cgl.popPMatrix();\n\n    this._cgl.profileData.profileFramebuffer++;\n\n\n    if (this._numRenderBuffers <= 1)\n    {\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this._frameBuffer);\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this._textureFrameBuffer);\n\n        // const a = this._cgl.gl.getFramebufferAttachmentParameter(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING);\n        // if (a == this._cgl.gl.SRGB)console.log(\"SRGB\", this._cgl.gl.SRGB);\n        // else if (a == this._cgl.gl.LINEAR)console.log(\"LINEAR\", this._cgl.gl.LINEAR);\n\n\n        this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);\n        this._cgl.gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, this._cgl.gl.COLOR_BUFFER_BIT | this._cgl.gl.DEPTH_BUFFER_BIT, this._cgl.gl.NEAREST);\n    }\n    else\n    {\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);\n        this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._depthRenderbuffer);\n\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);\n        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.TEXTURE_2D, this._textureDepth.tex, 0);\n\n        // console.log(\"fb this._numRenderBuffers\", this._numRenderBuffers);\n        for (let i = 0; i < this._numRenderBuffers; i++)\n        {\n            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);\n            this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.RENDERBUFFER, this._colorRenderbuffers[i]);\n\n\n            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);\n            this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex, 0);\n\n            this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);\n\n            this._cgl.gl.bindFramebuffer(this._cgl.gl.READ_FRAMEBUFFER, this.Framebuffer2BlittingFramebuffer);\n            this._cgl.gl.bindFramebuffer(this._cgl.gl.DRAW_FRAMEBUFFER, this.Framebuffer2FinalFramebuffer);\n\n            // this._cgl.gl.clearBufferfv(this._cgl.gl.COLOR, i, [0.0, 0.0, 0.0, 1.0]);\n\n\n\n            let flags = this._cgl.gl.COLOR_BUFFER_BIT;\n            if (i == 0) flags |= this._cgl.gl.DEPTH_BUFFER_BIT;\n\n            this._cgl.gl.blitFramebuffer(0, 0, this._width, this._height, 0, 0, this._width, this._height, flags, this._cgl.gl.NEAREST);\n        }\n    }\n\n    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.popGlFrameBuffer());\n    this._cgl.popFrameBuffer();\n\n    this._cgl.popModelMatrix();\n    // this._cgl.resetViewPort();\n    this._cgl.popViewPort();\n\n\n    if (this._colorTextures[0].filter == _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture.FILTER_MIPMAP)\n    {\n        for (let i = 0; i < this._numRenderBuffers; i++)\n        {\n            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._colorTextures[i].tex);\n            this._colorTextures[i].updateMipMap();\n            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);\n        }\n    }\n};\n\n\n\n/// ///////\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX2ZyYW1lYnVmZmVyMi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dsL2NnbF9mcmFtZWJ1ZmZlcjIuanM/YTk2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAqIHNlZSBmcmFtZWJ1ZmZlcjFcblxuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiY2FibGVzLXNoYXJlZC1jbGllbnRcIjtcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tIFwiLi9jZ2xfdGV4dHVyZS5qc1wiO1xuXG5cbmNvbnN0IEZyYW1lYnVmZmVyMiA9IGZ1bmN0aW9uIChjZ2wsIHcsIGgsIG9wdGlvbnMpXG57XG4gICAgaWYgKGNnbC5nbFZlcnNpb24gPT0gMSkgcmV0dXJuIGNvbnNvbGUubG9nKFwiZnJhbWVidWZmZXIyIHVzZWQgb24gd2ViZ2wxXCIpO1xuICAgIHRoaXMuX2xvZyA9IG5ldyBMb2dnZXIoXCJjZ2xfZnJhbWVidWZmZXIyXCIpO1xuICAgIHRoaXMuRnJhbWVidWZmZXIyRHJhd1RhcmdldHNEZWZhdWx0ID0gbnVsbDtcbiAgICB0aGlzLkZyYW1lYnVmZmVyMkJsaXR0aW5nRnJhbWVidWZmZXIgPSBudWxsO1xuICAgIHRoaXMuRnJhbWVidWZmZXIyRmluYWxGcmFtZWJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5fY2dsID0gY2dsO1xuXG4gICAgdGhpcy5fY2dsLnByaW50RXJyb3IoXCJiZWZvcmUgZnJhbWVidWZmZXIyIGNvbnN0cnVjdG9yXCIpO1xuXG4gICAgdGhpcy5fd2lkdGggPSAwO1xuICAgIHRoaXMuX2hlaWdodCA9IDA7XG4gICAgdGhpcy52YWxpZCA9IHRydWU7XG5cbiAgICB0aGlzLl9kZXB0aFJlbmRlcmJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5fZnJhbWVCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuX3RleHR1cmVGcmFtZUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5fY29sb3JSZW5kZXJidWZmZXJzID0gW107XG4gICAgdGhpcy5fZHJhd1RhcmdldEFycmF5ID0gW107XG4gICAgdGhpcy5fZGlzcG9zZWQgPSBmYWxzZTtcblxuICAgIGlmICghdGhpcy5GcmFtZWJ1ZmZlcjJCbGl0dGluZ0ZyYW1lYnVmZmVyKSB0aGlzLkZyYW1lYnVmZmVyMkJsaXR0aW5nRnJhbWVidWZmZXIgPSBjZ2wuZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBpZiAoIXRoaXMuRnJhbWVidWZmZXIyRmluYWxGcmFtZWJ1ZmZlcikgdGhpcy5GcmFtZWJ1ZmZlcjJGaW5hbEZyYW1lYnVmZmVyID0gY2dsLmdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cbiAgICBpZiAoIXRoaXMuRnJhbWVidWZmZXIyRHJhd1RhcmdldHNEZWZhdWx0KSB0aGlzLkZyYW1lYnVmZmVyMkRyYXdUYXJnZXRzRGVmYXVsdCA9IFtjZ2wuZ2wuQ09MT1JfQVRUQUNITUVOVDBdO1xuXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgICBcImlzRmxvYXRpbmdQb2ludFRleHR1cmVcIjogZmFsc2UsXG4gICAgfTtcblxuICAgIC8vIHRoaXMuX2NnbC5wcmludEVycm9yKFwiZmIyIGJlZm9yZVwiKTtcblxuICAgIHRoaXMubmFtZSA9IHRoaXMuX29wdGlvbnMubmFtZSB8fCBcInVua25vd25cIjtcblxuICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5hZGRIZWF2eUV2ZW50KFwiZnJhbWVidWZmZXIgY3JlYXRlXCIsIHRoaXMubmFtZSk7XG5cbiAgICBpZiAoIXRoaXMuX29wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJudW1SZW5kZXJCdWZmZXJzXCIpKSB0aGlzLl9vcHRpb25zLm51bVJlbmRlckJ1ZmZlcnMgPSAxO1xuICAgIGlmICghdGhpcy5fb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcImRlcHRoXCIpKSB0aGlzLl9vcHRpb25zLmRlcHRoID0gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuX29wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJjbGVhclwiKSkgdGhpcy5fb3B0aW9ucy5jbGVhciA9IHRydWU7XG4gICAgaWYgKCF0aGlzLl9vcHRpb25zLmhhc093blByb3BlcnR5KFwibXVsdGlzYW1wbGluZ1wiKSlcbiAgICB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMubXVsdGlzYW1wbGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vcHRpb25zLm11bHRpc2FtcGxpbmdTYW1wbGVzID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5tdWx0aXNhbXBsaW5nU2FtcGxlcylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9jZ2wuZ2xTbG93UmVuZGVyZXIpIHRoaXMuX29wdGlvbnMubXVsdGlzYW1wbGluZ1NhbXBsZXMgPSAwO1xuICAgICAgICBpZiAoIXRoaXMuX2NnbC5nbC5NQVhfU0FNUExFUykgdGhpcy5fb3B0aW9ucy5tdWx0aXNhbXBsaW5nU2FtcGxlcyA9IDA7XG4gICAgICAgIGVsc2UgdGhpcy5fb3B0aW9ucy5tdWx0aXNhbXBsaW5nU2FtcGxlcyA9IE1hdGgubWluKHRoaXMuX2NnbC5tYXhTYW1wbGVzLCB0aGlzLl9vcHRpb25zLm11bHRpc2FtcGxpbmdTYW1wbGVzKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX29wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJmaWx0ZXJcIikpIHRoaXMuX29wdGlvbnMuZmlsdGVyID0gVGV4dHVyZS5GSUxURVJfTElORUFSO1xuICAgIGlmICghdGhpcy5fb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcIndyYXBcIikpIHRoaXMuX29wdGlvbnMud3JhcCA9IFRleHR1cmUuV1JBUF9SRVBFQVQ7XG5cbiAgICB0aGlzLl9udW1SZW5kZXJCdWZmZXJzID0gdGhpcy5fb3B0aW9ucy5udW1SZW5kZXJCdWZmZXJzO1xuICAgIHRoaXMuX2NvbG9yVGV4dHVyZXMgPSBbXTtcblxuICAgIHRoaXMuY2xlYXJDb2xvcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX251bVJlbmRlckJ1ZmZlcnM7IGkrKykgdGhpcy5jbGVhckNvbG9ycy5wdXNoKFswLCAwLCAwLCAxXSk7XG5cblxuICAgIGlmICghb3B0aW9ucy5waXhlbEZvcm1hdClcbiAgICB7XG4gICAgICAgIGlmIChvcHRpb25zLmlzRmxvYXRpbmdQb2ludFRleHR1cmUpIHRoaXMuX29wdGlvbnMucGl4ZWxGb3JtYXQgPSBUZXh0dXJlLlBGT1JNQVRTVFJfUkdCQTMyRjtcbiAgICAgICAgZWxzZSB0aGlzLl9vcHRpb25zLnBpeGVsRm9ybWF0ID0gVGV4dHVyZS5QRk9STUFUU1RSX1JHQkE4VUI7XG4gICAgfVxuXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX251bVJlbmRlckJ1ZmZlcnM7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMuX2NvbG9yVGV4dHVyZXNbaV0gPSBuZXcgVGV4dHVyZShjZ2wsIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImZiMiBcIiArIHRoaXMubmFtZSArIFwiIFwiICsgaSxcbiAgICAgICAgICAgIFwiaXNGbG9hdGluZ1BvaW50VGV4dHVyZVwiOiB0aGlzLl9vcHRpb25zLmlzRmxvYXRpbmdQb2ludFRleHR1cmUsXG4gICAgICAgICAgICBcImFuaXNvdHJvcGljXCI6IHRoaXMuX29wdGlvbnMuYW5pc290cm9waWMgfHwgMCxcbiAgICAgICAgICAgIFwicGl4ZWxGb3JtYXRcIjogdGhpcy5fb3B0aW9ucy5waXhlbEZvcm1hdCxcbiAgICAgICAgICAgIFwiZmlsdGVyXCI6IHRoaXMuX29wdGlvbnMuZmlsdGVyLFxuICAgICAgICAgICAgXCJ3cmFwXCI6IHRoaXMuX29wdGlvbnMud3JhcCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cblxuICAgIGxldCBmaWwgPSBUZXh0dXJlLkZJTFRFUl9ORUFSRVNUO1xuICAgIGlmICh0aGlzLl9vcHRpb25zLnNoYWRvd01hcCkgZmlsID0gVGV4dHVyZS5GSUxURVJfTElORUFSO1xuXG4gICAgY29uc3QgZGVmYXVsdFRleFNpemUgPSA1MTI7XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5kZXB0aClcbiAgICB7XG4gICAgICAgIHRoaXMuX3RleHR1cmVEZXB0aCA9IG5ldyBUZXh0dXJlKGNnbCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJmYjIgZGVwdGggXCIgKyB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgXCJpc0RlcHRoVGV4dHVyZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwiZmlsdGVyXCI6IGZpbCxcbiAgICAgICAgICAgICAgICBcInNoYWRvd01hcFwiOiB0aGlzLl9vcHRpb25zLnNoYWRvd01hcCB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBcIndpZHRoXCI6IHcgfHwgZGVmYXVsdFRleFNpemUsXG4gICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogaCB8fCBkZWZhdWx0VGV4U2l6ZSxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjZ2wuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgdGhpcy5zZXRTaXplKHcgfHwgZGVmYXVsdFRleFNpemUsIGggfHwgZGVmYXVsdFRleFNpemUpO1xuXG4gICAgdGhpcy5fY2dsLnByaW50RXJyb3IoXCJmcmFtZWJ1ZmZlcjIgY29uc3RydWN0b3JcIik7XG59O1xuXG5GcmFtZWJ1ZmZlcjIucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG59O1xuRnJhbWVidWZmZXIyLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG59O1xuXG5GcmFtZWJ1ZmZlcjIucHJvdG90eXBlLmdldEdsRnJhbWVCdWZmZXIgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9mcmFtZUJ1ZmZlcjtcbn07XG5cbkZyYW1lYnVmZmVyMi5wcm90b3R5cGUuZ2V0RGVwdGhSZW5kZXJCdWZmZXIgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9kZXB0aFJlbmRlcmJ1ZmZlcjtcbn07XG5cbkZyYW1lYnVmZmVyMi5wcm90b3R5cGUuZ2V0VGV4dHVyZUNvbG9yID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fY29sb3JUZXh0dXJlc1swXTtcbn07XG5cbkZyYW1lYnVmZmVyMi5wcm90b3R5cGUuZ2V0VGV4dHVyZUNvbG9yTnVtID0gZnVuY3Rpb24gKGkpXG57XG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yVGV4dHVyZXNbaV07XG59O1xuXG5GcmFtZWJ1ZmZlcjIucHJvdG90eXBlLmdldFRleHR1cmVEZXB0aCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVEZXB0aDtcbn07XG5cbkZyYW1lYnVmZmVyMi5wcm90b3R5cGUuc2V0RmlsdGVyID0gZnVuY3Rpb24gKGYpXG57XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9udW1SZW5kZXJCdWZmZXJzOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLl9jb2xvclRleHR1cmVzW2ldLmZpbHRlciA9IGY7XG4gICAgICAgIHRoaXMuX2NvbG9yVGV4dHVyZXNbaV0uc2V0U2l6ZSh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICB9XG59O1xuXG5GcmFtZWJ1ZmZlcjIucHJvdG90eXBlLmRlbGV0ZSA9IEZyYW1lYnVmZmVyMi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbnVtUmVuZGVyQnVmZmVyczsgaSsrKSB0aGlzLl9jb2xvclRleHR1cmVzW2ldLmRlbGV0ZSgpO1xuICAgIC8vIHRoaXMuX3RleHR1cmUuZGVsZXRlKCk7XG4gICAgaWYgKHRoaXMuX3RleHR1cmVEZXB0aCkgdGhpcy5fdGV4dHVyZURlcHRoLmRlbGV0ZSgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9udW1SZW5kZXJCdWZmZXJzOyBpKyspIHRoaXMuX2NnbC5nbC5kZWxldGVSZW5kZXJidWZmZXIodGhpcy5fY29sb3JSZW5kZXJidWZmZXJzW2ldKTtcbiAgICB0aGlzLl9jZ2wuZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKHRoaXMuX2RlcHRoUmVuZGVyYnVmZmVyKTtcbiAgICB0aGlzLl9jZ2wuZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5fZnJhbWVCdWZmZXIpO1xuICAgIHRoaXMuX2NnbC5nbC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLl90ZXh0dXJlRnJhbWVCdWZmZXIpO1xufTtcblxuRnJhbWVidWZmZXIyLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24gKHcsIGgpXG57XG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSByZXR1cm4gdGhpcy5fbG9nLndhcm4oXCJkaXNwb3NlZCBmcmFtZWJ1ZmZlciBzZXRzaXplLi4uXCIpO1xuICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5hZGRIZWF2eUV2ZW50KFwiZnJhbWVidWZmZXIgcmVzaXplXCIsIHRoaXMubmFtZSk7XG5cbiAgICBsZXQgaSA9IDA7XG4gICAgdGhpcy5fd2lkdGggPSBNYXRoLmZsb29yKHcpO1xuICAgIHRoaXMuX2hlaWdodCA9IE1hdGguZmxvb3IoaCk7XG4gICAgdGhpcy5fd2lkdGggPSBNYXRoLm1pbih0aGlzLl93aWR0aCwgdGhpcy5fY2dsLm1heFRleFNpemUpO1xuICAgIHRoaXMuX2hlaWdodCA9IE1hdGgubWluKHRoaXMuX2hlaWdodCwgdGhpcy5fY2dsLm1heFRleFNpemUpO1xuXG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVGcmFtZUJ1ZmZlcmNyZWF0ZSsrO1xuXG4gICAgaWYgKHRoaXMuX2ZyYW1lQnVmZmVyKVxuICAgIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX251bVJlbmRlckJ1ZmZlcnM7IGkrKykgdGhpcy5fY2dsLmdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcih0aGlzLl9jb2xvclJlbmRlcmJ1ZmZlcnNbaV0pO1xuICAgICAgICAvLyB0aGlzLl9jZ2wuZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKHRoaXMuX2NvbG9yUmVuZGVyYnVmZmVyKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcih0aGlzLl9kZXB0aFJlbmRlcmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLl9mcmFtZUJ1ZmZlcik7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLl90ZXh0dXJlRnJhbWVCdWZmZXIpO1xuICAgIH1cblxuICAgIHRoaXMuX2ZyYW1lQnVmZmVyID0gdGhpcy5fY2dsLmdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdGhpcy5fdGV4dHVyZUZyYW1lQnVmZmVyID0gdGhpcy5fY2dsLmdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cbiAgICBjb25zdCBkZXB0aCA9IHRoaXMuX29wdGlvbnMuZGVwdGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbnVtUmVuZGVyQnVmZmVyczsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY29sb3JUZXh0dXJlc1tpXS5zZXRTaXplKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgIH1cblxuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fbnVtUmVuZGVyQnVmZmVyczsgaSsrKVxuICAgIHtcbiAgICAgICAgY29uc3QgcmVuZGVyQnVmZmVyID0gdGhpcy5fY2dsLmdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXG4gICAgICAgIC8vIGNvbG9yIHJlbmRlcmJ1ZmZlclxuXG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9mcmFtZUJ1ZmZlcik7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kUmVuZGVyYnVmZmVyKHRoaXMuX2NnbC5nbC5SRU5ERVJCVUZGRVIsIHJlbmRlckJ1ZmZlcik7XG5cbiAgICAgICAgY29uc3QgaW5mbyA9IFRleHR1cmUuc2V0VXBHbFBpeGVsRm9ybWF0KHRoaXMuX2NnbCwgdGhpcy5fb3B0aW9ucy5waXhlbEZvcm1hdCk7XG4gICAgICAgIGxldCBpbnRlcm5Gb3JtYXQgPSBpbmZvLmdsSW50ZXJuYWxGb3JtYXQ7XG5cbiAgICAgICAgLy8gaWYgKHRoaXMuX29wdGlvbnMuaXNGbG9hdGluZ1BvaW50VGV4dHVyZSlcbiAgICAgICAgLy8ge1xuICAgICAgICBpZiAoQ0dMLlRleHR1cmUuaXNQaXhlbEZvcm1hdEhhbGZGbG9hdChpbmZvLnBpeGVsRm9ybWF0KSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jZ2wuZW5hYmxlRXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXCIpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuZmlsdGVyID0gVGV4dHVyZS5GSUxURVJfTkVBUkVTVDtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZpbHRlcih0aGlzLl9vcHRpb25zLmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ0dMLlRleHR1cmUuaXNQaXhlbEZvcm1hdEZsb2F0KGluZm8ucGl4ZWxGb3JtYXQpKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NnbC5lbmFibGVFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXJcIikpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJubyBsaW5lYXIgcGl4ZWxmb3JtYXQsdXNpbmcgbmVhcmVzdFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmZpbHRlciA9IFRleHR1cmUuRklMVEVSX05FQVJFU1Q7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGaWx0ZXIodGhpcy5fb3B0aW9ucy5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2UgaWYgKGluZm8ucGl4ZWxGb3JtYXQgPT0gVGV4dHVyZS5QRk9STUFUU1RSX1JHQkEzMkYgfHwgaW5mby5waXhlbEZvcm1hdCA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUjExRkcxMUZCMTBGXG4gICAgICAgIC8vIGVsc2UgaWYgKGluZm8ucGl4ZWxGb3JtYXQgPT0gVGV4dHVyZS5QRk9STUFUU1RSX1JHQkEzMkYgfHwgaW5mby5waXhlbEZvcm1hdCA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUjExRkcxMUZCMTBGXG4gICAgICAgIC8vIGVsc2UgaWYgKGluZm8ucGl4ZWxGb3JtYXQgPT0gVGV4dHVyZS5QRk9STUFUU1RSX1JHMTZGKVxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgICBjb25zdCBleHRjYiA9IHRoaXMuX2NnbC5lbmFibGVFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpO1xuXG4gICAgICAgIC8vICAgICBpZiAoIXRoaXMuX2NnbC5lbmFibGVFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXJcIikpXG4gICAgICAgIC8vICAgICB7XG4gICAgICAgIC8vICAgICAgICAgY29uc29sZS5sb2coXCJubyBsaW5lYXIgcGl4ZWxmb3JtYXQsc3dpdGNoaW5nIHRvIG5lYXJlc3RcIik7XG4gICAgICAgIC8vICAgICAgICAgdGhpcy5fb3B0aW9ucy5maWx0ZXIgPSBUZXh0dXJlLkZJTFRFUl9ORUFSRVNUO1xuICAgICAgICAvLyAgICAgICAgIHRoaXMuc2V0RmlsdGVyKHRoaXMuX29wdGlvbnMuZmlsdGVyKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMubXVsdGlzYW1wbGluZyAmJiB0aGlzLl9vcHRpb25zLm11bHRpc2FtcGxpbmdTYW1wbGVzKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKHRoaXMuX2NnbC5nbC5SRU5ERVJCVUZGRVIsIHRoaXMuX29wdGlvbnMubXVsdGlzYW1wbGluZ1NhbXBsZXMsIGludGVybkZvcm1hdCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSh0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLCBpbnRlcm5Gb3JtYXQsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICB9XG5cblxuXG4gICAgICAgIHRoaXMuX2NnbC5nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2NnbC5nbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIHRoaXMuX2NnbC5nbC5SRU5ERVJCVUZGRVIsIHJlbmRlckJ1ZmZlcik7XG4gICAgICAgIHRoaXMuX2NvbG9yUmVuZGVyYnVmZmVyc1tpXSA9IHJlbmRlckJ1ZmZlcjtcbiAgICB9XG5cbiAgICAvLyB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5EUkFXX0ZSQU1FQlVGRkVSLCB0aGlzLl90ZXh0dXJlRnJhbWVCdWZmZXIpO1xuICAgIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl90ZXh0dXJlRnJhbWVCdWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX251bVJlbmRlckJ1ZmZlcnM7IGkrKylcbiAgICB7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2NnbC5nbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIHRoaXMuX2NnbC5nbC5URVhUVVJFXzJELCB0aGlzLl9jb2xvclRleHR1cmVzW2ldLnRleCwgMCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZGVwdGgpXG4gICAge1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9jZ2wuZ2wuREVQVEhfQVRUQUNITUVOVCwgdGhpcy5fY2dsLmdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmVEZXB0aC50ZXgsIDApO1xuICAgIH1cblxuICAgIC8vIGRlcHRoIHJlbmRlcmJ1ZmZlclxuXG4gICAgdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lQnVmZmVyKTtcblxuXG4gICAgbGV0IGRlcHRoVHlwZSA9IHRoaXMuX2NnbC5nbC5ERVBUSF9DT01QT05FTlQzMkY7XG5cbiAgICBpZiAodGhpcy5fY2dsLmdsU2xvd1JlbmRlcmVyKSBkZXB0aFR5cGUgPSB0aGlzLl9jZ2wuZ2wuREVQVEhfQ09NUE9ORU5UMTY7XG4gICAgaWYgKGRlcHRoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdGV4dHVyZURlcHRoLnNldFNpemUodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgICAgIHRoaXMuX2RlcHRoUmVuZGVyYnVmZmVyID0gdGhpcy5fY2dsLmdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kUmVuZGVyYnVmZmVyKHRoaXMuX2NnbC5nbC5SRU5ERVJCVUZGRVIsIHRoaXMuX2RlcHRoUmVuZGVyYnVmZmVyKTtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuaXNGbG9hdGluZ1BvaW50VGV4dHVyZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMubXVsdGlzYW1wbGluZykgdGhpcy5fY2dsLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZSh0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9vcHRpb25zLm11bHRpc2FtcGxpbmdTYW1wbGVzLCBkZXB0aFR5cGUsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICAgICAgZWxzZSB0aGlzLl9jZ2wuZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSh0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLCBkZXB0aFR5cGUsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX29wdGlvbnMubXVsdGlzYW1wbGluZylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZSh0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9vcHRpb25zLm11bHRpc2FtcGxpbmdTYW1wbGVzLCBkZXB0aFR5cGUsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICAgICAgLy8gdGhpcy5fY2dsLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UodGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUixkZXB0aFR5cGUsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UodGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUiwgZGVwdGhUeXBlLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NnbC5nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2NnbC5nbC5ERVBUSF9BVFRBQ0hNRU5ULCB0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9kZXB0aFJlbmRlcmJ1ZmZlcik7XG4gICAgfVxuXG4gICAgLy8gdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIC8vIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl90ZXh0dXJlRnJhbWVCdWZmZXIpO1xuXG4gICAgdGhpcy5fZHJhd1RhcmdldEFycmF5Lmxlbmd0aCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX251bVJlbmRlckJ1ZmZlcnM7IGkrKykgdGhpcy5fZHJhd1RhcmdldEFycmF5LnB1c2godGhpcy5fY2dsLmdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSk7XG5cbiAgICAvLyB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cblxuICAgIGlmICghdGhpcy5fY2dsLmdsLmlzRnJhbWVidWZmZXIodGhpcy5fdGV4dHVyZUZyYW1lQnVmZmVyKSkgdGhpcy5fbG9nLndhcm4oXCJpbnZhbGlkIGZyYW1lYnVmZmVyXCIpOy8vIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZnJhbWVidWZmZXJcIik7XG4gICAgY29uc3Qgc3RhdHVzID0gdGhpcy5fY2dsLmdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXModGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSKTtcblxuICAgIGlmIChzdGF0dXMgIT0gdGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwiZnJhbWVidWZmZXIgaW5jb21wbGV0ZTogXCIgKyB0aGlzLm5hbWUsIHRoaXMpO1xuICAgICAgICBzd2l0Y2ggKHN0YXR1cylcbiAgICAgICAge1xuICAgICAgICBjYXNlIHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQ6XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVC4uLlwiLCB0aGlzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVFwiKTtcbiAgICAgICAgY2FzZSB0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQ6XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlRcIik7XG4gICAgICAgIGNhc2UgdGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzpcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TXCIpO1xuICAgICAgICBjYXNlIHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDpcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiRlJBTUVCVUZGRVJfVU5TVVBQT1JURURcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRFwiKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiaW5jb21wbGV0ZSBmcmFtZWJ1ZmZlclwiLCBzdGF0dXMsIHRoaXMuX2ZyYW1lQnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5wcmludEVycm9yKCk7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZXhpdEVycm9yKFwiRnJhbWVidWZmZXIgaW5jb21wbGV0ZS4uLlwiKTtcblxuICAgICAgICAgICAgdGhpcy5fZnJhbWVCdWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgLy8gZGVidWdnZXI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBcIiArIHN0YXR1cyk7XG4gICAgICAgIC8vIHRocm93KFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogXCIgKyBzdGF0dXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIHRoaXMuX2NnbC5nbC5iaW5kUmVuZGVyYnVmZmVyKHRoaXMuX2NnbC5nbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuXG4gICAgLy8gdGhpcy5fY2dsLnByaW50RXJyb3IoXCJmYiBzZXRzaXplXCIpO1xufTtcblxuRnJhbWVidWZmZXIyLnByb3RvdHlwZS5yZW5kZXJTdGFydCA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKSByZXR1cm4gdGhpcy5fbG9nLndhcm4oXCJkaXNwb3NlZCBmcmFtZWJ1ZmZlciByZW5kZXJTdGFydC4uLlwiKTtcbiAgICB0aGlzLl9jZ2wuY2hlY2tGcmFtZVN0YXJ0ZWQoXCJmYjIgcmVuZGVyc3RhcnRcIik7XG4gICAgdGhpcy5fY2dsLnB1c2hNb2RlbE1hdHJpeCgpOyAvLyBuZWVkZWQgPz9cblxuICAgIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9mcmFtZUJ1ZmZlcik7XG4gICAgdGhpcy5fY2dsLnB1c2hHbEZyYW1lQnVmZmVyKHRoaXMuX2ZyYW1lQnVmZmVyKTtcbiAgICB0aGlzLl9jZ2wucHVzaEZyYW1lQnVmZmVyKHRoaXMpO1xuXG4gICAgdGhpcy5fY2dsLnB1c2hQTWF0cml4KCk7XG4gICAgLy8gdGhpcy5fY2dsLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgIHRoaXMuX2NnbC5wdXNoVmlld1BvcnQoMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG5cbiAgICB0aGlzLl9jZ2wuZ2wuZHJhd0J1ZmZlcnModGhpcy5fZHJhd1RhcmdldEFycmF5KTtcblxuXG4gICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPD0gdGhpcy5fbnVtUmVuZGVyQnVmZmVyczsgaSsrKVxuICAgIC8vIHtcbiAgICAvLyAgICAgdGhpcy5fY2dsLmdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fY2dsLmdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgdGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUiwgdGhpcy5fY29sb3JSZW5kZXJidWZmZXJzW2ldKTtcbiAgICAvLyAgICAgdGhpcy5fY2dsLmdsLmNsZWFyQnVmZmVyZnYodGhpcy5fY2dsLmdsLkNPTE9SLCBpLCBbMS4wLCAwLjAsIDAuMCwgMC4wXSk7XG4gICAgLy8gfVxuXG4gICAgLy8gdGhpcy5jbGVhcigpO1xuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsZWFyKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5jbGVhcih0aGlzLl9jZ2wuZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IHRoaXMuX2NnbC5nbC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICB9XG59O1xuXG5GcmFtZWJ1ZmZlcjIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fbnVtUmVuZGVyQnVmZmVycyA8PSAxKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuUkVBRF9GUkFNRUJVRkZFUiwgdGhpcy5fZnJhbWVCdWZmZXIpO1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5EUkFXX0ZSQU1FQlVGRkVSLCB0aGlzLl90ZXh0dXJlRnJhbWVCdWZmZXIpO1xuICAgIH1cbiAgICBlbHNlIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9mcmFtZUJ1ZmZlcik7XG5cbiAgICB0aGlzLl9jZ2wuZ2wuZHJhd0J1ZmZlcnModGhpcy5fZHJhd1RhcmdldEFycmF5KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbnVtUmVuZGVyQnVmZmVyczsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fY2dsLmdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgdGhpcy5fY2dsLmdsLlRFWFRVUkVfMkQsIHRoaXMuX2NvbG9yVGV4dHVyZXNbaV0udGV4LCAwKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmNsZWFyQnVmZmVyZnYodGhpcy5fY2dsLmdsLkNPTE9SLCBpLCB0aGlzLmNsZWFyQ29sb3JzW2ldKTtcbiAgICB9XG4gICAgdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xufTtcblxuRnJhbWVidWZmZXIyLnByb3RvdHlwZS5yZW5kZXJFbmQgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLl9kaXNwb3NlZCkgcmV0dXJuIHRoaXMuX2xvZy53YXJuKFwiZGlzcG9zZWQgZnJhbWVidWZmZXIgcmVuZGVyRW5kLi4uXCIpO1xuICAgIHRoaXMuX2NnbC5wb3BQTWF0cml4KCk7XG5cbiAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZUZyYW1lYnVmZmVyKys7XG5cblxuICAgIGlmICh0aGlzLl9udW1SZW5kZXJCdWZmZXJzIDw9IDEpXG4gICAge1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5SRUFEX0ZSQU1FQlVGRkVSLCB0aGlzLl9mcmFtZUJ1ZmZlcik7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLkRSQVdfRlJBTUVCVUZGRVIsIHRoaXMuX3RleHR1cmVGcmFtZUJ1ZmZlcik7XG5cbiAgICAgICAgLy8gY29uc3QgYSA9IHRoaXMuX2NnbC5nbC5nZXRGcmFtZWJ1ZmZlckF0dGFjaG1lbnRQYXJhbWV0ZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9jZ2wuZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0NPTE9SX0VOQ09ESU5HKTtcbiAgICAgICAgLy8gaWYgKGEgPT0gdGhpcy5fY2dsLmdsLlNSR0IpY29uc29sZS5sb2coXCJTUkdCXCIsIHRoaXMuX2NnbC5nbC5TUkdCKTtcbiAgICAgICAgLy8gZWxzZSBpZiAoYSA9PSB0aGlzLl9jZ2wuZ2wuTElORUFSKWNvbnNvbGUubG9nKFwiTElORUFSXCIsIHRoaXMuX2NnbC5nbC5MSU5FQVIpO1xuXG5cbiAgICAgICAgdGhpcy5fY2dsLmdsLmNsZWFyQnVmZmVyZnYodGhpcy5fY2dsLmdsLkNPTE9SLCAwLCBbMC4wLCAwLjAsIDAuMCwgMS4wXSk7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5ibGl0RnJhbWVidWZmZXIoMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgdGhpcy5fY2dsLmdsLkNPTE9SX0JVRkZFUl9CSVQgfCB0aGlzLl9jZ2wuZ2wuREVQVEhfQlVGRkVSX0JJVCwgdGhpcy5fY2dsLmdsLk5FQVJFU1QpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5GcmFtZWJ1ZmZlcjJCbGl0dGluZ0ZyYW1lYnVmZmVyKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fY2dsLmdsLkRFUFRIX0FUVEFDSE1FTlQsIHRoaXMuX2NnbC5nbC5SRU5ERVJCVUZGRVIsIHRoaXMuX2RlcHRoUmVuZGVyYnVmZmVyKTtcblxuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5GcmFtZWJ1ZmZlcjJGaW5hbEZyYW1lYnVmZmVyKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fY2dsLmdsLkRFUFRIX0FUVEFDSE1FTlQsIHRoaXMuX2NnbC5nbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlRGVwdGgudGV4LCAwKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImZiIHRoaXMuX251bVJlbmRlckJ1ZmZlcnNcIiwgdGhpcy5fbnVtUmVuZGVyQnVmZmVycyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbnVtUmVuZGVyQnVmZmVyczsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5GcmFtZWJ1ZmZlcjJCbGl0dGluZ0ZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2NnbC5nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUiwgdGhpcy5fY29sb3JSZW5kZXJidWZmZXJzW2ldKTtcblxuXG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5GcmFtZWJ1ZmZlcjJGaW5hbEZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2NnbC5nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGhpcy5fY2dsLmdsLlRFWFRVUkVfMkQsIHRoaXMuX2NvbG9yVGV4dHVyZXNbaV0udGV4LCAwKTtcblxuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5SRUFEX0ZSQU1FQlVGRkVSLCB0aGlzLkZyYW1lYnVmZmVyMkJsaXR0aW5nRnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRFJBV19GUkFNRUJVRkZFUiwgdGhpcy5GcmFtZWJ1ZmZlcjJGaW5hbEZyYW1lYnVmZmVyKTtcblxuICAgICAgICAgICAgLy8gdGhpcy5fY2dsLmdsLmNsZWFyQnVmZmVyZnYodGhpcy5fY2dsLmdsLkNPTE9SLCBpLCBbMC4wLCAwLjAsIDAuMCwgMS4wXSk7XG5cblxuXG4gICAgICAgICAgICBsZXQgZmxhZ3MgPSB0aGlzLl9jZ2wuZ2wuQ09MT1JfQlVGRkVSX0JJVDtcbiAgICAgICAgICAgIGlmIChpID09IDApIGZsYWdzIHw9IHRoaXMuX2NnbC5nbC5ERVBUSF9CVUZGRVJfQklUO1xuXG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuYmxpdEZyYW1lYnVmZmVyKDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIGZsYWdzLCB0aGlzLl9jZ2wuZ2wuTkVBUkVTVCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fY2dsLnBvcEdsRnJhbWVCdWZmZXIoKSk7XG4gICAgdGhpcy5fY2dsLnBvcEZyYW1lQnVmZmVyKCk7XG5cbiAgICB0aGlzLl9jZ2wucG9wTW9kZWxNYXRyaXgoKTtcbiAgICAvLyB0aGlzLl9jZ2wucmVzZXRWaWV3UG9ydCgpO1xuICAgIHRoaXMuX2NnbC5wb3BWaWV3UG9ydCgpO1xuXG5cbiAgICBpZiAodGhpcy5fY29sb3JUZXh0dXJlc1swXS5maWx0ZXIgPT0gVGV4dHVyZS5GSUxURVJfTUlQTUFQKVxuICAgIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9udW1SZW5kZXJCdWZmZXJzOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kVGV4dHVyZSh0aGlzLl9jZ2wuZ2wuVEVYVFVSRV8yRCwgdGhpcy5fY29sb3JUZXh0dXJlc1tpXS50ZXgpO1xuICAgICAgICAgICAgdGhpcy5fY29sb3JUZXh0dXJlc1tpXS51cGRhdGVNaXBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kVGV4dHVyZSh0aGlzLl9jZ2wuZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgeyBGcmFtZWJ1ZmZlcjIgfTtcblxuLy8vIC8vLy8vLy9cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_framebuffer2.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_marker.js":
/*!************************************!*\
  !*** ./src/core/cgl/cgl_marker.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Marker\": () => (/* binding */ Marker),\n/* harmony export */   \"WireCube\": () => (/* binding */ WireCube),\n/* harmony export */   \"WirePoint\": () => (/* binding */ WirePoint)\n/* harmony export */ });\n/* harmony import */ var _cg_cg_geom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cg/cg_geom.js */ \"./src/core/cg/cg_geom.js\");\n/* harmony import */ var _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgl_mesh.js */ \"./src/core/cgl/cgl_mesh.js\");\n/* harmony import */ var _cgl_shader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgl_shader.js */ \"./src/core/cgl/cgl_shader.js\");\n/* harmony import */ var _cgl_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cgl_utils.js */ \"./src/core/cgl/cgl_utils.js\");\n// import { vec3, mat4 } from \"gl-matrix\";\n\n\n\n\n\n\nconst Marker = function (_cgl)\n{\n    const geom = new _cg_cg_geom_js__WEBPACK_IMPORTED_MODULE_0__.Geometry(\"marker\");\n    geom.setPointVertices(\n        [\n            0.00001, 0, 0, 1, 0, 0,\n            0, 0.00001, 0, 0, 1, 0,\n            0, 0, 0.00001, 0, 0, 1,\n        ]\n    );\n    const mesh = new _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_1__.Mesh(_cgl, geom, _cgl.gl.LINES);\n    mesh.setGeom(geom);\n\n    const shader = new _cgl_shader_js__WEBPACK_IMPORTED_MODULE_2__.Shader(_cgl, \"markermaterial\");\n\n    const frag = \"\"\n        .endl() + \"precision highp float;\"\n        .endl() + \"IN vec3 axisColor;\"\n\n        .endl() + \"void main()\"\n        .endl() + \"{\"\n        .endl() + \"    vec4 col=vec4(axisColor,1.0);\"\n        .endl() + \"    outColor = col;\"\n        .endl() + \"}\";\n\n    const vert = \"\"\n        .endl() + \"IN vec3 vPosition;\"\n        .endl() + \"UNI mat4 projMatrix;\"\n        .endl() + \"UNI mat4 mvMatrix;\"\n        .endl() + \"OUT vec3 axisColor;\"\n\n        .endl() + \"void main()\"\n        .endl() + \"{\"\n        .endl() + \"   vec4 pos=vec4(vPosition, 1.0);\"\n        .endl() + \"   if(pos.x!=0.0)axisColor=vec3(1.0,0.3,0.0);\"\n        .endl() + \"   if(pos.y!=0.0)axisColor=vec3(0.0,1.0,0.2);\"\n        .endl() + \"   if(pos.z!=0.0)axisColor=vec3(0.0,0.5,1.0);\"\n\n        .endl() + \"   gl_Position = projMatrix * mvMatrix * pos;\"\n        .endl() + \"}\";\n\n    shader.setSource(vert, frag);\n\n    this._vScale = vec3.create();\n\n    this.draw = function (cgl, _size, depthTest)\n    {\n        const size = _size || 2;\n        cgl.pushModelMatrix();\n\n        cgl.pushShader(shader);\n\n        vec3.set(this._vScale, size, size, size);\n        mat4.scale(cgl.mvMatrix, cgl.mvMatrix, this._vScale);\n\n        // cgl.gl.disable(cgl.gl.DEPTH_TEST);\n        cgl.pushDepthTest(depthTest == true);\n\n        mesh.render(cgl.getShader());\n\n        // cgl.gl.enable(cgl.gl.DEPTH_TEST);\n        cgl.popDepthTest();\n        cgl.popShader();\n\n        cgl.popModelMatrix();\n    };\n};\n\n\nconst WirePoint = function (cgl)\n{\n    const buffer = cgl.gl.createBuffer();\n    const vScale = vec3.create();\n\n    function bufferData()\n    {\n        const points = [];\n        const segments = 24;\n        let i = 0, degInRad = 0;\n        const radius = 0.5;\n\n        for (i = 0; i <= Math.round(segments); i++)\n        {\n            degInRad = (360.0 / Math.round(segments)) * i * _cgl_utils_js__WEBPACK_IMPORTED_MODULE_3__.DEG2RAD;\n            points.push(Math.cos(degInRad) * radius);\n            points.push(0);\n            points.push(Math.sin(degInRad) * radius);\n        }\n\n        for (i = 0; i <= Math.round(segments); i++)\n        {\n            degInRad = (360.0 / Math.round(segments)) * i * _cgl_utils_js__WEBPACK_IMPORTED_MODULE_3__.DEG2RAD;\n            points.push(Math.cos(degInRad) * radius);\n            points.push(Math.sin(degInRad) * radius);\n            points.push(0);\n        }\n\n        for (i = 0; i <= Math.round(segments); i++)\n        {\n            degInRad = (360.0 / Math.round(segments)) * i * _cgl_utils_js__WEBPACK_IMPORTED_MODULE_3__.DEG2RAD;\n            points.push(0);\n            points.push(Math.cos(degInRad) * radius);\n            points.push(Math.sin(degInRad) * radius);\n        }\n\n        cgl.gl.bindBuffer(cgl.gl.ARRAY_BUFFER, buffer);\n        cgl.gl.bufferData(cgl.gl.ARRAY_BUFFER, new Float32Array(points), cgl.gl.STATIC_DRAW);\n        buffer.itemSize = 3;\n        buffer.numItems = points.length / buffer.itemSize;\n    }\n\n    this.render = function (_cgl, _size)\n    {\n        _cgl.pushModelMatrix();\n\n        vec3.set(vScale, _size, _size, _size);\n        mat4.scale(_cgl.mvMatrix, _cgl.mvMatrix, vScale);\n\n        const shader = _cgl.getShader();\n\n        if (shader)\n        {\n            shader.bind();\n            _cgl.gl.bindBuffer(_cgl.gl.ARRAY_BUFFER, buffer);\n\n            _cgl.gl.vertexAttribPointer(shader.getAttrVertexPos(), buffer.itemSize, _cgl.gl.FLOAT, false, 0, 0);\n            _cgl.gl.enableVertexAttribArray(shader.getAttrVertexPos());\n\n            _cgl.gl.bindBuffer(_cgl.gl.ARRAY_BUFFER, buffer);\n            _cgl.gl.drawArrays(_cgl.gl.LINE_STRIP, 0, buffer.numItems);\n        }\n\n        _cgl.popModelMatrix();\n    };\n\n    bufferData();\n};\n\n\nconst WireCube = function (cgl)\n{\n    const buffer = cgl.gl.createBuffer();\n    const vScale = vec3.create();\n\n    function bufferData()\n    {\n        const points = [];\n        const tc = [];\n        const norms = [];\n        const segments = 24;\n        const radius = 0.5;\n\n        points.push(-1, -1, 1);\n        points.push(1, -1, 1);\n        points.push(1, 1, 1);\n        points.push(-1, 1, 1);\n        points.push(-1, -1, 1);\n\n        points.push(-1, -1, -1);\n        points.push(1, -1, -1);\n        points.push(1, 1, -1);\n        points.push(-1, 1, -1);\n        points.push(-1, -1, -1);\n\n        points.push(-1, -1, -1);\n        points.push(-1, 1, -1);\n        points.push(-1, 1, 1);\n        points.push(-1, -1, 1);\n        points.push(-1, -1, -1);\n\n        points.push(1, -1, -1);\n        points.push(1, 1, -1);\n        points.push(1, 1, 1);\n        points.push(1, -1, 1);\n        points.push(1, -1, -1);\n\n        cgl.gl.bindBuffer(cgl.gl.ARRAY_BUFFER, buffer);\n        cgl.gl.bufferData(cgl.gl.ARRAY_BUFFER, new Float32Array(points), cgl.gl.STATIC_DRAW);\n        buffer.itemSize = 3;\n        buffer.numItems = points.length / buffer.itemSize;\n    }\n\n    this.render = function (_cgl, sizeX, sizeY, sizeZ)\n    {\n        _cgl.pushModelMatrix();\n\n        vec3.set(vScale, sizeX || 1, sizeY || 1, sizeZ || 1);\n        mat4.scale(_cgl.mvMatrix, _cgl.mvMatrix, vScale);\n\n        const shader = _cgl.getShader();\n        if (shader)\n        {\n            shader.bind();\n            _cgl.gl.bindBuffer(_cgl.gl.ARRAY_BUFFER, buffer);\n\n            _cgl.gl.vertexAttribPointer(shader.getAttrVertexPos(), buffer.itemSize, _cgl.gl.FLOAT, false, 0, 0);\n            _cgl.gl.enableVertexAttribArray(shader.getAttrVertexPos());\n\n            _cgl.gl.bindBuffer(_cgl.gl.ARRAY_BUFFER, buffer);\n            _cgl.gl.drawArrays(_cgl.gl.LINE_STRIP, 0, buffer.numItems);\n        }\n\n        _cgl.popModelMatrix();\n    };\n\n    bufferData();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX21hcmtlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnbC9jZ2xfbWFya2VyLmpzPzFjMTciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IHsgdmVjMywgbWF0NCB9IGZyb20gXCJnbC1tYXRyaXhcIjtcbmltcG9ydCB7IEdlb21ldHJ5IH0gZnJvbSBcIi4uL2NnL2NnX2dlb20uanNcIjtcbmltcG9ydCB7IE1lc2ggfSBmcm9tIFwiLi9jZ2xfbWVzaC5qc1wiO1xuaW1wb3J0IHsgU2hhZGVyIH0gZnJvbSBcIi4vY2dsX3NoYWRlci5qc1wiO1xuaW1wb3J0IHsgREVHMlJBRCB9IGZyb20gXCIuL2NnbF91dGlscy5qc1wiO1xuXG5cbmV4cG9ydCBjb25zdCBNYXJrZXIgPSBmdW5jdGlvbiAoX2NnbClcbntcbiAgICBjb25zdCBnZW9tID0gbmV3IEdlb21ldHJ5KFwibWFya2VyXCIpO1xuICAgIGdlb20uc2V0UG9pbnRWZXJ0aWNlcyhcbiAgICAgICAgW1xuICAgICAgICAgICAgMC4wMDAwMSwgMCwgMCwgMSwgMCwgMCxcbiAgICAgICAgICAgIDAsIDAuMDAwMDEsIDAsIDAsIDEsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLjAwMDAxLCAwLCAwLCAxLFxuICAgICAgICBdXG4gICAgKTtcbiAgICBjb25zdCBtZXNoID0gbmV3IE1lc2goX2NnbCwgZ2VvbSwgX2NnbC5nbC5MSU5FUyk7XG4gICAgbWVzaC5zZXRHZW9tKGdlb20pO1xuXG4gICAgY29uc3Qgc2hhZGVyID0gbmV3IFNoYWRlcihfY2dsLCBcIm1hcmtlcm1hdGVyaWFsXCIpO1xuXG4gICAgY29uc3QgZnJhZyA9IFwiXCJcbiAgICAgICAgLmVuZGwoKSArIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1wiXG4gICAgICAgIC5lbmRsKCkgKyBcIklOIHZlYzMgYXhpc0NvbG9yO1wiXG5cbiAgICAgICAgLmVuZGwoKSArIFwidm9pZCBtYWluKClcIlxuICAgICAgICAuZW5kbCgpICsgXCJ7XCJcbiAgICAgICAgLmVuZGwoKSArIFwiICAgIHZlYzQgY29sPXZlYzQoYXhpc0NvbG9yLDEuMCk7XCJcbiAgICAgICAgLmVuZGwoKSArIFwiICAgIG91dENvbG9yID0gY29sO1wiXG4gICAgICAgIC5lbmRsKCkgKyBcIn1cIjtcblxuICAgIGNvbnN0IHZlcnQgPSBcIlwiXG4gICAgICAgIC5lbmRsKCkgKyBcIklOIHZlYzMgdlBvc2l0aW9uO1wiXG4gICAgICAgIC5lbmRsKCkgKyBcIlVOSSBtYXQ0IHByb2pNYXRyaXg7XCJcbiAgICAgICAgLmVuZGwoKSArIFwiVU5JIG1hdDQgbXZNYXRyaXg7XCJcbiAgICAgICAgLmVuZGwoKSArIFwiT1VUIHZlYzMgYXhpc0NvbG9yO1wiXG5cbiAgICAgICAgLmVuZGwoKSArIFwidm9pZCBtYWluKClcIlxuICAgICAgICAuZW5kbCgpICsgXCJ7XCJcbiAgICAgICAgLmVuZGwoKSArIFwiICAgdmVjNCBwb3M9dmVjNCh2UG9zaXRpb24sIDEuMCk7XCJcbiAgICAgICAgLmVuZGwoKSArIFwiICAgaWYocG9zLnghPTAuMClheGlzQ29sb3I9dmVjMygxLjAsMC4zLDAuMCk7XCJcbiAgICAgICAgLmVuZGwoKSArIFwiICAgaWYocG9zLnkhPTAuMClheGlzQ29sb3I9dmVjMygwLjAsMS4wLDAuMik7XCJcbiAgICAgICAgLmVuZGwoKSArIFwiICAgaWYocG9zLnohPTAuMClheGlzQ29sb3I9dmVjMygwLjAsMC41LDEuMCk7XCJcblxuICAgICAgICAuZW5kbCgpICsgXCIgICBnbF9Qb3NpdGlvbiA9IHByb2pNYXRyaXggKiBtdk1hdHJpeCAqIHBvcztcIlxuICAgICAgICAuZW5kbCgpICsgXCJ9XCI7XG5cbiAgICBzaGFkZXIuc2V0U291cmNlKHZlcnQsIGZyYWcpO1xuXG4gICAgdGhpcy5fdlNjYWxlID0gdmVjMy5jcmVhdGUoKTtcblxuICAgIHRoaXMuZHJhdyA9IGZ1bmN0aW9uIChjZ2wsIF9zaXplLCBkZXB0aFRlc3QpXG4gICAge1xuICAgICAgICBjb25zdCBzaXplID0gX3NpemUgfHwgMjtcbiAgICAgICAgY2dsLnB1c2hNb2RlbE1hdHJpeCgpO1xuXG4gICAgICAgIGNnbC5wdXNoU2hhZGVyKHNoYWRlcik7XG5cbiAgICAgICAgdmVjMy5zZXQodGhpcy5fdlNjYWxlLCBzaXplLCBzaXplLCBzaXplKTtcbiAgICAgICAgbWF0NC5zY2FsZShjZ2wubXZNYXRyaXgsIGNnbC5tdk1hdHJpeCwgdGhpcy5fdlNjYWxlKTtcblxuICAgICAgICAvLyBjZ2wuZ2wuZGlzYWJsZShjZ2wuZ2wuREVQVEhfVEVTVCk7XG4gICAgICAgIGNnbC5wdXNoRGVwdGhUZXN0KGRlcHRoVGVzdCA9PSB0cnVlKTtcblxuICAgICAgICBtZXNoLnJlbmRlcihjZ2wuZ2V0U2hhZGVyKCkpO1xuXG4gICAgICAgIC8vIGNnbC5nbC5lbmFibGUoY2dsLmdsLkRFUFRIX1RFU1QpO1xuICAgICAgICBjZ2wucG9wRGVwdGhUZXN0KCk7XG4gICAgICAgIGNnbC5wb3BTaGFkZXIoKTtcblxuICAgICAgICBjZ2wucG9wTW9kZWxNYXRyaXgoKTtcbiAgICB9O1xufTtcblxuXG5leHBvcnQgY29uc3QgV2lyZVBvaW50ID0gZnVuY3Rpb24gKGNnbClcbntcbiAgICBjb25zdCBidWZmZXIgPSBjZ2wuZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgY29uc3QgdlNjYWxlID0gdmVjMy5jcmVhdGUoKTtcblxuICAgIGZ1bmN0aW9uIGJ1ZmZlckRhdGEoKVxuICAgIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gMjQ7XG4gICAgICAgIGxldCBpID0gMCwgZGVnSW5SYWQgPSAwO1xuICAgICAgICBjb25zdCByYWRpdXMgPSAwLjU7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8PSBNYXRoLnJvdW5kKHNlZ21lbnRzKTsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWdJblJhZCA9ICgzNjAuMCAvIE1hdGgucm91bmQoc2VnbWVudHMpKSAqIGkgKiBERUcyUkFEO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goTWF0aC5jb3MoZGVnSW5SYWQpICogcmFkaXVzKTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKDApO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goTWF0aC5zaW4oZGVnSW5SYWQpICogcmFkaXVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPD0gTWF0aC5yb3VuZChzZWdtZW50cyk7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgZGVnSW5SYWQgPSAoMzYwLjAgLyBNYXRoLnJvdW5kKHNlZ21lbnRzKSkgKiBpICogREVHMlJBRDtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKE1hdGguY29zKGRlZ0luUmFkKSAqIHJhZGl1cyk7XG4gICAgICAgICAgICBwb2ludHMucHVzaChNYXRoLnNpbihkZWdJblJhZCkgKiByYWRpdXMpO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goMCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IE1hdGgucm91bmQoc2VnbWVudHMpOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlZ0luUmFkID0gKDM2MC4wIC8gTWF0aC5yb3VuZChzZWdtZW50cykpICogaSAqIERFRzJSQUQ7XG4gICAgICAgICAgICBwb2ludHMucHVzaCgwKTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKE1hdGguY29zKGRlZ0luUmFkKSAqIHJhZGl1cyk7XG4gICAgICAgICAgICBwb2ludHMucHVzaChNYXRoLnNpbihkZWdJblJhZCkgKiByYWRpdXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2dsLmdsLmJpbmRCdWZmZXIoY2dsLmdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgICAgY2dsLmdsLmJ1ZmZlckRhdGEoY2dsLmdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShwb2ludHMpLCBjZ2wuZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICBidWZmZXIuaXRlbVNpemUgPSAzO1xuICAgICAgICBidWZmZXIubnVtSXRlbXMgPSBwb2ludHMubGVuZ3RoIC8gYnVmZmVyLml0ZW1TaXplO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKF9jZ2wsIF9zaXplKVxuICAgIHtcbiAgICAgICAgX2NnbC5wdXNoTW9kZWxNYXRyaXgoKTtcblxuICAgICAgICB2ZWMzLnNldCh2U2NhbGUsIF9zaXplLCBfc2l6ZSwgX3NpemUpO1xuICAgICAgICBtYXQ0LnNjYWxlKF9jZ2wubXZNYXRyaXgsIF9jZ2wubXZNYXRyaXgsIHZTY2FsZSk7XG5cbiAgICAgICAgY29uc3Qgc2hhZGVyID0gX2NnbC5nZXRTaGFkZXIoKTtcblxuICAgICAgICBpZiAoc2hhZGVyKVxuICAgICAgICB7XG4gICAgICAgICAgICBzaGFkZXIuYmluZCgpO1xuICAgICAgICAgICAgX2NnbC5nbC5iaW5kQnVmZmVyKF9jZ2wuZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXG4gICAgICAgICAgICBfY2dsLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmdldEF0dHJWZXJ0ZXhQb3MoKSwgYnVmZmVyLml0ZW1TaXplLCBfY2dsLmdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICBfY2dsLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlci5nZXRBdHRyVmVydGV4UG9zKCkpO1xuXG4gICAgICAgICAgICBfY2dsLmdsLmJpbmRCdWZmZXIoX2NnbC5nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICAgICAgICBfY2dsLmdsLmRyYXdBcnJheXMoX2NnbC5nbC5MSU5FX1NUUklQLCAwLCBidWZmZXIubnVtSXRlbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2NnbC5wb3BNb2RlbE1hdHJpeCgpO1xuICAgIH07XG5cbiAgICBidWZmZXJEYXRhKCk7XG59O1xuXG5cbmV4cG9ydCBjb25zdCBXaXJlQ3ViZSA9IGZ1bmN0aW9uIChjZ2wpXG57XG4gICAgY29uc3QgYnVmZmVyID0gY2dsLmdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGNvbnN0IHZTY2FsZSA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgICBmdW5jdGlvbiBidWZmZXJEYXRhKClcbiAgICB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBjb25zdCB0YyA9IFtdO1xuICAgICAgICBjb25zdCBub3JtcyA9IFtdO1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IDI0O1xuICAgICAgICBjb25zdCByYWRpdXMgPSAwLjU7XG5cbiAgICAgICAgcG9pbnRzLnB1c2goLTEsIC0xLCAxKTtcbiAgICAgICAgcG9pbnRzLnB1c2goMSwgLTEsIDEpO1xuICAgICAgICBwb2ludHMucHVzaCgxLCAxLCAxKTtcbiAgICAgICAgcG9pbnRzLnB1c2goLTEsIDEsIDEpO1xuICAgICAgICBwb2ludHMucHVzaCgtMSwgLTEsIDEpO1xuXG4gICAgICAgIHBvaW50cy5wdXNoKC0xLCAtMSwgLTEpO1xuICAgICAgICBwb2ludHMucHVzaCgxLCAtMSwgLTEpO1xuICAgICAgICBwb2ludHMucHVzaCgxLCAxLCAtMSk7XG4gICAgICAgIHBvaW50cy5wdXNoKC0xLCAxLCAtMSk7XG4gICAgICAgIHBvaW50cy5wdXNoKC0xLCAtMSwgLTEpO1xuXG4gICAgICAgIHBvaW50cy5wdXNoKC0xLCAtMSwgLTEpO1xuICAgICAgICBwb2ludHMucHVzaCgtMSwgMSwgLTEpO1xuICAgICAgICBwb2ludHMucHVzaCgtMSwgMSwgMSk7XG4gICAgICAgIHBvaW50cy5wdXNoKC0xLCAtMSwgMSk7XG4gICAgICAgIHBvaW50cy5wdXNoKC0xLCAtMSwgLTEpO1xuXG4gICAgICAgIHBvaW50cy5wdXNoKDEsIC0xLCAtMSk7XG4gICAgICAgIHBvaW50cy5wdXNoKDEsIDEsIC0xKTtcbiAgICAgICAgcG9pbnRzLnB1c2goMSwgMSwgMSk7XG4gICAgICAgIHBvaW50cy5wdXNoKDEsIC0xLCAxKTtcbiAgICAgICAgcG9pbnRzLnB1c2goMSwgLTEsIC0xKTtcblxuICAgICAgICBjZ2wuZ2wuYmluZEJ1ZmZlcihjZ2wuZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgICBjZ2wuZ2wuYnVmZmVyRGF0YShjZ2wuZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHBvaW50cyksIGNnbC5nbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgIGJ1ZmZlci5pdGVtU2l6ZSA9IDM7XG4gICAgICAgIGJ1ZmZlci5udW1JdGVtcyA9IHBvaW50cy5sZW5ndGggLyBidWZmZXIuaXRlbVNpemU7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoX2NnbCwgc2l6ZVgsIHNpemVZLCBzaXplWilcbiAgICB7XG4gICAgICAgIF9jZ2wucHVzaE1vZGVsTWF0cml4KCk7XG5cbiAgICAgICAgdmVjMy5zZXQodlNjYWxlLCBzaXplWCB8fCAxLCBzaXplWSB8fCAxLCBzaXplWiB8fCAxKTtcbiAgICAgICAgbWF0NC5zY2FsZShfY2dsLm12TWF0cml4LCBfY2dsLm12TWF0cml4LCB2U2NhbGUpO1xuXG4gICAgICAgIGNvbnN0IHNoYWRlciA9IF9jZ2wuZ2V0U2hhZGVyKCk7XG4gICAgICAgIGlmIChzaGFkZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNoYWRlci5iaW5kKCk7XG4gICAgICAgICAgICBfY2dsLmdsLmJpbmRCdWZmZXIoX2NnbC5nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG5cbiAgICAgICAgICAgIF9jZ2wuZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuZ2V0QXR0clZlcnRleFBvcygpLCBidWZmZXIuaXRlbVNpemUsIF9jZ2wuZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgICAgIF9jZ2wuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoc2hhZGVyLmdldEF0dHJWZXJ0ZXhQb3MoKSk7XG5cbiAgICAgICAgICAgIF9jZ2wuZ2wuYmluZEJ1ZmZlcihfY2dsLmdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgICAgICAgIF9jZ2wuZ2wuZHJhd0FycmF5cyhfY2dsLmdsLkxJTkVfU1RSSVAsIDAsIGJ1ZmZlci5udW1JdGVtcyk7XG4gICAgICAgIH1cblxuICAgICAgICBfY2dsLnBvcE1vZGVsTWF0cml4KCk7XG4gICAgfTtcblxuICAgIGJ1ZmZlckRhdGEoKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_marker.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_mesh.js":
/*!**********************************!*\
  !*** ./src/core/cgl/cgl_mesh.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MESH\": () => (/* binding */ MESH),\n/* harmony export */   \"Mesh\": () => (/* binding */ Mesh)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n/* harmony import */ var _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgl_shader_uniform.js */ \"./src/core/cgl/cgl_shader_uniform.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./src/core/cgl/constants.js\");\n/* harmony import */ var _cgl_mesh_feedback_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cgl_mesh_feedback.js */ \"./src/core/cgl/cgl_mesh_feedback.js\");\n\n\n\n\n\nconst MESH = {};\nMESH.lastMesh = null;\n\n/**\n * webgl renderable 3d object\n * @external CGL\n * @namespace Mesh\n * @hideconstructor\n * @param {Context} cgl\n * @param {Geometry} geometry\n * @param {Number} [glPrimitive]\n * @class\n * @example\n * const cgl=this._cgl\n * const mesh=new CGL.Mesh(cgl, geometry);\n *\n * function render()\n * {\n *   mesh.render(cgl.getShader());\n * }\n */\nconst Mesh = function (_cgl, __geom, _options)\n{\n    this._cgl = _cgl;\n\n    let options = _options || {};\n    if (CABLES.UTILS.isNumeric(options))options = { \"glPrimitive\": _options }; // old constructor fallback...\n    this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"cgl_mesh\");\n    this._bufVertexAttrib = null;\n    this._bufVerticesIndizes = this._cgl.gl.createBuffer();\n    this._indexType = this._cgl.gl.UNSIGNED_SHORT;\n    this._attributes = [];\n    this._attribLocs = {};\n    this._geom = null;\n    this._lastShader = null;\n    this._numInstances = 0;\n    this._glPrimitive = options.glPrimitive;\n\n    this.opId = options.opId || \"\";\n    this._preWireframeGeom = null;\n    this.addVertexNumbers = false;\n    this._name = \"unknown\";\n\n    this.feedBackAttributes = [];\n    this.setGeom(__geom);\n\n    this._feedBacks = [];\n    this._feedBacksChanged = false;\n    this._transformFeedBackLoc = -1;\n    this._lastAttrUpdate = 0;\n\n    this.memFreed = false;\n\n    this._cgl.profileData.addHeavyEvent(\"mesh constructed\", this._name);\n\n    this._queryExt = null;\n\n    Object.defineProperty(this, \"numInstances\", {\n        get()\n        {\n            return this._numInstances;\n        },\n        set(v)\n        {\n            this.setNumInstances(v);\n        },\n    });\n};\n\nMesh.prototype.freeMem = function ()\n{\n    this.memFreed = true;\n\n    for (let i = 0; i < this._attributes.length; i++)\n    {\n        this._attributes[i].floatArray = null;\n    }\n};\n\n/**\n * @function updateVertices\n * @memberof Mesh\n * @instance\n * @description update vertices only from a geometry\n * @param {Geometry} geometry\n */\nMesh.prototype.updateVertices = function (geom)\n{\n    this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION, geom.vertices, 3);\n    this._numVerts = geom.vertices.length / 3;\n};\n\nMesh.prototype.setAttributePointer = function (attrName, name, stride, offset)\n{\n    for (let i = 0; i < this._attributes.length; i++)\n    {\n        if (this._attributes[i].name == attrName)\n        {\n            if (!this._attributes[i].pointer) this._attributes[i].pointer = [];\n\n            this._attributes[i].pointer.push(\n                {\n                    \"loc\": -1,\n                    \"name\": name,\n                    \"stride\": stride,\n                    \"offset\": offset,\n                    \"instanced\": attrName == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_INSTANCE_MMATRIX,\n                }\n            );\n        }\n    }\n};\n\nMesh.prototype.getAttribute = function (name)\n{\n    for (let i = 0; i < this._attributes.length; i++) if (this._attributes[i].name == name) return this._attributes[i];\n};\n\nMesh.prototype.setAttributeRange = function (attr, array, start, end)\n{\n    if (!attr) return;\n    if (!start && !end) return;\n\n    if (!attr.name)\n    {\n        this._log.stack(\"no attrname?!\");\n    }\n\n    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr.buffer);\n    this._cgl.profileData.profileMeshAttributes += (end - start) || 0;\n\n    this._cgl.profileData.profileSingleMeshAttribute[this._name] = this._cgl.profileData.profileSingleMeshAttribute[this._name] || 0;\n    this._cgl.profileData.profileSingleMeshAttribute[this._name] += (end - start) || 0;\n\n    if (attr.numItems < array.length / attr.itemSize)\n    {\n        this._resizeAttr(array, attr);\n    }\n\n    if (end >= array.length - 1)\n    {\n        this._log.log(this._cgl.canvas.id + \" \" + attr.name + \" buffersubdata out of bounds ?\", array.length, end, start, attr);\n    }\n\n    if (this._cgl.glVersion == 1) this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER, 0, array); // probably slow/ maybe create and array with only changed size ??\n    else this._cgl.gl.bufferSubData(this._cgl.gl.ARRAY_BUFFER, start * 4, array, start, (end - start));\n};\n\nMesh.prototype._resizeAttr = function (array, attr)\n{\n    if (attr.buffer)\n        this._cgl.gl.deleteBuffer(attr.buffer);\n\n    attr.buffer = this._cgl.gl.createBuffer();\n    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr.buffer);\n    this._bufferArray(array, attr);\n    attr.numItems = array.length / attr.itemSize;// numItems;\n};\n\n\nMesh.prototype._bufferArray = function (array, attr)\n{\n    let floatArray = attr.floatArray || null;\n    if (!array) return;\n\n\n    if (this._cgl.debugOneFrame)\n    {\n        console.log(\"_bufferArray\", array.length, attr.name); // eslint-disable-line\n    }\n\n    if (!(array instanceof Float32Array))\n    {\n        if (attr && floatArray && floatArray.length == array.length)\n        {\n            floatArray.set(array);\n            // floatArray = floatArray;\n        }\n        else\n        {\n            floatArray = new Float32Array(array);\n\n            if (this._cgl.debugOneFrame)\n            {\n                console.log(\"_bufferArray create new float32array\", array.length, attr.name); // eslint-disable-line\n            }\n\n            if (array.length > 10000)\n            {\n                this._cgl.profileData.profileNonTypedAttrib++;\n                this._cgl.profileData.profileNonTypedAttribNames = \"(\" + this._name + \":\" + attr.name + \")\";\n            }\n        }\n    }\n    else floatArray = array;\n\n    attr.arrayLength = floatArray.length;\n    attr.floatArray = null;// floatArray;\n\n    this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, floatArray, this._cgl.gl.DYNAMIC_DRAW);\n};\n\n/**\n * @function setAttribute\n * @description update attribute\n * @memberof Mesh\n * @instance\n * @param {String} attribute name\n * @param {Array} data\n * @param {Number} itemSize\n * @param {Object} options\n */\nMesh.prototype.addAttribute = Mesh.prototype.updateAttribute = Mesh.prototype.setAttribute = function (name, array, itemSize, options)\n{\n    if (!array)\n    {\n        this._log.error(\"mesh addAttribute - no array given! \" + name);\n        throw new Error();\n    }\n    let cb = null;\n    let instanced = false;\n    let i = 0;\n    const numItems = array.length / itemSize;\n\n    this._cgl.profileData.profileMeshAttributes += numItems || 0;\n\n    if (typeof options == \"function\")\n    {\n        cb = options;\n    }\n\n    if (typeof options == \"object\")\n    {\n        if (options.cb) cb = options.cb;\n        if (options.instanced) instanced = options.instanced;\n    }\n\n    if (name == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_INSTANCE_MMATRIX) instanced = true;\n\n\n    for (i = 0; i < this._attributes.length; i++)\n    {\n        const attr = this._attributes[i];\n        if (attr.name == name)\n        {\n            if (attr.numItems === numItems)\n            {\n            }\n            else\n            {\n                // this._log.log(\"wrong buffer size\", this._geom.name, attr.name, attr.numItems, numItems);\n                this._resizeAttr(array, attr);\n            }\n\n            this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr.buffer);\n            this._bufferArray(array, attr);\n\n            return attr;\n        }\n    }\n\n    // create new buffer...\n\n    const buffer = this._cgl.gl.createBuffer();\n\n    this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, buffer);\n    // this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, floatArray, this._cgl.gl.DYNAMIC_DRAW);\n\n    let type = this._cgl.gl.FLOAT;\n    if (options && options.type) type = options.type;\n    const attr = {\n        \"buffer\": buffer,\n        \"name\": name,\n        \"cb\": cb,\n        \"itemSize\": itemSize,\n        \"numItems\": numItems,\n        \"startItem\": 0,\n        \"instanced\": instanced,\n        \"type\": type\n    };\n\n    this._bufferArray(array, attr);\n\n    if (name == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION) this._bufVertexAttrib = attr;\n    this._attributes.push(attr);\n    this._attribLocs = {};\n\n    return attr;\n};\n\nMesh.prototype.getAttributes = function ()\n{\n    return this._attributes;\n};\n\n/**\n * @function updateTexCoords\n * @description update texture coordinates only from a geometry\n * @memberof Mesh\n * @instance\n * @param {Geometry} geometry\n */\nMesh.prototype.updateTexCoords = function (geom)\n{\n    if (geom.texCoords && geom.texCoords.length > 0)\n    {\n        this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD, geom.texCoords, 2);\n    }\n    else\n    {\n        const tcBuff = new Float32Array(Math.round((geom.vertices.length / 3) * 2));\n        this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD, tcBuff, 2);\n    }\n};\n\n\n/**\n * @function updateNormals\n * @description update normals only from a geometry\n * @memberof Mesh\n * @instance\n * @param {Geometry} geometry\n */\nMesh.prototype.updateNormals = function (geom)\n{\n    if (geom.vertexNormals && geom.vertexNormals.length > 0)\n    {\n        this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL, geom.vertexNormals, 3);\n    }\n    else\n    {\n        const tcBuff = new Float32Array(Math.round((geom.vertices.length)));\n        this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL, tcBuff, 3);\n    }\n};\n\n\nMesh.prototype._setVertexNumbers = function (arr)\n{\n    if (!this._verticesNumbers || this._verticesNumbers.length != this._numVerts || arr)\n    {\n        if (arr) this._verticesNumbers = arr;\n        else\n        {\n            this._verticesNumbers = new Float32Array(this._numVerts);\n            for (let i = 0; i < this._numVerts; i++) this._verticesNumbers[i] = i;\n        }\n\n        this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_NUMBER, this._verticesNumbers, 1, (attr, geom, shader) =>\n        {\n            if (!shader.uniformNumVertices) shader.uniformNumVertices = new _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_2__.Uniform(shader, \"f\", \"numVertices\", this._numVerts);\n            shader.uniformNumVertices.setValue(this._numVerts);\n\n            // console.log(\"this._numVerts\", this._numVerts, attr, shader.uniformNumVertices);\n        });\n    }\n};\n\n/**\n * @function setVertexIndices\n * @description update vertex indices / faces\n * @memberof Mesh\n * @instance\n * @param {array} vertIndices\n */\nMesh.prototype.setVertexIndices = function (vertIndices)\n{\n    if (!this._bufVerticesIndizes)\n    {\n        this._log.warn(\"no bufVerticesIndizes: \" + this._name);\n        return;\n    }\n    if (vertIndices.length > 0)\n    {\n        if (vertIndices instanceof Float32Array) this._log.warn(\"vertIndices float32Array: \" + this._name);\n\n        for (let i = 0; i < vertIndices.length; i++)\n        {\n            if (vertIndices[i] >= this._numVerts)\n            {\n                this._log.warn(\"invalid index in \" + this._name, i, vertIndices[i]);\n                return;\n            }\n        }\n\n        this._cgl.gl.bindBuffer(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this._bufVerticesIndizes);\n\n        // todo cache this ?\n        // if(!this.vertIndicesTyped || this.vertIndicesTyped.length!=this._geom.verticesIndices.length)\n\n        if (vertIndices.length > 65535)\n        {\n            this.vertIndicesTyped = new Uint32Array(vertIndices);\n            this._indexType = this._cgl.gl.UNSIGNED_INT;\n        }\n        else\n        if (vertIndices instanceof Uint32Array)\n        {\n            this.vertIndicesTyped = vertIndices;\n            this._indexType = this._cgl.gl.UNSIGNED_INT;\n        }\n        else\n        if (!(vertIndices instanceof Uint16Array))\n        {\n            this.vertIndicesTyped = new Uint16Array(vertIndices);\n            this._indexType = this._cgl.gl.UNSIGNED_SHORT;\n        }\n        else this.vertIndicesTyped = vertIndices;\n\n        this._cgl.gl.bufferData(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this.vertIndicesTyped, this._cgl.gl.DYNAMIC_DRAW);\n        this._bufVerticesIndizes.itemSize = 1;\n        this._bufVerticesIndizes.numItems = vertIndices.length;\n    }\n    else this._bufVerticesIndizes.numItems = 0;\n};\n\n/**\n * @function setGeom\n * @memberof Mesh\n * @instance\n * @description set geometry for mesh\n * @param {Geometry} geometry\n */\nMesh.prototype.setGeom = function (geom, removeRef)\n{\n    this._geom = geom;\n    if (geom.glPrimitive != null) this._glPrimitive = geom.glPrimitive;\n    if (this._geom && this._geom.name) this._name = \"mesh \" + this._geom.name;\n\n    MESH.lastMesh = null;\n    this._cgl.profileData.profileMeshSetGeom++;\n\n    this._disposeAttributes();\n\n    this.updateVertices(this._geom);\n    this.setVertexIndices(this._geom.verticesIndices);\n\n    if (this.addVertexNumbers) this._setVertexNumbers();\n\n    const geomAttribs = this._geom.getAttributes();\n\n    const attribAssoc = {\n        \"texCoords\": _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_TEXCOORD,\n        \"vertexNormals\": _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_NORMAL,\n        \"vertexColors\": _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_VERTEX_COLOR,\n        \"tangents\": \"attrTangent\",\n        \"biTangents\": \"attrBiTangent\",\n    };\n\n    for (const index in geomAttribs)\n        if (geomAttribs[index].data && geomAttribs[index].data.length)\n            this.setAttribute(attribAssoc[index] || index, geomAttribs[index].data, geomAttribs[index].itemSize);\n\n\n    if (removeRef)\n    {\n        this._geom = null;\n    }\n};\n\nMesh.prototype._preBind = function (shader)\n{\n    for (let i = 0; i < this._attributes.length; i++)\n        if (this._attributes[i].cb)\n            this._attributes[i].cb(this._attributes[i], this._geom, shader);\n};\n\nMesh.prototype._checkAttrLengths = function ()\n{\n    if (this.memFreed) return;\n    // check length\n    for (let i = 0; i < this._attributes.length; i++)\n    {\n        if (this._attributes[i].arrayLength / this._attributes[i].itemSize < this._attributes[0].arrayLength / this._attributes[0].itemSize)\n        {\n            let name = \"unknown\";\n            if (this._geom)name = this._geom.name;\n            // this._log.warn(\n            //     name + \": \" + this._attributes[i].name +\n            //     \" wrong attr length. is:\", this._attributes[i].arrayLength / this._attributes[i].itemSize,\n            //     \" should be:\", this._attributes[0].arrayLength / this._attributes[0].itemSize,\n            // );\n        }\n    }\n};\n\nMesh.prototype._bind = function (shader)\n{\n    if (!shader.isValid()) return;\n\n    let attrLocs = [];\n    if (this._attribLocs[shader.id]) attrLocs = this._attribLocs[shader.id];\n    else this._attribLocs[shader.id] = attrLocs;\n\n    this._lastShader = shader;\n    if (shader.lastCompile > this._lastAttrUpdate || attrLocs.length != this._attributes.length)\n    {\n        this._lastAttrUpdate = shader.lastCompile;\n        for (let i = 0; i < this._attributes.length; i++) attrLocs[i] = -1;\n    }\n\n    for (let i = 0; i < this._attributes.length; i++)\n    {\n        const attribute = this._attributes[i];\n        if (attrLocs[i] == -1)\n        {\n            if (attribute._attrLocationLastShaderTime != shader.lastCompile)\n            {\n                attribute._attrLocationLastShaderTime = shader.lastCompile;\n                attrLocs[i] = this._cgl.glGetAttribLocation(shader.getProgram(), attribute.name);\n                // this._log.log('attribloc',attribute.name,attrLocs[i]);\n                this._cgl.profileData.profileAttrLoc++;\n            }\n        }\n\n        if (attrLocs[i] != -1)\n        {\n            this._cgl.gl.enableVertexAttribArray(attrLocs[i]);\n            this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attribute.buffer);\n\n            if (attribute.instanced)\n            {\n                // todo: easier way to fill mat4 attribs...\n                if (attribute.itemSize <= 4)\n                {\n                    if (!attribute.itemSize || attribute.itemSize == 0) this._log.warn(\"instanced attrib itemsize error\", this._geom.name, attribute);\n\n                    this._cgl.gl.vertexAttribPointer(attrLocs[i], attribute.itemSize, attribute.type, false, attribute.itemSize * 4, 0);\n                    this._cgl.gl.vertexAttribDivisor(attrLocs[i], 1);\n                }\n                else if (attribute.itemSize == 16)\n                {\n                    const stride = 16 * 4;\n\n                    this._cgl.gl.vertexAttribPointer(attrLocs[i], 4, attribute.type, false, stride, 0);\n                    this._cgl.gl.enableVertexAttribArray(attrLocs[i] + 1);\n                    this._cgl.gl.vertexAttribPointer(attrLocs[i] + 1, 4, attribute.type, false, stride, 4 * 4 * 1);\n                    this._cgl.gl.enableVertexAttribArray(attrLocs[i] + 2);\n                    this._cgl.gl.vertexAttribPointer(attrLocs[i] + 2, 4, attribute.type, false, stride, 4 * 4 * 2);\n                    this._cgl.gl.enableVertexAttribArray(attrLocs[i] + 3);\n                    this._cgl.gl.vertexAttribPointer(attrLocs[i] + 3, 4, attribute.type, false, stride, 4 * 4 * 3);\n\n                    this._cgl.gl.vertexAttribDivisor(attrLocs[i], 1);\n                    this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 1, 1);\n                    this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 2, 1);\n                    this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 3, 1);\n                }\n                else\n                {\n                    this._log.warn(\"unknown instance attrib size\", attribute.name);\n                }\n            }\n            else\n            {\n                if (!attribute.itemSize || attribute.itemSize == 0) this._log.warn(\"attrib itemsize error\", this._name, attribute);\n                this._cgl.gl.vertexAttribPointer(attrLocs[i], attribute.itemSize, attribute.type, false, attribute.itemSize * 4, 0);\n\n                if (attribute.pointer)\n                {\n                    for (let ip = 0; ip < attribute.pointer.length; ip++)\n                    {\n                        const pointer = attribute.pointer[ip];\n\n                        if (pointer.loc == -1)\n                            pointer.loc = this._cgl.glGetAttribLocation(shader.getProgram(), pointer.name);\n\n                        this._cgl.profileData.profileAttrLoc++;\n\n                        this._cgl.gl.enableVertexAttribArray(pointer.loc);\n                        this._cgl.gl.vertexAttribPointer(pointer.loc, attribute.itemSize, attribute.type, false, pointer.stride, pointer.offset);\n                    }\n                }\n                this.bindFeedback(attribute);\n            }\n        }\n    }\n\n    if (this._bufVerticesIndizes && this._bufVerticesIndizes.numItems !== 0) this._cgl.gl.bindBuffer(this._cgl.gl.ELEMENT_ARRAY_BUFFER, this._bufVerticesIndizes);\n};\n\nMesh.prototype.unBind = function ()\n{\n    const shader = this._lastShader;\n    this._lastShader = null;\n    if (!shader) return;\n\n    let attrLocs = [];\n    if (this._attribLocs[shader.id]) attrLocs = this._attribLocs[shader.id];\n    else this._attribLocs[shader.id] = attrLocs;\n\n    MESH.lastMesh = null;\n\n    for (let i = 0; i < this._attributes.length; i++)\n    {\n        if (this._attributes[i].instanced)\n        {\n            // todo: easier way to fill mat4 attribs...\n            if (this._attributes[i].itemSize <= 4)\n            {\n                if (attrLocs[i] != -1) this._cgl.gl.vertexAttribDivisor(attrLocs[i], 0);\n                if (attrLocs[i] >= 0) this._cgl.gl.disableVertexAttribArray(attrLocs[i]);\n            }\n            else\n            {\n                this._cgl.gl.vertexAttribDivisor(attrLocs[i], 0);\n                this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 1, 0);\n                this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 2, 0);\n                this._cgl.gl.vertexAttribDivisor(attrLocs[i] + 3, 0);\n                this._cgl.gl.disableVertexAttribArray(attrLocs[i] + 1);\n                this._cgl.gl.disableVertexAttribArray(attrLocs[i] + 2);\n                this._cgl.gl.disableVertexAttribArray(attrLocs[i] + 3);\n            }\n        }\n\n        if (attrLocs[i] != -1) this._cgl.gl.disableVertexAttribArray(attrLocs[i]);\n    }\n};\n\nMesh.prototype.meshChanged = function ()\n{\n    return this._cgl.lastMesh && this._cgl.lastMesh != this;\n};\n\nMesh.prototype.printDebug = function (shader)\n{\n    console.log(\"--attributes\");\n    for (let i = 0; i < this._attributes.length; i++)\n    {\n        console.log(\"attribute \" + i + \" \" + this._attributes[i].name);\n    }\n};\n\nMesh.prototype.setNumVertices = function (num)\n{\n    this._bufVertexAttrib.numItems = num;\n};\n\nMesh.prototype.getNumVertices = function ()\n{\n    return this._bufVertexAttrib.numItems;\n};\n\n\n/**\n * @function render\n * @memberof Mesh\n * @instance\n * @description draw mesh to screen\n * @param {Shader} shader\n */\nMesh.prototype.render = function (shader)\n{\n    // TODO: enable/disablevertex only if the mesh has changed... think drawing 10000x the same mesh\n\n    if (!shader || !shader.isValid() || this._cgl.aborted) return;\n\n    this._checkAttrLengths();\n\n    if (this._geom)\n    {\n        if (this._preWireframeGeom && !shader.wireframe && !this._geom.isIndexed())\n        {\n            this.setGeom(this._preWireframeGeom);\n            this._preWireframeGeom = null;\n            // console.log(\"remove prewireframe geom\");\n        }\n\n        if (shader.wireframe)\n        {\n            let changed = false;\n\n            if (this._geom.isIndexed())\n            {\n                if (!this._preWireframeGeom)\n                {\n                    this._preWireframeGeom = this._geom;\n                    this._geom = this._geom.copy();\n                }\n\n                this._geom.unIndex();\n                changed = true;\n            }\n\n            if (!this._geom.getAttribute(\"attrBarycentric\"))\n            {\n                if (!this._preWireframeGeom)\n                {\n                    this._preWireframeGeom = this._geom;\n                    this._geom = this._geom.copy();\n                }\n                changed = true;\n\n                this._geom.calcBarycentric();\n            }\n            if (changed) this.setGeom(this._geom);\n        }\n        // if (shader.wireframe)\n        // console.log(shader.wireframe, this._geom.isIndexed());\n    }\n\n    let needsBind = false;\n    if (MESH.lastMesh != this)\n    {\n        if (MESH.lastMesh) MESH.lastMesh.unBind();\n        needsBind = true;\n    }\n\n\n    // var needsBind=false;\n    // {\n    //     needsBind=true;\n    // }\n    if (needsBind) this._preBind(shader);\n\n    if (!shader.bind()) return;\n\n    // if(needsBind)\n    this._bind(shader);\n    if (this.addVertexNumbers) this._setVertexNumbers();\n\n    MESH.lastMesh = this;\n\n    let prim = this._cgl.gl.TRIANGLES;\n    if (this._glPrimitive !== undefined) prim = this._glPrimitive;\n    if (shader.glPrimitive !== null) prim = shader.glPrimitive;\n\n    let elementDiv = 1;\n    let doQuery = this._cgl.profileData.doProfileGlQuery;\n    let queryStarted = false;\n    if (doQuery)\n    {\n        let id = this._name + \" - \" + shader.getName() + \" #\" + shader.id;\n        if (this._numInstances) id += \" instanced \" + this._numInstances + \"x\";\n\n        let queryProfilerData = this._cgl.profileData.glQueryData[id];\n\n        if (!queryProfilerData) queryProfilerData = { \"id\": id, \"num\": 0 };\n\n        if (shader.opId)queryProfilerData.shaderOp = shader.opId;\n        if (this.opId)queryProfilerData.meshOp = this.opId;\n\n        this._cgl.profileData.glQueryData[id] = queryProfilerData;\n\n        if (!this._queryExt && this._queryExt !== false) this._queryExt = this._cgl.enableExtension(\"EXT_disjoint_timer_query_webgl2\") || false;\n        if (this._queryExt)\n        {\n            if (queryProfilerData._drawQuery)\n            {\n                const available = this._cgl.gl.getQueryParameter(queryProfilerData._drawQuery, this._cgl.gl.QUERY_RESULT_AVAILABLE);\n                if (available)\n                {\n                    const elapsedNanos = this._cgl.gl.getQueryParameter(queryProfilerData._drawQuery, this._cgl.gl.QUERY_RESULT);\n                    const currentTimeGPU = elapsedNanos / 1000000;\n\n                    queryProfilerData._times = queryProfilerData._times || 0;\n                    queryProfilerData._times += currentTimeGPU;\n                    queryProfilerData._numcount++;\n                    queryProfilerData.when = performance.now();\n                    queryProfilerData._drawQuery = null;\n                    queryProfilerData.queryStarted = false;\n                }\n            }\n\n            if (!queryProfilerData.queryStarted)\n            {\n                queryProfilerData._drawQuery = this._cgl.gl.createQuery();\n                this._cgl.gl.beginQuery(this._queryExt.TIME_ELAPSED_EXT, queryProfilerData._drawQuery);\n                queryStarted = queryProfilerData.queryStarted = true;\n            }\n        }\n    }\n\n\n    if (this.hasFeedbacks())\n    {\n        this.drawFeedbacks(shader, prim);\n    }\n    else if (!this._bufVerticesIndizes || this._bufVerticesIndizes.numItems === 0)\n    {\n        // for (let i = 0; i < this._attributes.length; i++)\n        // {\n        //     if (this._attributes[i].arrayLength / this._attributes[i].itemSize != this._bufVertexAttrib.floatArray.length / 3)\n        //     {\n        //         this._log.warn(\"attrib buffer length wrong! \", this._attributes[i].name, this._attributes[i].arrayLength / this._attributes[i].itemSize, this._bufVertexAttrib.floatArray.length / 3, this._attributes[i].itemSize);\n        //         // this._log.log(this);\n        //         // debugger;\n        //         return;\n        //     }\n        // }\n\n\n        if (prim == this._cgl.gl.TRIANGLES)elementDiv = 3;\n        if (this._numInstances === 0) this._cgl.gl.drawArrays(prim, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems - this._bufVertexAttrib.startItem);\n        else this._cgl.gl.drawArraysInstanced(prim, this._bufVertexAttrib.startItem, this._bufVertexAttrib.numItems, this._numInstances);\n    }\n    else\n    {\n        if (prim == this._cgl.gl.TRIANGLES)elementDiv = 3;\n        if (this._numInstances === 0)\n        {\n            // console.log(\"la\", this._bufVerticesIndizes.numItems);\n\n            this._cgl.gl.drawElements(prim, this._bufVerticesIndizes.numItems, this._indexType, 0);\n        }\n        else\n        {\n            this._cgl.gl.drawElementsInstanced(prim, this._bufVerticesIndizes.numItems, this._indexType, 0, this._numInstances);\n        }\n    }\n\n    if (this._cgl.debugOneFrame && this._cgl.gl.getError() != this._cgl.gl.NO_ERROR)\n    {\n        this._log.error(\"mesh draw gl error\");\n        this._log.error(\"mesh\", this);\n        this._log.error(\"shader\", shader);\n\n        const attribNames = [];\n        for (let i = 0; i < this._cgl.gl.getProgramParameter(shader.getProgram(), this._cgl.gl.ACTIVE_ATTRIBUTES); i++)\n        {\n            const name = this._cgl.gl.getActiveAttrib(shader.getProgram(), i).name;\n            this._log.error(\"attrib \", name);\n        }\n    }\n\n    this._cgl.profileData.profileMeshNumElements += (this._bufVertexAttrib.numItems / elementDiv) * (this._numInstances || 1);\n    this._cgl.profileData.profileMeshDraw++;\n\n    if (doQuery && queryStarted)\n    {\n        this._cgl.gl.endQuery(this._queryExt.TIME_ELAPSED_EXT);\n    }\n\n    this._cgl.printError(\"mesh render \" + this._name);\n\n    this.unBind();\n};\n\nMesh.prototype.setNumInstances = function (n)\n{\n    n = Math.max(0, n);\n    if (this._numInstances != n)\n    {\n        this._numInstances = n;\n        const indexArr = new Float32Array(n);\n        for (let i = 0; i < n; i++) indexArr[i] = i;\n        this.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.SHADER.SHADERVAR_INSTANCE_INDEX, indexArr, 1, { \"instanced\": true });\n    }\n};\n\nMesh.prototype._disposeAttributes = function ()\n{\n    if (!this._attributes) return;\n\n    for (let i = 0; i < this._attributes.length; i++)\n    {\n        if (this._attributes[i].buffer)\n        {\n            this._cgl.gl.deleteBuffer(this._attributes[i].buffer);\n            this._attributes[i].buffer = null;\n        }\n    }\n    this._attributes.length = 0;\n};\n\nMesh.prototype.dispose = function ()\n{\n    if (this._bufVertexAttrib && this._bufVertexAttrib.buffer) this._cgl.gl.deleteBuffer(this._bufVertexAttrib.buffer);\n    if (this._bufVerticesIndizes) this._cgl.gl.deleteBuffer(this._bufVerticesIndizes);\n    this._bufVerticesIndizes = null;\n\n    this._disposeAttributes();\n};\n\n(0,_cgl_mesh_feedback_js__WEBPACK_IMPORTED_MODULE_3__.extendMeshWithFeedback)(Mesh);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX21lc2guanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dsL2NnbF9tZXNoLmpzPzAwZDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcImNhYmxlcy1zaGFyZWQtY2xpZW50XCI7XG5pbXBvcnQgeyBVbmlmb3JtIH0gZnJvbSBcIi4vY2dsX3NoYWRlcl91bmlmb3JtLmpzXCI7XG5pbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IGV4dGVuZE1lc2hXaXRoRmVlZGJhY2sgfSBmcm9tIFwiLi9jZ2xfbWVzaF9mZWVkYmFjay5qc1wiO1xuXG5jb25zdCBNRVNIID0ge307XG5NRVNILmxhc3RNZXNoID0gbnVsbDtcblxuLyoqXG4gKiB3ZWJnbCByZW5kZXJhYmxlIDNkIG9iamVjdFxuICogQGV4dGVybmFsIENHTFxuICogQG5hbWVzcGFjZSBNZXNoXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0NvbnRleHR9IGNnbFxuICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnlcbiAqIEBwYXJhbSB7TnVtYmVyfSBbZ2xQcmltaXRpdmVdXG4gKiBAY2xhc3NcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBjZ2w9dGhpcy5fY2dsXG4gKiBjb25zdCBtZXNoPW5ldyBDR0wuTWVzaChjZ2wsIGdlb21ldHJ5KTtcbiAqXG4gKiBmdW5jdGlvbiByZW5kZXIoKVxuICoge1xuICogICBtZXNoLnJlbmRlcihjZ2wuZ2V0U2hhZGVyKCkpO1xuICogfVxuICovXG5jb25zdCBNZXNoID0gZnVuY3Rpb24gKF9jZ2wsIF9fZ2VvbSwgX29wdGlvbnMpXG57XG4gICAgdGhpcy5fY2dsID0gX2NnbDtcblxuICAgIGxldCBvcHRpb25zID0gX29wdGlvbnMgfHwge307XG4gICAgaWYgKENBQkxFUy5VVElMUy5pc051bWVyaWMob3B0aW9ucykpb3B0aW9ucyA9IHsgXCJnbFByaW1pdGl2ZVwiOiBfb3B0aW9ucyB9OyAvLyBvbGQgY29uc3RydWN0b3IgZmFsbGJhY2suLi5cbiAgICB0aGlzLl9sb2cgPSBuZXcgTG9nZ2VyKFwiY2dsX21lc2hcIik7XG4gICAgdGhpcy5fYnVmVmVydGV4QXR0cmliID0gbnVsbDtcbiAgICB0aGlzLl9idWZWZXJ0aWNlc0luZGl6ZXMgPSB0aGlzLl9jZ2wuZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5faW5kZXhUeXBlID0gdGhpcy5fY2dsLmdsLlVOU0lHTkVEX1NIT1JUO1xuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBbXTtcbiAgICB0aGlzLl9hdHRyaWJMb2NzID0ge307XG4gICAgdGhpcy5fZ2VvbSA9IG51bGw7XG4gICAgdGhpcy5fbGFzdFNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbnVtSW5zdGFuY2VzID0gMDtcbiAgICB0aGlzLl9nbFByaW1pdGl2ZSA9IG9wdGlvbnMuZ2xQcmltaXRpdmU7XG5cbiAgICB0aGlzLm9wSWQgPSBvcHRpb25zLm9wSWQgfHwgXCJcIjtcbiAgICB0aGlzLl9wcmVXaXJlZnJhbWVHZW9tID0gbnVsbDtcbiAgICB0aGlzLmFkZFZlcnRleE51bWJlcnMgPSBmYWxzZTtcbiAgICB0aGlzLl9uYW1lID0gXCJ1bmtub3duXCI7XG5cbiAgICB0aGlzLmZlZWRCYWNrQXR0cmlidXRlcyA9IFtdO1xuICAgIHRoaXMuc2V0R2VvbShfX2dlb20pO1xuXG4gICAgdGhpcy5fZmVlZEJhY2tzID0gW107XG4gICAgdGhpcy5fZmVlZEJhY2tzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3RyYW5zZm9ybUZlZWRCYWNrTG9jID0gLTE7XG4gICAgdGhpcy5fbGFzdEF0dHJVcGRhdGUgPSAwO1xuXG4gICAgdGhpcy5tZW1GcmVlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLmFkZEhlYXZ5RXZlbnQoXCJtZXNoIGNvbnN0cnVjdGVkXCIsIHRoaXMuX25hbWUpO1xuXG4gICAgdGhpcy5fcXVlcnlFeHQgPSBudWxsO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibnVtSW5zdGFuY2VzXCIsIHtcbiAgICAgICAgZ2V0KClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX251bUluc3RhbmNlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHYpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TnVtSW5zdGFuY2VzKHYpO1xuICAgICAgICB9LFxuICAgIH0pO1xufTtcblxuTWVzaC5wcm90b3R5cGUuZnJlZU1lbSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5tZW1GcmVlZCA9IHRydWU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2F0dHJpYnV0ZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzW2ldLmZsb2F0QXJyYXkgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIHVwZGF0ZVZlcnRpY2VzXG4gKiBAbWVtYmVyb2YgTWVzaFxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gdXBkYXRlIHZlcnRpY2VzIG9ubHkgZnJvbSBhIGdlb21ldHJ5XG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBnZW9tZXRyeVxuICovXG5NZXNoLnByb3RvdHlwZS51cGRhdGVWZXJ0aWNlcyA9IGZ1bmN0aW9uIChnZW9tKVxue1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKENPTlNUQU5UUy5TSEFERVIuU0hBREVSVkFSX1ZFUlRFWF9QT1NJVElPTiwgZ2VvbS52ZXJ0aWNlcywgMyk7XG4gICAgdGhpcy5fbnVtVmVydHMgPSBnZW9tLnZlcnRpY2VzLmxlbmd0aCAvIDM7XG59O1xuXG5NZXNoLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVQb2ludGVyID0gZnVuY3Rpb24gKGF0dHJOYW1lLCBuYW1lLCBzdHJpZGUsIG9mZnNldClcbntcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2F0dHJpYnV0ZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fYXR0cmlidXRlc1tpXS5uYW1lID09IGF0dHJOYW1lKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2F0dHJpYnV0ZXNbaV0ucG9pbnRlcikgdGhpcy5fYXR0cmlidXRlc1tpXS5wb2ludGVyID0gW107XG5cbiAgICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZXNbaV0ucG9pbnRlci5wdXNoKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgXCJsb2NcIjogLTEsXG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBcInN0cmlkZVwiOiBzdHJpZGUsXG4gICAgICAgICAgICAgICAgICAgIFwib2Zmc2V0XCI6IG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgXCJpbnN0YW5jZWRcIjogYXR0ck5hbWUgPT0gQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfSU5TVEFOQ0VfTU1BVFJJWCxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuTWVzaC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUpXG57XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSBpZiAodGhpcy5fYXR0cmlidXRlc1tpXS5uYW1lID09IG5hbWUpIHJldHVybiB0aGlzLl9hdHRyaWJ1dGVzW2ldO1xufTtcblxuTWVzaC5wcm90b3R5cGUuc2V0QXR0cmlidXRlUmFuZ2UgPSBmdW5jdGlvbiAoYXR0ciwgYXJyYXksIHN0YXJ0LCBlbmQpXG57XG4gICAgaWYgKCFhdHRyKSByZXR1cm47XG4gICAgaWYgKCFzdGFydCAmJiAhZW5kKSByZXR1cm47XG5cbiAgICBpZiAoIWF0dHIubmFtZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy5zdGFjayhcIm5vIGF0dHJuYW1lPyFcIik7XG4gICAgfVxuXG4gICAgdGhpcy5fY2dsLmdsLmJpbmRCdWZmZXIodGhpcy5fY2dsLmdsLkFSUkFZX0JVRkZFUiwgYXR0ci5idWZmZXIpO1xuICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlTWVzaEF0dHJpYnV0ZXMgKz0gKGVuZCAtIHN0YXJ0KSB8fCAwO1xuXG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaW5nbGVNZXNoQXR0cmlidXRlW3RoaXMuX25hbWVdID0gdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaW5nbGVNZXNoQXR0cmlidXRlW3RoaXMuX25hbWVdIHx8IDA7XG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaW5nbGVNZXNoQXR0cmlidXRlW3RoaXMuX25hbWVdICs9IChlbmQgLSBzdGFydCkgfHwgMDtcblxuICAgIGlmIChhdHRyLm51bUl0ZW1zIDwgYXJyYXkubGVuZ3RoIC8gYXR0ci5pdGVtU2l6ZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZUF0dHIoYXJyYXksIGF0dHIpO1xuICAgIH1cblxuICAgIGlmIChlbmQgPj0gYXJyYXkubGVuZ3RoIC0gMSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy5sb2codGhpcy5fY2dsLmNhbnZhcy5pZCArIFwiIFwiICsgYXR0ci5uYW1lICsgXCIgYnVmZmVyc3ViZGF0YSBvdXQgb2YgYm91bmRzID9cIiwgYXJyYXkubGVuZ3RoLCBlbmQsIHN0YXJ0LCBhdHRyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY2dsLmdsVmVyc2lvbiA9PSAxKSB0aGlzLl9jZ2wuZ2wuYnVmZmVyU3ViRGF0YSh0aGlzLl9jZ2wuZ2wuQVJSQVlfQlVGRkVSLCAwLCBhcnJheSk7IC8vIHByb2JhYmx5IHNsb3cvIG1heWJlIGNyZWF0ZSBhbmQgYXJyYXkgd2l0aCBvbmx5IGNoYW5nZWQgc2l6ZSA/P1xuICAgIGVsc2UgdGhpcy5fY2dsLmdsLmJ1ZmZlclN1YkRhdGEodGhpcy5fY2dsLmdsLkFSUkFZX0JVRkZFUiwgc3RhcnQgKiA0LCBhcnJheSwgc3RhcnQsIChlbmQgLSBzdGFydCkpO1xufTtcblxuTWVzaC5wcm90b3R5cGUuX3Jlc2l6ZUF0dHIgPSBmdW5jdGlvbiAoYXJyYXksIGF0dHIpXG57XG4gICAgaWYgKGF0dHIuYnVmZmVyKVxuICAgICAgICB0aGlzLl9jZ2wuZ2wuZGVsZXRlQnVmZmVyKGF0dHIuYnVmZmVyKTtcblxuICAgIGF0dHIuYnVmZmVyID0gdGhpcy5fY2dsLmdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuX2NnbC5nbC5iaW5kQnVmZmVyKHRoaXMuX2NnbC5nbC5BUlJBWV9CVUZGRVIsIGF0dHIuYnVmZmVyKTtcbiAgICB0aGlzLl9idWZmZXJBcnJheShhcnJheSwgYXR0cik7XG4gICAgYXR0ci5udW1JdGVtcyA9IGFycmF5Lmxlbmd0aCAvIGF0dHIuaXRlbVNpemU7Ly8gbnVtSXRlbXM7XG59O1xuXG5cbk1lc2gucHJvdG90eXBlLl9idWZmZXJBcnJheSA9IGZ1bmN0aW9uIChhcnJheSwgYXR0cilcbntcbiAgICBsZXQgZmxvYXRBcnJheSA9IGF0dHIuZmxvYXRBcnJheSB8fCBudWxsO1xuICAgIGlmICghYXJyYXkpIHJldHVybjtcblxuXG4gICAgaWYgKHRoaXMuX2NnbC5kZWJ1Z09uZUZyYW1lKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJfYnVmZmVyQXJyYXlcIiwgYXJyYXkubGVuZ3RoLCBhdHRyLm5hbWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfVxuXG4gICAgaWYgKCEoYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKVxuICAgIHtcbiAgICAgICAgaWYgKGF0dHIgJiYgZmxvYXRBcnJheSAmJiBmbG9hdEFycmF5Lmxlbmd0aCA9PSBhcnJheS5sZW5ndGgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZsb2F0QXJyYXkuc2V0KGFycmF5KTtcbiAgICAgICAgICAgIC8vIGZsb2F0QXJyYXkgPSBmbG9hdEFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoYXJyYXkpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fY2dsLmRlYnVnT25lRnJhbWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJfYnVmZmVyQXJyYXkgY3JlYXRlIG5ldyBmbG9hdDMyYXJyYXlcIiwgYXJyYXkubGVuZ3RoLCBhdHRyLm5hbWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPiAxMDAwMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZU5vblR5cGVkQXR0cmliKys7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVOb25UeXBlZEF0dHJpYk5hbWVzID0gXCIoXCIgKyB0aGlzLl9uYW1lICsgXCI6XCIgKyBhdHRyLm5hbWUgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGZsb2F0QXJyYXkgPSBhcnJheTtcblxuICAgIGF0dHIuYXJyYXlMZW5ndGggPSBmbG9hdEFycmF5Lmxlbmd0aDtcbiAgICBhdHRyLmZsb2F0QXJyYXkgPSBudWxsOy8vIGZsb2F0QXJyYXk7XG5cbiAgICB0aGlzLl9jZ2wuZ2wuYnVmZmVyRGF0YSh0aGlzLl9jZ2wuZ2wuQVJSQVlfQlVGRkVSLCBmbG9hdEFycmF5LCB0aGlzLl9jZ2wuZ2wuRFlOQU1JQ19EUkFXKTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIHNldEF0dHJpYnV0ZVxuICogQGRlc2NyaXB0aW9uIHVwZGF0ZSBhdHRyaWJ1dGVcbiAqIEBtZW1iZXJvZiBNZXNoXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGUgbmFtZVxuICogQHBhcmFtIHtBcnJheX0gZGF0YVxuICogQHBhcmFtIHtOdW1iZXJ9IGl0ZW1TaXplXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5NZXNoLnByb3RvdHlwZS5hZGRBdHRyaWJ1dGUgPSBNZXNoLnByb3RvdHlwZS51cGRhdGVBdHRyaWJ1dGUgPSBNZXNoLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSwgYXJyYXksIGl0ZW1TaXplLCBvcHRpb25zKVxue1xuICAgIGlmICghYXJyYXkpXG4gICAge1xuICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJtZXNoIGFkZEF0dHJpYnV0ZSAtIG5vIGFycmF5IGdpdmVuISBcIiArIG5hbWUpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgbGV0IGNiID0gbnVsbDtcbiAgICBsZXQgaW5zdGFuY2VkID0gZmFsc2U7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IG51bUl0ZW1zID0gYXJyYXkubGVuZ3RoIC8gaXRlbVNpemU7XG5cbiAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZU1lc2hBdHRyaWJ1dGVzICs9IG51bUl0ZW1zIHx8IDA7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gXCJmdW5jdGlvblwiKVxuICAgIHtcbiAgICAgICAgY2IgPSBvcHRpb25zO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSBcIm9iamVjdFwiKVxuICAgIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2IpIGNiID0gb3B0aW9ucy5jYjtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5zdGFuY2VkKSBpbnN0YW5jZWQgPSBvcHRpb25zLmluc3RhbmNlZDtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PSBDT05TVEFOVFMuU0hBREVSLlNIQURFUlZBUl9JTlNUQU5DRV9NTUFUUklYKSBpbnN0YW5jZWQgPSB0cnVlO1xuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSB0aGlzLl9hdHRyaWJ1dGVzW2ldO1xuICAgICAgICBpZiAoYXR0ci5uYW1lID09IG5hbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChhdHRyLm51bUl0ZW1zID09PSBudW1JdGVtcylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9sb2cubG9nKFwid3JvbmcgYnVmZmVyIHNpemVcIiwgdGhpcy5fZ2VvbS5uYW1lLCBhdHRyLm5hbWUsIGF0dHIubnVtSXRlbXMsIG51bUl0ZW1zKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNpemVBdHRyKGFycmF5LCBhdHRyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRCdWZmZXIodGhpcy5fY2dsLmdsLkFSUkFZX0JVRkZFUiwgYXR0ci5idWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQXJyYXkoYXJyYXksIGF0dHIpO1xuXG4gICAgICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBuZXcgYnVmZmVyLi4uXG5cbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9jZ2wuZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICB0aGlzLl9jZ2wuZ2wuYmluZEJ1ZmZlcih0aGlzLl9jZ2wuZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgIC8vIHRoaXMuX2NnbC5nbC5idWZmZXJEYXRhKHRoaXMuX2NnbC5nbC5BUlJBWV9CVUZGRVIsIGZsb2F0QXJyYXksIHRoaXMuX2NnbC5nbC5EWU5BTUlDX0RSQVcpO1xuXG4gICAgbGV0IHR5cGUgPSB0aGlzLl9jZ2wuZ2wuRkxPQVQ7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlKSB0eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIGNvbnN0IGF0dHIgPSB7XG4gICAgICAgIFwiYnVmZmVyXCI6IGJ1ZmZlcixcbiAgICAgICAgXCJuYW1lXCI6IG5hbWUsXG4gICAgICAgIFwiY2JcIjogY2IsXG4gICAgICAgIFwiaXRlbVNpemVcIjogaXRlbVNpemUsXG4gICAgICAgIFwibnVtSXRlbXNcIjogbnVtSXRlbXMsXG4gICAgICAgIFwic3RhcnRJdGVtXCI6IDAsXG4gICAgICAgIFwiaW5zdGFuY2VkXCI6IGluc3RhbmNlZCxcbiAgICAgICAgXCJ0eXBlXCI6IHR5cGVcbiAgICB9O1xuXG4gICAgdGhpcy5fYnVmZmVyQXJyYXkoYXJyYXksIGF0dHIpO1xuXG4gICAgaWYgKG5hbWUgPT0gQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfVkVSVEVYX1BPU0lUSU9OKSB0aGlzLl9idWZWZXJ0ZXhBdHRyaWIgPSBhdHRyO1xuICAgIHRoaXMuX2F0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgICB0aGlzLl9hdHRyaWJMb2NzID0ge307XG5cbiAgICByZXR1cm4gYXR0cjtcbn07XG5cbk1lc2gucHJvdG90eXBlLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9hdHRyaWJ1dGVzO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gdXBkYXRlVGV4Q29vcmRzXG4gKiBAZGVzY3JpcHRpb24gdXBkYXRlIHRleHR1cmUgY29vcmRpbmF0ZXMgb25seSBmcm9tIGEgZ2VvbWV0cnlcbiAqIEBtZW1iZXJvZiBNZXNoXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5XG4gKi9cbk1lc2gucHJvdG90eXBlLnVwZGF0ZVRleENvb3JkcyA9IGZ1bmN0aW9uIChnZW9tKVxue1xuICAgIGlmIChnZW9tLnRleENvb3JkcyAmJiBnZW9tLnRleENvb3Jkcy5sZW5ndGggPiAwKVxuICAgIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfVkVSVEVYX1RFWENPT1JELCBnZW9tLnRleENvb3JkcywgMik7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGNvbnN0IHRjQnVmZiA9IG5ldyBGbG9hdDMyQXJyYXkoTWF0aC5yb3VuZCgoZ2VvbS52ZXJ0aWNlcy5sZW5ndGggLyAzKSAqIDIpKTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfVkVSVEVYX1RFWENPT1JELCB0Y0J1ZmYsIDIpO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBAZnVuY3Rpb24gdXBkYXRlTm9ybWFsc1xuICogQGRlc2NyaXB0aW9uIHVwZGF0ZSBub3JtYWxzIG9ubHkgZnJvbSBhIGdlb21ldHJ5XG4gKiBAbWVtYmVyb2YgTWVzaFxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBnZW9tZXRyeVxuICovXG5NZXNoLnByb3RvdHlwZS51cGRhdGVOb3JtYWxzID0gZnVuY3Rpb24gKGdlb20pXG57XG4gICAgaWYgKGdlb20udmVydGV4Tm9ybWFscyAmJiBnZW9tLnZlcnRleE5vcm1hbHMubGVuZ3RoID4gMClcbiAgICB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKENPTlNUQU5UUy5TSEFERVIuU0hBREVSVkFSX1ZFUlRFWF9OT1JNQUwsIGdlb20udmVydGV4Tm9ybWFscywgMyk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGNvbnN0IHRjQnVmZiA9IG5ldyBGbG9hdDMyQXJyYXkoTWF0aC5yb3VuZCgoZ2VvbS52ZXJ0aWNlcy5sZW5ndGgpKSk7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKENPTlNUQU5UUy5TSEFERVIuU0hBREVSVkFSX1ZFUlRFWF9OT1JNQUwsIHRjQnVmZiwgMyk7XG4gICAgfVxufTtcblxuXG5NZXNoLnByb3RvdHlwZS5fc2V0VmVydGV4TnVtYmVycyA9IGZ1bmN0aW9uIChhcnIpXG57XG4gICAgaWYgKCF0aGlzLl92ZXJ0aWNlc051bWJlcnMgfHwgdGhpcy5fdmVydGljZXNOdW1iZXJzLmxlbmd0aCAhPSB0aGlzLl9udW1WZXJ0cyB8fCBhcnIpXG4gICAge1xuICAgICAgICBpZiAoYXJyKSB0aGlzLl92ZXJ0aWNlc051bWJlcnMgPSBhcnI7XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fdmVydGljZXNOdW1iZXJzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLl9udW1WZXJ0cyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX251bVZlcnRzOyBpKyspIHRoaXMuX3ZlcnRpY2VzTnVtYmVyc1tpXSA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShDT05TVEFOVFMuU0hBREVSLlNIQURFUlZBUl9WRVJURVhfTlVNQkVSLCB0aGlzLl92ZXJ0aWNlc051bWJlcnMsIDEsIChhdHRyLCBnZW9tLCBzaGFkZXIpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghc2hhZGVyLnVuaWZvcm1OdW1WZXJ0aWNlcykgc2hhZGVyLnVuaWZvcm1OdW1WZXJ0aWNlcyA9IG5ldyBVbmlmb3JtKHNoYWRlciwgXCJmXCIsIFwibnVtVmVydGljZXNcIiwgdGhpcy5fbnVtVmVydHMpO1xuICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1OdW1WZXJ0aWNlcy5zZXRWYWx1ZSh0aGlzLl9udW1WZXJ0cyk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwidGhpcy5fbnVtVmVydHNcIiwgdGhpcy5fbnVtVmVydHMsIGF0dHIsIHNoYWRlci51bmlmb3JtTnVtVmVydGljZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBzZXRWZXJ0ZXhJbmRpY2VzXG4gKiBAZGVzY3JpcHRpb24gdXBkYXRlIHZlcnRleCBpbmRpY2VzIC8gZmFjZXNcbiAqIEBtZW1iZXJvZiBNZXNoXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7YXJyYXl9IHZlcnRJbmRpY2VzXG4gKi9cbk1lc2gucHJvdG90eXBlLnNldFZlcnRleEluZGljZXMgPSBmdW5jdGlvbiAodmVydEluZGljZXMpXG57XG4gICAgaWYgKCF0aGlzLl9idWZWZXJ0aWNlc0luZGl6ZXMpXG4gICAge1xuICAgICAgICB0aGlzLl9sb2cud2FybihcIm5vIGJ1ZlZlcnRpY2VzSW5kaXplczogXCIgKyB0aGlzLl9uYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmVydEluZGljZXMubGVuZ3RoID4gMClcbiAgICB7XG4gICAgICAgIGlmICh2ZXJ0SW5kaWNlcyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkgdGhpcy5fbG9nLndhcm4oXCJ2ZXJ0SW5kaWNlcyBmbG9hdDMyQXJyYXk6IFwiICsgdGhpcy5fbmFtZSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0SW5kaWNlcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZlcnRJbmRpY2VzW2ldID49IHRoaXMuX251bVZlcnRzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiaW52YWxpZCBpbmRleCBpbiBcIiArIHRoaXMuX25hbWUsIGksIHZlcnRJbmRpY2VzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuX2J1ZlZlcnRpY2VzSW5kaXplcyk7XG5cbiAgICAgICAgLy8gdG9kbyBjYWNoZSB0aGlzID9cbiAgICAgICAgLy8gaWYoIXRoaXMudmVydEluZGljZXNUeXBlZCB8fCB0aGlzLnZlcnRJbmRpY2VzVHlwZWQubGVuZ3RoIT10aGlzLl9nZW9tLnZlcnRpY2VzSW5kaWNlcy5sZW5ndGgpXG5cbiAgICAgICAgaWYgKHZlcnRJbmRpY2VzLmxlbmd0aCA+IDY1NTM1KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnZlcnRJbmRpY2VzVHlwZWQgPSBuZXcgVWludDMyQXJyYXkodmVydEluZGljZXMpO1xuICAgICAgICAgICAgdGhpcy5faW5kZXhUeXBlID0gdGhpcy5fY2dsLmdsLlVOU0lHTkVEX0lOVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIGlmICh2ZXJ0SW5kaWNlcyBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnZlcnRJbmRpY2VzVHlwZWQgPSB2ZXJ0SW5kaWNlcztcbiAgICAgICAgICAgIHRoaXMuX2luZGV4VHlwZSA9IHRoaXMuX2NnbC5nbC5VTlNJR05FRF9JTlQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICBpZiAoISh2ZXJ0SW5kaWNlcyBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy52ZXJ0SW5kaWNlc1R5cGVkID0gbmV3IFVpbnQxNkFycmF5KHZlcnRJbmRpY2VzKTtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4VHlwZSA9IHRoaXMuX2NnbC5nbC5VTlNJR05FRF9TSE9SVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHRoaXMudmVydEluZGljZXNUeXBlZCA9IHZlcnRJbmRpY2VzO1xuXG4gICAgICAgIHRoaXMuX2NnbC5nbC5idWZmZXJEYXRhKHRoaXMuX2NnbC5nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0SW5kaWNlc1R5cGVkLCB0aGlzLl9jZ2wuZ2wuRFlOQU1JQ19EUkFXKTtcbiAgICAgICAgdGhpcy5fYnVmVmVydGljZXNJbmRpemVzLml0ZW1TaXplID0gMTtcbiAgICAgICAgdGhpcy5fYnVmVmVydGljZXNJbmRpemVzLm51bUl0ZW1zID0gdmVydEluZGljZXMubGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIHRoaXMuX2J1ZlZlcnRpY2VzSW5kaXplcy5udW1JdGVtcyA9IDA7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBzZXRHZW9tXG4gKiBAbWVtYmVyb2YgTWVzaFxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gc2V0IGdlb21ldHJ5IGZvciBtZXNoXG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBnZW9tZXRyeVxuICovXG5NZXNoLnByb3RvdHlwZS5zZXRHZW9tID0gZnVuY3Rpb24gKGdlb20sIHJlbW92ZVJlZilcbntcbiAgICB0aGlzLl9nZW9tID0gZ2VvbTtcbiAgICBpZiAoZ2VvbS5nbFByaW1pdGl2ZSAhPSBudWxsKSB0aGlzLl9nbFByaW1pdGl2ZSA9IGdlb20uZ2xQcmltaXRpdmU7XG4gICAgaWYgKHRoaXMuX2dlb20gJiYgdGhpcy5fZ2VvbS5uYW1lKSB0aGlzLl9uYW1lID0gXCJtZXNoIFwiICsgdGhpcy5fZ2VvbS5uYW1lO1xuXG4gICAgTUVTSC5sYXN0TWVzaCA9IG51bGw7XG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVNZXNoU2V0R2VvbSsrO1xuXG4gICAgdGhpcy5fZGlzcG9zZUF0dHJpYnV0ZXMoKTtcblxuICAgIHRoaXMudXBkYXRlVmVydGljZXModGhpcy5fZ2VvbSk7XG4gICAgdGhpcy5zZXRWZXJ0ZXhJbmRpY2VzKHRoaXMuX2dlb20udmVydGljZXNJbmRpY2VzKTtcblxuICAgIGlmICh0aGlzLmFkZFZlcnRleE51bWJlcnMpIHRoaXMuX3NldFZlcnRleE51bWJlcnMoKTtcblxuICAgIGNvbnN0IGdlb21BdHRyaWJzID0gdGhpcy5fZ2VvbS5nZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICBjb25zdCBhdHRyaWJBc3NvYyA9IHtcbiAgICAgICAgXCJ0ZXhDb29yZHNcIjogQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfVkVSVEVYX1RFWENPT1JELFxuICAgICAgICBcInZlcnRleE5vcm1hbHNcIjogQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfVkVSVEVYX05PUk1BTCxcbiAgICAgICAgXCJ2ZXJ0ZXhDb2xvcnNcIjogQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfVkVSVEVYX0NPTE9SLFxuICAgICAgICBcInRhbmdlbnRzXCI6IFwiYXR0clRhbmdlbnRcIixcbiAgICAgICAgXCJiaVRhbmdlbnRzXCI6IFwiYXR0ckJpVGFuZ2VudFwiLFxuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IGluZGV4IGluIGdlb21BdHRyaWJzKVxuICAgICAgICBpZiAoZ2VvbUF0dHJpYnNbaW5kZXhdLmRhdGEgJiYgZ2VvbUF0dHJpYnNbaW5kZXhdLmRhdGEubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoYXR0cmliQXNzb2NbaW5kZXhdIHx8IGluZGV4LCBnZW9tQXR0cmlic1tpbmRleF0uZGF0YSwgZ2VvbUF0dHJpYnNbaW5kZXhdLml0ZW1TaXplKTtcblxuXG4gICAgaWYgKHJlbW92ZVJlZilcbiAgICB7XG4gICAgICAgIHRoaXMuX2dlb20gPSBudWxsO1xuICAgIH1cbn07XG5cbk1lc2gucHJvdG90eXBlLl9wcmVCaW5kID0gZnVuY3Rpb24gKHNoYWRlcilcbntcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2F0dHJpYnV0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzW2ldLmNiKVxuICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlc1tpXS5jYih0aGlzLl9hdHRyaWJ1dGVzW2ldLCB0aGlzLl9nZW9tLCBzaGFkZXIpO1xufTtcblxuTWVzaC5wcm90b3R5cGUuX2NoZWNrQXR0ckxlbmd0aHMgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLm1lbUZyZWVkKSByZXR1cm47XG4gICAgLy8gY2hlY2sgbGVuZ3RoXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXNbaV0uYXJyYXlMZW5ndGggLyB0aGlzLl9hdHRyaWJ1dGVzW2ldLml0ZW1TaXplIDwgdGhpcy5fYXR0cmlidXRlc1swXS5hcnJheUxlbmd0aCAvIHRoaXMuX2F0dHJpYnV0ZXNbMF0uaXRlbVNpemUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gXCJ1bmtub3duXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2VvbSluYW1lID0gdGhpcy5fZ2VvbS5uYW1lO1xuICAgICAgICAgICAgLy8gdGhpcy5fbG9nLndhcm4oXG4gICAgICAgICAgICAvLyAgICAgbmFtZSArIFwiOiBcIiArIHRoaXMuX2F0dHJpYnV0ZXNbaV0ubmFtZSArXG4gICAgICAgICAgICAvLyAgICAgXCIgd3JvbmcgYXR0ciBsZW5ndGguIGlzOlwiLCB0aGlzLl9hdHRyaWJ1dGVzW2ldLmFycmF5TGVuZ3RoIC8gdGhpcy5fYXR0cmlidXRlc1tpXS5pdGVtU2l6ZSxcbiAgICAgICAgICAgIC8vICAgICBcIiBzaG91bGQgYmU6XCIsIHRoaXMuX2F0dHJpYnV0ZXNbMF0uYXJyYXlMZW5ndGggLyB0aGlzLl9hdHRyaWJ1dGVzWzBdLml0ZW1TaXplLFxuICAgICAgICAgICAgLy8gKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbk1lc2gucHJvdG90eXBlLl9iaW5kID0gZnVuY3Rpb24gKHNoYWRlcilcbntcbiAgICBpZiAoIXNoYWRlci5pc1ZhbGlkKCkpIHJldHVybjtcblxuICAgIGxldCBhdHRyTG9jcyA9IFtdO1xuICAgIGlmICh0aGlzLl9hdHRyaWJMb2NzW3NoYWRlci5pZF0pIGF0dHJMb2NzID0gdGhpcy5fYXR0cmliTG9jc1tzaGFkZXIuaWRdO1xuICAgIGVsc2UgdGhpcy5fYXR0cmliTG9jc1tzaGFkZXIuaWRdID0gYXR0ckxvY3M7XG5cbiAgICB0aGlzLl9sYXN0U2hhZGVyID0gc2hhZGVyO1xuICAgIGlmIChzaGFkZXIubGFzdENvbXBpbGUgPiB0aGlzLl9sYXN0QXR0clVwZGF0ZSB8fCBhdHRyTG9jcy5sZW5ndGggIT0gdGhpcy5fYXR0cmlidXRlcy5sZW5ndGgpXG4gICAge1xuICAgICAgICB0aGlzLl9sYXN0QXR0clVwZGF0ZSA9IHNoYWRlci5sYXN0Q29tcGlsZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSBhdHRyTG9jc1tpXSA9IC0xO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuX2F0dHJpYnV0ZXNbaV07XG4gICAgICAgIGlmIChhdHRyTG9jc1tpXSA9PSAtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5fYXR0ckxvY2F0aW9uTGFzdFNoYWRlclRpbWUgIT0gc2hhZGVyLmxhc3RDb21waWxlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5fYXR0ckxvY2F0aW9uTGFzdFNoYWRlclRpbWUgPSBzaGFkZXIubGFzdENvbXBpbGU7XG4gICAgICAgICAgICAgICAgYXR0ckxvY3NbaV0gPSB0aGlzLl9jZ2wuZ2xHZXRBdHRyaWJMb2NhdGlvbihzaGFkZXIuZ2V0UHJvZ3JhbSgpLCBhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5fbG9nLmxvZygnYXR0cmlibG9jJyxhdHRyaWJ1dGUubmFtZSxhdHRyTG9jc1tpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVBdHRyTG9jKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXR0ckxvY3NbaV0gIT0gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyTG9jc1tpXSk7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEJ1ZmZlcih0aGlzLl9jZ2wuZ2wuQVJSQVlfQlVGRkVSLCBhdHRyaWJ1dGUuYnVmZmVyKTtcblxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5pbnN0YW5jZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbzogZWFzaWVyIHdheSB0byBmaWxsIG1hdDQgYXR0cmlicy4uLlxuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUuaXRlbVNpemUgPD0gNClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXR0cmlidXRlLml0ZW1TaXplIHx8IGF0dHJpYnV0ZS5pdGVtU2l6ZSA9PSAwKSB0aGlzLl9sb2cud2FybihcImluc3RhbmNlZCBhdHRyaWIgaXRlbXNpemUgZXJyb3JcIiwgdGhpcy5fZ2VvbS5uYW1lLCBhdHRyaWJ1dGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJMb2NzW2ldLCBhdHRyaWJ1dGUuaXRlbVNpemUsIGF0dHJpYnV0ZS50eXBlLCBmYWxzZSwgYXR0cmlidXRlLml0ZW1TaXplICogNCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJMb2NzW2ldLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0cmlidXRlLml0ZW1TaXplID09IDE2KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaWRlID0gMTYgKiA0O1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJMb2NzW2ldLCA0LCBhdHRyaWJ1dGUudHlwZSwgZmFsc2UsIHN0cmlkZSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyTG9jc1tpXSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyTG9jc1tpXSArIDEsIDQsIGF0dHJpYnV0ZS50eXBlLCBmYWxzZSwgc3RyaWRlLCA0ICogNCAqIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0ckxvY3NbaV0gKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0ckxvY3NbaV0gKyAyLCA0LCBhdHRyaWJ1dGUudHlwZSwgZmFsc2UsIHN0cmlkZSwgNCAqIDQgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJMb2NzW2ldICsgMyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJMb2NzW2ldICsgMywgNCwgYXR0cmlidXRlLnR5cGUsIGZhbHNlLCBzdHJpZGUsIDQgKiA0ICogMyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0ckxvY3NbaV0sIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyTG9jc1tpXSArIDEsIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyTG9jc1tpXSArIDIsIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyTG9jc1tpXSArIDMsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2FybihcInVua25vd24gaW5zdGFuY2UgYXR0cmliIHNpemVcIiwgYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZS5pdGVtU2l6ZSB8fCBhdHRyaWJ1dGUuaXRlbVNpemUgPT0gMCkgdGhpcy5fbG9nLndhcm4oXCJhdHRyaWIgaXRlbXNpemUgZXJyb3JcIiwgdGhpcy5fbmFtZSwgYXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyTG9jc1tpXSwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGUudHlwZSwgZmFsc2UsIGF0dHJpYnV0ZS5pdGVtU2l6ZSAqIDQsIDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5wb2ludGVyKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaXAgPSAwOyBpcCA8IGF0dHJpYnV0ZS5wb2ludGVyLmxlbmd0aDsgaXArKylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnRlciA9IGF0dHJpYnV0ZS5wb2ludGVyW2lwXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50ZXIubG9jID09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXIubG9jID0gdGhpcy5fY2dsLmdsR2V0QXR0cmliTG9jYXRpb24oc2hhZGVyLmdldFByb2dyYW0oKSwgcG9pbnRlci5uYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVBdHRyTG9jKys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb2ludGVyLmxvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb2ludGVyLmxvYywgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGUudHlwZSwgZmFsc2UsIHBvaW50ZXIuc3RyaWRlLCBwb2ludGVyLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kRmVlZGJhY2soYXR0cmlidXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9idWZWZXJ0aWNlc0luZGl6ZXMgJiYgdGhpcy5fYnVmVmVydGljZXNJbmRpemVzLm51bUl0ZW1zICE9PSAwKSB0aGlzLl9jZ2wuZ2wuYmluZEJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuX2J1ZlZlcnRpY2VzSW5kaXplcyk7XG59O1xuXG5NZXNoLnByb3RvdHlwZS51bkJpbmQgPSBmdW5jdGlvbiAoKVxue1xuICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuX2xhc3RTaGFkZXI7XG4gICAgdGhpcy5fbGFzdFNoYWRlciA9IG51bGw7XG4gICAgaWYgKCFzaGFkZXIpIHJldHVybjtcblxuICAgIGxldCBhdHRyTG9jcyA9IFtdO1xuICAgIGlmICh0aGlzLl9hdHRyaWJMb2NzW3NoYWRlci5pZF0pIGF0dHJMb2NzID0gdGhpcy5fYXR0cmliTG9jc1tzaGFkZXIuaWRdO1xuICAgIGVsc2UgdGhpcy5fYXR0cmliTG9jc1tzaGFkZXIuaWRdID0gYXR0ckxvY3M7XG5cbiAgICBNRVNILmxhc3RNZXNoID0gbnVsbDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzW2ldLmluc3RhbmNlZClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gdG9kbzogZWFzaWVyIHdheSB0byBmaWxsIG1hdDQgYXR0cmlicy4uLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXNbaV0uaXRlbVNpemUgPD0gNClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ckxvY3NbaV0gIT0gLTEpIHRoaXMuX2NnbC5nbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJMb2NzW2ldLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ckxvY3NbaV0gPj0gMCkgdGhpcy5fY2dsLmdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyTG9jc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0ckxvY3NbaV0sIDApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJMb2NzW2ldICsgMSwgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0ckxvY3NbaV0gKyAyLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyTG9jc1tpXSArIDMsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0ckxvY3NbaV0gKyAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJMb2NzW2ldICsgMik7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyTG9jc1tpXSArIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF0dHJMb2NzW2ldICE9IC0xKSB0aGlzLl9jZ2wuZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJMb2NzW2ldKTtcbiAgICB9XG59O1xuXG5NZXNoLnByb3RvdHlwZS5tZXNoQ2hhbmdlZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX2NnbC5sYXN0TWVzaCAmJiB0aGlzLl9jZ2wubGFzdE1lc2ggIT0gdGhpcztcbn07XG5cbk1lc2gucHJvdG90eXBlLnByaW50RGVidWcgPSBmdW5jdGlvbiAoc2hhZGVyKVxue1xuICAgIGNvbnNvbGUubG9nKFwiLS1hdHRyaWJ1dGVzXCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiYXR0cmlidXRlIFwiICsgaSArIFwiIFwiICsgdGhpcy5fYXR0cmlidXRlc1tpXS5uYW1lKTtcbiAgICB9XG59O1xuXG5NZXNoLnByb3RvdHlwZS5zZXROdW1WZXJ0aWNlcyA9IGZ1bmN0aW9uIChudW0pXG57XG4gICAgdGhpcy5fYnVmVmVydGV4QXR0cmliLm51bUl0ZW1zID0gbnVtO1xufTtcblxuTWVzaC5wcm90b3R5cGUuZ2V0TnVtVmVydGljZXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9idWZWZXJ0ZXhBdHRyaWIubnVtSXRlbXM7XG59O1xuXG5cbi8qKlxuICogQGZ1bmN0aW9uIHJlbmRlclxuICogQG1lbWJlcm9mIE1lc2hcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIGRyYXcgbWVzaCB0byBzY3JlZW5cbiAqIEBwYXJhbSB7U2hhZGVyfSBzaGFkZXJcbiAqL1xuTWVzaC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNoYWRlcilcbntcbiAgICAvLyBUT0RPOiBlbmFibGUvZGlzYWJsZXZlcnRleCBvbmx5IGlmIHRoZSBtZXNoIGhhcyBjaGFuZ2VkLi4uIHRoaW5rIGRyYXdpbmcgMTAwMDB4IHRoZSBzYW1lIG1lc2hcblxuICAgIGlmICghc2hhZGVyIHx8ICFzaGFkZXIuaXNWYWxpZCgpIHx8IHRoaXMuX2NnbC5hYm9ydGVkKSByZXR1cm47XG5cbiAgICB0aGlzLl9jaGVja0F0dHJMZW5ndGhzKCk7XG5cbiAgICBpZiAodGhpcy5fZ2VvbSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9wcmVXaXJlZnJhbWVHZW9tICYmICFzaGFkZXIud2lyZWZyYW1lICYmICF0aGlzLl9nZW9tLmlzSW5kZXhlZCgpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNldEdlb20odGhpcy5fcHJlV2lyZWZyYW1lR2VvbSk7XG4gICAgICAgICAgICB0aGlzLl9wcmVXaXJlZnJhbWVHZW9tID0gbnVsbDtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicmVtb3ZlIHByZXdpcmVmcmFtZSBnZW9tXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYWRlci53aXJlZnJhbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9nZW9tLmlzSW5kZXhlZCgpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcHJlV2lyZWZyYW1lR2VvbSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZVdpcmVmcmFtZUdlb20gPSB0aGlzLl9nZW9tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZW9tID0gdGhpcy5fZ2VvbS5jb3B5KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VvbS51bkluZGV4KCk7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fZ2VvbS5nZXRBdHRyaWJ1dGUoXCJhdHRyQmFyeWNlbnRyaWNcIikpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9wcmVXaXJlZnJhbWVHZW9tKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlV2lyZWZyYW1lR2VvbSA9IHRoaXMuX2dlb207XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dlb20gPSB0aGlzLl9nZW9tLmNvcHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9nZW9tLmNhbGNCYXJ5Y2VudHJpYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHRoaXMuc2V0R2VvbSh0aGlzLl9nZW9tKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiAoc2hhZGVyLndpcmVmcmFtZSlcbiAgICAgICAgLy8gY29uc29sZS5sb2coc2hhZGVyLndpcmVmcmFtZSwgdGhpcy5fZ2VvbS5pc0luZGV4ZWQoKSk7XG4gICAgfVxuXG4gICAgbGV0IG5lZWRzQmluZCA9IGZhbHNlO1xuICAgIGlmIChNRVNILmxhc3RNZXNoICE9IHRoaXMpXG4gICAge1xuICAgICAgICBpZiAoTUVTSC5sYXN0TWVzaCkgTUVTSC5sYXN0TWVzaC51bkJpbmQoKTtcbiAgICAgICAgbmVlZHNCaW5kID0gdHJ1ZTtcbiAgICB9XG5cblxuICAgIC8vIHZhciBuZWVkc0JpbmQ9ZmFsc2U7XG4gICAgLy8ge1xuICAgIC8vICAgICBuZWVkc0JpbmQ9dHJ1ZTtcbiAgICAvLyB9XG4gICAgaWYgKG5lZWRzQmluZCkgdGhpcy5fcHJlQmluZChzaGFkZXIpO1xuXG4gICAgaWYgKCFzaGFkZXIuYmluZCgpKSByZXR1cm47XG5cbiAgICAvLyBpZihuZWVkc0JpbmQpXG4gICAgdGhpcy5fYmluZChzaGFkZXIpO1xuICAgIGlmICh0aGlzLmFkZFZlcnRleE51bWJlcnMpIHRoaXMuX3NldFZlcnRleE51bWJlcnMoKTtcblxuICAgIE1FU0gubGFzdE1lc2ggPSB0aGlzO1xuXG4gICAgbGV0IHByaW0gPSB0aGlzLl9jZ2wuZ2wuVFJJQU5HTEVTO1xuICAgIGlmICh0aGlzLl9nbFByaW1pdGl2ZSAhPT0gdW5kZWZpbmVkKSBwcmltID0gdGhpcy5fZ2xQcmltaXRpdmU7XG4gICAgaWYgKHNoYWRlci5nbFByaW1pdGl2ZSAhPT0gbnVsbCkgcHJpbSA9IHNoYWRlci5nbFByaW1pdGl2ZTtcblxuICAgIGxldCBlbGVtZW50RGl2ID0gMTtcbiAgICBsZXQgZG9RdWVyeSA9IHRoaXMuX2NnbC5wcm9maWxlRGF0YS5kb1Byb2ZpbGVHbFF1ZXJ5O1xuICAgIGxldCBxdWVyeVN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBpZiAoZG9RdWVyeSlcbiAgICB7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuX25hbWUgKyBcIiAtIFwiICsgc2hhZGVyLmdldE5hbWUoKSArIFwiICNcIiArIHNoYWRlci5pZDtcbiAgICAgICAgaWYgKHRoaXMuX251bUluc3RhbmNlcykgaWQgKz0gXCIgaW5zdGFuY2VkIFwiICsgdGhpcy5fbnVtSW5zdGFuY2VzICsgXCJ4XCI7XG5cbiAgICAgICAgbGV0IHF1ZXJ5UHJvZmlsZXJEYXRhID0gdGhpcy5fY2dsLnByb2ZpbGVEYXRhLmdsUXVlcnlEYXRhW2lkXTtcblxuICAgICAgICBpZiAoIXF1ZXJ5UHJvZmlsZXJEYXRhKSBxdWVyeVByb2ZpbGVyRGF0YSA9IHsgXCJpZFwiOiBpZCwgXCJudW1cIjogMCB9O1xuXG4gICAgICAgIGlmIChzaGFkZXIub3BJZClxdWVyeVByb2ZpbGVyRGF0YS5zaGFkZXJPcCA9IHNoYWRlci5vcElkO1xuICAgICAgICBpZiAodGhpcy5vcElkKXF1ZXJ5UHJvZmlsZXJEYXRhLm1lc2hPcCA9IHRoaXMub3BJZDtcblxuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEuZ2xRdWVyeURhdGFbaWRdID0gcXVlcnlQcm9maWxlckRhdGE7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9xdWVyeUV4dCAmJiB0aGlzLl9xdWVyeUV4dCAhPT0gZmFsc2UpIHRoaXMuX3F1ZXJ5RXh0ID0gdGhpcy5fY2dsLmVuYWJsZUV4dGVuc2lvbihcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDJcIikgfHwgZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9xdWVyeUV4dClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5UHJvZmlsZXJEYXRhLl9kcmF3UXVlcnkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXZhaWxhYmxlID0gdGhpcy5fY2dsLmdsLmdldFF1ZXJ5UGFyYW1ldGVyKHF1ZXJ5UHJvZmlsZXJEYXRhLl9kcmF3UXVlcnksIHRoaXMuX2NnbC5nbC5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFKTtcbiAgICAgICAgICAgICAgICBpZiAoYXZhaWxhYmxlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxhcHNlZE5hbm9zID0gdGhpcy5fY2dsLmdsLmdldFF1ZXJ5UGFyYW1ldGVyKHF1ZXJ5UHJvZmlsZXJEYXRhLl9kcmF3UXVlcnksIHRoaXMuX2NnbC5nbC5RVUVSWV9SRVNVTFQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VGltZUdQVSA9IGVsYXBzZWROYW5vcyAvIDEwMDAwMDA7XG5cbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQcm9maWxlckRhdGEuX3RpbWVzID0gcXVlcnlQcm9maWxlckRhdGEuX3RpbWVzIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UHJvZmlsZXJEYXRhLl90aW1lcyArPSBjdXJyZW50VGltZUdQVTtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQcm9maWxlckRhdGEuX251bWNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UHJvZmlsZXJEYXRhLndoZW4gPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQcm9maWxlckRhdGEuX2RyYXdRdWVyeSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UHJvZmlsZXJEYXRhLnF1ZXJ5U3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFxdWVyeVByb2ZpbGVyRGF0YS5xdWVyeVN0YXJ0ZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcXVlcnlQcm9maWxlckRhdGEuX2RyYXdRdWVyeSA9IHRoaXMuX2NnbC5nbC5jcmVhdGVRdWVyeSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5iZWdpblF1ZXJ5KHRoaXMuX3F1ZXJ5RXh0LlRJTUVfRUxBUFNFRF9FWFQsIHF1ZXJ5UHJvZmlsZXJEYXRhLl9kcmF3UXVlcnkpO1xuICAgICAgICAgICAgICAgIHF1ZXJ5U3RhcnRlZCA9IHF1ZXJ5UHJvZmlsZXJEYXRhLnF1ZXJ5U3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGlmICh0aGlzLmhhc0ZlZWRiYWNrcygpKVxuICAgIHtcbiAgICAgICAgdGhpcy5kcmF3RmVlZGJhY2tzKHNoYWRlciwgcHJpbSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCF0aGlzLl9idWZWZXJ0aWNlc0luZGl6ZXMgfHwgdGhpcy5fYnVmVmVydGljZXNJbmRpemVzLm51bUl0ZW1zID09PSAwKVxuICAgIHtcbiAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgICBpZiAodGhpcy5fYXR0cmlidXRlc1tpXS5hcnJheUxlbmd0aCAvIHRoaXMuX2F0dHJpYnV0ZXNbaV0uaXRlbVNpemUgIT0gdGhpcy5fYnVmVmVydGV4QXR0cmliLmZsb2F0QXJyYXkubGVuZ3RoIC8gMylcbiAgICAgICAgLy8gICAgIHtcbiAgICAgICAgLy8gICAgICAgICB0aGlzLl9sb2cud2FybihcImF0dHJpYiBidWZmZXIgbGVuZ3RoIHdyb25nISBcIiwgdGhpcy5fYXR0cmlidXRlc1tpXS5uYW1lLCB0aGlzLl9hdHRyaWJ1dGVzW2ldLmFycmF5TGVuZ3RoIC8gdGhpcy5fYXR0cmlidXRlc1tpXS5pdGVtU2l6ZSwgdGhpcy5fYnVmVmVydGV4QXR0cmliLmZsb2F0QXJyYXkubGVuZ3RoIC8gMywgdGhpcy5fYXR0cmlidXRlc1tpXS5pdGVtU2l6ZSk7XG4gICAgICAgIC8vICAgICAgICAgLy8gdGhpcy5fbG9nLmxvZyh0aGlzKTtcbiAgICAgICAgLy8gICAgICAgICAvLyBkZWJ1Z2dlcjtcbiAgICAgICAgLy8gICAgICAgICByZXR1cm47XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cblxuXG4gICAgICAgIGlmIChwcmltID09IHRoaXMuX2NnbC5nbC5UUklBTkdMRVMpZWxlbWVudERpdiA9IDM7XG4gICAgICAgIGlmICh0aGlzLl9udW1JbnN0YW5jZXMgPT09IDApIHRoaXMuX2NnbC5nbC5kcmF3QXJyYXlzKHByaW0sIHRoaXMuX2J1ZlZlcnRleEF0dHJpYi5zdGFydEl0ZW0sIHRoaXMuX2J1ZlZlcnRleEF0dHJpYi5udW1JdGVtcyAtIHRoaXMuX2J1ZlZlcnRleEF0dHJpYi5zdGFydEl0ZW0pO1xuICAgICAgICBlbHNlIHRoaXMuX2NnbC5nbC5kcmF3QXJyYXlzSW5zdGFuY2VkKHByaW0sIHRoaXMuX2J1ZlZlcnRleEF0dHJpYi5zdGFydEl0ZW0sIHRoaXMuX2J1ZlZlcnRleEF0dHJpYi5udW1JdGVtcywgdGhpcy5fbnVtSW5zdGFuY2VzKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgaWYgKHByaW0gPT0gdGhpcy5fY2dsLmdsLlRSSUFOR0xFUyllbGVtZW50RGl2ID0gMztcbiAgICAgICAgaWYgKHRoaXMuX251bUluc3RhbmNlcyA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJsYVwiLCB0aGlzLl9idWZWZXJ0aWNlc0luZGl6ZXMubnVtSXRlbXMpO1xuXG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuZHJhd0VsZW1lbnRzKHByaW0sIHRoaXMuX2J1ZlZlcnRpY2VzSW5kaXplcy5udW1JdGVtcywgdGhpcy5faW5kZXhUeXBlLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5kcmF3RWxlbWVudHNJbnN0YW5jZWQocHJpbSwgdGhpcy5fYnVmVmVydGljZXNJbmRpemVzLm51bUl0ZW1zLCB0aGlzLl9pbmRleFR5cGUsIDAsIHRoaXMuX251bUluc3RhbmNlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY2dsLmRlYnVnT25lRnJhbWUgJiYgdGhpcy5fY2dsLmdsLmdldEVycm9yKCkgIT0gdGhpcy5fY2dsLmdsLk5PX0VSUk9SKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwibWVzaCBkcmF3IGdsIGVycm9yXCIpO1xuICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJtZXNoXCIsIHRoaXMpO1xuICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJzaGFkZXJcIiwgc2hhZGVyKTtcblxuICAgICAgICBjb25zdCBhdHRyaWJOYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2NnbC5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHNoYWRlci5nZXRQcm9ncmFtKCksIHRoaXMuX2NnbC5nbC5BQ1RJVkVfQVRUUklCVVRFUyk7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX2NnbC5nbC5nZXRBY3RpdmVBdHRyaWIoc2hhZGVyLmdldFByb2dyYW0oKSwgaSkubmFtZTtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihcImF0dHJpYiBcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZU1lc2hOdW1FbGVtZW50cyArPSAodGhpcy5fYnVmVmVydGV4QXR0cmliLm51bUl0ZW1zIC8gZWxlbWVudERpdikgKiAodGhpcy5fbnVtSW5zdGFuY2VzIHx8IDEpO1xuICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlTWVzaERyYXcrKztcblxuICAgIGlmIChkb1F1ZXJ5ICYmIHF1ZXJ5U3RhcnRlZClcbiAgICB7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5lbmRRdWVyeSh0aGlzLl9xdWVyeUV4dC5USU1FX0VMQVBTRURfRVhUKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jZ2wucHJpbnRFcnJvcihcIm1lc2ggcmVuZGVyIFwiICsgdGhpcy5fbmFtZSk7XG5cbiAgICB0aGlzLnVuQmluZCgpO1xufTtcblxuTWVzaC5wcm90b3R5cGUuc2V0TnVtSW5zdGFuY2VzID0gZnVuY3Rpb24gKG4pXG57XG4gICAgbiA9IE1hdGgubWF4KDAsIG4pO1xuICAgIGlmICh0aGlzLl9udW1JbnN0YW5jZXMgIT0gbilcbiAgICB7XG4gICAgICAgIHRoaXMuX251bUluc3RhbmNlcyA9IG47XG4gICAgICAgIGNvbnN0IGluZGV4QXJyID0gbmV3IEZsb2F0MzJBcnJheShuKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIGluZGV4QXJyW2ldID0gaTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfSU5TVEFOQ0VfSU5ERVgsIGluZGV4QXJyLCAxLCB7IFwiaW5zdGFuY2VkXCI6IHRydWUgfSk7XG4gICAgfVxufTtcblxuTWVzaC5wcm90b3R5cGUuX2Rpc3Bvc2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoIXRoaXMuX2F0dHJpYnV0ZXMpIHJldHVybjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzW2ldLmJ1ZmZlcilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLl9hdHRyaWJ1dGVzW2ldLmJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzW2ldLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGggPSAwO1xufTtcblxuTWVzaC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX2J1ZlZlcnRleEF0dHJpYiAmJiB0aGlzLl9idWZWZXJ0ZXhBdHRyaWIuYnVmZmVyKSB0aGlzLl9jZ2wuZ2wuZGVsZXRlQnVmZmVyKHRoaXMuX2J1ZlZlcnRleEF0dHJpYi5idWZmZXIpO1xuICAgIGlmICh0aGlzLl9idWZWZXJ0aWNlc0luZGl6ZXMpIHRoaXMuX2NnbC5nbC5kZWxldGVCdWZmZXIodGhpcy5fYnVmVmVydGljZXNJbmRpemVzKTtcbiAgICB0aGlzLl9idWZWZXJ0aWNlc0luZGl6ZXMgPSBudWxsO1xuXG4gICAgdGhpcy5fZGlzcG9zZUF0dHJpYnV0ZXMoKTtcbn07XG5cbmV4dGVuZE1lc2hXaXRoRmVlZGJhY2soTWVzaCk7XG5cbmV4cG9ydCB7IE1lc2gsIE1FU0ggfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_mesh.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_mesh_feedback.js":
/*!*******************************************!*\
  !*** ./src/core/cgl/cgl_mesh_feedback.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"extendMeshWithFeedback\": () => (/* binding */ extendMeshWithFeedback)\n/* harmony export */ });\n// view-source:http://toji.github.io/webgl2-particles-2/\n\nfunction extendMeshWithFeedback(Mesh)\n{\n    Mesh.prototype.hasFeedbacks = function ()\n    {\n        return this._feedBacks.length > 0;\n    };\n\n    Mesh.prototype.removeFeedbacks = function (shader)\n    {\n        if (!this._feedbacks) return;\n        this._feedbacks.length = 0;\n        this._feedBacksChanged = true;\n    };\n\n    Mesh.prototype.setAttributeFeedback = function () {};\n\n    Mesh.prototype.setFeedback = function (attrib, nameOut, initialArr)\n    {\n        let fb = { nameOut, };\n        let found = false;\n        this.unBindFeedbacks();\n\n        for (let i = 0; i < this._feedBacks.length; i++)\n        {\n            if (this._feedBacks[i].nameOut == nameOut)\n            {\n                fb = this._feedBacks[i];\n\n                found = true;\n            }\n        }\n\n        if (!found) this._feedBacksChanged = true;\n\n        fb.initialArr = initialArr;\n        fb.attrib = attrib;\n\n        // console.log(\"setfeedback\");\n\n        if (fb.outBuffer) this._cgl.gl.deleteBuffer(fb.outBuffer);\n        // if(fb.attrib.buffer)this._cgl.gl.deleteBuffer(fb.attrib.buffer);\n        fb.outBuffer = this._cgl.gl.createBuffer();\n        this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, fb.outBuffer);\n        this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, fb.initialArr, this._cgl.gl.STATIC_DRAW);\n\n        this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, fb.attrib.buffer);\n        this._cgl.gl.bufferData(this._cgl.gl.ARRAY_BUFFER, fb.initialArr, this._cgl.gl.STATIC_DRAW);\n\n        if (!found) this._feedBacks.push(fb);\n\n        // console.log('initialArr',initialArr.length/3);\n        // console.log('vertices',fb.attrib.numItems);\n        // console.log('vertices',this._bufVertexAttrib.numItems);\n\n        return fb;\n    };\n\n    Mesh.prototype.bindFeedback = function (attrib)\n    {\n        if (!this._feedBacks || this._feedBacks.length === 0) return;\n        if (this._transformFeedBackLoc == -1) this._transformFeedBackLoc = this._cgl.gl.createTransformFeedback();\n\n        this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, this._transformFeedBackLoc);\n\n        let found = false;\n\n        for (let i = 0; i < this._feedBacks.length; i++)\n        {\n            const fb = this._feedBacks[i];\n\n            if (fb.attrib == attrib)\n            {\n                found = true;\n                // this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, fb.attrib.buffer);\n                //\n                // this._cgl.gl.vertexAttribPointer(\n                //     fb.attrib.loc,\n                //     fb.attrib.itemSize,\n                //     fb.attrib.type,\n                //     false,\n                //     fb.attrib.itemSize*4, 0);\n\n                this._cgl.gl.bindBufferBase(this._cgl.gl.TRANSFORM_FEEDBACK_BUFFER, i, fb.outBuffer);\n            }\n        }\n\n        if (!found)\n        {\n            // console.log(\"ARTTRIB NOT FOUND\",attrib.name);\n        }\n    };\n\n    Mesh.prototype.drawFeedbacks = function (shader, prim)\n    {\n        let i = 0;\n\n        if (this._feedBacksChanged)\n        {\n            const names = [];\n            this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, this._transformFeedBackLoc);\n\n            for (i = 0; i < this._feedBacks.length; i++) names.push(this._feedBacks[i].nameOut);\n            shader.setFeedbackNames(names);\n\n            console.log(\"feedbacknames\", names);\n\n            shader.compile();\n            this._feedBacksChanged = false;\n            this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, null);\n            console.log(\"changed finished\");\n            return;\n        }\n\n        //\n        // for( i=0;i<this._feedBacks.length;i++)\n        // {\n        //     var fb=this._feedBacks[i];\n        //\n        //     this._cgl.gl.bindBufferBase(this._cgl.gl.TRANSFORM_FEEDBACK_BUFFER, i, fb.outBuffer);\n        // }\n\n        // draw\n        this._cgl.gl.beginTransformFeedback(this.glPrimitive);\n        this._cgl.gl.drawArrays(prim, 0, this._feedBacks[0].attrib.numItems);\n\n        // unbind\n        this._cgl.gl.endTransformFeedback();\n\n        this.unBindFeedbacks();\n\n        this.feedBacksSwapBuffers();\n    };\n\n    Mesh.prototype.unBindFeedbacks = function ()\n    {\n        for (let i = 0; i < this._feedBacks.length; i++)\n        {\n            // this._cgl.gl.disableVertexAttribArray(this._feedBacks[i].attrib.loc);\n            this._cgl.gl.bindBufferBase(this._cgl.gl.TRANSFORM_FEEDBACK_BUFFER, i, null);\n        }\n\n        this._cgl.gl.bindTransformFeedback(this._cgl.gl.TRANSFORM_FEEDBACK, null);\n    };\n\n    Mesh.prototype.feedBacksSwapBuffers = function ()\n    {\n        for (let i = 0; i < this._feedBacks.length; i++)\n        {\n            const t = this._feedBacks[i].attrib.buffer;\n            this._feedBacks[i].attrib.buffer = this._feedBacks[i].outBuffer;\n            this._feedBacks[i].outBuffer = t;\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX21lc2hfZmVlZGJhY2suanMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dsL2NnbF9tZXNoX2ZlZWRiYWNrLmpzP2ZmNWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdmlldy1zb3VyY2U6aHR0cDovL3RvamkuZ2l0aHViLmlvL3dlYmdsMi1wYXJ0aWNsZXMtMi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZE1lc2hXaXRoRmVlZGJhY2soTWVzaClcbntcbiAgICBNZXNoLnByb3RvdHlwZS5oYXNGZWVkYmFja3MgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZlZWRCYWNrcy5sZW5ndGggPiAwO1xuICAgIH07XG5cbiAgICBNZXNoLnByb3RvdHlwZS5yZW1vdmVGZWVkYmFja3MgPSBmdW5jdGlvbiAoc2hhZGVyKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mZWVkYmFja3MpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZmVlZGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2ZlZWRCYWNrc0NoYW5nZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICBNZXNoLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVGZWVkYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgTWVzaC5wcm90b3R5cGUuc2V0RmVlZGJhY2sgPSBmdW5jdGlvbiAoYXR0cmliLCBuYW1lT3V0LCBpbml0aWFsQXJyKVxuICAgIHtcbiAgICAgICAgbGV0IGZiID0geyBuYW1lT3V0LCB9O1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51bkJpbmRGZWVkYmFja3MoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2ZlZWRCYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZlZWRCYWNrc1tpXS5uYW1lT3V0ID09IG5hbWVPdXQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZmIgPSB0aGlzLl9mZWVkQmFja3NbaV07XG5cbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZvdW5kKSB0aGlzLl9mZWVkQmFja3NDaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgICBmYi5pbml0aWFsQXJyID0gaW5pdGlhbEFycjtcbiAgICAgICAgZmIuYXR0cmliID0gYXR0cmliO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwic2V0ZmVlZGJhY2tcIik7XG5cbiAgICAgICAgaWYgKGZiLm91dEJ1ZmZlcikgdGhpcy5fY2dsLmdsLmRlbGV0ZUJ1ZmZlcihmYi5vdXRCdWZmZXIpO1xuICAgICAgICAvLyBpZihmYi5hdHRyaWIuYnVmZmVyKXRoaXMuX2NnbC5nbC5kZWxldGVCdWZmZXIoZmIuYXR0cmliLmJ1ZmZlcik7XG4gICAgICAgIGZiLm91dEJ1ZmZlciA9IHRoaXMuX2NnbC5nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRCdWZmZXIodGhpcy5fY2dsLmdsLkFSUkFZX0JVRkZFUiwgZmIub3V0QnVmZmVyKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmJ1ZmZlckRhdGEodGhpcy5fY2dsLmdsLkFSUkFZX0JVRkZFUiwgZmIuaW5pdGlhbEFyciwgdGhpcy5fY2dsLmdsLlNUQVRJQ19EUkFXKTtcblxuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEJ1ZmZlcih0aGlzLl9jZ2wuZ2wuQVJSQVlfQlVGRkVSLCBmYi5hdHRyaWIuYnVmZmVyKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmJ1ZmZlckRhdGEodGhpcy5fY2dsLmdsLkFSUkFZX0JVRkZFUiwgZmIuaW5pdGlhbEFyciwgdGhpcy5fY2dsLmdsLlNUQVRJQ19EUkFXKTtcblxuICAgICAgICBpZiAoIWZvdW5kKSB0aGlzLl9mZWVkQmFja3MucHVzaChmYik7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2luaXRpYWxBcnInLGluaXRpYWxBcnIubGVuZ3RoLzMpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygndmVydGljZXMnLGZiLmF0dHJpYi5udW1JdGVtcyk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd2ZXJ0aWNlcycsdGhpcy5fYnVmVmVydGV4QXR0cmliLm51bUl0ZW1zKTtcblxuICAgICAgICByZXR1cm4gZmI7XG4gICAgfTtcblxuICAgIE1lc2gucHJvdG90eXBlLmJpbmRGZWVkYmFjayA9IGZ1bmN0aW9uIChhdHRyaWIpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2ZlZWRCYWNrcyB8fCB0aGlzLl9mZWVkQmFja3MubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLl90cmFuc2Zvcm1GZWVkQmFja0xvYyA9PSAtMSkgdGhpcy5fdHJhbnNmb3JtRmVlZEJhY2tMb2MgPSB0aGlzLl9jZ2wuZ2wuY3JlYXRlVHJhbnNmb3JtRmVlZGJhY2soKTtcblxuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKHRoaXMuX2NnbC5nbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIHRoaXMuX3RyYW5zZm9ybUZlZWRCYWNrTG9jKTtcblxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2ZlZWRCYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZmIgPSB0aGlzLl9mZWVkQmFja3NbaV07XG5cbiAgICAgICAgICAgIGlmIChmYi5hdHRyaWIgPT0gYXR0cmliKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9jZ2wuZ2wuYmluZEJ1ZmZlcih0aGlzLl9jZ2wuZ2wuQVJSQVlfQlVGRkVSLCBmYi5hdHRyaWIuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2NnbC5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgICAgICAgIC8vICAgICBmYi5hdHRyaWIubG9jLFxuICAgICAgICAgICAgICAgIC8vICAgICBmYi5hdHRyaWIuaXRlbVNpemUsXG4gICAgICAgICAgICAgICAgLy8gICAgIGZiLmF0dHJpYi50eXBlLFxuICAgICAgICAgICAgICAgIC8vICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAvLyAgICAgZmIuYXR0cmliLml0ZW1TaXplKjQsIDApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRCdWZmZXJCYXNlKHRoaXMuX2NnbC5nbC5UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSLCBpLCBmYi5vdXRCdWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJBUlRUUklCIE5PVCBGT1VORFwiLGF0dHJpYi5uYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBNZXNoLnByb3RvdHlwZS5kcmF3RmVlZGJhY2tzID0gZnVuY3Rpb24gKHNoYWRlciwgcHJpbSlcbiAgICB7XG4gICAgICAgIGxldCBpID0gMDtcblxuICAgICAgICBpZiAodGhpcy5fZmVlZEJhY2tzQ2hhbmdlZClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2sodGhpcy5fY2dsLmdsLlRSQU5TRk9STV9GRUVEQkFDSywgdGhpcy5fdHJhbnNmb3JtRmVlZEJhY2tMb2MpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fZmVlZEJhY2tzLmxlbmd0aDsgaSsrKSBuYW1lcy5wdXNoKHRoaXMuX2ZlZWRCYWNrc1tpXS5uYW1lT3V0KTtcbiAgICAgICAgICAgIHNoYWRlci5zZXRGZWVkYmFja05hbWVzKG5hbWVzKTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJmZWVkYmFja25hbWVzXCIsIG5hbWVzKTtcblxuICAgICAgICAgICAgc2hhZGVyLmNvbXBpbGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2ZlZWRCYWNrc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2sodGhpcy5fY2dsLmdsLlRSQU5TRk9STV9GRUVEQkFDSywgbnVsbCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNoYW5nZWQgZmluaXNoZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL1xuICAgICAgICAvLyBmb3IoIGk9MDtpPHRoaXMuX2ZlZWRCYWNrcy5sZW5ndGg7aSsrKVxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgICB2YXIgZmI9dGhpcy5fZmVlZEJhY2tzW2ldO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgdGhpcy5fY2dsLmdsLmJpbmRCdWZmZXJCYXNlKHRoaXMuX2NnbC5nbC5UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSLCBpLCBmYi5vdXRCdWZmZXIpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gZHJhd1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmVnaW5UcmFuc2Zvcm1GZWVkYmFjayh0aGlzLmdsUHJpbWl0aXZlKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmRyYXdBcnJheXMocHJpbSwgMCwgdGhpcy5fZmVlZEJhY2tzWzBdLmF0dHJpYi5udW1JdGVtcyk7XG5cbiAgICAgICAgLy8gdW5iaW5kXG4gICAgICAgIHRoaXMuX2NnbC5nbC5lbmRUcmFuc2Zvcm1GZWVkYmFjaygpO1xuXG4gICAgICAgIHRoaXMudW5CaW5kRmVlZGJhY2tzKCk7XG5cbiAgICAgICAgdGhpcy5mZWVkQmFja3NTd2FwQnVmZmVycygpO1xuICAgIH07XG5cbiAgICBNZXNoLnByb3RvdHlwZS51bkJpbmRGZWVkYmFja3MgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9mZWVkQmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHRoaXMuX2NnbC5nbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fZmVlZEJhY2tzW2ldLmF0dHJpYi5sb2MpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRCdWZmZXJCYXNlKHRoaXMuX2NnbC5nbC5UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSLCBpLCBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2sodGhpcy5fY2dsLmdsLlRSQU5TRk9STV9GRUVEQkFDSywgbnVsbCk7XG4gICAgfTtcblxuICAgIE1lc2gucHJvdG90eXBlLmZlZWRCYWNrc1N3YXBCdWZmZXJzID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZmVlZEJhY2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCB0ID0gdGhpcy5fZmVlZEJhY2tzW2ldLmF0dHJpYi5idWZmZXI7XG4gICAgICAgICAgICB0aGlzLl9mZWVkQmFja3NbaV0uYXR0cmliLmJ1ZmZlciA9IHRoaXMuX2ZlZWRCYWNrc1tpXS5vdXRCdWZmZXI7XG4gICAgICAgICAgICB0aGlzLl9mZWVkQmFja3NbaV0ub3V0QnVmZmVyID0gdDtcbiAgICAgICAgfVxuICAgIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_mesh_feedback.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_profiledata.js":
/*!*****************************************!*\
  !*** ./src/core/cgl/cgl_profiledata.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ProfileData\": () => (/* binding */ ProfileData)\n/* harmony export */ });\nclass ProfileData\n{\n    constructor(cgl)\n    {\n        this._cgl = cgl;\n        this._lastTime = 0;\n        this.pause = false;\n        this.profileUniformCount = 0;\n        this.profileShaderBinds = 0;\n        this.profileUniformCount = 0;\n        this.profileShaderCompiles = 0;\n        this.profileVideosPlaying = 0;\n        this.profileMVPMatrixCount = 0;\n        this.profileEffectBuffercreate = 0;\n        this.profileShaderGetUniform = 0;\n        this.profileFrameBuffercreate = 0;\n        this.profileMeshSetGeom = 0;\n        this.profileTextureNew = 0;\n        this.profileGenMipMap = 0;\n        this.profileOnAnimFrameOps = 0;\n\n        this.profileFencedPixelRead = 0;\n        this.profileMainloopMs = 0;\n        this.profileMeshDraw = 0;\n        this.profileTextureEffect = 0;\n        this.profileTexPreviews = 0;\n        this.shaderCompileTime = 0;\n        this.profileMeshNumElements = 0;\n        this.profileMeshAttributes = 0;\n        this.profileSingleMeshAttribute = [];\n        this.heavyEvents = [];\n\n        this.doProfileGlQuery = false;\n        this.glQueryData = {};\n    }\n\n    clear()\n    {\n        this.profileSingleMeshAttribute = {};\n        this.profileMeshAttributes = 0;\n        this.profileUniformCount = 0;\n        this.profileShaderGetUniform = 0;\n        this.profileShaderCompiles = 0;\n        this.profileShaderBinds = 0;\n        this.profileTextureResize = 0;\n        this.profileFrameBuffercreate = 0;\n        this.profileEffectBuffercreate = 0;\n        this.profileTextureDelete = 0;\n        this.profileMeshSetGeom = 0;\n        this.profileVideosPlaying = 0;\n        this.profileMVPMatrixCount = 0;\n        this.profileNonTypedAttrib = 0;\n        this.profileNonTypedAttribNames = \"\";\n        this.profileTextureNew = 0;\n        this.profileGenMipMap = 0;\n        this.profileFramebuffer = 0;\n        this.profileMeshDraw = 0;\n        this.profileTextureEffect = 0;\n        this.profileTexPreviews = 0;\n        this.profileMeshNumElements = 0;\n        this.profileFencedPixelRead = 0;\n    }\n\n    clearGlQuery()\n    {\n        for (let i in this.glQueryData)\n        {\n            if (!this.glQueryData[i].lastClear || performance.now() - this.glQueryData[i].lastClear > 1000)\n            {\n                this.glQueryData[i].time = this.glQueryData[i]._times / this.glQueryData[i]._numcount;\n                this.glQueryData[i].num = this.glQueryData[i]._numcount;\n\n                this.glQueryData[i]._times = 0;\n                this.glQueryData[i]._numcount = 0;\n                this.glQueryData[i].lastClear = performance.now();\n            }\n        }\n    }\n\n    addHeavyEvent(event, name, info)\n    {\n        const e = { \"event\": event, \"name\": name, \"info\": info, \"date\": performance.now() };\n        this.heavyEvents.push(e);\n        this._cgl.emitEvent(\"heavyEvent\", e);\n    }\n}\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3Byb2ZpbGVkYXRhLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZ2wvY2dsX3Byb2ZpbGVkYXRhLmpzP2FmMzQiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgUHJvZmlsZURhdGFcbntcbiAgICBjb25zdHJ1Y3RvcihjZ2wpXG4gICAge1xuICAgICAgICB0aGlzLl9jZ2wgPSBjZ2w7XG4gICAgICAgIHRoaXMuX2xhc3RUaW1lID0gMDtcbiAgICAgICAgdGhpcy5wYXVzZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb2ZpbGVVbmlmb3JtQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVTaGFkZXJCaW5kcyA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZVVuaWZvcm1Db3VudCA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZVNoYWRlckNvbXBpbGVzID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlVmlkZW9zUGxheWluZyA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZU1WUE1hdHJpeENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlRWZmZWN0QnVmZmVyY3JlYXRlID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlU2hhZGVyR2V0VW5pZm9ybSA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZUZyYW1lQnVmZmVyY3JlYXRlID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlTWVzaFNldEdlb20gPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVUZXh0dXJlTmV3ID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlR2VuTWlwTWFwID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlT25BbmltRnJhbWVPcHMgPSAwO1xuXG4gICAgICAgIHRoaXMucHJvZmlsZUZlbmNlZFBpeGVsUmVhZCA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZU1haW5sb29wTXMgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVNZXNoRHJhdyA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZVRleHR1cmVFZmZlY3QgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVUZXhQcmV2aWV3cyA9IDA7XG4gICAgICAgIHRoaXMuc2hhZGVyQ29tcGlsZVRpbWUgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVNZXNoTnVtRWxlbWVudHMgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVNZXNoQXR0cmlidXRlcyA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZVNpbmdsZU1lc2hBdHRyaWJ1dGUgPSBbXTtcbiAgICAgICAgdGhpcy5oZWF2eUV2ZW50cyA9IFtdO1xuXG4gICAgICAgIHRoaXMuZG9Qcm9maWxlR2xRdWVyeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmdsUXVlcnlEYXRhID0ge307XG4gICAgfVxuXG4gICAgY2xlYXIoKVxuICAgIHtcbiAgICAgICAgdGhpcy5wcm9maWxlU2luZ2xlTWVzaEF0dHJpYnV0ZSA9IHt9O1xuICAgICAgICB0aGlzLnByb2ZpbGVNZXNoQXR0cmlidXRlcyA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZVVuaWZvcm1Db3VudCA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZVNoYWRlckdldFVuaWZvcm0gPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVTaGFkZXJDb21waWxlcyA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZVNoYWRlckJpbmRzID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlVGV4dHVyZVJlc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZUZyYW1lQnVmZmVyY3JlYXRlID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlRWZmZWN0QnVmZmVyY3JlYXRlID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlVGV4dHVyZURlbGV0ZSA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZU1lc2hTZXRHZW9tID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlVmlkZW9zUGxheWluZyA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZU1WUE1hdHJpeENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlTm9uVHlwZWRBdHRyaWIgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVOb25UeXBlZEF0dHJpYk5hbWVzID0gXCJcIjtcbiAgICAgICAgdGhpcy5wcm9maWxlVGV4dHVyZU5ldyA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZUdlbk1pcE1hcCA9IDA7XG4gICAgICAgIHRoaXMucHJvZmlsZUZyYW1lYnVmZmVyID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlTWVzaERyYXcgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVUZXh0dXJlRWZmZWN0ID0gMDtcbiAgICAgICAgdGhpcy5wcm9maWxlVGV4UHJldmlld3MgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVNZXNoTnVtRWxlbWVudHMgPSAwO1xuICAgICAgICB0aGlzLnByb2ZpbGVGZW5jZWRQaXhlbFJlYWQgPSAwO1xuICAgIH1cblxuICAgIGNsZWFyR2xRdWVyeSgpXG4gICAge1xuICAgICAgICBmb3IgKGxldCBpIGluIHRoaXMuZ2xRdWVyeURhdGEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5nbFF1ZXJ5RGF0YVtpXS5sYXN0Q2xlYXIgfHwgcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLmdsUXVlcnlEYXRhW2ldLmxhc3RDbGVhciA+IDEwMDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5nbFF1ZXJ5RGF0YVtpXS50aW1lID0gdGhpcy5nbFF1ZXJ5RGF0YVtpXS5fdGltZXMgLyB0aGlzLmdsUXVlcnlEYXRhW2ldLl9udW1jb3VudDtcbiAgICAgICAgICAgICAgICB0aGlzLmdsUXVlcnlEYXRhW2ldLm51bSA9IHRoaXMuZ2xRdWVyeURhdGFbaV0uX251bWNvdW50O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5nbFF1ZXJ5RGF0YVtpXS5fdGltZXMgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2xRdWVyeURhdGFbaV0uX251bWNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmdsUXVlcnlEYXRhW2ldLmxhc3RDbGVhciA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkSGVhdnlFdmVudChldmVudCwgbmFtZSwgaW5mbylcbiAgICB7XG4gICAgICAgIGNvbnN0IGUgPSB7IFwiZXZlbnRcIjogZXZlbnQsIFwibmFtZVwiOiBuYW1lLCBcImluZm9cIjogaW5mbywgXCJkYXRlXCI6IHBlcmZvcm1hbmNlLm5vdygpIH07XG4gICAgICAgIHRoaXMuaGVhdnlFdmVudHMucHVzaChlKTtcbiAgICAgICAgdGhpcy5fY2dsLmVtaXRFdmVudChcImhlYXZ5RXZlbnRcIiwgZSk7XG4gICAgfVxufVxuXG5cbmV4cG9ydCB7IFByb2ZpbGVEYXRhIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_profiledata.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_shader.js":
/*!************************************!*\
  !*** ./src/core/cgl/cgl_shader.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Shader\": () => (/* binding */ Shader)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n/* harmony import */ var _cgl_shader_lib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgl_shader_lib.js */ \"./src/core/cgl/cgl_shader_lib.js\");\n/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../timer.js */ \"./src/core/timer.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"./src/core/utils.js\");\n/* harmony import */ var _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cgl_mesh.js */ \"./src/core/cgl/cgl_mesh.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants.js */ \"./src/core/cgl/constants.js\");\n/* harmony import */ var _cgl_utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cgl_utils.js */ \"./src/core/cgl/cgl_utils.js\");\n/* harmony import */ var _cgl_shader_default_glsl_vert__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cgl_shader_default_glsl.vert */ \"./src/core/cgl/cgl_shader_default_glsl.vert\");\n\n\n\n\n\n// import { CGL } from \"./index.js\";\n\n\n\n// ---------------------------------------------------------------------------\n\n\n/*\n\nproposal default shader variable names:\n\nattrVertex - currently: vPosition\nattrVertexIndex - currently: attrVertIndex\nattrTexCoord\nattrInstMat - currently: instMat\nattrVertColor\nattrTangent\nattrBiTangent\n\nuProjMatrix - currently: projMatrix\nuModelMatrix - currently: modelMatrix\nuNormalMatrix - currently: normalMatrix\nuCamPosition - currently: camPos\n\n*/\n\n\n// ---------------------------------------------------------------------------\n\nlet materialIdCounter = 0;\n\n/**\n * @class\n * @external CGL\n * @namespace Shader\n * @hideconstructor\n * @example\n * var shader=new CGL.Shader(cgl,'MinimalMaterial');\n * shader.setSource(attachments.shader_vert,attachments.shader_frag);\n */\nconst Shader = function (_cgl, _name, _op)\n{\n    if (!_cgl) throw new Error(\"shader constructed without cgl \" + _name);\n\n    this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"cgl_shader\");\n    this._cgl = _cgl;\n\n    if (!_name) this._log.stack(\"no shader name given\");\n    this._name = _name || \"unknown\";\n\n    if (_op) this.opId = _op.id;\n    this.glslVersion = 0;\n    if (_cgl.glVersion > 1) this.glslVersion = 300;\n\n    this._materialId = ++materialIdCounter;\n\n    this.id = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.simpleId)();\n    this._isValid = true;\n    this._program = null;\n    this._uniforms = [];\n    this._drawBuffers = [true];\n    this._defines = [];\n    this._needsRecompile = true;\n    this._compileReason = \"initial\";\n\n    this.ignoreMissingUniforms = false;\n    this._projMatrixUniform = null;\n    this._mvMatrixUniform = null;\n    this._mMatrixUniform = null;\n    this._vMatrixUniform = null;\n    this._camPosUniform = null;\n    this._normalMatrixUniform = null;\n    this._inverseViewMatrixUniform = null;\n\n    this._attrVertexPos = -1;\n    this.precision = _cgl.patch.config.glslPrecision || \"highp\";\n\n    this._pMatrixState = -1;\n    this._vMatrixState = -1;\n\n    this._countMissingUniforms = 0;\n    this._modGroupCount = 0; // not needed anymore...\n    this._feedBackNames = [];\n    this._attributes = [];\n\n    this.glPrimitive = null;\n    this.offScreenPass = false;\n    this._extensions = [];\n    this.srcVert = this.getDefaultVertexShader();\n    this.srcFrag = this.getDefaultFragmentShader();\n    this.lastCompile = 0;\n\n    this._moduleNames = [];\n    this._modules = [];\n    this._moduleNumId = 0;\n\n    this._libs = [];\n    this._structNames = [];\n    this._structUniformNames = [];\n    this._textureStackUni = [];\n    this._textureStackTex = [];\n    this._textureStackType = [];\n    this._textureStackTexCgl = [];\n\n    this._tempNormalMatrix = mat4.create();\n    this._tempCamPosMatrix = mat4.create();\n    this._tempInverseViewMatrix = mat4.create();\n    this._tempInverseProjMatrix = mat4.create();\n\n    this.setModules([\"MODULE_VERTEX_POSITION\", \"MODULE_COLOR\", \"MODULE_BEGIN_FRAG\", \"MODULE_VERTEX_MOVELVIEW\"]);\n};\n\nShader.prototype.isValid = function ()\n{\n    return this._isValid;\n};\n\nShader.prototype.getCgl = function ()\n{\n    return this._cgl;\n};\n\nShader.prototype.getName = function ()\n{\n    return this._name;\n};\n\n/**\n * enable an extension for the shader\n * @function enableExtension\n * @memberof Shader\n * @instance\n * @param name extension name\n */\nShader.prototype.enableExtension = function (name)\n{\n    this.setWhyCompile(\"enable extension \" + name);\n    this._needsRecompile = true;\n    this._extensions.push(name);\n};\n\nShader.prototype.getAttrVertexPos = function ()\n{\n    return this._attrVertexPos;\n};\n\nShader.prototype.hasTextureUniforms = function ()\n{\n    for (let i = 0; i < this._uniforms.length; i++)\n        if (this._uniforms[i].getType() == \"t\") return true;\n    return false;\n};\n\nShader.prototype.setWhyCompile = function (why)\n{\n    this._compileReason = why;\n};\n\n/**\n * copy all uniform values from another shader\n * @function copyUniforms\n * @memberof Shader\n * @instance\n * @param shader uniform values will be copied from this shader\n */\nShader.prototype.copyUniformValues = function (origShader)\n{\n    // console.log(origShader._uniforms);\n    for (let i = 0; i < origShader._uniforms.length; i++)\n    {\n        if (!this._uniforms[i])\n        {\n            this._log.log(\"unknown uniform?!\");\n            continue;\n        }\n\n        // this._log.log(origShader._uniforms[i].getName());\n        // this.getUniform(origShader._uniforms[i].)\n        // this._uniforms[i].set(origShader._uniforms[i].getValue());\n\n\n        // if (origShader._uniforms[i].getName().contains(\"pathPoints\"))\n        //     console.log(\"copyUniformValues\", origShader._uniforms[i].getName(), origShader._uniforms[i].getValue());\n\n        this.getUniform(origShader._uniforms[i].getName()).set(origShader._uniforms[i].getValue());\n    }\n\n    this.popTextures();\n    for (let i = 0; i < origShader._textureStackUni.length; i++)\n    {\n        this._textureStackUni[i] = origShader._textureStackUni[i];\n        this._textureStackTex[i] = origShader._textureStackTex[i];\n        this._textureStackType[i] = origShader._textureStackType[i];\n        this._textureStackTexCgl[i] = origShader._textureStackTexCgl[i];\n    }\n\n    // this._textureStackUni = [];\n    // this._textureStackTex = [];\n    // this._textureStackType = [];\n    // this._textureStackTexCgl = [];\n};\n\n/**\n * copy current shader\n * @function copy\n * @memberof Shader\n * @instance\n * @returns newShader\n */\nShader.prototype.copy = function ()\n{\n    const shader = new Shader(this._cgl, this._name + \" copy\");\n    shader.setSource(this.srcVert, this.srcFrag);\n\n    shader._modules = JSON.parse(JSON.stringify(this._modules));\n    shader._defines = JSON.parse(JSON.stringify(this._defines));\n\n    shader._modGroupCount = this._modGroupCount;\n    shader._moduleNames = this._moduleNames;\n    shader.glPrimitive = this.glPrimitive;\n    shader.offScreenPass = this.offScreenPass;\n    shader._extensions = this._extensions;\n    shader.wireframe = this.wireframe;\n    shader._attributes = this._attributes;\n\n    for (let i = 0; i < this._uniforms.length; i++)\n    {\n        const u = this._uniforms[i].copy(shader);\n        u.resetLoc();\n    }\n\n    this.setWhyCompile(\"copy\");\n    shader._needsRecompile = true;\n    return shader;\n};\n\n\n/**\n * set shader source code\n * @function setSource\n * @memberof Shader\n * @instance\n * @param {String} srcVert\n * @param {String} srcFrag\n */\nShader.prototype.setSource = function (srcVert, srcFrag)\n{\n    this.srcVert = srcVert;\n    this.srcFrag = srcFrag;\n    this.setWhyCompile(\"Source changed\");\n    this._needsRecompile = true;\n    this._isValid = true;\n};\n\nShader.prototype._addLibs = function (src)\n{\n    for (const id in _cgl_shader_lib_js__WEBPACK_IMPORTED_MODULE_2__.ShaderLibMods)\n    {\n        if (src.contains(id))\n        {\n            const lib = new _cgl_shader_lib_js__WEBPACK_IMPORTED_MODULE_2__.ShaderLibMods[id]();\n            src = src.replace(\"{{\" + id + \"}}\", lib.srcHeadFrag);\n            this._libs.push(lib);\n            if (lib.initUniforms)lib.initUniforms(this);\n        }\n    }\n\n    return src;\n};\n\nShader.prototype.createStructUniforms = function ()\n{\n    // * create structs\n    let structStrFrag = \"\";\n    let structStrVert = \"\"; // TODO: not used yet\n\n    this._structNames = [];\n    // * reset the arrays holding the value each recompile so we don't skip structs\n    // * key value mapping so the same struct can be added twice (two times the same modifier)\n    this._injectedStringsFrag = {};\n    this._injectedStringsVert = {};\n\n    this._structUniformNamesIndicesFrag = [];\n    this._structUniformNamesIndicesVert = [];\n\n    for (let i = 0; i < this._uniforms.length; i++)\n    {\n        // * only add uniforms to struct that are a member of a struct\n        if (this._uniforms[i].isStructMember())\n        {\n            const injectionString = \"{{INJECTION_POINT_STRUCT_\" + this._uniforms[i]._structName + \"}}\";\n\n            // * check if struct is not already part of shader\n            if (!this._structNames.includes(this._uniforms[i]._structName))\n            {\n                // * create struct definition with placeholder string to inject\n                const structDefinition = \"struct \"\n                    + this._uniforms[i]._structName + \" {\".endl()\n                    + injectionString\n                    + \"};\".endl().endl();\n\n                if (this._uniforms[i].getShaderType() === \"both\" || this._uniforms[i].getShaderType() === \"frag\")\n                    structStrFrag = structStrFrag.concat(structDefinition);\n\n                if (this._uniforms[i].getShaderType() === \"both\" || this._uniforms[i].getShaderType() === \"vert\")\n                    structStrVert = structStrVert.concat(structDefinition);\n\n                this._structNames.push(this._uniforms[i]._structName);\n                this._injectedStringsFrag[this._uniforms[i]._structName] = [];\n                this._injectedStringsVert[this._uniforms[i]._structName] = [];\n            }\n\n            // * create member & comment\n            let comment = \"\";\n            if (this._uniforms[i].comment) comment = \" // \" + this._uniforms[i].comment;\n\n            let stringToInsert = \"\";\n            if (this._uniforms[i].getGlslTypeString() == undefined)stringToInsert += \"//\";\n            stringToInsert += \"  \" + this._uniforms[i].getGlslTypeString()\n                    + \" \" + this._uniforms[i]._propertyName + \";\"\n                    + comment;\n\n            if (this._uniforms[i].getShaderType() === \"both\")\n            {\n                // * inject member before {injectionString}\n                if (\n                    !this._injectedStringsFrag[this._uniforms[i]._structName].contains(stringToInsert)\n                && !this._injectedStringsVert[this._uniforms[i]._structName].contains(stringToInsert))\n                {\n                    const insertionIndexFrag = structStrFrag.lastIndexOf(injectionString);\n                    const insertionIndexVert = structStrVert.lastIndexOf(injectionString);\n\n                    structStrFrag =\n                        structStrFrag.slice(0, insertionIndexFrag)\n                        + stringToInsert + structStrFrag.slice(insertionIndexFrag - 1);\n\n                    structStrVert =\n                        structStrVert.slice(0, insertionIndexVert)\n                        + stringToInsert + structStrVert.slice(insertionIndexVert - 1);\n\n                    this._injectedStringsFrag[this._uniforms[i]._structName].push(stringToInsert);\n                    this._injectedStringsVert[this._uniforms[i]._structName].push(stringToInsert);\n                }\n\n                if (!this._structUniformNamesIndicesFrag.includes(i)) this._structUniformNamesIndicesFrag.push(i);\n                if (!this._structUniformNamesIndicesVert.includes(i)) this._structUniformNamesIndicesVert.push(i);\n            }\n            else if (this._uniforms[i].getShaderType() === \"frag\")\n            {\n                // * inject member before {injectionString}\n                if (!this._injectedStringsFrag[this._uniforms[i]._structName].includes(stringToInsert)) //\n                {\n                    const insertionIndexFrag = structStrFrag.lastIndexOf(injectionString);\n\n                    structStrFrag =\n                        structStrFrag.slice(0, insertionIndexFrag)\n                        + stringToInsert + structStrFrag.slice(insertionIndexFrag - 1);\n\n                    this._injectedStringsFrag[this._uniforms[i]._structName].push(stringToInsert);\n                }\n\n                if (!this._structUniformNamesIndicesFrag.includes(i)) this._structUniformNamesIndicesFrag.push(i);\n            }\n            else if (this._uniforms[i].getShaderType() === \"vert\")\n            {\n                // * inject member before {injectionString}\n                if (!this._injectedStringsVert[this._uniforms[i]._structName].includes(stringToInsert))\n                {\n                    const insertionIndexVert = structStrVert.lastIndexOf(injectionString);\n\n                    structStrVert =\n                        structStrVert.slice(0, insertionIndexVert)\n                        + stringToInsert + structStrVert.slice(insertionIndexVert - 1);\n\n                    this._injectedStringsVert[this._uniforms[i]._structName].push(stringToInsert);\n                }\n\n                if (!this._structUniformNamesIndicesVert.includes(i)) this._structUniformNamesIndicesVert.push(i);\n            }\n        }\n    }\n\n    // * dedupe injected uni declarations\n    this._uniDeclarationsFrag = [];\n    this._uniDeclarationsVert = [];\n\n    // * remove struct injection points and add uniform in fragment\n    for (let i = 0; i < this._structUniformNamesIndicesFrag.length; i += 1)\n    {\n        const index = this._structUniformNamesIndicesFrag[i];\n        const uniDeclarationString = \"UNI \" + this._uniforms[index]._structName + \" \" + this._uniforms[index]._structUniformName + \";\".endl();\n\n        if (!this._uniDeclarationsFrag.includes(uniDeclarationString))\n        {\n            const injectionString = \"{{INJECTION_POINT_STRUCT_\" + this._uniforms[index]._structName + \"}}\";\n\n            structStrFrag = structStrFrag.replace(injectionString, \"\");\n            structStrFrag += uniDeclarationString;\n\n            this._uniDeclarationsFrag.push(uniDeclarationString);\n        }\n    }\n\n    // * remove struct injection points and add uniform in vertex\n    for (let i = 0; i < this._structUniformNamesIndicesVert.length; i += 1)\n    {\n        const index = this._structUniformNamesIndicesVert[i];\n        const uniDeclarationString = \"UNI \" + this._uniforms[index]._structName + \" \" + this._uniforms[index]._structUniformName + \";\".endl();\n\n        if (!this._uniDeclarationsVert.includes(uniDeclarationString))\n        {\n            const injectionString = \"{{INJECTION_POINT_STRUCT_\" + this._uniforms[index]._structName + \"}}\";\n\n            structStrVert = structStrVert.replace(injectionString, \"\");\n            structStrVert += uniDeclarationString;\n            this._uniDeclarationsVert.push(uniDeclarationString);\n        }\n    }\n\n    return [structStrVert, structStrFrag];\n};\n\nShader.prototype._getAttrSrc = function (attr, firstLevel)\n{\n    const r = {};\n    if (attr.name && attr.type)\n    {\n        r.srcHeadVert = \"\";\n        if (!firstLevel) r.srcHeadVert += \"#ifndef ATTRIB_\" + attr.name.endl();\n        r.srcHeadVert += \"#define ATTRIB_\" + attr.name.endl();\n        r.srcHeadVert += \"IN \" + attr.type + \" \" + attr.name + \";\".endl();\n        if (!firstLevel) r.srcHeadVert += \"#endif\".endl();\n\n        if (attr.nameFrag)\n        {\n            r.srcHeadVert += \"\";\n            if (!firstLevel) r.srcHeadVert += \"#ifndef ATTRIB_\" + attr.nameFrag.endl();\n            r.srcHeadVert += \"#define ATTRIB_\" + attr.nameFrag.endl();\n            r.srcHeadVert += \"OUT \" + attr.type + \" \" + attr.nameFrag + \";\".endl();\n            if (!firstLevel) r.srcHeadVert += \"#endif\".endl();\n\n            r.srcVert = \"\".endl() + attr.nameFrag + \"=\" + attr.name + \";\";\n\n            r.srcHeadFrag = \"\";\n            if (!firstLevel) r.srcHeadFrag += \"#ifndef ATTRIB_\" + attr.nameFrag.endl();\n            r.srcHeadFrag += \"#define ATTRIB_\" + attr.nameFrag.endl();\n            r.srcHeadFrag += \"IN \" + attr.type + \" \" + attr.nameFrag + \";\".endl();\n            if (!firstLevel) r.srcHeadFrag += \"#endif\".endl();\n        }\n    }\n    return r;\n};\n\nShader.prototype.compile = function ()\n{\n    if (this._cgl.aborted) return;\n    const startTime = performance.now();\n\n\n\n    this._cgl.profileData.profileShaderCompiles++;\n    this._cgl.profileData.profileShaderCompileName = this._name + \" [\" + this._compileReason + \"]\";\n\n    let extensionString = \"\";\n    if (this._extensions)\n        for (let i = 0; i < this._extensions.length; i++)\n            extensionString += \"#extension \" + this._extensions[i] + \" : enable\".endl();\n\n    let definesStr = \"\";\n    if (this._defines.length) definesStr = \"\\n// cgl generated\".endl();\n    for (let i = 0; i < this._defines.length; i++)\n        definesStr += \"#define \" + this._defines[i][0] + \" \" + this._defines[i][1] + \"\".endl();\n\n    const structStrings = this.createStructUniforms();\n    this._cgl.profileData.addHeavyEvent(\"shader compile\", this._name + \" [\" + this._compileReason + \"]\");\n    this._compileReason = \"\";\n\n\n\n    if (this._uniforms)\n    {\n        // * we create an array of the uniform names to check our indices & an array to save them\n        const uniNames = this._uniforms.map((uni) => { return uni._name; });\n        const indicesToRemove = [];\n\n        // * we go through our uniforms and check if the same name is contained somewhere further in the array\n        // * if so, we add the current index to be removed later\n        for (let i = 0; i < this._uniforms.length; i++)\n        {\n            const uni = this._uniforms[i];\n            const nextIndex = uniNames.indexOf(uni._name, i + 1);\n            if (nextIndex > -1) indicesToRemove.push(i);\n        }\n\n        // * after that, we go through the uniforms backwards (so we keep the order) and remove the indices\n        // * also, we reset the locations of all the other valid uniforms\n        for (let j = this._uniforms.length - 1; j >= 0; j -= 1)\n        {\n            if (indicesToRemove.includes(j)) this._uniforms.splice(j, 1);\n            else this._uniforms[j].resetLoc();\n        }\n    }\n\n    this._cgl.printError(\"uniform resets\");\n\n    if (this.hasTextureUniforms()) definesStr += \"#define HAS_TEXTURES\".endl();\n\n    let vs = \"\";\n    let fs = \"\";\n\n    if (!this.srcFrag)\n    {\n        this._log.error(\"[cgl shader] has no fragment source!\", this);\n        this.srcVert = this.getDefaultVertexShader();\n        this.srcFrag = this.getDefaultFragmentShader();\n        // return;\n    }\n\n    if (this.glslVersion == 300)\n    {\n        vs = \"#version 300 es\"\n            .endl() + \"// \"\n            .endl() + \"// vertex shader \" + this._name\n            .endl() + \"// \"\n            .endl() + \"precision \" + this.precision + \" float;\"\n            .endl() + \"precision \" + this.precision + \" sampler2D;\"\n            .endl() + \"\"\n            .endl() + \"#define WEBGL2\"\n            .endl() + \"#define texture2D texture\"\n            .endl() + \"#define UNI uniform\"\n            .endl() + \"#define IN in\"\n            .endl() + \"#define OUT out\"\n            .endl();\n\n        fs = \"#version 300 es\"\n            .endl() + \"// \"\n            .endl() + \"// fragment shader \" + this._name\n            .endl() + \"// \"\n            .endl() + \"precision \" + this.precision + \" float;\"\n            .endl() + \"precision \" + this.precision + \" sampler2D;\"\n            .endl() + \"\"\n            .endl() + \"#define WEBGL2\"\n            .endl() + \"#define texture2D texture\"\n            .endl() + \"#define IN in\"\n            .endl() + \"#define OUT out\"\n            .endl() + \"#define UNI uniform\"\n            .endl() + \"{{DRAWBUFFER}}\"\n\n            .endl();\n    }\n    else\n    {\n        fs = \"\"\n            .endl() + \"// \"\n            .endl() + \"// fragment shader \" + this._name\n            .endl() + \"// \"\n            .endl() + \"#define WEBGL1\"\n            .endl() + \"#define texture texture2D\"\n            .endl() + \"#define outColor gl_FragColor\"\n            .endl() + \"#define IN varying\"\n            .endl() + \"#define UNI uniform\"\n            .endl();\n\n        vs = \"\"\n            .endl() + \"// \"\n            .endl() + \"// vertex shader \" + this._name\n            .endl() + \"// \"\n            .endl() + \"#define WEBGL1\"\n            .endl() + \"#define texture texture2D\"\n            .endl() + \"#define OUT varying\"\n            .endl() + \"#define IN attribute\"\n            .endl() + \"#define UNI uniform\"\n            .endl();\n    }\n\n    let uniformsStrVert = \"\\n// cgl generated\".endl();\n    let uniformsStrFrag = \"\\n// cgl generated\".endl();\n\n\n    fs += \"\\n// active mods: --------------- \";\n    vs += \"\\n// active mods: --------------- \";\n\n    let foundModsFrag = false;\n    let foundModsVert = false;\n    for (let i = 0; i < this._moduleNames.length; i++)\n    {\n        for (let j = 0; j < this._modules.length; j++)\n        {\n            if (this._modules[j].name == this._moduleNames[i])\n            {\n                if (this._modules[j].srcBodyFrag || this._modules[j].srcHeadFrag)\n                {\n                    foundModsFrag = true;\n                    fs += \"\\n// \" + i + \".\" + j + \". \" + this._modules[j].title + \" (\" + this._modules[j].name + \")\";\n                }\n                if (this._modules[j].srcBodyVert || this._modules[j].srcHeadVert)\n                {\n                    vs += \"\\n// \" + i + \".\" + j + \". \" + this._modules[j].title + \" (\" + this._modules[j].name + \")\";\n                    foundModsVert = true;\n                }\n            }\n        }\n    }\n    if (!foundModsVert)fs += \"\\n// no mods used...\";\n    if (!foundModsFrag)fs += \"\\n// no mods used...\";\n    fs += \"\\n\";\n    vs += \"\\n\";\n\n    for (let i = 0; i < this._uniforms.length; i++)\n    {\n        if (this._uniforms[i].shaderType && !this._uniforms[i].isStructMember())\n        {\n            let uniStr = \"\";\n            if (!this._uniforms[i].getGlslTypeString())uniStr += \"// \";\n            uniStr += \"UNI \" + this._uniforms[i].getGlslTypeString() + \" \" + this._uniforms[i].getName();\n            let comment = \"\";\n            if (this._uniforms[i].comment) comment = \" // \" + this._uniforms[i].comment;\n\n            if (this._uniforms[i].shaderType == \"vert\" || this._uniforms[i].shaderType == \"both\")\n                if (!this.srcVert.contains(uniStr) && !this.srcVert.contains(\"uniform \" + this._uniforms[i].getGlslTypeString() + \" \" + this._uniforms[i].getName()))\n                    uniformsStrVert += uniStr + \";\" + comment.endl();\n\n            if (this._uniforms[i].shaderType == \"frag\" || this._uniforms[i].shaderType == \"both\")\n                if (!this.srcFrag.contains(uniStr) && !this.srcFrag.contains(\"uniform \" + this._uniforms[i].getGlslTypeString() + \" \" + this._uniforms[i].getName()))\n                    uniformsStrFrag += uniStr + \";\" + comment.endl();\n        }\n    }\n\n\n    let countUniFrag = 0;\n    let countUniVert = 0;\n    for (let i = 0; i < this._uniforms.length; i++)\n    {\n        if (this._uniforms[i].shaderType && !this._uniforms[i].isStructMember())\n        {\n            if (this._uniforms[i].shaderType == \"vert\" || this._uniforms[i].shaderType == \"both\") countUniVert++;\n            if (this._uniforms[i].shaderType == \"frag\" || this._uniforms[i].shaderType == \"both\") countUniFrag++;\n        }\n    }\n    if (countUniFrag >= this._cgl.maxUniformsFrag) this._log.warn(\"[cgl_shader] num uniforms frag: \" + countUniFrag + \" / \" + this._cgl.maxUniformsFrag);\n    if (countUniVert >= this._cgl.maxUniformsVert) this._log.warn(\"[cgl_shader] num uniforms vert: \" + countUniVert + \" / \" + this._cgl.maxUniformsVert);\n\n\n    if (!fs.contains(\"precision\")) fs = \"precision \" + this.precision + \" float;\".endl() + fs;\n    if (!vs.contains(\"precision\")) vs = \"precision \" + this.precision + \" float;\".endl() + vs;\n    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))\n    {\n        fs += \"#define MOBILE\".endl();\n        vs += \"#define MOBILE\".endl();\n    }\n    vs = extensionString + vs + definesStr + structStrings[0] + uniformsStrVert + \"\\n// -- \\n\" + this.srcVert;\n    fs = extensionString + fs + definesStr + structStrings[1] + uniformsStrFrag + \"\\n// -- \\n\" + this.srcFrag;\n\n\n    let srcHeadVert = \"\";\n    let srcHeadFrag = \"\";\n\n    this._modules.sort(function (a, b)\n    {\n        return a.group - b.group;\n    });\n\n    this._modules.sort(function (a, b)\n    {\n        return a.priority || 0 - b.priority || 0;\n    });\n\n\n    let addedAttribs = false;\n\n    for (let i = 0; i < this._moduleNames.length; i++)\n    {\n        let srcVert = \"\";\n        let srcFrag = \"\";\n\n        if (!addedAttribs)\n        {\n            addedAttribs = true;\n\n            for (let k = 0; k < this._attributes.length; k++)\n            {\n                const r = this._getAttrSrc(this._attributes[k], true);\n                if (r.srcHeadVert)srcHeadVert += r.srcHeadVert;\n                if (r.srcVert)srcVert += r.srcVert;\n                if (r.srcHeadFrag)srcHeadFrag += r.srcHeadFrag;\n            }\n        }\n\n        for (let j = 0; j < this._modules.length; j++)\n        {\n            const mod = this._modules[j];\n            if (mod.name == this._moduleNames[i])\n            {\n                srcHeadVert += \"\\n//---- MOD: group:\" + mod.group + \": idx:\" + j + \" - prfx:\" + mod.prefix + \" - \" + mod.title + \" ------\\n\";\n                srcHeadFrag += \"\\n//---- MOD: group:\" + mod.group + \": idx:\" + j + \" - prfx:\" + mod.prefix + \" - \" + mod.title + \" ------\\n\";\n\n                srcVert += \"\\n\\n//---- MOD: \" + mod.title + \" / \" + mod.priority + \" ------\\n\";\n                srcFrag += \"\\n\\n//---- MOD: \" + mod.title + \" / \" + mod.priority + \" ------\\n\";\n\n                if (mod.attributes)\n                    for (let k = 0; k < mod.attributes.length; k++)\n                    {\n                        const r = this._getAttrSrc(mod.attributes[k], false);\n                        if (r.srcHeadVert)srcHeadVert += r.srcHeadVert;\n                        if (r.srcVert)srcVert += r.srcVert;\n                        if (r.srcHeadFrag)srcHeadFrag += r.srcHeadFrag;\n                    }\n\n                srcHeadVert += mod.srcHeadVert || \"\";\n                srcHeadFrag += mod.srcHeadFrag || \"\";\n                srcVert += mod.srcBodyVert || \"\";\n                srcFrag += mod.srcBodyFrag || \"\";\n\n                srcHeadVert += \"\\n//---- end mod ------\\n\";\n                srcHeadFrag += \"\\n//---- end mod ------\\n\";\n\n                srcVert += \"\\n//---- end mod ------\\n\";\n                srcFrag += \"\\n//---- end mod ------\\n\";\n\n                srcVert = srcVert.replace(/{{mod}}/g, mod.prefix);\n                srcFrag = srcFrag.replace(/{{mod}}/g, mod.prefix);\n                srcHeadVert = srcHeadVert.replace(/{{mod}}/g, mod.prefix);\n                srcHeadFrag = srcHeadFrag.replace(/{{mod}}/g, mod.prefix);\n\n                srcVert = srcVert.replace(/MOD_/g, mod.prefix);\n                srcFrag = srcFrag.replace(/MOD_/g, mod.prefix);\n                srcHeadVert = srcHeadVert.replace(/MOD_/g, mod.prefix);\n                srcHeadFrag = srcHeadFrag.replace(/MOD_/g, mod.prefix);\n            }\n        }\n\n\n        vs = vs.replace(\"{{\" + this._moduleNames[i] + \"}}\", srcVert);\n        fs = fs.replace(\"{{\" + this._moduleNames[i] + \"}}\", srcFrag);\n    }\n    vs = vs.replace(\"{{MODULES_HEAD}}\", srcHeadVert);\n    fs = fs.replace(\"{{MODULES_HEAD}}\", srcHeadFrag);\n\n\n    vs = this._addLibs(vs);\n    fs = this._addLibs(fs);\n\n\n    // SETUP draw buffers / multi texture render targets\n\n    let drawBufferStr = \"\";\n    for (let i = 0; i < 16; i++)\n        if (fs.contains(\"outColor\" + i)) this._drawBuffers[i] = true;\n\n    if (this._drawBuffers.length == 1)\n    {\n        drawBufferStr = \"out vec4 outColor;\".endl();\n        drawBufferStr += \"#define gl_FragColor outColor\".endl();\n    }\n    else\n    {\n        drawBufferStr += \"#define MULTI_COLORTARGETS\".endl();\n        drawBufferStr += \"vec4 outColor;\".endl();\n\n        let count = 0;\n        for (let i = 0; i < this._drawBuffers.length; i++)\n        {\n            if (count == 0) drawBufferStr += \"#define gl_FragColor outColor\" + i + \"\".endl();\n            drawBufferStr += \"layout(location = \" + i + \") out vec4 outColor\" + i + \";\".endl();\n            count++;\n        }\n    }\n\n    fs = fs.replace(\"{{DRAWBUFFER}}\", drawBufferStr);\n    // //////\n\n\n    if (!this._program)\n    {\n        this._program = this._createProgram(vs, fs);\n    }\n    else\n    {\n        // this.vshader=createShader(vs, gl.VERTEX_SHADER, this.vshader );\n        // this.fshader=createShader(fs, gl.FRAGMENT_SHADER, this.fshader );\n        // linkProgram(program);\n        this._program = this._createProgram(vs, fs);\n\n        this._projMatrixUniform = null;\n\n        for (let i = 0; i < this._uniforms.length; i++) this._uniforms[i].resetLoc();\n    }\n\n    this.finalShaderFrag = fs;\n    this.finalShaderVert = vs;\n\n\n    _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_3__.MESH.lastMesh = null;\n    _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_3__.MESH.lastShader = null;\n\n    this._countMissingUniforms = 0;\n    this._needsRecompile = false;\n    this.lastCompile = (0,_timer_js__WEBPACK_IMPORTED_MODULE_4__.now)();\n\n    // this._cgl.printError(\"shader compile\");\n\n    this._cgl.profileData.shaderCompileTime += performance.now() - startTime;\n};\n\nShader.hasChanged = function ()\n{\n    return this._needsRecompile;\n};\n\n\nShader.prototype.bind = function ()\n{\n    if (!this._isValid || this._cgl.aborted) return;\n\n    _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_3__.MESH.lastShader = this;\n\n    if (!this._program || this._needsRecompile) this.compile();\n    if (!this._isValid) return;\n\n    if (!this._projMatrixUniform && !this.ignoreMissingUniforms)\n    {\n        this._countMissingUniforms++;\n        // if (this._countMissingUniforms == 10)console.log(\"stopping getlocation of missing uniforms...\", this._name);\n        if (this._countMissingUniforms < 10)\n        {\n            this._projMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.SHADER.SHADERVAR_UNI_PROJMAT);\n            this._attrVertexPos = this._cgl.glGetAttribLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.SHADER.SHADERVAR_VERTEX_POSITION);\n            this._mvMatrixUniform = this._cgl.gl.getUniformLocation(this._program, \"mvMatrix\");\n            this._vMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.SHADER.SHADERVAR_UNI_VIEWMAT);\n            this._mMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.SHADER.SHADERVAR_UNI_MODELMAT);\n            this._camPosUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.SHADER.SHADERVAR_UNI_VIEWPOS);\n            this._normalMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.SHADER.SHADERVAR_UNI_NORMALMAT);\n            this._inverseViewMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.SHADER.SHADERVAR_UNI_INVVIEWMAT);\n            this._inverseProjMatrixUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.SHADER.SHADERVAR_UNI_INVPROJMAT);\n            this._materialIdUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.SHADER.SHADERVAR_UNI_MATERIALID);\n            this._objectIdUniform = this._cgl.gl.getUniformLocation(this._program, _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.SHADER.SHADERVAR_UNI_OBJECTID);\n\n            for (let i = 0; i < this._uniforms.length; i++) this._uniforms[i].needsUpdate = true;\n        }\n    }\n\n\n    if (this._cgl.currentProgram != this._program)\n    {\n        this._cgl.profileData.profileShaderBinds++;\n        this._cgl.gl.useProgram(this._program);\n        this._cgl.currentProgram = this._program;\n    }\n\n    for (let i = 0; i < this._uniforms.length; i++)\n        if (this._uniforms[i].needsUpdate) this._uniforms[i].updateValue();\n\n    if (this._pMatrixState != this._cgl.getProjectionMatrixStateCount())\n    {\n        this._pMatrixState = this._cgl.getProjectionMatrixStateCount();\n        this._cgl.gl.uniformMatrix4fv(this._projMatrixUniform, false, this._cgl.pMatrix);\n        this._cgl.profileData.profileMVPMatrixCount++;\n    }\n\n    if (this._objectIdUniform)\n        this._cgl.gl.uniform1f(this._objectIdUniform, ++this._cgl.frameStore.objectIdCounter);\n\n    if (this._materialIdUniform)\n        this._cgl.gl.uniform1f(this._materialIdUniform, this._materialId);\n\n    if (this._vMatrixUniform)\n    {\n        if (this._vMatrixState != this._cgl.getViewMatrixStateCount())\n        {\n            this._cgl.gl.uniformMatrix4fv(this._vMatrixUniform, false, this._cgl.vMatrix);\n            this._cgl.profileData.profileMVPMatrixCount++;\n            this._vMatrixState = this._cgl.getViewMatrixStateCount();\n\n            if (this._inverseViewMatrixUniform)\n            {\n                mat4.invert(this._tempInverseViewMatrix, this._cgl.vMatrix);\n                this._cgl.gl.uniformMatrix4fv(this._inverseViewMatrixUniform, false, this._tempInverseViewMatrix);\n                this._cgl.profileData.profileMVPMatrixCount++;\n            }\n            if (this._inverseProjMatrixUniform)\n            {\n                mat4.invert(this._tempInverseProjMatrix, this._cgl.pMatrix);\n                this._cgl.gl.uniformMatrix4fv(this._inverseProjMatrixUniform, false, this._tempInverseProjMatrix);\n                this._cgl.profileData.profileMVPMatrixCount++;\n            }\n        }\n        this._cgl.gl.uniformMatrix4fv(this._mMatrixUniform, false, this._cgl.mMatrix);\n        this._cgl.profileData.profileMVPMatrixCount++;\n\n        if (this._camPosUniform)\n        {\n            mat4.invert(this._tempCamPosMatrix, this._cgl.vMatrix);\n            this._cgl.gl.uniform3f(this._camPosUniform, this._tempCamPosMatrix[12], this._tempCamPosMatrix[13], this._tempCamPosMatrix[14]);\n            this._cgl.profileData.profileMVPMatrixCount++;\n        }\n    }\n    else\n    {\n        // mvmatrix deprecated....\n        const tempmv = mat4.create();\n\n        mat4.mul(tempmv, this._cgl.vMatrix, this._cgl.mMatrix);\n        this._cgl.gl.uniformMatrix4fv(this._mvMatrixUniform, false, tempmv);\n        this._cgl.profileData.profileMVPMatrixCount++;\n    }\n\n    if (this._normalMatrixUniform)\n    {\n        // mat4.mul(this._tempNormalMatrix, this._cgl.vMatrix, this._cgl.mMatrix);\n        mat4.invert(this._tempNormalMatrix, this._cgl.mMatrix);\n        mat4.transpose(this._tempNormalMatrix, this._tempNormalMatrix);\n\n        this._cgl.gl.uniformMatrix4fv(this._normalMatrixUniform, false, this._tempNormalMatrix);\n        this._cgl.profileData.profileMVPMatrixCount++;\n    }\n\n    for (let i = 0; i < this._libs.length; i++)\n    {\n        if (this._libs[i].onBind) this._libs[i].onBind.bind(this._libs[i])(this._cgl, this);\n    }\n\n    this._bindTextures();\n\n    return this._isValid;\n};\n\nShader.prototype.unBind = function ()\n{\n};\n\n/**\n * easily enable/disable a define without a value\n * @function toggleDefine\n * @memberof Shader\n * @instance\n * @param {name} name\n * @param {any} value or port\n */\nShader.prototype.toggleDefine = function (name, enabled)\n{\n    if (enabled && typeof (enabled) == \"object\" && enabled.addEventListener) // port\n    {\n        if (enabled.changeListener)enabled.removeEventListener(enabled.changeListener);\n\n        enabled.onToggleDefine = (v) =>\n        {\n            this.toggleDefine(name, v);\n        };\n\n        enabled.changeListener = enabled.on(\"change\", enabled.onToggleDefine);\n        enabled = enabled.get();\n    }\n\n    if (enabled) this.define(name);\n    else this.removeDefine(name);\n};\n\n/**\n * add a define to a shader, e.g.  #define DO_THIS_THAT 1\n * @function define\n * @memberof Shader\n * @instance\n * @param {String} name\n * @param {Any} value (can be empty)\n */\nShader.prototype.define = function (name, value)\n{\n    if (value === null || value === undefined) value = \"\";\n\n    if (typeof (value) == \"object\") // port\n    {\n        value.removeEventListener(\"change\", value.onDefineChange);\n        value.onDefineChange = (v) =>\n        {\n            this.define(name, v);\n        };\n        value.on(\"change\", value.onDefineChange);\n\n        value = value.get();\n    }\n\n\n    for (let i = 0; i < this._defines.length; i++)\n    {\n        if (this._defines[i][0] == name && this._defines[i][1] == value) return;\n        if (this._defines[i][0] == name)\n        {\n            this._defines[i][1] = value;\n            this.setWhyCompile(\"define \" + name + \" \" + value);\n\n            this._needsRecompile = true;\n            return;\n        }\n    }\n    this.setWhyCompile(\"define \" + name + \" \" + value);\n    this._needsRecompile = true;\n    this._defines.push([name, value]);\n};\n\nShader.prototype.getDefines = function ()\n{\n    return this._defines;\n};\n\nShader.prototype.getDefine = function (name)\n{\n    for (let i = 0; i < this._defines.length; i++)\n        if (this._defines[i][0] == name) return this._defines[i][1];\n    return null;\n};\n\n/**\n * return true if shader has define\n * @function hasDefine\n * @memberof Shader\n * @instance\n * @param {String} name\n * @return {Boolean}\n */\nShader.prototype.hasDefine = function (name)\n{\n    for (let i = 0; i < this._defines.length; i++)\n        if (this._defines[i][0] == name) return true;\n};\n\n/**\n * remove a define from a shader\n * @param {name} name\n * @function removeDefine\n * @memberof Shader\n * @instance\n */\nShader.prototype.removeDefine = function (name)\n{\n    for (let i = 0; i < this._defines.length; i++)\n    {\n        if (this._defines[i][0] == name)\n        {\n            this._defines.splice(i, 1);\n            this._needsRecompile = true;\n\n            this.setWhyCompile(\"define removed:\" + name);\n\n            return;\n        }\n    }\n};\n\n/**\n * remove a module from shader\n * @function removeModule\n * @memberof Shader\n * @instance\n * @param {shaderModule} module the module to be removed\n */\nShader.prototype.removeModule = function (mod)\n{\n    for (let i = 0; i < this._modules.length; i++)\n    {\n        if (mod && mod.id)\n        {\n            if (this._modules[i].id == mod.id || !this._modules[i])\n            {\n                let found = true;\n                while (found)\n                {\n                    found = false;\n                    for (let j = 0; j < this._uniforms.length; j++)\n                    {\n                        if (this._uniforms[j].getName().startsWith(mod.prefix))\n                        {\n                            this._uniforms.splice(j, 1);\n                            found = true;\n                            continue;\n                        }\n                    }\n                }\n\n                this._needsRecompile = true;\n                this.setWhyCompile(\"remove module \" + mod.title);\n                this._modules.splice(i, 1);\n                break;\n            }\n        }\n    }\n};\n\n\nShader.prototype.getNumModules = function ()\n{\n    return this._modules.length;\n};\n\n\nShader.prototype.getCurrentModules = function () { return this._modules; };\n\n\n/**\n * add a module\n * @function addModule\n * @memberof Shader\n * @instance\n * @param {shaderModule} module the module to be added\n * @param {shaderModule} [sibling] sibling module, new module will share the same group\n */\nShader.prototype.addModule = function (mod, sibling)\n{\n    if (this.hasModule(mod.id)) return;\n    if (!mod.id) mod.id = CABLES.simpleId();\n    if (!mod.numId) mod.numId = this._moduleNumId;\n    if (!mod.num)mod.num = this._modules.length;\n    if (sibling && !sibling.group) sibling.group = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.simpleId)();\n\n    if (!mod.group)\n        if (sibling) mod.group = sibling.group;\n        else mod.group = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.simpleId)();\n\n    mod.prefix = \"mod\" + mod.group + \"_\";\n    this._modules.push(mod);\n\n    this._needsRecompile = true;\n    this.setWhyCompile(\"add module \" + mod.title);\n    this._moduleNumId++;\n\n    return mod;\n};\n\nShader.prototype.hasModule = function (modId)\n{\n    for (let i = 0; i < this._modules.length; i++)\n    {\n        if (this._modules[i].id == modId) return true;\n    }\n    return false;\n};\n\nShader.prototype.setModules = function (names)\n{\n    this._moduleNames = names;\n};\n\nShader.prototype.dispose = function ()\n{\n    this._cgl.gl.deleteProgram(this._program);\n};\n\nShader.prototype.needsRecompile = function ()\n{\n    return this._needsRecompile;\n};\n\nShader.prototype.setDrawBuffers = function (arr)\n{\n    console.log(\"useless drawbuffers...?!\");\n    // if (this._drawBuffers.length !== arr.length)\n    // {\n    //     this._drawBuffers = arr;\n    //     this._needsRecompile = true;\n    //     this.setWhyCompile(\"setDrawBuffers\");\n    //     return;\n    // }\n    // for (let i = 0; i < arr.length; i++)\n    // {\n    //     if (arr[i] !== this._drawBuffers[i])\n    //     {\n    //         this._drawBuffers = arr;\n    //         this._needsRecompile = true;\n    //         this.setWhyCompile(\"setDrawBuffers\");\n    //         return;\n    //     }\n    // }\n};\n\nShader.prototype.getUniforms = function ()\n{\n    return this._uniforms;\n};\n\nShader.prototype.getUniform = function (name)\n{\n    for (let i = 0; i < this._uniforms.length; i++)\n        if (this._uniforms[i].getName() == name)\n            return this._uniforms[i];\n    return null;\n};\n\nShader.prototype.removeAllUniforms = function ()\n{\n    this._uniforms = [];\n    // for (let i = 0; i < this._uniforms.length; i++)\n    //     this.removeUniform(this._uniforms[i].name);\n};\n\nShader.prototype.removeUniform = function (name)\n{\n    for (let i = 0; i < this._uniforms.length; i++)\n    {\n        if (this._uniforms[i].getName() == name)\n        {\n            this._uniforms.splice(i, 1);\n        }\n    }\n    this._needsRecompile = true;\n    this.setWhyCompile(\"remove uniform \" + name);\n};\n\n\nShader.prototype._addUniform = function (uni)\n{\n    this._uniforms.push(uni);\n    this.setWhyCompile(\"add uniform \" + name);\n    this._needsRecompile = true;\n};\n\n/**\n * add a uniform to the fragment shader\n * @param {String} type ['f','t', etc]\n * @param {String} name\n * @param {any} value or port\n * @memberof Shader\n * @instance\n * @function addUniformFrag\n * @returns {CGL.Uniform}\n */\nShader.prototype.addUniformFrag = function (type, name, valueOrPort, p2, p3, p4)\n{\n    const uni = new CGL.Uniform(this, type, name, valueOrPort, p2, p3, p4);\n    uni.shaderType = \"frag\";\n    return uni;\n};\n\n/**\n * add a uniform to the vertex shader\n * @param {String} type ['f','t', etc]\n * @param {String} name\n * @param {any} value or port\n * @memberof Shader\n * @instance\n * @function addUniformVert\n * @returns {CGL.Uniform}\n */\nShader.prototype.addUniformVert = function (type, name, valueOrPort, p2, p3, p4)\n{\n    const uni = new CGL.Uniform(this, type, name, valueOrPort, p2, p3, p4);\n    uni.shaderType = \"vert\";\n    return uni;\n};\n/**\n * add a uniform to both shaders\n * @param {String} type ['f','t', etc]\n * @param {String} name\n * @param {any} value or port\n * @memberof Shader\n * @instance\n * @function addUniformBoth\n * @returns {CGL.Uniform}\n */\nShader.prototype.addUniformBoth = function (type, name, valueOrPort, p2, p3, p4)\n{\n    const uni = new CGL.Uniform(this, type, name, valueOrPort, p2, p3, p4);\n    uni.shaderType = \"both\";\n    return uni;\n};\n\n/**\n * add a struct & its uniforms to the fragment shader\n * @param {String} structName name of the struct, i.e.: LightStruct\n * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni\n * @param {Array} members array of objects containing the struct members. see example for structure\n\n * @memberof Shader\n * @instance\n * @function addUniformStructFrag\n * @returns {Object}\n * @example\n * const shader = new CGL.Shader(cgl, 'MinimalMaterial');\n * shader.setSource(attachments.shader_vert, attachments.shader_frag);\n * shader.addUniformStructFrag(\"Light\", \"uniformLight\", [\n * { \"type\": \"3f\", \"name\": \"position\", \"v1\": null },\n * { \"type\": \"4f\", \"name\": \"color\", \"v1\": inR, v2: inG, v3: inB, v4: inAlpha }\n * ]);\n */\nShader.prototype.addUniformStructFrag = function (structName, uniformName, members)\n{\n    const uniforms = {};\n\n    if (!members) return uniforms;\n\n    for (let i = 0; i < members.length; i += 1)\n    {\n        const member = members[i];\n        if (!this.hasUniform(uniformName + \".\" + member.name))\n        {\n            const uni = new CGL.Uniform(this, member.type, uniformName + \".\" + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);\n            uni.shaderType = \"frag\";\n            uniforms[uniformName + \".\" + member.name] = uni;\n        }\n    }\n\n    return uniforms;\n};\n\n/**\n * add a struct & its uniforms to the vertex shader\n * @param {String} structName name of the struct, i.e.: LightStruct\n * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni\n * @param {Array} members array of objects containing the struct members. see example for structure\n\n * @memberof Shader\n * @instance\n * @function addUniformStructVert\n * @returns {CGL.Uniform}\n * @example\n * const shader = new CGL.Shader(cgl, 'MinimalMaterial');\n * shader.setSource(attachments.shader_vert, attachments.shader_frag);\n * shader.addUniformStructVert(\"Light\", \"uniformLight\", [\n * { \"type\": \"3f\", \"name\": \"position\", \"v1\": null },\n * { \"type\": \"4f\", \"name\": \"color\", \"v1\": inR, v2: inG, v3: inB, v4: inAlpha }\n * ]);\n */\nShader.prototype.addUniformStructVert = function (structName, uniformName, members)\n{\n    const uniforms = {};\n\n    if (!members) return uniforms;\n\n    for (let i = 0; i < members.length; i += 1)\n    {\n        const member = members[i];\n        if (!this.hasUniform(uniformName + \".\" + member.name))\n        {\n            const uni = new CGL.Uniform(this, member.type, uniformName + \".\" + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);\n            uni.shaderType = \"vert\";\n            uniforms[uniformName + \".\" + member.name] = uni;\n        }\n    }\n\n    return uniforms;\n};\n\n/**\n * add a struct & its uniforms to the both shaders. PLEASE NOTE: it is not possible to add the same struct to both shaders when it contains ANY integer members.\n * @param {String} structName name of the struct, i.e.: LightStruct\n * @param {String} uniformName name of the struct uniform in the shader, i.e.: lightUni\n * @param {Array} members array of objects containing the struct members. see example for structure\n\n * @memberof Shader\n * @instance\n * @function addUniformStructBoth\n * @returns {Object}\n * @example\n * const shader = new CGL.Shader(cgl, 'MinimalMaterial');\n * shader.setSource(attachments.shader_vert, attachments.shader_frag);\n * shader.addUniformStructBoth(\"Light\", \"uniformLight\", [\n * { \"type\": \"3f\", \"name\": \"position\", \"v1\": null },\n * { \"type\": \"4f\", \"name\": \"color\", \"v1\": inR, v2: inG, v3: inB, v4: inAlpha }\n * ]);\n */\nShader.prototype.addUniformStructBoth = function (structName, uniformName, members)\n{\n    const uniforms = {};\n\n    if (!members) return uniforms;\n\n    for (let i = 0; i < members.length; i += 1)\n    {\n        const member = members[i];\n        if ((member.type === \"2i\" || member.type === \"i\" || member.type === \"3i\"))\n            this._log.error(\"Adding an integer struct member to both shaders can potentially error. Please use different structs for each shader. Error occured in struct:\", structName, \" with member:\", member.name, \" of type:\", member.type, \".\");\n        if (!this.hasUniform(uniformName + \".\" + member.name))\n        {\n            const uni = new CGL.Uniform(this, member.type, uniformName + \".\" + member.name, member.v1, member.v2, member.v3, member.v4, uniformName, structName, member.name);\n            uni.shaderType = \"both\";\n            uniforms[uniformName + \".\" + member.name] = uni;\n        }\n    }\n\n    return uniforms;\n};\n\nShader.prototype.hasUniform = function (name)\n{\n    for (let i = 0; i < this._uniforms.length; i++)\n    {\n        if (this._uniforms[i].getName() == name) return true;\n    }\n    return false;\n};\n\nShader.prototype._createProgram = function (vstr, fstr)\n{\n    this._cgl.printError(\"before _createprogram\");\n\n    const program = this._cgl.gl.createProgram();\n\n    this.vshader = Shader.createShader(this._cgl, vstr, this._cgl.gl.VERTEX_SHADER, this);\n    this.fshader = Shader.createShader(this._cgl, fstr, this._cgl.gl.FRAGMENT_SHADER, this);\n\n\n    if (this.vshader && this.fshader)\n    {\n        this._cgl.gl.attachShader(program, this.vshader);\n        this._cgl.gl.attachShader(program, this.fshader);\n\n        this._linkProgram(program, vstr, fstr);\n    }\n    else\n    {\n        this._isValid = false;\n        this._cgl.printError(\"shader _createProgram\");\n        console.log(\"could not link shaderprogram\");\n        return null;\n    }\n\n    this._cgl.printError(\"shader _createProgram\");\n    return program;\n};\n\nShader.prototype.hasErrors = function ()\n{\n    return this._hasErrors;\n};\n\nShader.prototype._linkProgram = function (program, vstr, fstr)\n{\n    this._cgl.printError(\"before _linkprogram\");\n\n    if (this._feedBackNames.length > 0)\n    {\n        this._cgl.gl.transformFeedbackVaryings(program, this._feedBackNames, this._cgl.gl.SEPARATE_ATTRIBS);\n        // INTERLEAVED_ATTRIBS\n        // SEPARATE_ATTRIBS\n    }\n\n    this._cgl.gl.linkProgram(program);\n    this._cgl.printError(\"gl.linkprogram\");\n    this._isValid = true;\n\n    this._hasErrors = false;\n\n    if (this._cgl.patch.config.glValidateShader !== false)\n    {\n        this._cgl.gl.validateProgram(program);\n\n        if (!this._cgl.gl.getProgramParameter(program, this._cgl.gl.VALIDATE_STATUS))\n        {\n            // validation failed\n            console.log(\"shaderprogram validation failed...\");\n            console.log(this._name + \" programinfo: \", this._cgl.gl.getProgramInfoLog(program));\n        }\n\n        if (!this._cgl.gl.getProgramParameter(program, this._cgl.gl.LINK_STATUS))\n        {\n            this._hasErrors = true;\n            this._log.warn(this._cgl.gl.getShaderInfoLog(this.fshader) || \"empty shader infolog\");\n            this._log.warn(this._cgl.gl.getShaderInfoLog(this.vshader) || \"empty shader infolog\");\n            this._log.error(this._name + \" shader linking fail...\");\n\n            console.log(this._name + \" programinfo: \", this._cgl.gl.getProgramInfoLog(program));\n\n            console.log(\"--------------------------------------\");\n            console.log(this);\n            console.log(\"--------------------------------------\");\n            this._isValid = false;\n\n            this._name = \"errorshader\";\n            this.setSource(Shader.getDefaultVertexShader(), Shader.getErrorFragmentShader());\n            this._cgl.printError(\"shader link err\");\n        }\n    }\n};\n\nShader.prototype.getProgram = function ()\n{\n    return this._program;\n};\n\nShader.prototype.setFeedbackNames = function (names)\n{\n    this.setWhyCompile(\"setFeedbackNames\");\n    this._needsRecompile = true;\n    this._feedBackNames = names;\n};\n\nShader.prototype.getDefaultVertexShader = Shader.getDefaultVertexShader = function ()\n{\n    return _cgl_shader_default_glsl_vert__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\n};\n\nShader.prototype.getDefaultFragmentShader = Shader.getDefaultFragmentShader = function (r, g, b)\n{\n    if (r == undefined)\n    {\n        r = 0.5;\n        g = 0.5;\n        b = 0.5;\n    }\n    return \"\"\n        .endl() + \"IN vec2 texCoord;\"\n        .endl() + \"{{MODULES_HEAD}}\"\n        .endl() + \"void main()\"\n        .endl() + \"{\"\n        .endl() + \"    vec4 col=vec4(\" + r + \",\" + g + \",\" + b + \",1.0);\"\n        .endl() + \"    {{MODULE_COLOR}}\"\n        .endl() + \"    outColor = col;\"\n        .endl() + \"}\";\n};\n\n/**\n  * adds attribute definition to shader header without colliding with other shader modules...\n * when attrFrag is defined, vertex shader will output this attribute to the fragment shader\n * @function\n * @memberof Shader\n * @instance\n * @param {Object} attribObject {type:x,name:x,[nameFrag:x]}\n * @return {Object}\n */\nShader.prototype.addAttribute = function (attr)\n{\n    for (let i = 0; i < this._attributes.length; i++)\n    {\n        if (this._attributes[i].name == attr.name && this._attributes[i].nameFrag == attr.nameFrag) return;\n    }\n    this._attributes.push(attr);\n    this._needsRecompile = true;\n    this.setWhyCompile(\"addAttribute\");\n};\n\nShader.prototype.bindTextures =\nShader.prototype._bindTextures = function ()\n{\n    if (this._textureStackTex.length > this._cgl.maxTextureUnits)\n    {\n        this._log.warn(\"[shader._bindTextures] too many textures bound\", this._textureStackTex.length + \"/\" + this._cgl.maxTextureUnits);\n    }\n\n    // for (let i = this._textureStackTex.length + 1; i < this._cgl.maxTextureUnits; i++) this._cgl.setTexture(i, null);\n\n    for (let i = 0; i < this._textureStackTex.length; i++)\n    {\n        // console.log(this._textureStackTex.length, i);\n        if (!this._textureStackTex[i] && !this._textureStackTexCgl[i])\n        {\n            this._log.warn(\"no texture for pushtexture\", this._name);\n        }\n        else\n        {\n            let t = this._textureStackTex[i];\n            if (this._textureStackTexCgl[i])\n            {\n                t = this._textureStackTexCgl[i].tex || CGL.Texture.getEmptyTexture(this._cgl).tex;\n            }\n\n            let bindOk = true;\n\n            if (!this._textureStackUni[i])\n            {\n                // throw(new Error('no uniform given to texturestack'));\n                this._log.warn(\"no uniform for pushtexture\", this._name);\n                bindOk = this._cgl.setTexture(i, t, this._textureStackType[i]);\n            }\n            else\n            {\n                this._textureStackUni[i].setValue(i);\n                bindOk = this._cgl.setTexture(i, t, this._textureStackType[i]);\n\n                // console.log(bindOk, i, t, this._textureStackType[i]);\n            }\n            if (!bindOk) console.warn(\"tex bind failed\", this.getName(), this._textureStackUni[i]);\n        }\n    }\n};\n\nShader.prototype.setUniformTexture = function (uni, tex)\n{\n    tex = tex || CGL.Texture.getTempTexture(this._cgl);\n    for (let i = 0; i < this._textureStackUni.length; i++)\n        if (this._textureStackUni[i] == uni)\n        {\n            const old = this._textureStackTex[i] || this._textureStackTexCgl[i];\n            if (tex.hasOwnProperty(\"tex\"))\n            {\n                this._textureStackTexCgl[i] = tex;\n                this._textureStackTex[i] = null;\n            }\n            else\n            {\n                this._textureStackTexCgl[i] = null;\n                this._textureStackTex[i] = tex;\n            }\n\n            // this._textureStackTex[i] = tex;\n            // this._cgl.setTexture(i, tex, this._textureStackType[i]);\n            return old;\n        }\n    return null;\n};\n\n/**\n * push a texture on the stack. those textures will be bound when binding the shader. texture slots are automatically set\n * @param {uniform} texture uniform\n * @param {texture} texture\n * @param {type} texture type, can be ignored when TEXTURE_2D\n * @function pushTexture\n * @memberof Shader\n * @instance\n */\nShader.prototype.pushTexture = function (uniform, t, type)\n{\n    if (!uniform)\n    {\n        console.log(\"no uniform given to texturestack\", uniform);\n        return;\n    }\n    if (!t)\n    {\n        return;\n    }\n    if (!t.hasOwnProperty(\"tex\") && !(t instanceof WebGLTexture))\n    {\n        this._log.warn(new Error(\"invalid texture\").stack);\n\n        this._log.warn(\"[cgl_shader] invalid texture...\", t);\n        return;\n    }\n\n    this._textureStackUni.push(uniform);\n\n    if (t.hasOwnProperty(\"tex\"))\n    {\n        this._textureStackTexCgl.push(t);\n        this._textureStackTex.push(null);\n    }\n    else\n    {\n        this._textureStackTexCgl.push(null);\n        this._textureStackTex.push(t);\n    }\n\n    this._textureStackType.push(type);\n};\n\n/**\n * pop last texture\n * @function popTexture\n * @memberof Shader\n * @instance\n */\nShader.prototype.popTexture = function ()\n{\n    this._textureStackUni.pop();\n    this._textureStackTex.pop();\n    this._textureStackTexCgl.pop();\n    this._textureStackType.pop();\n};\n\n/**\n * pop all textures\n * @function popTextures\n * @memberof Shader\n * @instance\n */\nShader.prototype.popTextures = function ()\n{\n    this._textureStackTex.length =\n    this._textureStackTexCgl.length =\n    this._textureStackType.length =\n    this._textureStackUni.length = 0;\n};\n\nShader.prototype.getMaterialId = function ()\n{\n    return this._materialId;\n};\n\nShader.prototype.getInfo = function ()\n{\n    const info = {};\n    info.name = this._name;\n    // info.modules = JSON.parse(JSON.stringify(this._modules));\n    // info.defines = JSON.parse(JSON.stringify(this._defines));\n    info.defines = this.getDefines();\n    info.hasErrors = this.hasErrors();\n\n    return info;\n};\n\n// --------------------------\n\nShader.getErrorFragmentShader = function ()\n{\n    return \"\"\n        .endl() + \"void main()\"\n        .endl() + \"{\"\n        .endl() + \"   float g=mod((gl_FragCoord.y+gl_FragCoord.x),50.0)/50.0;\"\n        .endl() + \"   g= step(0.1,g);\"\n        .endl() + \"   outColor = vec4( g+0.5, 0.0, 0.0, 1.0);\"\n        .endl() + \"}\";\n};\n\nShader.createShader = function (cgl, str, type, cglShader)\n{\n    if (cgl.aborted) return;\n\n    // cgl.printError(\"[Shader.createShader] \", cglShader._name);\n\n    function getBadLines(infoLog)\n    {\n        const basLines = [];\n        const lines = infoLog.split(\"\\n\");\n        for (const i in lines)\n        {\n            const divide = lines[i].split(\":\");\n            if (parseInt(divide[2], 10)) basLines.push(parseInt(divide[2], 10));\n        }\n        return basLines;\n    }\n\n\n    const shader = cgl.gl.createShader(type);\n    cgl.gl.shaderSource(shader, str);\n    cgl.gl.compileShader(shader);\n\n    if (!cgl.gl.getShaderParameter(shader, cgl.gl.COMPILE_STATUS))\n    {\n        let infoLog = cgl.gl.getShaderInfoLog(shader);\n        if (!infoLog)\n        {\n            console.warn(\"empty shader info log\", this._name);\n            return;\n        }\n\n        console.log(\"compile status: \");\n\n        const badLines = getBadLines(infoLog);\n        let htmlWarning = \"<pre style=\\\"margin-bottom:0px;\\\"><code class=\\\"shaderErrorCode language-glsl\\\" style=\\\"padding-bottom:0px;max-height: initial;max-width: initial;\\\">\";\n        const lines = str.match(/^.*((\\r\\n|\\n|\\r)|$)/gm);\n\n        if (!cgl.aborted && infoLog)\n        {\n            if (type == cgl.gl.VERTEX_SHADER) console.log(\"VERTEX_SHADER\");\n            if (type == cgl.gl.FRAGMENT_SHADER) console.log(\"FRAGMENT_SHADER\");\n\n            for (const i in lines)\n            {\n                const j = parseInt(i, 10) + 1;\n                const line = j + \": \" + lines[i];\n                console.log(line);\n\n                let isBadLine = false;\n                for (const bj in badLines)\n                    if (badLines[bj] == j) isBadLine = true;\n\n                if (isBadLine)\n                {\n                    htmlWarning += \"</code></pre>\";\n                    // htmlWarning += \"<span class=\\\"shaderErrorCode error\\\">\";\n                    htmlWarning += \"<pre style=\\\"margin:0\\\"><code class=\\\"language-glsl\\\" style=\\\"background-color:#660000;padding-top:0px;padding-bottom:0px\\\">\";\n                }\n                htmlWarning += (0,_cgl_utils_js__WEBPACK_IMPORTED_MODULE_7__.escapeHTML)(line);\n\n                if (isBadLine)\n                {\n                    htmlWarning += \"</code></pre>\";\n                    htmlWarning += \"<pre style=\\\"margin:0\\\"><code class=\\\"language-glsl\\\" style=\\\";padding-top:0px;padding-bottom:0px\\\">\";\n                }\n            }\n        }\n\n        console.warn(infoLog);\n\n        infoLog = infoLog.replace(/\\n/g, \"<br/>\");\n        if (cgl.patch.isEditorMode())console.log(\"Shader error \", cglShader._name, infoLog, this);\n\n        htmlWarning = infoLog + \"<br/>\" + htmlWarning + \"<br/><br/>\";\n        htmlWarning += \"</code></pre>\";\n\n        cgl.patch.emitEvent(\"criticalError\", { \"title\": \"Shader error \" + cglShader._name, \"text\": htmlWarning, \"exception\": { \"message\": infoLog } });\n\n        // this._name = \"errorshader\";\n        cglShader.setSource(Shader.getDefaultVertexShader(), Shader.getErrorFragmentShader());\n    }\n    else\n    {\n        // console.log(name+' shader compiled...');\n    }\n    // cgl.printError(\"shader create2\");\n    return shader;\n};\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3NoYWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnbC9jZ2xfc2hhZGVyLmpzPzYxODMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcImNhYmxlcy1zaGFyZWQtY2xpZW50XCI7XG5pbXBvcnQgeyBTaGFkZXJMaWJNb2RzIH0gZnJvbSBcIi4vY2dsX3NoYWRlcl9saWIuanNcIjtcbmltcG9ydCB7IG5vdyB9IGZyb20gXCIuLi90aW1lci5qc1wiO1xuaW1wb3J0IHsgc2ltcGxlSWQgfSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IE1FU0ggfSBmcm9tIFwiLi9jZ2xfbWVzaC5qc1wiO1xuLy8gaW1wb3J0IHsgQ0dMIH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7IENPTlNUQU5UUyB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgZXNjYXBlSFRNTCB9IGZyb20gXCIuL2NnbF91dGlscy5qc1wiO1xuaW1wb3J0IGRlZmF1bHRTaGFkZXJTcmNWZXJ0IGZyb20gXCIuL2NnbF9zaGFkZXJfZGVmYXVsdF9nbHNsLnZlcnRcIjtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbi8qXG5cbnByb3Bvc2FsIGRlZmF1bHQgc2hhZGVyIHZhcmlhYmxlIG5hbWVzOlxuXG5hdHRyVmVydGV4IC0gY3VycmVudGx5OiB2UG9zaXRpb25cbmF0dHJWZXJ0ZXhJbmRleCAtIGN1cnJlbnRseTogYXR0clZlcnRJbmRleFxuYXR0clRleENvb3JkXG5hdHRySW5zdE1hdCAtIGN1cnJlbnRseTogaW5zdE1hdFxuYXR0clZlcnRDb2xvclxuYXR0clRhbmdlbnRcbmF0dHJCaVRhbmdlbnRcblxudVByb2pNYXRyaXggLSBjdXJyZW50bHk6IHByb2pNYXRyaXhcbnVNb2RlbE1hdHJpeCAtIGN1cnJlbnRseTogbW9kZWxNYXRyaXhcbnVOb3JtYWxNYXRyaXggLSBjdXJyZW50bHk6IG5vcm1hbE1hdHJpeFxudUNhbVBvc2l0aW9uIC0gY3VycmVudGx5OiBjYW1Qb3NcblxuKi9cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubGV0IG1hdGVyaWFsSWRDb3VudGVyID0gMDtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBleHRlcm5hbCBDR0xcbiAqIEBuYW1lc3BhY2UgU2hhZGVyXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKiBAZXhhbXBsZVxuICogdmFyIHNoYWRlcj1uZXcgQ0dMLlNoYWRlcihjZ2wsJ01pbmltYWxNYXRlcmlhbCcpO1xuICogc2hhZGVyLnNldFNvdXJjZShhdHRhY2htZW50cy5zaGFkZXJfdmVydCxhdHRhY2htZW50cy5zaGFkZXJfZnJhZyk7XG4gKi9cbmNvbnN0IFNoYWRlciA9IGZ1bmN0aW9uIChfY2dsLCBfbmFtZSwgX29wKVxue1xuICAgIGlmICghX2NnbCkgdGhyb3cgbmV3IEVycm9yKFwic2hhZGVyIGNvbnN0cnVjdGVkIHdpdGhvdXQgY2dsIFwiICsgX25hbWUpO1xuXG4gICAgdGhpcy5fbG9nID0gbmV3IExvZ2dlcihcImNnbF9zaGFkZXJcIik7XG4gICAgdGhpcy5fY2dsID0gX2NnbDtcblxuICAgIGlmICghX25hbWUpIHRoaXMuX2xvZy5zdGFjayhcIm5vIHNoYWRlciBuYW1lIGdpdmVuXCIpO1xuICAgIHRoaXMuX25hbWUgPSBfbmFtZSB8fCBcInVua25vd25cIjtcblxuICAgIGlmIChfb3ApIHRoaXMub3BJZCA9IF9vcC5pZDtcbiAgICB0aGlzLmdsc2xWZXJzaW9uID0gMDtcbiAgICBpZiAoX2NnbC5nbFZlcnNpb24gPiAxKSB0aGlzLmdsc2xWZXJzaW9uID0gMzAwO1xuXG4gICAgdGhpcy5fbWF0ZXJpYWxJZCA9ICsrbWF0ZXJpYWxJZENvdW50ZXI7XG5cbiAgICB0aGlzLmlkID0gc2ltcGxlSWQoKTtcbiAgICB0aGlzLl9pc1ZhbGlkID0gdHJ1ZTtcbiAgICB0aGlzLl9wcm9ncmFtID0gbnVsbDtcbiAgICB0aGlzLl91bmlmb3JtcyA9IFtdO1xuICAgIHRoaXMuX2RyYXdCdWZmZXJzID0gW3RydWVdO1xuICAgIHRoaXMuX2RlZmluZXMgPSBbXTtcbiAgICB0aGlzLl9uZWVkc1JlY29tcGlsZSA9IHRydWU7XG4gICAgdGhpcy5fY29tcGlsZVJlYXNvbiA9IFwiaW5pdGlhbFwiO1xuXG4gICAgdGhpcy5pZ25vcmVNaXNzaW5nVW5pZm9ybXMgPSBmYWxzZTtcbiAgICB0aGlzLl9wcm9qTWF0cml4VW5pZm9ybSA9IG51bGw7XG4gICAgdGhpcy5fbXZNYXRyaXhVbmlmb3JtID0gbnVsbDtcbiAgICB0aGlzLl9tTWF0cml4VW5pZm9ybSA9IG51bGw7XG4gICAgdGhpcy5fdk1hdHJpeFVuaWZvcm0gPSBudWxsO1xuICAgIHRoaXMuX2NhbVBvc1VuaWZvcm0gPSBudWxsO1xuICAgIHRoaXMuX25vcm1hbE1hdHJpeFVuaWZvcm0gPSBudWxsO1xuICAgIHRoaXMuX2ludmVyc2VWaWV3TWF0cml4VW5pZm9ybSA9IG51bGw7XG5cbiAgICB0aGlzLl9hdHRyVmVydGV4UG9zID0gLTE7XG4gICAgdGhpcy5wcmVjaXNpb24gPSBfY2dsLnBhdGNoLmNvbmZpZy5nbHNsUHJlY2lzaW9uIHx8IFwiaGlnaHBcIjtcblxuICAgIHRoaXMuX3BNYXRyaXhTdGF0ZSA9IC0xO1xuICAgIHRoaXMuX3ZNYXRyaXhTdGF0ZSA9IC0xO1xuXG4gICAgdGhpcy5fY291bnRNaXNzaW5nVW5pZm9ybXMgPSAwO1xuICAgIHRoaXMuX21vZEdyb3VwQ291bnQgPSAwOyAvLyBub3QgbmVlZGVkIGFueW1vcmUuLi5cbiAgICB0aGlzLl9mZWVkQmFja05hbWVzID0gW107XG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IFtdO1xuXG4gICAgdGhpcy5nbFByaW1pdGl2ZSA9IG51bGw7XG4gICAgdGhpcy5vZmZTY3JlZW5QYXNzID0gZmFsc2U7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IFtdO1xuICAgIHRoaXMuc3JjVmVydCA9IHRoaXMuZ2V0RGVmYXVsdFZlcnRleFNoYWRlcigpO1xuICAgIHRoaXMuc3JjRnJhZyA9IHRoaXMuZ2V0RGVmYXVsdEZyYWdtZW50U2hhZGVyKCk7XG4gICAgdGhpcy5sYXN0Q29tcGlsZSA9IDA7XG5cbiAgICB0aGlzLl9tb2R1bGVOYW1lcyA9IFtdO1xuICAgIHRoaXMuX21vZHVsZXMgPSBbXTtcbiAgICB0aGlzLl9tb2R1bGVOdW1JZCA9IDA7XG5cbiAgICB0aGlzLl9saWJzID0gW107XG4gICAgdGhpcy5fc3RydWN0TmFtZXMgPSBbXTtcbiAgICB0aGlzLl9zdHJ1Y3RVbmlmb3JtTmFtZXMgPSBbXTtcbiAgICB0aGlzLl90ZXh0dXJlU3RhY2tVbmkgPSBbXTtcbiAgICB0aGlzLl90ZXh0dXJlU3RhY2tUZXggPSBbXTtcbiAgICB0aGlzLl90ZXh0dXJlU3RhY2tUeXBlID0gW107XG4gICAgdGhpcy5fdGV4dHVyZVN0YWNrVGV4Q2dsID0gW107XG5cbiAgICB0aGlzLl90ZW1wTm9ybWFsTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgICB0aGlzLl90ZW1wQ2FtUG9zTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgICB0aGlzLl90ZW1wSW52ZXJzZVZpZXdNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuICAgIHRoaXMuX3RlbXBJbnZlcnNlUHJvak1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgICB0aGlzLnNldE1vZHVsZXMoW1wiTU9EVUxFX1ZFUlRFWF9QT1NJVElPTlwiLCBcIk1PRFVMRV9DT0xPUlwiLCBcIk1PRFVMRV9CRUdJTl9GUkFHXCIsIFwiTU9EVUxFX1ZFUlRFWF9NT1ZFTFZJRVdcIl0pO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbn07XG5cblNoYWRlci5wcm90b3R5cGUuZ2V0Q2dsID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fY2dsO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbn07XG5cbi8qKlxuICogZW5hYmxlIGFuIGV4dGVuc2lvbiBmb3IgdGhlIHNoYWRlclxuICogQGZ1bmN0aW9uIGVuYWJsZUV4dGVuc2lvblxuICogQG1lbWJlcm9mIFNoYWRlclxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0gbmFtZSBleHRlbnNpb24gbmFtZVxuICovXG5TaGFkZXIucHJvdG90eXBlLmVuYWJsZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIChuYW1lKVxue1xuICAgIHRoaXMuc2V0V2h5Q29tcGlsZShcImVuYWJsZSBleHRlbnNpb24gXCIgKyBuYW1lKTtcbiAgICB0aGlzLl9uZWVkc1JlY29tcGlsZSA9IHRydWU7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucy5wdXNoKG5hbWUpO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5nZXRBdHRyVmVydGV4UG9zID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fYXR0clZlcnRleFBvcztcbn07XG5cblNoYWRlci5wcm90b3R5cGUuaGFzVGV4dHVyZVVuaWZvcm1zID0gZnVuY3Rpb24gKClcbntcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3VuaWZvcm1zLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAodGhpcy5fdW5pZm9ybXNbaV0uZ2V0VHlwZSgpID09IFwidFwiKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLnNldFdoeUNvbXBpbGUgPSBmdW5jdGlvbiAod2h5KVxue1xuICAgIHRoaXMuX2NvbXBpbGVSZWFzb24gPSB3aHk7XG59O1xuXG4vKipcbiAqIGNvcHkgYWxsIHVuaWZvcm0gdmFsdWVzIGZyb20gYW5vdGhlciBzaGFkZXJcbiAqIEBmdW5jdGlvbiBjb3B5VW5pZm9ybXNcbiAqIEBtZW1iZXJvZiBTaGFkZXJcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHNoYWRlciB1bmlmb3JtIHZhbHVlcyB3aWxsIGJlIGNvcGllZCBmcm9tIHRoaXMgc2hhZGVyXG4gKi9cblNoYWRlci5wcm90b3R5cGUuY29weVVuaWZvcm1WYWx1ZXMgPSBmdW5jdGlvbiAob3JpZ1NoYWRlcilcbntcbiAgICAvLyBjb25zb2xlLmxvZyhvcmlnU2hhZGVyLl91bmlmb3Jtcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmlnU2hhZGVyLl91bmlmb3Jtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5fdW5pZm9ybXNbaV0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5sb2coXCJ1bmtub3duIHVuaWZvcm0/IVwiKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcy5fbG9nLmxvZyhvcmlnU2hhZGVyLl91bmlmb3Jtc1tpXS5nZXROYW1lKCkpO1xuICAgICAgICAvLyB0aGlzLmdldFVuaWZvcm0ob3JpZ1NoYWRlci5fdW5pZm9ybXNbaV0uKVxuICAgICAgICAvLyB0aGlzLl91bmlmb3Jtc1tpXS5zZXQob3JpZ1NoYWRlci5fdW5pZm9ybXNbaV0uZ2V0VmFsdWUoKSk7XG5cblxuICAgICAgICAvLyBpZiAob3JpZ1NoYWRlci5fdW5pZm9ybXNbaV0uZ2V0TmFtZSgpLmNvbnRhaW5zKFwicGF0aFBvaW50c1wiKSlcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKFwiY29weVVuaWZvcm1WYWx1ZXNcIiwgb3JpZ1NoYWRlci5fdW5pZm9ybXNbaV0uZ2V0TmFtZSgpLCBvcmlnU2hhZGVyLl91bmlmb3Jtc1tpXS5nZXRWYWx1ZSgpKTtcblxuICAgICAgICB0aGlzLmdldFVuaWZvcm0ob3JpZ1NoYWRlci5fdW5pZm9ybXNbaV0uZ2V0TmFtZSgpKS5zZXQob3JpZ1NoYWRlci5fdW5pZm9ybXNbaV0uZ2V0VmFsdWUoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5wb3BUZXh0dXJlcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZ1NoYWRlci5fdGV4dHVyZVN0YWNrVW5pLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdGV4dHVyZVN0YWNrVW5pW2ldID0gb3JpZ1NoYWRlci5fdGV4dHVyZVN0YWNrVW5pW2ldO1xuICAgICAgICB0aGlzLl90ZXh0dXJlU3RhY2tUZXhbaV0gPSBvcmlnU2hhZGVyLl90ZXh0dXJlU3RhY2tUZXhbaV07XG4gICAgICAgIHRoaXMuX3RleHR1cmVTdGFja1R5cGVbaV0gPSBvcmlnU2hhZGVyLl90ZXh0dXJlU3RhY2tUeXBlW2ldO1xuICAgICAgICB0aGlzLl90ZXh0dXJlU3RhY2tUZXhDZ2xbaV0gPSBvcmlnU2hhZGVyLl90ZXh0dXJlU3RhY2tUZXhDZ2xbaV07XG4gICAgfVxuXG4gICAgLy8gdGhpcy5fdGV4dHVyZVN0YWNrVW5pID0gW107XG4gICAgLy8gdGhpcy5fdGV4dHVyZVN0YWNrVGV4ID0gW107XG4gICAgLy8gdGhpcy5fdGV4dHVyZVN0YWNrVHlwZSA9IFtdO1xuICAgIC8vIHRoaXMuX3RleHR1cmVTdGFja1RleENnbCA9IFtdO1xufTtcblxuLyoqXG4gKiBjb3B5IGN1cnJlbnQgc2hhZGVyXG4gKiBAZnVuY3Rpb24gY29weVxuICogQG1lbWJlcm9mIFNoYWRlclxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJucyBuZXdTaGFkZXJcbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKClcbntcbiAgICBjb25zdCBzaGFkZXIgPSBuZXcgU2hhZGVyKHRoaXMuX2NnbCwgdGhpcy5fbmFtZSArIFwiIGNvcHlcIik7XG4gICAgc2hhZGVyLnNldFNvdXJjZSh0aGlzLnNyY1ZlcnQsIHRoaXMuc3JjRnJhZyk7XG5cbiAgICBzaGFkZXIuX21vZHVsZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuX21vZHVsZXMpKTtcbiAgICBzaGFkZXIuX2RlZmluZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuX2RlZmluZXMpKTtcblxuICAgIHNoYWRlci5fbW9kR3JvdXBDb3VudCA9IHRoaXMuX21vZEdyb3VwQ291bnQ7XG4gICAgc2hhZGVyLl9tb2R1bGVOYW1lcyA9IHRoaXMuX21vZHVsZU5hbWVzO1xuICAgIHNoYWRlci5nbFByaW1pdGl2ZSA9IHRoaXMuZ2xQcmltaXRpdmU7XG4gICAgc2hhZGVyLm9mZlNjcmVlblBhc3MgPSB0aGlzLm9mZlNjcmVlblBhc3M7XG4gICAgc2hhZGVyLl9leHRlbnNpb25zID0gdGhpcy5fZXh0ZW5zaW9ucztcbiAgICBzaGFkZXIud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XG4gICAgc2hhZGVyLl9hdHRyaWJ1dGVzID0gdGhpcy5fYXR0cmlidXRlcztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdW5pZm9ybXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBjb25zdCB1ID0gdGhpcy5fdW5pZm9ybXNbaV0uY29weShzaGFkZXIpO1xuICAgICAgICB1LnJlc2V0TG9jKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRXaHlDb21waWxlKFwiY29weVwiKTtcbiAgICBzaGFkZXIuX25lZWRzUmVjb21waWxlID0gdHJ1ZTtcbiAgICByZXR1cm4gc2hhZGVyO1xufTtcblxuXG4vKipcbiAqIHNldCBzaGFkZXIgc291cmNlIGNvZGVcbiAqIEBmdW5jdGlvbiBzZXRTb3VyY2VcbiAqIEBtZW1iZXJvZiBTaGFkZXJcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IHNyY1ZlcnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzcmNGcmFnXG4gKi9cblNoYWRlci5wcm90b3R5cGUuc2V0U291cmNlID0gZnVuY3Rpb24gKHNyY1ZlcnQsIHNyY0ZyYWcpXG57XG4gICAgdGhpcy5zcmNWZXJ0ID0gc3JjVmVydDtcbiAgICB0aGlzLnNyY0ZyYWcgPSBzcmNGcmFnO1xuICAgIHRoaXMuc2V0V2h5Q29tcGlsZShcIlNvdXJjZSBjaGFuZ2VkXCIpO1xuICAgIHRoaXMuX25lZWRzUmVjb21waWxlID0gdHJ1ZTtcbiAgICB0aGlzLl9pc1ZhbGlkID0gdHJ1ZTtcbn07XG5cblNoYWRlci5wcm90b3R5cGUuX2FkZExpYnMgPSBmdW5jdGlvbiAoc3JjKVxue1xuICAgIGZvciAoY29uc3QgaWQgaW4gU2hhZGVyTGliTW9kcylcbiAgICB7XG4gICAgICAgIGlmIChzcmMuY29udGFpbnMoaWQpKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBsaWIgPSBuZXcgU2hhZGVyTGliTW9kc1tpZF0oKTtcbiAgICAgICAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKFwie3tcIiArIGlkICsgXCJ9fVwiLCBsaWIuc3JjSGVhZEZyYWcpO1xuICAgICAgICAgICAgdGhpcy5fbGlicy5wdXNoKGxpYik7XG4gICAgICAgICAgICBpZiAobGliLmluaXRVbmlmb3JtcylsaWIuaW5pdFVuaWZvcm1zKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNyYztcbn07XG5cblNoYWRlci5wcm90b3R5cGUuY3JlYXRlU3RydWN0VW5pZm9ybXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIC8vICogY3JlYXRlIHN0cnVjdHNcbiAgICBsZXQgc3RydWN0U3RyRnJhZyA9IFwiXCI7XG4gICAgbGV0IHN0cnVjdFN0clZlcnQgPSBcIlwiOyAvLyBUT0RPOiBub3QgdXNlZCB5ZXRcblxuICAgIHRoaXMuX3N0cnVjdE5hbWVzID0gW107XG4gICAgLy8gKiByZXNldCB0aGUgYXJyYXlzIGhvbGRpbmcgdGhlIHZhbHVlIGVhY2ggcmVjb21waWxlIHNvIHdlIGRvbid0IHNraXAgc3RydWN0c1xuICAgIC8vICoga2V5IHZhbHVlIG1hcHBpbmcgc28gdGhlIHNhbWUgc3RydWN0IGNhbiBiZSBhZGRlZCB0d2ljZSAodHdvIHRpbWVzIHRoZSBzYW1lIG1vZGlmaWVyKVxuICAgIHRoaXMuX2luamVjdGVkU3RyaW5nc0ZyYWcgPSB7fTtcbiAgICB0aGlzLl9pbmplY3RlZFN0cmluZ3NWZXJ0ID0ge307XG5cbiAgICB0aGlzLl9zdHJ1Y3RVbmlmb3JtTmFtZXNJbmRpY2VzRnJhZyA9IFtdO1xuICAgIHRoaXMuX3N0cnVjdFVuaWZvcm1OYW1lc0luZGljZXNWZXJ0ID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3VuaWZvcm1zLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgLy8gKiBvbmx5IGFkZCB1bmlmb3JtcyB0byBzdHJ1Y3QgdGhhdCBhcmUgYSBtZW1iZXIgb2YgYSBzdHJ1Y3RcbiAgICAgICAgaWYgKHRoaXMuX3VuaWZvcm1zW2ldLmlzU3RydWN0TWVtYmVyKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGluamVjdGlvblN0cmluZyA9IFwie3tJTkpFQ1RJT05fUE9JTlRfU1RSVUNUX1wiICsgdGhpcy5fdW5pZm9ybXNbaV0uX3N0cnVjdE5hbWUgKyBcIn19XCI7XG5cbiAgICAgICAgICAgIC8vICogY2hlY2sgaWYgc3RydWN0IGlzIG5vdCBhbHJlYWR5IHBhcnQgb2Ygc2hhZGVyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0cnVjdE5hbWVzLmluY2x1ZGVzKHRoaXMuX3VuaWZvcm1zW2ldLl9zdHJ1Y3ROYW1lKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyAqIGNyZWF0ZSBzdHJ1Y3QgZGVmaW5pdGlvbiB3aXRoIHBsYWNlaG9sZGVyIHN0cmluZyB0byBpbmplY3RcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJ1Y3REZWZpbml0aW9uID0gXCJzdHJ1Y3QgXCJcbiAgICAgICAgICAgICAgICAgICAgKyB0aGlzLl91bmlmb3Jtc1tpXS5fc3RydWN0TmFtZSArIFwiIHtcIi5lbmRsKClcbiAgICAgICAgICAgICAgICAgICAgKyBpbmplY3Rpb25TdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgKyBcIn07XCIuZW5kbCgpLmVuZGwoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91bmlmb3Jtc1tpXS5nZXRTaGFkZXJUeXBlKCkgPT09IFwiYm90aFwiIHx8IHRoaXMuX3VuaWZvcm1zW2ldLmdldFNoYWRlclR5cGUoKSA9PT0gXCJmcmFnXCIpXG4gICAgICAgICAgICAgICAgICAgIHN0cnVjdFN0ckZyYWcgPSBzdHJ1Y3RTdHJGcmFnLmNvbmNhdChzdHJ1Y3REZWZpbml0aW9uKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91bmlmb3Jtc1tpXS5nZXRTaGFkZXJUeXBlKCkgPT09IFwiYm90aFwiIHx8IHRoaXMuX3VuaWZvcm1zW2ldLmdldFNoYWRlclR5cGUoKSA9PT0gXCJ2ZXJ0XCIpXG4gICAgICAgICAgICAgICAgICAgIHN0cnVjdFN0clZlcnQgPSBzdHJ1Y3RTdHJWZXJ0LmNvbmNhdChzdHJ1Y3REZWZpbml0aW9uKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3N0cnVjdE5hbWVzLnB1c2godGhpcy5fdW5pZm9ybXNbaV0uX3N0cnVjdE5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luamVjdGVkU3RyaW5nc0ZyYWdbdGhpcy5fdW5pZm9ybXNbaV0uX3N0cnVjdE5hbWVdID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5faW5qZWN0ZWRTdHJpbmdzVmVydFt0aGlzLl91bmlmb3Jtc1tpXS5fc3RydWN0TmFtZV0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gKiBjcmVhdGUgbWVtYmVyICYgY29tbWVudFxuICAgICAgICAgICAgbGV0IGNvbW1lbnQgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VuaWZvcm1zW2ldLmNvbW1lbnQpIGNvbW1lbnQgPSBcIiAvLyBcIiArIHRoaXMuX3VuaWZvcm1zW2ldLmNvbW1lbnQ7XG5cbiAgICAgICAgICAgIGxldCBzdHJpbmdUb0luc2VydCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5fdW5pZm9ybXNbaV0uZ2V0R2xzbFR5cGVTdHJpbmcoKSA9PSB1bmRlZmluZWQpc3RyaW5nVG9JbnNlcnQgKz0gXCIvL1wiO1xuICAgICAgICAgICAgc3RyaW5nVG9JbnNlcnQgKz0gXCIgIFwiICsgdGhpcy5fdW5pZm9ybXNbaV0uZ2V0R2xzbFR5cGVTdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICArIFwiIFwiICsgdGhpcy5fdW5pZm9ybXNbaV0uX3Byb3BlcnR5TmFtZSArIFwiO1wiXG4gICAgICAgICAgICAgICAgICAgICsgY29tbWVudDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3VuaWZvcm1zW2ldLmdldFNoYWRlclR5cGUoKSA9PT0gXCJib3RoXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gKiBpbmplY3QgbWVtYmVyIGJlZm9yZSB7aW5qZWN0aW9uU3RyaW5nfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2luamVjdGVkU3RyaW5nc0ZyYWdbdGhpcy5fdW5pZm9ybXNbaV0uX3N0cnVjdE5hbWVdLmNvbnRhaW5zKHN0cmluZ1RvSW5zZXJ0KVxuICAgICAgICAgICAgICAgICYmICF0aGlzLl9pbmplY3RlZFN0cmluZ3NWZXJ0W3RoaXMuX3VuaWZvcm1zW2ldLl9zdHJ1Y3ROYW1lXS5jb250YWlucyhzdHJpbmdUb0luc2VydCkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnNlcnRpb25JbmRleEZyYWcgPSBzdHJ1Y3RTdHJGcmFnLmxhc3RJbmRleE9mKGluamVjdGlvblN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc2VydGlvbkluZGV4VmVydCA9IHN0cnVjdFN0clZlcnQubGFzdEluZGV4T2YoaW5qZWN0aW9uU3RyaW5nKTtcblxuICAgICAgICAgICAgICAgICAgICBzdHJ1Y3RTdHJGcmFnID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cnVjdFN0ckZyYWcuc2xpY2UoMCwgaW5zZXJ0aW9uSW5kZXhGcmFnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBzdHJpbmdUb0luc2VydCArIHN0cnVjdFN0ckZyYWcuc2xpY2UoaW5zZXJ0aW9uSW5kZXhGcmFnIC0gMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RydWN0U3RyVmVydCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJ1Y3RTdHJWZXJ0LnNsaWNlKDAsIGluc2VydGlvbkluZGV4VmVydClcbiAgICAgICAgICAgICAgICAgICAgICAgICsgc3RyaW5nVG9JbnNlcnQgKyBzdHJ1Y3RTdHJWZXJ0LnNsaWNlKGluc2VydGlvbkluZGV4VmVydCAtIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luamVjdGVkU3RyaW5nc0ZyYWdbdGhpcy5fdW5pZm9ybXNbaV0uX3N0cnVjdE5hbWVdLnB1c2goc3RyaW5nVG9JbnNlcnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmplY3RlZFN0cmluZ3NWZXJ0W3RoaXMuX3VuaWZvcm1zW2ldLl9zdHJ1Y3ROYW1lXS5wdXNoKHN0cmluZ1RvSW5zZXJ0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0cnVjdFVuaWZvcm1OYW1lc0luZGljZXNGcmFnLmluY2x1ZGVzKGkpKSB0aGlzLl9zdHJ1Y3RVbmlmb3JtTmFtZXNJbmRpY2VzRnJhZy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RydWN0VW5pZm9ybU5hbWVzSW5kaWNlc1ZlcnQuaW5jbHVkZXMoaSkpIHRoaXMuX3N0cnVjdFVuaWZvcm1OYW1lc0luZGljZXNWZXJ0LnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl91bmlmb3Jtc1tpXS5nZXRTaGFkZXJUeXBlKCkgPT09IFwiZnJhZ1wiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vICogaW5qZWN0IG1lbWJlciBiZWZvcmUge2luamVjdGlvblN0cmluZ31cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2luamVjdGVkU3RyaW5nc0ZyYWdbdGhpcy5fdW5pZm9ybXNbaV0uX3N0cnVjdE5hbWVdLmluY2x1ZGVzKHN0cmluZ1RvSW5zZXJ0KSkgLy9cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc2VydGlvbkluZGV4RnJhZyA9IHN0cnVjdFN0ckZyYWcubGFzdEluZGV4T2YoaW5qZWN0aW9uU3RyaW5nKTtcblxuICAgICAgICAgICAgICAgICAgICBzdHJ1Y3RTdHJGcmFnID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cnVjdFN0ckZyYWcuc2xpY2UoMCwgaW5zZXJ0aW9uSW5kZXhGcmFnKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBzdHJpbmdUb0luc2VydCArIHN0cnVjdFN0ckZyYWcuc2xpY2UoaW5zZXJ0aW9uSW5kZXhGcmFnIC0gMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5qZWN0ZWRTdHJpbmdzRnJhZ1t0aGlzLl91bmlmb3Jtc1tpXS5fc3RydWN0TmFtZV0ucHVzaChzdHJpbmdUb0luc2VydCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdHJ1Y3RVbmlmb3JtTmFtZXNJbmRpY2VzRnJhZy5pbmNsdWRlcyhpKSkgdGhpcy5fc3RydWN0VW5pZm9ybU5hbWVzSW5kaWNlc0ZyYWcucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3VuaWZvcm1zW2ldLmdldFNoYWRlclR5cGUoKSA9PT0gXCJ2ZXJ0XCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gKiBpbmplY3QgbWVtYmVyIGJlZm9yZSB7aW5qZWN0aW9uU3RyaW5nfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faW5qZWN0ZWRTdHJpbmdzVmVydFt0aGlzLl91bmlmb3Jtc1tpXS5fc3RydWN0TmFtZV0uaW5jbHVkZXMoc3RyaW5nVG9JbnNlcnQpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0aW9uSW5kZXhWZXJ0ID0gc3RydWN0U3RyVmVydC5sYXN0SW5kZXhPZihpbmplY3Rpb25TdHJpbmcpO1xuXG4gICAgICAgICAgICAgICAgICAgIHN0cnVjdFN0clZlcnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0U3RyVmVydC5zbGljZSgwLCBpbnNlcnRpb25JbmRleFZlcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICArIHN0cmluZ1RvSW5zZXJ0ICsgc3RydWN0U3RyVmVydC5zbGljZShpbnNlcnRpb25JbmRleFZlcnQgLSAxKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmplY3RlZFN0cmluZ3NWZXJ0W3RoaXMuX3VuaWZvcm1zW2ldLl9zdHJ1Y3ROYW1lXS5wdXNoKHN0cmluZ1RvSW5zZXJ0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0cnVjdFVuaWZvcm1OYW1lc0luZGljZXNWZXJ0LmluY2x1ZGVzKGkpKSB0aGlzLl9zdHJ1Y3RVbmlmb3JtTmFtZXNJbmRpY2VzVmVydC5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gKiBkZWR1cGUgaW5qZWN0ZWQgdW5pIGRlY2xhcmF0aW9uc1xuICAgIHRoaXMuX3VuaURlY2xhcmF0aW9uc0ZyYWcgPSBbXTtcbiAgICB0aGlzLl91bmlEZWNsYXJhdGlvbnNWZXJ0ID0gW107XG5cbiAgICAvLyAqIHJlbW92ZSBzdHJ1Y3QgaW5qZWN0aW9uIHBvaW50cyBhbmQgYWRkIHVuaWZvcm0gaW4gZnJhZ21lbnRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3N0cnVjdFVuaWZvcm1OYW1lc0luZGljZXNGcmFnLmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9zdHJ1Y3RVbmlmb3JtTmFtZXNJbmRpY2VzRnJhZ1tpXTtcbiAgICAgICAgY29uc3QgdW5pRGVjbGFyYXRpb25TdHJpbmcgPSBcIlVOSSBcIiArIHRoaXMuX3VuaWZvcm1zW2luZGV4XS5fc3RydWN0TmFtZSArIFwiIFwiICsgdGhpcy5fdW5pZm9ybXNbaW5kZXhdLl9zdHJ1Y3RVbmlmb3JtTmFtZSArIFwiO1wiLmVuZGwoKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3VuaURlY2xhcmF0aW9uc0ZyYWcuaW5jbHVkZXModW5pRGVjbGFyYXRpb25TdHJpbmcpKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBpbmplY3Rpb25TdHJpbmcgPSBcInt7SU5KRUNUSU9OX1BPSU5UX1NUUlVDVF9cIiArIHRoaXMuX3VuaWZvcm1zW2luZGV4XS5fc3RydWN0TmFtZSArIFwifX1cIjtcblxuICAgICAgICAgICAgc3RydWN0U3RyRnJhZyA9IHN0cnVjdFN0ckZyYWcucmVwbGFjZShpbmplY3Rpb25TdHJpbmcsIFwiXCIpO1xuICAgICAgICAgICAgc3RydWN0U3RyRnJhZyArPSB1bmlEZWNsYXJhdGlvblN0cmluZztcblxuICAgICAgICAgICAgdGhpcy5fdW5pRGVjbGFyYXRpb25zRnJhZy5wdXNoKHVuaURlY2xhcmF0aW9uU3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vICogcmVtb3ZlIHN0cnVjdCBpbmplY3Rpb24gcG9pbnRzIGFuZCBhZGQgdW5pZm9ybSBpbiB2ZXJ0ZXhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3N0cnVjdFVuaWZvcm1OYW1lc0luZGljZXNWZXJ0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9zdHJ1Y3RVbmlmb3JtTmFtZXNJbmRpY2VzVmVydFtpXTtcbiAgICAgICAgY29uc3QgdW5pRGVjbGFyYXRpb25TdHJpbmcgPSBcIlVOSSBcIiArIHRoaXMuX3VuaWZvcm1zW2luZGV4XS5fc3RydWN0TmFtZSArIFwiIFwiICsgdGhpcy5fdW5pZm9ybXNbaW5kZXhdLl9zdHJ1Y3RVbmlmb3JtTmFtZSArIFwiO1wiLmVuZGwoKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3VuaURlY2xhcmF0aW9uc1ZlcnQuaW5jbHVkZXModW5pRGVjbGFyYXRpb25TdHJpbmcpKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBpbmplY3Rpb25TdHJpbmcgPSBcInt7SU5KRUNUSU9OX1BPSU5UX1NUUlVDVF9cIiArIHRoaXMuX3VuaWZvcm1zW2luZGV4XS5fc3RydWN0TmFtZSArIFwifX1cIjtcblxuICAgICAgICAgICAgc3RydWN0U3RyVmVydCA9IHN0cnVjdFN0clZlcnQucmVwbGFjZShpbmplY3Rpb25TdHJpbmcsIFwiXCIpO1xuICAgICAgICAgICAgc3RydWN0U3RyVmVydCArPSB1bmlEZWNsYXJhdGlvblN0cmluZztcbiAgICAgICAgICAgIHRoaXMuX3VuaURlY2xhcmF0aW9uc1ZlcnQucHVzaCh1bmlEZWNsYXJhdGlvblN0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3N0cnVjdFN0clZlcnQsIHN0cnVjdFN0ckZyYWddO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5fZ2V0QXR0clNyYyA9IGZ1bmN0aW9uIChhdHRyLCBmaXJzdExldmVsKVxue1xuICAgIGNvbnN0IHIgPSB7fTtcbiAgICBpZiAoYXR0ci5uYW1lICYmIGF0dHIudHlwZSlcbiAgICB7XG4gICAgICAgIHIuc3JjSGVhZFZlcnQgPSBcIlwiO1xuICAgICAgICBpZiAoIWZpcnN0TGV2ZWwpIHIuc3JjSGVhZFZlcnQgKz0gXCIjaWZuZGVmIEFUVFJJQl9cIiArIGF0dHIubmFtZS5lbmRsKCk7XG4gICAgICAgIHIuc3JjSGVhZFZlcnQgKz0gXCIjZGVmaW5lIEFUVFJJQl9cIiArIGF0dHIubmFtZS5lbmRsKCk7XG4gICAgICAgIHIuc3JjSGVhZFZlcnQgKz0gXCJJTiBcIiArIGF0dHIudHlwZSArIFwiIFwiICsgYXR0ci5uYW1lICsgXCI7XCIuZW5kbCgpO1xuICAgICAgICBpZiAoIWZpcnN0TGV2ZWwpIHIuc3JjSGVhZFZlcnQgKz0gXCIjZW5kaWZcIi5lbmRsKCk7XG5cbiAgICAgICAgaWYgKGF0dHIubmFtZUZyYWcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHIuc3JjSGVhZFZlcnQgKz0gXCJcIjtcbiAgICAgICAgICAgIGlmICghZmlyc3RMZXZlbCkgci5zcmNIZWFkVmVydCArPSBcIiNpZm5kZWYgQVRUUklCX1wiICsgYXR0ci5uYW1lRnJhZy5lbmRsKCk7XG4gICAgICAgICAgICByLnNyY0hlYWRWZXJ0ICs9IFwiI2RlZmluZSBBVFRSSUJfXCIgKyBhdHRyLm5hbWVGcmFnLmVuZGwoKTtcbiAgICAgICAgICAgIHIuc3JjSGVhZFZlcnQgKz0gXCJPVVQgXCIgKyBhdHRyLnR5cGUgKyBcIiBcIiArIGF0dHIubmFtZUZyYWcgKyBcIjtcIi5lbmRsKCk7XG4gICAgICAgICAgICBpZiAoIWZpcnN0TGV2ZWwpIHIuc3JjSGVhZFZlcnQgKz0gXCIjZW5kaWZcIi5lbmRsKCk7XG5cbiAgICAgICAgICAgIHIuc3JjVmVydCA9IFwiXCIuZW5kbCgpICsgYXR0ci5uYW1lRnJhZyArIFwiPVwiICsgYXR0ci5uYW1lICsgXCI7XCI7XG5cbiAgICAgICAgICAgIHIuc3JjSGVhZEZyYWcgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKCFmaXJzdExldmVsKSByLnNyY0hlYWRGcmFnICs9IFwiI2lmbmRlZiBBVFRSSUJfXCIgKyBhdHRyLm5hbWVGcmFnLmVuZGwoKTtcbiAgICAgICAgICAgIHIuc3JjSGVhZEZyYWcgKz0gXCIjZGVmaW5lIEFUVFJJQl9cIiArIGF0dHIubmFtZUZyYWcuZW5kbCgpO1xuICAgICAgICAgICAgci5zcmNIZWFkRnJhZyArPSBcIklOIFwiICsgYXR0ci50eXBlICsgXCIgXCIgKyBhdHRyLm5hbWVGcmFnICsgXCI7XCIuZW5kbCgpO1xuICAgICAgICAgICAgaWYgKCFmaXJzdExldmVsKSByLnNyY0hlYWRGcmFnICs9IFwiI2VuZGlmXCIuZW5kbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fY2dsLmFib3J0ZWQpIHJldHVybjtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuXG5cbiAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVNoYWRlckNvbXBpbGVzKys7XG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaGFkZXJDb21waWxlTmFtZSA9IHRoaXMuX25hbWUgKyBcIiBbXCIgKyB0aGlzLl9jb21waWxlUmVhc29uICsgXCJdXCI7XG5cbiAgICBsZXQgZXh0ZW5zaW9uU3RyaW5nID0gXCJcIjtcbiAgICBpZiAodGhpcy5fZXh0ZW5zaW9ucylcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9leHRlbnNpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZXh0ZW5zaW9uU3RyaW5nICs9IFwiI2V4dGVuc2lvbiBcIiArIHRoaXMuX2V4dGVuc2lvbnNbaV0gKyBcIiA6IGVuYWJsZVwiLmVuZGwoKTtcblxuICAgIGxldCBkZWZpbmVzU3RyID0gXCJcIjtcbiAgICBpZiAodGhpcy5fZGVmaW5lcy5sZW5ndGgpIGRlZmluZXNTdHIgPSBcIlxcbi8vIGNnbCBnZW5lcmF0ZWRcIi5lbmRsKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9kZWZpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBkZWZpbmVzU3RyICs9IFwiI2RlZmluZSBcIiArIHRoaXMuX2RlZmluZXNbaV1bMF0gKyBcIiBcIiArIHRoaXMuX2RlZmluZXNbaV1bMV0gKyBcIlwiLmVuZGwoKTtcblxuICAgIGNvbnN0IHN0cnVjdFN0cmluZ3MgPSB0aGlzLmNyZWF0ZVN0cnVjdFVuaWZvcm1zKCk7XG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLmFkZEhlYXZ5RXZlbnQoXCJzaGFkZXIgY29tcGlsZVwiLCB0aGlzLl9uYW1lICsgXCIgW1wiICsgdGhpcy5fY29tcGlsZVJlYXNvbiArIFwiXVwiKTtcbiAgICB0aGlzLl9jb21waWxlUmVhc29uID0gXCJcIjtcblxuXG5cbiAgICBpZiAodGhpcy5fdW5pZm9ybXMpXG4gICAge1xuICAgICAgICAvLyAqIHdlIGNyZWF0ZSBhbiBhcnJheSBvZiB0aGUgdW5pZm9ybSBuYW1lcyB0byBjaGVjayBvdXIgaW5kaWNlcyAmIGFuIGFycmF5IHRvIHNhdmUgdGhlbVxuICAgICAgICBjb25zdCB1bmlOYW1lcyA9IHRoaXMuX3VuaWZvcm1zLm1hcCgodW5pKSA9PiB7IHJldHVybiB1bmkuX25hbWU7IH0pO1xuICAgICAgICBjb25zdCBpbmRpY2VzVG9SZW1vdmUgPSBbXTtcblxuICAgICAgICAvLyAqIHdlIGdvIHRocm91Z2ggb3VyIHVuaWZvcm1zIGFuZCBjaGVjayBpZiB0aGUgc2FtZSBuYW1lIGlzIGNvbnRhaW5lZCBzb21ld2hlcmUgZnVydGhlciBpbiB0aGUgYXJyYXlcbiAgICAgICAgLy8gKiBpZiBzbywgd2UgYWRkIHRoZSBjdXJyZW50IGluZGV4IHRvIGJlIHJlbW92ZWQgbGF0ZXJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl91bmlmb3Jtcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdW5pID0gdGhpcy5fdW5pZm9ybXNbaV07XG4gICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB1bmlOYW1lcy5pbmRleE9mKHVuaS5fbmFtZSwgaSArIDEpO1xuICAgICAgICAgICAgaWYgKG5leHRJbmRleCA+IC0xKSBpbmRpY2VzVG9SZW1vdmUucHVzaChpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICogYWZ0ZXIgdGhhdCwgd2UgZ28gdGhyb3VnaCB0aGUgdW5pZm9ybXMgYmFja3dhcmRzIChzbyB3ZSBrZWVwIHRoZSBvcmRlcikgYW5kIHJlbW92ZSB0aGUgaW5kaWNlc1xuICAgICAgICAvLyAqIGFsc28sIHdlIHJlc2V0IHRoZSBsb2NhdGlvbnMgb2YgYWxsIHRoZSBvdGhlciB2YWxpZCB1bmlmb3Jtc1xuICAgICAgICBmb3IgKGxldCBqID0gdGhpcy5fdW5pZm9ybXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqIC09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpbmRpY2VzVG9SZW1vdmUuaW5jbHVkZXMoaikpIHRoaXMuX3VuaWZvcm1zLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5fdW5pZm9ybXNbal0ucmVzZXRMb2MoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2NnbC5wcmludEVycm9yKFwidW5pZm9ybSByZXNldHNcIik7XG5cbiAgICBpZiAodGhpcy5oYXNUZXh0dXJlVW5pZm9ybXMoKSkgZGVmaW5lc1N0ciArPSBcIiNkZWZpbmUgSEFTX1RFWFRVUkVTXCIuZW5kbCgpO1xuXG4gICAgbGV0IHZzID0gXCJcIjtcbiAgICBsZXQgZnMgPSBcIlwiO1xuXG4gICAgaWYgKCF0aGlzLnNyY0ZyYWcpXG4gICAge1xuICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJbY2dsIHNoYWRlcl0gaGFzIG5vIGZyYWdtZW50IHNvdXJjZSFcIiwgdGhpcyk7XG4gICAgICAgIHRoaXMuc3JjVmVydCA9IHRoaXMuZ2V0RGVmYXVsdFZlcnRleFNoYWRlcigpO1xuICAgICAgICB0aGlzLnNyY0ZyYWcgPSB0aGlzLmdldERlZmF1bHRGcmFnbWVudFNoYWRlcigpO1xuICAgICAgICAvLyByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ2xzbFZlcnNpb24gPT0gMzAwKVxuICAgIHtcbiAgICAgICAgdnMgPSBcIiN2ZXJzaW9uIDMwMCBlc1wiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIvLyBcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiLy8gdmVydGV4IHNoYWRlciBcIiArIHRoaXMuX25hbWVcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIi8vIFwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCJwcmVjaXNpb24gXCIgKyB0aGlzLnByZWNpc2lvbiArIFwiIGZsb2F0O1wiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCJwcmVjaXNpb24gXCIgKyB0aGlzLnByZWNpc2lvbiArIFwiIHNhbXBsZXIyRDtcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIiNkZWZpbmUgV0VCR0wyXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIiNkZWZpbmUgdGV4dHVyZTJEIHRleHR1cmVcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiI2RlZmluZSBVTkkgdW5pZm9ybVwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIjZGVmaW5lIElOIGluXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIiNkZWZpbmUgT1VUIG91dFwiXG4gICAgICAgICAgICAuZW5kbCgpO1xuXG4gICAgICAgIGZzID0gXCIjdmVyc2lvbiAzMDAgZXNcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiLy8gXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIi8vIGZyYWdtZW50IHNoYWRlciBcIiArIHRoaXMuX25hbWVcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIi8vIFwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCJwcmVjaXNpb24gXCIgKyB0aGlzLnByZWNpc2lvbiArIFwiIGZsb2F0O1wiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCJwcmVjaXNpb24gXCIgKyB0aGlzLnByZWNpc2lvbiArIFwiIHNhbXBsZXIyRDtcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIiNkZWZpbmUgV0VCR0wyXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIiNkZWZpbmUgdGV4dHVyZTJEIHRleHR1cmVcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiI2RlZmluZSBJTiBpblwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIjZGVmaW5lIE9VVCBvdXRcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiI2RlZmluZSBVTkkgdW5pZm9ybVwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCJ7e0RSQVdCVUZGRVJ9fVwiXG5cbiAgICAgICAgICAgIC5lbmRsKCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGZzID0gXCJcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiLy8gXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIi8vIGZyYWdtZW50IHNoYWRlciBcIiArIHRoaXMuX25hbWVcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIi8vIFwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIjZGVmaW5lIFdFQkdMMVwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIjZGVmaW5lIHRleHR1cmUgdGV4dHVyZTJEXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIiNkZWZpbmUgb3V0Q29sb3IgZ2xfRnJhZ0NvbG9yXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIiNkZWZpbmUgSU4gdmFyeWluZ1wiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIjZGVmaW5lIFVOSSB1bmlmb3JtXCJcbiAgICAgICAgICAgIC5lbmRsKCk7XG5cbiAgICAgICAgdnMgPSBcIlwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIvLyBcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiLy8gdmVydGV4IHNoYWRlciBcIiArIHRoaXMuX25hbWVcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIi8vIFwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIjZGVmaW5lIFdFQkdMMVwiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIjZGVmaW5lIHRleHR1cmUgdGV4dHVyZTJEXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIiNkZWZpbmUgT1VUIHZhcnlpbmdcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiI2RlZmluZSBJTiBhdHRyaWJ1dGVcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiI2RlZmluZSBVTkkgdW5pZm9ybVwiXG4gICAgICAgICAgICAuZW5kbCgpO1xuICAgIH1cblxuICAgIGxldCB1bmlmb3Jtc1N0clZlcnQgPSBcIlxcbi8vIGNnbCBnZW5lcmF0ZWRcIi5lbmRsKCk7XG4gICAgbGV0IHVuaWZvcm1zU3RyRnJhZyA9IFwiXFxuLy8gY2dsIGdlbmVyYXRlZFwiLmVuZGwoKTtcblxuXG4gICAgZnMgKz0gXCJcXG4vLyBhY3RpdmUgbW9kczogLS0tLS0tLS0tLS0tLS0tIFwiO1xuICAgIHZzICs9IFwiXFxuLy8gYWN0aXZlIG1vZHM6IC0tLS0tLS0tLS0tLS0tLSBcIjtcblxuICAgIGxldCBmb3VuZE1vZHNGcmFnID0gZmFsc2U7XG4gICAgbGV0IGZvdW5kTW9kc1ZlcnQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX21vZHVsZU5hbWVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl9tb2R1bGVzLmxlbmd0aDsgaisrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbW9kdWxlc1tqXS5uYW1lID09IHRoaXMuX21vZHVsZU5hbWVzW2ldKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb2R1bGVzW2pdLnNyY0JvZHlGcmFnIHx8IHRoaXMuX21vZHVsZXNbal0uc3JjSGVhZEZyYWcpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZE1vZHNGcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZnMgKz0gXCJcXG4vLyBcIiArIGkgKyBcIi5cIiArIGogKyBcIi4gXCIgKyB0aGlzLl9tb2R1bGVzW2pdLnRpdGxlICsgXCIgKFwiICsgdGhpcy5fbW9kdWxlc1tqXS5uYW1lICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb2R1bGVzW2pdLnNyY0JvZHlWZXJ0IHx8IHRoaXMuX21vZHVsZXNbal0uc3JjSGVhZFZlcnQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2cyArPSBcIlxcbi8vIFwiICsgaSArIFwiLlwiICsgaiArIFwiLiBcIiArIHRoaXMuX21vZHVsZXNbal0udGl0bGUgKyBcIiAoXCIgKyB0aGlzLl9tb2R1bGVzW2pdLm5hbWUgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRNb2RzVmVydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghZm91bmRNb2RzVmVydClmcyArPSBcIlxcbi8vIG5vIG1vZHMgdXNlZC4uLlwiO1xuICAgIGlmICghZm91bmRNb2RzRnJhZylmcyArPSBcIlxcbi8vIG5vIG1vZHMgdXNlZC4uLlwiO1xuICAgIGZzICs9IFwiXFxuXCI7XG4gICAgdnMgKz0gXCJcXG5cIjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdW5pZm9ybXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fdW5pZm9ybXNbaV0uc2hhZGVyVHlwZSAmJiAhdGhpcy5fdW5pZm9ybXNbaV0uaXNTdHJ1Y3RNZW1iZXIoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHVuaVN0ciA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3VuaWZvcm1zW2ldLmdldEdsc2xUeXBlU3RyaW5nKCkpdW5pU3RyICs9IFwiLy8gXCI7XG4gICAgICAgICAgICB1bmlTdHIgKz0gXCJVTkkgXCIgKyB0aGlzLl91bmlmb3Jtc1tpXS5nZXRHbHNsVHlwZVN0cmluZygpICsgXCIgXCIgKyB0aGlzLl91bmlmb3Jtc1tpXS5nZXROYW1lKCk7XG4gICAgICAgICAgICBsZXQgY29tbWVudCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5fdW5pZm9ybXNbaV0uY29tbWVudCkgY29tbWVudCA9IFwiIC8vIFwiICsgdGhpcy5fdW5pZm9ybXNbaV0uY29tbWVudDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3VuaWZvcm1zW2ldLnNoYWRlclR5cGUgPT0gXCJ2ZXJ0XCIgfHwgdGhpcy5fdW5pZm9ybXNbaV0uc2hhZGVyVHlwZSA9PSBcImJvdGhcIilcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3JjVmVydC5jb250YWlucyh1bmlTdHIpICYmICF0aGlzLnNyY1ZlcnQuY29udGFpbnMoXCJ1bmlmb3JtIFwiICsgdGhpcy5fdW5pZm9ybXNbaV0uZ2V0R2xzbFR5cGVTdHJpbmcoKSArIFwiIFwiICsgdGhpcy5fdW5pZm9ybXNbaV0uZ2V0TmFtZSgpKSlcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybXNTdHJWZXJ0ICs9IHVuaVN0ciArIFwiO1wiICsgY29tbWVudC5lbmRsKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl91bmlmb3Jtc1tpXS5zaGFkZXJUeXBlID09IFwiZnJhZ1wiIHx8IHRoaXMuX3VuaWZvcm1zW2ldLnNoYWRlclR5cGUgPT0gXCJib3RoXCIpXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNyY0ZyYWcuY29udGFpbnModW5pU3RyKSAmJiAhdGhpcy5zcmNGcmFnLmNvbnRhaW5zKFwidW5pZm9ybSBcIiArIHRoaXMuX3VuaWZvcm1zW2ldLmdldEdsc2xUeXBlU3RyaW5nKCkgKyBcIiBcIiArIHRoaXMuX3VuaWZvcm1zW2ldLmdldE5hbWUoKSkpXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1zU3RyRnJhZyArPSB1bmlTdHIgKyBcIjtcIiArIGNvbW1lbnQuZW5kbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBsZXQgY291bnRVbmlGcmFnID0gMDtcbiAgICBsZXQgY291bnRVbmlWZXJ0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3VuaWZvcm1zLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX3VuaWZvcm1zW2ldLnNoYWRlclR5cGUgJiYgIXRoaXMuX3VuaWZvcm1zW2ldLmlzU3RydWN0TWVtYmVyKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl91bmlmb3Jtc1tpXS5zaGFkZXJUeXBlID09IFwidmVydFwiIHx8IHRoaXMuX3VuaWZvcm1zW2ldLnNoYWRlclR5cGUgPT0gXCJib3RoXCIpIGNvdW50VW5pVmVydCsrO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VuaWZvcm1zW2ldLnNoYWRlclR5cGUgPT0gXCJmcmFnXCIgfHwgdGhpcy5fdW5pZm9ybXNbaV0uc2hhZGVyVHlwZSA9PSBcImJvdGhcIikgY291bnRVbmlGcmFnKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvdW50VW5pRnJhZyA+PSB0aGlzLl9jZ2wubWF4VW5pZm9ybXNGcmFnKSB0aGlzLl9sb2cud2FybihcIltjZ2xfc2hhZGVyXSBudW0gdW5pZm9ybXMgZnJhZzogXCIgKyBjb3VudFVuaUZyYWcgKyBcIiAvIFwiICsgdGhpcy5fY2dsLm1heFVuaWZvcm1zRnJhZyk7XG4gICAgaWYgKGNvdW50VW5pVmVydCA+PSB0aGlzLl9jZ2wubWF4VW5pZm9ybXNWZXJ0KSB0aGlzLl9sb2cud2FybihcIltjZ2xfc2hhZGVyXSBudW0gdW5pZm9ybXMgdmVydDogXCIgKyBjb3VudFVuaVZlcnQgKyBcIiAvIFwiICsgdGhpcy5fY2dsLm1heFVuaWZvcm1zVmVydCk7XG5cblxuICAgIGlmICghZnMuY29udGFpbnMoXCJwcmVjaXNpb25cIikpIGZzID0gXCJwcmVjaXNpb24gXCIgKyB0aGlzLnByZWNpc2lvbiArIFwiIGZsb2F0O1wiLmVuZGwoKSArIGZzO1xuICAgIGlmICghdnMuY29udGFpbnMoXCJwcmVjaXNpb25cIikpIHZzID0gXCJwcmVjaXNpb24gXCIgKyB0aGlzLnByZWNpc2lvbiArIFwiIGZsb2F0O1wiLmVuZGwoKSArIHZzO1xuICAgIGlmICgvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpXG4gICAge1xuICAgICAgICBmcyArPSBcIiNkZWZpbmUgTU9CSUxFXCIuZW5kbCgpO1xuICAgICAgICB2cyArPSBcIiNkZWZpbmUgTU9CSUxFXCIuZW5kbCgpO1xuICAgIH1cbiAgICB2cyA9IGV4dGVuc2lvblN0cmluZyArIHZzICsgZGVmaW5lc1N0ciArIHN0cnVjdFN0cmluZ3NbMF0gKyB1bmlmb3Jtc1N0clZlcnQgKyBcIlxcbi8vIC0tIFxcblwiICsgdGhpcy5zcmNWZXJ0O1xuICAgIGZzID0gZXh0ZW5zaW9uU3RyaW5nICsgZnMgKyBkZWZpbmVzU3RyICsgc3RydWN0U3RyaW5nc1sxXSArIHVuaWZvcm1zU3RyRnJhZyArIFwiXFxuLy8gLS0gXFxuXCIgKyB0aGlzLnNyY0ZyYWc7XG5cblxuICAgIGxldCBzcmNIZWFkVmVydCA9IFwiXCI7XG4gICAgbGV0IHNyY0hlYWRGcmFnID0gXCJcIjtcblxuICAgIHRoaXMuX21vZHVsZXMuc29ydChmdW5jdGlvbiAoYSwgYilcbiAgICB7XG4gICAgICAgIHJldHVybiBhLmdyb3VwIC0gYi5ncm91cDtcbiAgICB9KTtcblxuICAgIHRoaXMuX21vZHVsZXMuc29ydChmdW5jdGlvbiAoYSwgYilcbiAgICB7XG4gICAgICAgIHJldHVybiBhLnByaW9yaXR5IHx8IDAgLSBiLnByaW9yaXR5IHx8IDA7XG4gICAgfSk7XG5cblxuICAgIGxldCBhZGRlZEF0dHJpYnMgPSBmYWxzZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbW9kdWxlTmFtZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBsZXQgc3JjVmVydCA9IFwiXCI7XG4gICAgICAgIGxldCBzcmNGcmFnID0gXCJcIjtcblxuICAgICAgICBpZiAoIWFkZGVkQXR0cmlicylcbiAgICAgICAge1xuICAgICAgICAgICAgYWRkZWRBdHRyaWJzID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLl9hdHRyaWJ1dGVzLmxlbmd0aDsgaysrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9nZXRBdHRyU3JjKHRoaXMuX2F0dHJpYnV0ZXNba10sIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChyLnNyY0hlYWRWZXJ0KXNyY0hlYWRWZXJ0ICs9IHIuc3JjSGVhZFZlcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHIuc3JjVmVydClzcmNWZXJ0ICs9IHIuc3JjVmVydDtcbiAgICAgICAgICAgICAgICBpZiAoci5zcmNIZWFkRnJhZylzcmNIZWFkRnJhZyArPSByLnNyY0hlYWRGcmFnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl9tb2R1bGVzLmxlbmd0aDsgaisrKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBtb2QgPSB0aGlzLl9tb2R1bGVzW2pdO1xuICAgICAgICAgICAgaWYgKG1vZC5uYW1lID09IHRoaXMuX21vZHVsZU5hbWVzW2ldKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNyY0hlYWRWZXJ0ICs9IFwiXFxuLy8tLS0tIE1PRDogZ3JvdXA6XCIgKyBtb2QuZ3JvdXAgKyBcIjogaWR4OlwiICsgaiArIFwiIC0gcHJmeDpcIiArIG1vZC5wcmVmaXggKyBcIiAtIFwiICsgbW9kLnRpdGxlICsgXCIgLS0tLS0tXFxuXCI7XG4gICAgICAgICAgICAgICAgc3JjSGVhZEZyYWcgKz0gXCJcXG4vLy0tLS0gTU9EOiBncm91cDpcIiArIG1vZC5ncm91cCArIFwiOiBpZHg6XCIgKyBqICsgXCIgLSBwcmZ4OlwiICsgbW9kLnByZWZpeCArIFwiIC0gXCIgKyBtb2QudGl0bGUgKyBcIiAtLS0tLS1cXG5cIjtcblxuICAgICAgICAgICAgICAgIHNyY1ZlcnQgKz0gXCJcXG5cXG4vLy0tLS0gTU9EOiBcIiArIG1vZC50aXRsZSArIFwiIC8gXCIgKyBtb2QucHJpb3JpdHkgKyBcIiAtLS0tLS1cXG5cIjtcbiAgICAgICAgICAgICAgICBzcmNGcmFnICs9IFwiXFxuXFxuLy8tLS0tIE1PRDogXCIgKyBtb2QudGl0bGUgKyBcIiAvIFwiICsgbW9kLnByaW9yaXR5ICsgXCIgLS0tLS0tXFxuXCI7XG5cbiAgICAgICAgICAgICAgICBpZiAobW9kLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbW9kLmF0dHJpYnV0ZXMubGVuZ3RoOyBrKyspXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9nZXRBdHRyU3JjKG1vZC5hdHRyaWJ1dGVzW2tdLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5zcmNIZWFkVmVydClzcmNIZWFkVmVydCArPSByLnNyY0hlYWRWZXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuc3JjVmVydClzcmNWZXJ0ICs9IHIuc3JjVmVydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLnNyY0hlYWRGcmFnKXNyY0hlYWRGcmFnICs9IHIuc3JjSGVhZEZyYWc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNyY0hlYWRWZXJ0ICs9IG1vZC5zcmNIZWFkVmVydCB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHNyY0hlYWRGcmFnICs9IG1vZC5zcmNIZWFkRnJhZyB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHNyY1ZlcnQgKz0gbW9kLnNyY0JvZHlWZXJ0IHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgc3JjRnJhZyArPSBtb2Quc3JjQm9keUZyYWcgfHwgXCJcIjtcblxuICAgICAgICAgICAgICAgIHNyY0hlYWRWZXJ0ICs9IFwiXFxuLy8tLS0tIGVuZCBtb2QgLS0tLS0tXFxuXCI7XG4gICAgICAgICAgICAgICAgc3JjSGVhZEZyYWcgKz0gXCJcXG4vLy0tLS0gZW5kIG1vZCAtLS0tLS1cXG5cIjtcblxuICAgICAgICAgICAgICAgIHNyY1ZlcnQgKz0gXCJcXG4vLy0tLS0gZW5kIG1vZCAtLS0tLS1cXG5cIjtcbiAgICAgICAgICAgICAgICBzcmNGcmFnICs9IFwiXFxuLy8tLS0tIGVuZCBtb2QgLS0tLS0tXFxuXCI7XG5cbiAgICAgICAgICAgICAgICBzcmNWZXJ0ID0gc3JjVmVydC5yZXBsYWNlKC97e21vZH19L2csIG1vZC5wcmVmaXgpO1xuICAgICAgICAgICAgICAgIHNyY0ZyYWcgPSBzcmNGcmFnLnJlcGxhY2UoL3t7bW9kfX0vZywgbW9kLnByZWZpeCk7XG4gICAgICAgICAgICAgICAgc3JjSGVhZFZlcnQgPSBzcmNIZWFkVmVydC5yZXBsYWNlKC97e21vZH19L2csIG1vZC5wcmVmaXgpO1xuICAgICAgICAgICAgICAgIHNyY0hlYWRGcmFnID0gc3JjSGVhZEZyYWcucmVwbGFjZSgve3ttb2R9fS9nLCBtb2QucHJlZml4KTtcblxuICAgICAgICAgICAgICAgIHNyY1ZlcnQgPSBzcmNWZXJ0LnJlcGxhY2UoL01PRF8vZywgbW9kLnByZWZpeCk7XG4gICAgICAgICAgICAgICAgc3JjRnJhZyA9IHNyY0ZyYWcucmVwbGFjZSgvTU9EXy9nLCBtb2QucHJlZml4KTtcbiAgICAgICAgICAgICAgICBzcmNIZWFkVmVydCA9IHNyY0hlYWRWZXJ0LnJlcGxhY2UoL01PRF8vZywgbW9kLnByZWZpeCk7XG4gICAgICAgICAgICAgICAgc3JjSGVhZEZyYWcgPSBzcmNIZWFkRnJhZy5yZXBsYWNlKC9NT0RfL2csIG1vZC5wcmVmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICB2cyA9IHZzLnJlcGxhY2UoXCJ7e1wiICsgdGhpcy5fbW9kdWxlTmFtZXNbaV0gKyBcIn19XCIsIHNyY1ZlcnQpO1xuICAgICAgICBmcyA9IGZzLnJlcGxhY2UoXCJ7e1wiICsgdGhpcy5fbW9kdWxlTmFtZXNbaV0gKyBcIn19XCIsIHNyY0ZyYWcpO1xuICAgIH1cbiAgICB2cyA9IHZzLnJlcGxhY2UoXCJ7e01PRFVMRVNfSEVBRH19XCIsIHNyY0hlYWRWZXJ0KTtcbiAgICBmcyA9IGZzLnJlcGxhY2UoXCJ7e01PRFVMRVNfSEVBRH19XCIsIHNyY0hlYWRGcmFnKTtcblxuXG4gICAgdnMgPSB0aGlzLl9hZGRMaWJzKHZzKTtcbiAgICBmcyA9IHRoaXMuX2FkZExpYnMoZnMpO1xuXG5cbiAgICAvLyBTRVRVUCBkcmF3IGJ1ZmZlcnMgLyBtdWx0aSB0ZXh0dXJlIHJlbmRlciB0YXJnZXRzXG5cbiAgICBsZXQgZHJhd0J1ZmZlclN0ciA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgICAgICBpZiAoZnMuY29udGFpbnMoXCJvdXRDb2xvclwiICsgaSkpIHRoaXMuX2RyYXdCdWZmZXJzW2ldID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLl9kcmF3QnVmZmVycy5sZW5ndGggPT0gMSlcbiAgICB7XG4gICAgICAgIGRyYXdCdWZmZXJTdHIgPSBcIm91dCB2ZWM0IG91dENvbG9yO1wiLmVuZGwoKTtcbiAgICAgICAgZHJhd0J1ZmZlclN0ciArPSBcIiNkZWZpbmUgZ2xfRnJhZ0NvbG9yIG91dENvbG9yXCIuZW5kbCgpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBkcmF3QnVmZmVyU3RyICs9IFwiI2RlZmluZSBNVUxUSV9DT0xPUlRBUkdFVFNcIi5lbmRsKCk7XG4gICAgICAgIGRyYXdCdWZmZXJTdHIgKz0gXCJ2ZWM0IG91dENvbG9yO1wiLmVuZGwoKTtcblxuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RyYXdCdWZmZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoY291bnQgPT0gMCkgZHJhd0J1ZmZlclN0ciArPSBcIiNkZWZpbmUgZ2xfRnJhZ0NvbG9yIG91dENvbG9yXCIgKyBpICsgXCJcIi5lbmRsKCk7XG4gICAgICAgICAgICBkcmF3QnVmZmVyU3RyICs9IFwibGF5b3V0KGxvY2F0aW9uID0gXCIgKyBpICsgXCIpIG91dCB2ZWM0IG91dENvbG9yXCIgKyBpICsgXCI7XCIuZW5kbCgpO1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZzID0gZnMucmVwbGFjZShcInt7RFJBV0JVRkZFUn19XCIsIGRyYXdCdWZmZXJTdHIpO1xuICAgIC8vIC8vLy8vL1xuXG5cbiAgICBpZiAoIXRoaXMuX3Byb2dyYW0pXG4gICAge1xuICAgICAgICB0aGlzLl9wcm9ncmFtID0gdGhpcy5fY3JlYXRlUHJvZ3JhbSh2cywgZnMpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICAvLyB0aGlzLnZzaGFkZXI9Y3JlYXRlU2hhZGVyKHZzLCBnbC5WRVJURVhfU0hBREVSLCB0aGlzLnZzaGFkZXIgKTtcbiAgICAgICAgLy8gdGhpcy5mc2hhZGVyPWNyZWF0ZVNoYWRlcihmcywgZ2wuRlJBR01FTlRfU0hBREVSLCB0aGlzLmZzaGFkZXIgKTtcbiAgICAgICAgLy8gbGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIHRoaXMuX3Byb2dyYW0gPSB0aGlzLl9jcmVhdGVQcm9ncmFtKHZzLCBmcyk7XG5cbiAgICAgICAgdGhpcy5fcHJvak1hdHJpeFVuaWZvcm0gPSBudWxsO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdW5pZm9ybXMubGVuZ3RoOyBpKyspIHRoaXMuX3VuaWZvcm1zW2ldLnJlc2V0TG9jKCk7XG4gICAgfVxuXG4gICAgdGhpcy5maW5hbFNoYWRlckZyYWcgPSBmcztcbiAgICB0aGlzLmZpbmFsU2hhZGVyVmVydCA9IHZzO1xuXG5cbiAgICBNRVNILmxhc3RNZXNoID0gbnVsbDtcbiAgICBNRVNILmxhc3RTaGFkZXIgPSBudWxsO1xuXG4gICAgdGhpcy5fY291bnRNaXNzaW5nVW5pZm9ybXMgPSAwO1xuICAgIHRoaXMuX25lZWRzUmVjb21waWxlID0gZmFsc2U7XG4gICAgdGhpcy5sYXN0Q29tcGlsZSA9IG5vdygpO1xuXG4gICAgLy8gdGhpcy5fY2dsLnByaW50RXJyb3IoXCJzaGFkZXIgY29tcGlsZVwiKTtcblxuICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5zaGFkZXJDb21waWxlVGltZSArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbn07XG5cblNoYWRlci5oYXNDaGFuZ2VkID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fbmVlZHNSZWNvbXBpbGU7XG59O1xuXG5cblNoYWRlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKCF0aGlzLl9pc1ZhbGlkIHx8IHRoaXMuX2NnbC5hYm9ydGVkKSByZXR1cm47XG5cbiAgICBNRVNILmxhc3RTaGFkZXIgPSB0aGlzO1xuXG4gICAgaWYgKCF0aGlzLl9wcm9ncmFtIHx8IHRoaXMuX25lZWRzUmVjb21waWxlKSB0aGlzLmNvbXBpbGUoKTtcbiAgICBpZiAoIXRoaXMuX2lzVmFsaWQpIHJldHVybjtcblxuICAgIGlmICghdGhpcy5fcHJvak1hdHJpeFVuaWZvcm0gJiYgIXRoaXMuaWdub3JlTWlzc2luZ1VuaWZvcm1zKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY291bnRNaXNzaW5nVW5pZm9ybXMrKztcbiAgICAgICAgLy8gaWYgKHRoaXMuX2NvdW50TWlzc2luZ1VuaWZvcm1zID09IDEwKWNvbnNvbGUubG9nKFwic3RvcHBpbmcgZ2V0bG9jYXRpb24gb2YgbWlzc2luZyB1bmlmb3Jtcy4uLlwiLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuX2NvdW50TWlzc2luZ1VuaWZvcm1zIDwgMTApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2pNYXRyaXhVbmlmb3JtID0gdGhpcy5fY2dsLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9wcm9ncmFtLCBDT05TVEFOVFMuU0hBREVSLlNIQURFUlZBUl9VTklfUFJPSk1BVCk7XG4gICAgICAgICAgICB0aGlzLl9hdHRyVmVydGV4UG9zID0gdGhpcy5fY2dsLmdsR2V0QXR0cmliTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfVkVSVEVYX1BPU0lUSU9OKTtcbiAgICAgICAgICAgIHRoaXMuX212TWF0cml4VW5pZm9ybSA9IHRoaXMuX2NnbC5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgXCJtdk1hdHJpeFwiKTtcbiAgICAgICAgICAgIHRoaXMuX3ZNYXRyaXhVbmlmb3JtID0gdGhpcy5fY2dsLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9wcm9ncmFtLCBDT05TVEFOVFMuU0hBREVSLlNIQURFUlZBUl9VTklfVklFV01BVCk7XG4gICAgICAgICAgICB0aGlzLl9tTWF0cml4VW5pZm9ybSA9IHRoaXMuX2NnbC5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgQ09OU1RBTlRTLlNIQURFUi5TSEFERVJWQVJfVU5JX01PREVMTUFUKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbVBvc1VuaWZvcm0gPSB0aGlzLl9jZ2wuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sIENPTlNUQU5UUy5TSEFERVIuU0hBREVSVkFSX1VOSV9WSUVXUE9TKTtcbiAgICAgICAgICAgIHRoaXMuX25vcm1hbE1hdHJpeFVuaWZvcm0gPSB0aGlzLl9jZ2wuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sIENPTlNUQU5UUy5TSEFERVIuU0hBREVSVkFSX1VOSV9OT1JNQUxNQVQpO1xuICAgICAgICAgICAgdGhpcy5faW52ZXJzZVZpZXdNYXRyaXhVbmlmb3JtID0gdGhpcy5fY2dsLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9wcm9ncmFtLCBDT05TVEFOVFMuU0hBREVSLlNIQURFUlZBUl9VTklfSU5WVklFV01BVCk7XG4gICAgICAgICAgICB0aGlzLl9pbnZlcnNlUHJvak1hdHJpeFVuaWZvcm0gPSB0aGlzLl9jZ2wuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sIENPTlNUQU5UUy5TSEFERVIuU0hBREVSVkFSX1VOSV9JTlZQUk9KTUFUKTtcbiAgICAgICAgICAgIHRoaXMuX21hdGVyaWFsSWRVbmlmb3JtID0gdGhpcy5fY2dsLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9wcm9ncmFtLCBDT05TVEFOVFMuU0hBREVSLlNIQURFUlZBUl9VTklfTUFURVJJQUxJRCk7XG4gICAgICAgICAgICB0aGlzLl9vYmplY3RJZFVuaWZvcm0gPSB0aGlzLl9jZ2wuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sIENPTlNUQU5UUy5TSEFERVIuU0hBREVSVkFSX1VOSV9PQkpFQ1RJRCk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdW5pZm9ybXMubGVuZ3RoOyBpKyspIHRoaXMuX3VuaWZvcm1zW2ldLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgaWYgKHRoaXMuX2NnbC5jdXJyZW50UHJvZ3JhbSAhPSB0aGlzLl9wcm9ncmFtKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaGFkZXJCaW5kcysrO1xuICAgICAgICB0aGlzLl9jZ2wuZ2wudXNlUHJvZ3JhbSh0aGlzLl9wcm9ncmFtKTtcbiAgICAgICAgdGhpcy5fY2dsLmN1cnJlbnRQcm9ncmFtID0gdGhpcy5fcHJvZ3JhbTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3VuaWZvcm1zLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAodGhpcy5fdW5pZm9ybXNbaV0ubmVlZHNVcGRhdGUpIHRoaXMuX3VuaWZvcm1zW2ldLnVwZGF0ZVZhbHVlKCk7XG5cbiAgICBpZiAodGhpcy5fcE1hdHJpeFN0YXRlICE9IHRoaXMuX2NnbC5nZXRQcm9qZWN0aW9uTWF0cml4U3RhdGVDb3VudCgpKVxuICAgIHtcbiAgICAgICAgdGhpcy5fcE1hdHJpeFN0YXRlID0gdGhpcy5fY2dsLmdldFByb2plY3Rpb25NYXRyaXhTdGF0ZUNvdW50KCk7XG4gICAgICAgIHRoaXMuX2NnbC5nbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX3Byb2pNYXRyaXhVbmlmb3JtLCBmYWxzZSwgdGhpcy5fY2dsLnBNYXRyaXgpO1xuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZU1WUE1hdHJpeENvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29iamVjdElkVW5pZm9ybSlcbiAgICAgICAgdGhpcy5fY2dsLmdsLnVuaWZvcm0xZih0aGlzLl9vYmplY3RJZFVuaWZvcm0sICsrdGhpcy5fY2dsLmZyYW1lU3RvcmUub2JqZWN0SWRDb3VudGVyKTtcblxuICAgIGlmICh0aGlzLl9tYXRlcmlhbElkVW5pZm9ybSlcbiAgICAgICAgdGhpcy5fY2dsLmdsLnVuaWZvcm0xZih0aGlzLl9tYXRlcmlhbElkVW5pZm9ybSwgdGhpcy5fbWF0ZXJpYWxJZCk7XG5cbiAgICBpZiAodGhpcy5fdk1hdHJpeFVuaWZvcm0pXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fdk1hdHJpeFN0YXRlICE9IHRoaXMuX2NnbC5nZXRWaWV3TWF0cml4U3RhdGVDb3VudCgpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl92TWF0cml4VW5pZm9ybSwgZmFsc2UsIHRoaXMuX2NnbC52TWF0cml4KTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlTVZQTWF0cml4Q291bnQrKztcbiAgICAgICAgICAgIHRoaXMuX3ZNYXRyaXhTdGF0ZSA9IHRoaXMuX2NnbC5nZXRWaWV3TWF0cml4U3RhdGVDb3VudCgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5faW52ZXJzZVZpZXdNYXRyaXhVbmlmb3JtKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hdDQuaW52ZXJ0KHRoaXMuX3RlbXBJbnZlcnNlVmlld01hdHJpeCwgdGhpcy5fY2dsLnZNYXRyaXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX2ludmVyc2VWaWV3TWF0cml4VW5pZm9ybSwgZmFsc2UsIHRoaXMuX3RlbXBJbnZlcnNlVmlld01hdHJpeCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVNVlBNYXRyaXhDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2ludmVyc2VQcm9qTWF0cml4VW5pZm9ybSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYXQ0LmludmVydCh0aGlzLl90ZW1wSW52ZXJzZVByb2pNYXRyaXgsIHRoaXMuX2NnbC5wTWF0cml4KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl9pbnZlcnNlUHJvak1hdHJpeFVuaWZvcm0sIGZhbHNlLCB0aGlzLl90ZW1wSW52ZXJzZVByb2pNYXRyaXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlTVZQTWF0cml4Q291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jZ2wuZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl9tTWF0cml4VW5pZm9ybSwgZmFsc2UsIHRoaXMuX2NnbC5tTWF0cml4KTtcbiAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVNVlBNYXRyaXhDb3VudCsrO1xuXG4gICAgICAgIGlmICh0aGlzLl9jYW1Qb3NVbmlmb3JtKVxuICAgICAgICB7XG4gICAgICAgICAgICBtYXQ0LmludmVydCh0aGlzLl90ZW1wQ2FtUG9zTWF0cml4LCB0aGlzLl9jZ2wudk1hdHJpeCk7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudW5pZm9ybTNmKHRoaXMuX2NhbVBvc1VuaWZvcm0sIHRoaXMuX3RlbXBDYW1Qb3NNYXRyaXhbMTJdLCB0aGlzLl90ZW1wQ2FtUG9zTWF0cml4WzEzXSwgdGhpcy5fdGVtcENhbVBvc01hdHJpeFsxNF0pO1xuICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVNVlBNYXRyaXhDb3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIC8vIG12bWF0cml4IGRlcHJlY2F0ZWQuLi4uXG4gICAgICAgIGNvbnN0IHRlbXBtdiA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgICAgICAgbWF0NC5tdWwodGVtcG12LCB0aGlzLl9jZ2wudk1hdHJpeCwgdGhpcy5fY2dsLm1NYXRyaXgpO1xuICAgICAgICB0aGlzLl9jZ2wuZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl9tdk1hdHJpeFVuaWZvcm0sIGZhbHNlLCB0ZW1wbXYpO1xuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZU1WUE1hdHJpeENvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX25vcm1hbE1hdHJpeFVuaWZvcm0pXG4gICAge1xuICAgICAgICAvLyBtYXQ0Lm11bCh0aGlzLl90ZW1wTm9ybWFsTWF0cml4LCB0aGlzLl9jZ2wudk1hdHJpeCwgdGhpcy5fY2dsLm1NYXRyaXgpO1xuICAgICAgICBtYXQ0LmludmVydCh0aGlzLl90ZW1wTm9ybWFsTWF0cml4LCB0aGlzLl9jZ2wubU1hdHJpeCk7XG4gICAgICAgIG1hdDQudHJhbnNwb3NlKHRoaXMuX3RlbXBOb3JtYWxNYXRyaXgsIHRoaXMuX3RlbXBOb3JtYWxNYXRyaXgpO1xuXG4gICAgICAgIHRoaXMuX2NnbC5nbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuX25vcm1hbE1hdHJpeFVuaWZvcm0sIGZhbHNlLCB0aGlzLl90ZW1wTm9ybWFsTWF0cml4KTtcbiAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVNVlBNYXRyaXhDb3VudCsrO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbGlicy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9saWJzW2ldLm9uQmluZCkgdGhpcy5fbGlic1tpXS5vbkJpbmQuYmluZCh0aGlzLl9saWJzW2ldKSh0aGlzLl9jZ2wsIHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuX2JpbmRUZXh0dXJlcygpO1xuXG4gICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLnVuQmluZCA9IGZ1bmN0aW9uICgpXG57XG59O1xuXG4vKipcbiAqIGVhc2lseSBlbmFibGUvZGlzYWJsZSBhIGRlZmluZSB3aXRob3V0IGEgdmFsdWVcbiAqIEBmdW5jdGlvbiB0b2dnbGVEZWZpbmVcbiAqIEBtZW1iZXJvZiBTaGFkZXJcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtuYW1lfSBuYW1lXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgb3IgcG9ydFxuICovXG5TaGFkZXIucHJvdG90eXBlLnRvZ2dsZURlZmluZSA9IGZ1bmN0aW9uIChuYW1lLCBlbmFibGVkKVxue1xuICAgIGlmIChlbmFibGVkICYmIHR5cGVvZiAoZW5hYmxlZCkgPT0gXCJvYmplY3RcIiAmJiBlbmFibGVkLmFkZEV2ZW50TGlzdGVuZXIpIC8vIHBvcnRcbiAgICB7XG4gICAgICAgIGlmIChlbmFibGVkLmNoYW5nZUxpc3RlbmVyKWVuYWJsZWQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbmFibGVkLmNoYW5nZUxpc3RlbmVyKTtcblxuICAgICAgICBlbmFibGVkLm9uVG9nZ2xlRGVmaW5lID0gKHYpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlRGVmaW5lKG5hbWUsIHYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGVuYWJsZWQuY2hhbmdlTGlzdGVuZXIgPSBlbmFibGVkLm9uKFwiY2hhbmdlXCIsIGVuYWJsZWQub25Ub2dnbGVEZWZpbmUpO1xuICAgICAgICBlbmFibGVkID0gZW5hYmxlZC5nZXQoKTtcbiAgICB9XG5cbiAgICBpZiAoZW5hYmxlZCkgdGhpcy5kZWZpbmUobmFtZSk7XG4gICAgZWxzZSB0aGlzLnJlbW92ZURlZmluZShuYW1lKTtcbn07XG5cbi8qKlxuICogYWRkIGEgZGVmaW5lIHRvIGEgc2hhZGVyLCBlLmcuICAjZGVmaW5lIERPX1RISVNfVEhBVCAxXG4gKiBAZnVuY3Rpb24gZGVmaW5lXG4gKiBAbWVtYmVyb2YgU2hhZGVyXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgKGNhbiBiZSBlbXB0eSlcbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpXG57XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHZhbHVlID0gXCJcIjtcblxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PSBcIm9iamVjdFwiKSAvLyBwb3J0XG4gICAge1xuICAgICAgICB2YWx1ZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHZhbHVlLm9uRGVmaW5lQ2hhbmdlKTtcbiAgICAgICAgdmFsdWUub25EZWZpbmVDaGFuZ2UgPSAodikgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5kZWZpbmUobmFtZSwgdik7XG4gICAgICAgIH07XG4gICAgICAgIHZhbHVlLm9uKFwiY2hhbmdlXCIsIHZhbHVlLm9uRGVmaW5lQ2hhbmdlKTtcblxuICAgICAgICB2YWx1ZSA9IHZhbHVlLmdldCgpO1xuICAgIH1cblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9kZWZpbmVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZmluZXNbaV1bMF0gPT0gbmFtZSAmJiB0aGlzLl9kZWZpbmVzW2ldWzFdID09IHZhbHVlKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLl9kZWZpbmVzW2ldWzBdID09IG5hbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2RlZmluZXNbaV1bMV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0V2h5Q29tcGlsZShcImRlZmluZSBcIiArIG5hbWUgKyBcIiBcIiArIHZhbHVlKTtcblxuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWNvbXBpbGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2V0V2h5Q29tcGlsZShcImRlZmluZSBcIiArIG5hbWUgKyBcIiBcIiArIHZhbHVlKTtcbiAgICB0aGlzLl9uZWVkc1JlY29tcGlsZSA9IHRydWU7XG4gICAgdGhpcy5fZGVmaW5lcy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5nZXREZWZpbmVzID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fZGVmaW5lcztcbn07XG5cblNoYWRlci5wcm90b3R5cGUuZ2V0RGVmaW5lID0gZnVuY3Rpb24gKG5hbWUpXG57XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9kZWZpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAodGhpcy5fZGVmaW5lc1tpXVswXSA9PSBuYW1lKSByZXR1cm4gdGhpcy5fZGVmaW5lc1tpXVsxXTtcbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogcmV0dXJuIHRydWUgaWYgc2hhZGVyIGhhcyBkZWZpbmVcbiAqIEBmdW5jdGlvbiBoYXNEZWZpbmVcbiAqIEBtZW1iZXJvZiBTaGFkZXJcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblNoYWRlci5wcm90b3R5cGUuaGFzRGVmaW5lID0gZnVuY3Rpb24gKG5hbWUpXG57XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9kZWZpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAodGhpcy5fZGVmaW5lc1tpXVswXSA9PSBuYW1lKSByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogcmVtb3ZlIGEgZGVmaW5lIGZyb20gYSBzaGFkZXJcbiAqIEBwYXJhbSB7bmFtZX0gbmFtZVxuICogQGZ1bmN0aW9uIHJlbW92ZURlZmluZVxuICogQG1lbWJlcm9mIFNoYWRlclxuICogQGluc3RhbmNlXG4gKi9cblNoYWRlci5wcm90b3R5cGUucmVtb3ZlRGVmaW5lID0gZnVuY3Rpb24gKG5hbWUpXG57XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9kZWZpbmVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZmluZXNbaV1bMF0gPT0gbmFtZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZGVmaW5lcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlY29tcGlsZSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0V2h5Q29tcGlsZShcImRlZmluZSByZW1vdmVkOlwiICsgbmFtZSk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogcmVtb3ZlIGEgbW9kdWxlIGZyb20gc2hhZGVyXG4gKiBAZnVuY3Rpb24gcmVtb3ZlTW9kdWxlXG4gKiBAbWVtYmVyb2YgU2hhZGVyXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7c2hhZGVyTW9kdWxlfSBtb2R1bGUgdGhlIG1vZHVsZSB0byBiZSByZW1vdmVkXG4gKi9cblNoYWRlci5wcm90b3R5cGUucmVtb3ZlTW9kdWxlID0gZnVuY3Rpb24gKG1vZClcbntcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX21vZHVsZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5pZClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21vZHVsZXNbaV0uaWQgPT0gbW9kLmlkIHx8ICF0aGlzLl9tb2R1bGVzW2ldKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGZvdW5kKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl91bmlmb3Jtcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VuaWZvcm1zW2pdLmdldE5hbWUoKS5zdGFydHNXaXRoKG1vZC5wcmVmaXgpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VuaWZvcm1zLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc1JlY29tcGlsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRXaHlDb21waWxlKFwicmVtb3ZlIG1vZHVsZSBcIiArIG1vZC50aXRsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kdWxlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblNoYWRlci5wcm90b3R5cGUuZ2V0TnVtTW9kdWxlcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX21vZHVsZXMubGVuZ3RoO1xufTtcblxuXG5TaGFkZXIucHJvdG90eXBlLmdldEN1cnJlbnRNb2R1bGVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbW9kdWxlczsgfTtcblxuXG4vKipcbiAqIGFkZCBhIG1vZHVsZVxuICogQGZ1bmN0aW9uIGFkZE1vZHVsZVxuICogQG1lbWJlcm9mIFNoYWRlclxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge3NoYWRlck1vZHVsZX0gbW9kdWxlIHRoZSBtb2R1bGUgdG8gYmUgYWRkZWRcbiAqIEBwYXJhbSB7c2hhZGVyTW9kdWxlfSBbc2libGluZ10gc2libGluZyBtb2R1bGUsIG5ldyBtb2R1bGUgd2lsbCBzaGFyZSB0aGUgc2FtZSBncm91cFxuICovXG5TaGFkZXIucHJvdG90eXBlLmFkZE1vZHVsZSA9IGZ1bmN0aW9uIChtb2QsIHNpYmxpbmcpXG57XG4gICAgaWYgKHRoaXMuaGFzTW9kdWxlKG1vZC5pZCkpIHJldHVybjtcbiAgICBpZiAoIW1vZC5pZCkgbW9kLmlkID0gQ0FCTEVTLnNpbXBsZUlkKCk7XG4gICAgaWYgKCFtb2QubnVtSWQpIG1vZC5udW1JZCA9IHRoaXMuX21vZHVsZU51bUlkO1xuICAgIGlmICghbW9kLm51bSltb2QubnVtID0gdGhpcy5fbW9kdWxlcy5sZW5ndGg7XG4gICAgaWYgKHNpYmxpbmcgJiYgIXNpYmxpbmcuZ3JvdXApIHNpYmxpbmcuZ3JvdXAgPSBzaW1wbGVJZCgpO1xuXG4gICAgaWYgKCFtb2QuZ3JvdXApXG4gICAgICAgIGlmIChzaWJsaW5nKSBtb2QuZ3JvdXAgPSBzaWJsaW5nLmdyb3VwO1xuICAgICAgICBlbHNlIG1vZC5ncm91cCA9IHNpbXBsZUlkKCk7XG5cbiAgICBtb2QucHJlZml4ID0gXCJtb2RcIiArIG1vZC5ncm91cCArIFwiX1wiO1xuICAgIHRoaXMuX21vZHVsZXMucHVzaChtb2QpO1xuXG4gICAgdGhpcy5fbmVlZHNSZWNvbXBpbGUgPSB0cnVlO1xuICAgIHRoaXMuc2V0V2h5Q29tcGlsZShcImFkZCBtb2R1bGUgXCIgKyBtb2QudGl0bGUpO1xuICAgIHRoaXMuX21vZHVsZU51bUlkKys7XG5cbiAgICByZXR1cm4gbW9kO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5oYXNNb2R1bGUgPSBmdW5jdGlvbiAobW9kSWQpXG57XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9tb2R1bGVzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX21vZHVsZXNbaV0uaWQgPT0gbW9kSWQpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLnNldE1vZHVsZXMgPSBmdW5jdGlvbiAobmFtZXMpXG57XG4gICAgdGhpcy5fbW9kdWxlTmFtZXMgPSBuYW1lcztcbn07XG5cblNoYWRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fY2dsLmdsLmRlbGV0ZVByb2dyYW0odGhpcy5fcHJvZ3JhbSk7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLm5lZWRzUmVjb21waWxlID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fbmVlZHNSZWNvbXBpbGU7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLnNldERyYXdCdWZmZXJzID0gZnVuY3Rpb24gKGFycilcbntcbiAgICBjb25zb2xlLmxvZyhcInVzZWxlc3MgZHJhd2J1ZmZlcnMuLi4/IVwiKTtcbiAgICAvLyBpZiAodGhpcy5fZHJhd0J1ZmZlcnMubGVuZ3RoICE9PSBhcnIubGVuZ3RoKVxuICAgIC8vIHtcbiAgICAvLyAgICAgdGhpcy5fZHJhd0J1ZmZlcnMgPSBhcnI7XG4gICAgLy8gICAgIHRoaXMuX25lZWRzUmVjb21waWxlID0gdHJ1ZTtcbiAgICAvLyAgICAgdGhpcy5zZXRXaHlDb21waWxlKFwic2V0RHJhd0J1ZmZlcnNcIik7XG4gICAgLy8gICAgIHJldHVybjtcbiAgICAvLyB9XG4gICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspXG4gICAgLy8ge1xuICAgIC8vICAgICBpZiAoYXJyW2ldICE9PSB0aGlzLl9kcmF3QnVmZmVyc1tpXSlcbiAgICAvLyAgICAge1xuICAgIC8vICAgICAgICAgdGhpcy5fZHJhd0J1ZmZlcnMgPSBhcnI7XG4gICAgLy8gICAgICAgICB0aGlzLl9uZWVkc1JlY29tcGlsZSA9IHRydWU7XG4gICAgLy8gICAgICAgICB0aGlzLnNldFdoeUNvbXBpbGUoXCJzZXREcmF3QnVmZmVyc1wiKTtcbiAgICAvLyAgICAgICAgIHJldHVybjtcbiAgICAvLyAgICAgfVxuICAgIC8vIH1cbn07XG5cblNoYWRlci5wcm90b3R5cGUuZ2V0VW5pZm9ybXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl91bmlmb3Jtcztcbn07XG5cblNoYWRlci5wcm90b3R5cGUuZ2V0VW5pZm9ybSA9IGZ1bmN0aW9uIChuYW1lKVxue1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdW5pZm9ybXMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICh0aGlzLl91bmlmb3Jtc1tpXS5nZXROYW1lKCkgPT0gbmFtZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91bmlmb3Jtc1tpXTtcbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblNoYWRlci5wcm90b3R5cGUucmVtb3ZlQWxsVW5pZm9ybXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX3VuaWZvcm1zID0gW107XG4gICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl91bmlmb3Jtcy5sZW5ndGg7IGkrKylcbiAgICAvLyAgICAgdGhpcy5yZW1vdmVVbmlmb3JtKHRoaXMuX3VuaWZvcm1zW2ldLm5hbWUpO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5yZW1vdmVVbmlmb3JtID0gZnVuY3Rpb24gKG5hbWUpXG57XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl91bmlmb3Jtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl91bmlmb3Jtc1tpXS5nZXROYW1lKCkgPT0gbmFtZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fdW5pZm9ybXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuX25lZWRzUmVjb21waWxlID0gdHJ1ZTtcbiAgICB0aGlzLnNldFdoeUNvbXBpbGUoXCJyZW1vdmUgdW5pZm9ybSBcIiArIG5hbWUpO1xufTtcblxuXG5TaGFkZXIucHJvdG90eXBlLl9hZGRVbmlmb3JtID0gZnVuY3Rpb24gKHVuaSlcbntcbiAgICB0aGlzLl91bmlmb3Jtcy5wdXNoKHVuaSk7XG4gICAgdGhpcy5zZXRXaHlDb21waWxlKFwiYWRkIHVuaWZvcm0gXCIgKyBuYW1lKTtcbiAgICB0aGlzLl9uZWVkc1JlY29tcGlsZSA9IHRydWU7XG59O1xuXG4vKipcbiAqIGFkZCBhIHVuaWZvcm0gdG8gdGhlIGZyYWdtZW50IHNoYWRlclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgWydmJywndCcsIGV0Y11cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgb3IgcG9ydFxuICogQG1lbWJlcm9mIFNoYWRlclxuICogQGluc3RhbmNlXG4gKiBAZnVuY3Rpb24gYWRkVW5pZm9ybUZyYWdcbiAqIEByZXR1cm5zIHtDR0wuVW5pZm9ybX1cbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5hZGRVbmlmb3JtRnJhZyA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCB2YWx1ZU9yUG9ydCwgcDIsIHAzLCBwNClcbntcbiAgICBjb25zdCB1bmkgPSBuZXcgQ0dMLlVuaWZvcm0odGhpcywgdHlwZSwgbmFtZSwgdmFsdWVPclBvcnQsIHAyLCBwMywgcDQpO1xuICAgIHVuaS5zaGFkZXJUeXBlID0gXCJmcmFnXCI7XG4gICAgcmV0dXJuIHVuaTtcbn07XG5cbi8qKlxuICogYWRkIGEgdW5pZm9ybSB0byB0aGUgdmVydGV4IHNoYWRlclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgWydmJywndCcsIGV0Y11cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgb3IgcG9ydFxuICogQG1lbWJlcm9mIFNoYWRlclxuICogQGluc3RhbmNlXG4gKiBAZnVuY3Rpb24gYWRkVW5pZm9ybVZlcnRcbiAqIEByZXR1cm5zIHtDR0wuVW5pZm9ybX1cbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5hZGRVbmlmb3JtVmVydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCB2YWx1ZU9yUG9ydCwgcDIsIHAzLCBwNClcbntcbiAgICBjb25zdCB1bmkgPSBuZXcgQ0dMLlVuaWZvcm0odGhpcywgdHlwZSwgbmFtZSwgdmFsdWVPclBvcnQsIHAyLCBwMywgcDQpO1xuICAgIHVuaS5zaGFkZXJUeXBlID0gXCJ2ZXJ0XCI7XG4gICAgcmV0dXJuIHVuaTtcbn07XG4vKipcbiAqIGFkZCBhIHVuaWZvcm0gdG8gYm90aCBzaGFkZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBbJ2YnLCd0JywgZXRjXVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBvciBwb3J0XG4gKiBAbWVtYmVyb2YgU2hhZGVyXG4gKiBAaW5zdGFuY2VcbiAqIEBmdW5jdGlvbiBhZGRVbmlmb3JtQm90aFxuICogQHJldHVybnMge0NHTC5Vbmlmb3JtfVxuICovXG5TaGFkZXIucHJvdG90eXBlLmFkZFVuaWZvcm1Cb3RoID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHZhbHVlT3JQb3J0LCBwMiwgcDMsIHA0KVxue1xuICAgIGNvbnN0IHVuaSA9IG5ldyBDR0wuVW5pZm9ybSh0aGlzLCB0eXBlLCBuYW1lLCB2YWx1ZU9yUG9ydCwgcDIsIHAzLCBwNCk7XG4gICAgdW5pLnNoYWRlclR5cGUgPSBcImJvdGhcIjtcbiAgICByZXR1cm4gdW5pO1xufTtcblxuLyoqXG4gKiBhZGQgYSBzdHJ1Y3QgJiBpdHMgdW5pZm9ybXMgdG8gdGhlIGZyYWdtZW50IHNoYWRlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0cnVjdE5hbWUgbmFtZSBvZiB0aGUgc3RydWN0LCBpLmUuOiBMaWdodFN0cnVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHVuaWZvcm1OYW1lIG5hbWUgb2YgdGhlIHN0cnVjdCB1bmlmb3JtIGluIHRoZSBzaGFkZXIsIGkuZS46IGxpZ2h0VW5pXG4gKiBAcGFyYW0ge0FycmF5fSBtZW1iZXJzIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgc3RydWN0IG1lbWJlcnMuIHNlZSBleGFtcGxlIGZvciBzdHJ1Y3R1cmVcblxuICogQG1lbWJlcm9mIFNoYWRlclxuICogQGluc3RhbmNlXG4gKiBAZnVuY3Rpb24gYWRkVW5pZm9ybVN0cnVjdEZyYWdcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAZXhhbXBsZVxuICogY29uc3Qgc2hhZGVyID0gbmV3IENHTC5TaGFkZXIoY2dsLCAnTWluaW1hbE1hdGVyaWFsJyk7XG4gKiBzaGFkZXIuc2V0U291cmNlKGF0dGFjaG1lbnRzLnNoYWRlcl92ZXJ0LCBhdHRhY2htZW50cy5zaGFkZXJfZnJhZyk7XG4gKiBzaGFkZXIuYWRkVW5pZm9ybVN0cnVjdEZyYWcoXCJMaWdodFwiLCBcInVuaWZvcm1MaWdodFwiLCBbXG4gKiB7IFwidHlwZVwiOiBcIjNmXCIsIFwibmFtZVwiOiBcInBvc2l0aW9uXCIsIFwidjFcIjogbnVsbCB9LFxuICogeyBcInR5cGVcIjogXCI0ZlwiLCBcIm5hbWVcIjogXCJjb2xvclwiLCBcInYxXCI6IGluUiwgdjI6IGluRywgdjM6IGluQiwgdjQ6IGluQWxwaGEgfVxuICogXSk7XG4gKi9cblNoYWRlci5wcm90b3R5cGUuYWRkVW5pZm9ybVN0cnVjdEZyYWcgPSBmdW5jdGlvbiAoc3RydWN0TmFtZSwgdW5pZm9ybU5hbWUsIG1lbWJlcnMpXG57XG4gICAgY29uc3QgdW5pZm9ybXMgPSB7fTtcblxuICAgIGlmICghbWVtYmVycykgcmV0dXJuIHVuaWZvcm1zO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZW1iZXJzLmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICAgICAgY29uc3QgbWVtYmVyID0gbWVtYmVyc1tpXTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1VuaWZvcm0odW5pZm9ybU5hbWUgKyBcIi5cIiArIG1lbWJlci5uYW1lKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdW5pID0gbmV3IENHTC5Vbmlmb3JtKHRoaXMsIG1lbWJlci50eXBlLCB1bmlmb3JtTmFtZSArIFwiLlwiICsgbWVtYmVyLm5hbWUsIG1lbWJlci52MSwgbWVtYmVyLnYyLCBtZW1iZXIudjMsIG1lbWJlci52NCwgdW5pZm9ybU5hbWUsIHN0cnVjdE5hbWUsIG1lbWJlci5uYW1lKTtcbiAgICAgICAgICAgIHVuaS5zaGFkZXJUeXBlID0gXCJmcmFnXCI7XG4gICAgICAgICAgICB1bmlmb3Jtc1t1bmlmb3JtTmFtZSArIFwiLlwiICsgbWVtYmVyLm5hbWVdID0gdW5pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaWZvcm1zO1xufTtcblxuLyoqXG4gKiBhZGQgYSBzdHJ1Y3QgJiBpdHMgdW5pZm9ybXMgdG8gdGhlIHZlcnRleCBzaGFkZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJ1Y3ROYW1lIG5hbWUgb2YgdGhlIHN0cnVjdCwgaS5lLjogTGlnaHRTdHJ1Y3RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1bmlmb3JtTmFtZSBuYW1lIG9mIHRoZSBzdHJ1Y3QgdW5pZm9ybSBpbiB0aGUgc2hhZGVyLCBpLmUuOiBsaWdodFVuaVxuICogQHBhcmFtIHtBcnJheX0gbWVtYmVycyBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHN0cnVjdCBtZW1iZXJzLiBzZWUgZXhhbXBsZSBmb3Igc3RydWN0dXJlXG5cbiAqIEBtZW1iZXJvZiBTaGFkZXJcbiAqIEBpbnN0YW5jZVxuICogQGZ1bmN0aW9uIGFkZFVuaWZvcm1TdHJ1Y3RWZXJ0XG4gKiBAcmV0dXJucyB7Q0dMLlVuaWZvcm19XG4gKiBAZXhhbXBsZVxuICogY29uc3Qgc2hhZGVyID0gbmV3IENHTC5TaGFkZXIoY2dsLCAnTWluaW1hbE1hdGVyaWFsJyk7XG4gKiBzaGFkZXIuc2V0U291cmNlKGF0dGFjaG1lbnRzLnNoYWRlcl92ZXJ0LCBhdHRhY2htZW50cy5zaGFkZXJfZnJhZyk7XG4gKiBzaGFkZXIuYWRkVW5pZm9ybVN0cnVjdFZlcnQoXCJMaWdodFwiLCBcInVuaWZvcm1MaWdodFwiLCBbXG4gKiB7IFwidHlwZVwiOiBcIjNmXCIsIFwibmFtZVwiOiBcInBvc2l0aW9uXCIsIFwidjFcIjogbnVsbCB9LFxuICogeyBcInR5cGVcIjogXCI0ZlwiLCBcIm5hbWVcIjogXCJjb2xvclwiLCBcInYxXCI6IGluUiwgdjI6IGluRywgdjM6IGluQiwgdjQ6IGluQWxwaGEgfVxuICogXSk7XG4gKi9cblNoYWRlci5wcm90b3R5cGUuYWRkVW5pZm9ybVN0cnVjdFZlcnQgPSBmdW5jdGlvbiAoc3RydWN0TmFtZSwgdW5pZm9ybU5hbWUsIG1lbWJlcnMpXG57XG4gICAgY29uc3QgdW5pZm9ybXMgPSB7fTtcblxuICAgIGlmICghbWVtYmVycykgcmV0dXJuIHVuaWZvcm1zO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZW1iZXJzLmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICAgICAgY29uc3QgbWVtYmVyID0gbWVtYmVyc1tpXTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1VuaWZvcm0odW5pZm9ybU5hbWUgKyBcIi5cIiArIG1lbWJlci5uYW1lKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdW5pID0gbmV3IENHTC5Vbmlmb3JtKHRoaXMsIG1lbWJlci50eXBlLCB1bmlmb3JtTmFtZSArIFwiLlwiICsgbWVtYmVyLm5hbWUsIG1lbWJlci52MSwgbWVtYmVyLnYyLCBtZW1iZXIudjMsIG1lbWJlci52NCwgdW5pZm9ybU5hbWUsIHN0cnVjdE5hbWUsIG1lbWJlci5uYW1lKTtcbiAgICAgICAgICAgIHVuaS5zaGFkZXJUeXBlID0gXCJ2ZXJ0XCI7XG4gICAgICAgICAgICB1bmlmb3Jtc1t1bmlmb3JtTmFtZSArIFwiLlwiICsgbWVtYmVyLm5hbWVdID0gdW5pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaWZvcm1zO1xufTtcblxuLyoqXG4gKiBhZGQgYSBzdHJ1Y3QgJiBpdHMgdW5pZm9ybXMgdG8gdGhlIGJvdGggc2hhZGVycy4gUExFQVNFIE5PVEU6IGl0IGlzIG5vdCBwb3NzaWJsZSB0byBhZGQgdGhlIHNhbWUgc3RydWN0IHRvIGJvdGggc2hhZGVycyB3aGVuIGl0IGNvbnRhaW5zIEFOWSBpbnRlZ2VyIG1lbWJlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RydWN0TmFtZSBuYW1lIG9mIHRoZSBzdHJ1Y3QsIGkuZS46IExpZ2h0U3RydWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdW5pZm9ybU5hbWUgbmFtZSBvZiB0aGUgc3RydWN0IHVuaWZvcm0gaW4gdGhlIHNoYWRlciwgaS5lLjogbGlnaHRVbmlcbiAqIEBwYXJhbSB7QXJyYXl9IG1lbWJlcnMgYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBzdHJ1Y3QgbWVtYmVycy4gc2VlIGV4YW1wbGUgZm9yIHN0cnVjdHVyZVxuXG4gKiBAbWVtYmVyb2YgU2hhZGVyXG4gKiBAaW5zdGFuY2VcbiAqIEBmdW5jdGlvbiBhZGRVbmlmb3JtU3RydWN0Qm90aFxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBleGFtcGxlXG4gKiBjb25zdCBzaGFkZXIgPSBuZXcgQ0dMLlNoYWRlcihjZ2wsICdNaW5pbWFsTWF0ZXJpYWwnKTtcbiAqIHNoYWRlci5zZXRTb3VyY2UoYXR0YWNobWVudHMuc2hhZGVyX3ZlcnQsIGF0dGFjaG1lbnRzLnNoYWRlcl9mcmFnKTtcbiAqIHNoYWRlci5hZGRVbmlmb3JtU3RydWN0Qm90aChcIkxpZ2h0XCIsIFwidW5pZm9ybUxpZ2h0XCIsIFtcbiAqIHsgXCJ0eXBlXCI6IFwiM2ZcIiwgXCJuYW1lXCI6IFwicG9zaXRpb25cIiwgXCJ2MVwiOiBudWxsIH0sXG4gKiB7IFwidHlwZVwiOiBcIjRmXCIsIFwibmFtZVwiOiBcImNvbG9yXCIsIFwidjFcIjogaW5SLCB2MjogaW5HLCB2MzogaW5CLCB2NDogaW5BbHBoYSB9XG4gKiBdKTtcbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5hZGRVbmlmb3JtU3RydWN0Qm90aCA9IGZ1bmN0aW9uIChzdHJ1Y3ROYW1lLCB1bmlmb3JtTmFtZSwgbWVtYmVycylcbntcbiAgICBjb25zdCB1bmlmb3JtcyA9IHt9O1xuXG4gICAgaWYgKCFtZW1iZXJzKSByZXR1cm4gdW5pZm9ybXM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lbWJlcnMubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgICAgICBjb25zdCBtZW1iZXIgPSBtZW1iZXJzW2ldO1xuICAgICAgICBpZiAoKG1lbWJlci50eXBlID09PSBcIjJpXCIgfHwgbWVtYmVyLnR5cGUgPT09IFwiaVwiIHx8IG1lbWJlci50eXBlID09PSBcIjNpXCIpKVxuICAgICAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwiQWRkaW5nIGFuIGludGVnZXIgc3RydWN0IG1lbWJlciB0byBib3RoIHNoYWRlcnMgY2FuIHBvdGVudGlhbGx5IGVycm9yLiBQbGVhc2UgdXNlIGRpZmZlcmVudCBzdHJ1Y3RzIGZvciBlYWNoIHNoYWRlci4gRXJyb3Igb2NjdXJlZCBpbiBzdHJ1Y3Q6XCIsIHN0cnVjdE5hbWUsIFwiIHdpdGggbWVtYmVyOlwiLCBtZW1iZXIubmFtZSwgXCIgb2YgdHlwZTpcIiwgbWVtYmVyLnR5cGUsIFwiLlwiKTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1VuaWZvcm0odW5pZm9ybU5hbWUgKyBcIi5cIiArIG1lbWJlci5uYW1lKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdW5pID0gbmV3IENHTC5Vbmlmb3JtKHRoaXMsIG1lbWJlci50eXBlLCB1bmlmb3JtTmFtZSArIFwiLlwiICsgbWVtYmVyLm5hbWUsIG1lbWJlci52MSwgbWVtYmVyLnYyLCBtZW1iZXIudjMsIG1lbWJlci52NCwgdW5pZm9ybU5hbWUsIHN0cnVjdE5hbWUsIG1lbWJlci5uYW1lKTtcbiAgICAgICAgICAgIHVuaS5zaGFkZXJUeXBlID0gXCJib3RoXCI7XG4gICAgICAgICAgICB1bmlmb3Jtc1t1bmlmb3JtTmFtZSArIFwiLlwiICsgbWVtYmVyLm5hbWVdID0gdW5pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaWZvcm1zO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5oYXNVbmlmb3JtID0gZnVuY3Rpb24gKG5hbWUpXG57XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl91bmlmb3Jtcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl91bmlmb3Jtc1tpXS5nZXROYW1lKCkgPT0gbmFtZSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblNoYWRlci5wcm90b3R5cGUuX2NyZWF0ZVByb2dyYW0gPSBmdW5jdGlvbiAodnN0ciwgZnN0cilcbntcbiAgICB0aGlzLl9jZ2wucHJpbnRFcnJvcihcImJlZm9yZSBfY3JlYXRlcHJvZ3JhbVwiKTtcblxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLl9jZ2wuZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgdGhpcy52c2hhZGVyID0gU2hhZGVyLmNyZWF0ZVNoYWRlcih0aGlzLl9jZ2wsIHZzdHIsIHRoaXMuX2NnbC5nbC5WRVJURVhfU0hBREVSLCB0aGlzKTtcbiAgICB0aGlzLmZzaGFkZXIgPSBTaGFkZXIuY3JlYXRlU2hhZGVyKHRoaXMuX2NnbCwgZnN0ciwgdGhpcy5fY2dsLmdsLkZSQUdNRU5UX1NIQURFUiwgdGhpcyk7XG5cblxuICAgIGlmICh0aGlzLnZzaGFkZXIgJiYgdGhpcy5mc2hhZGVyKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB0aGlzLnZzaGFkZXIpO1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHRoaXMuZnNoYWRlcik7XG5cbiAgICAgICAgdGhpcy5fbGlua1Byb2dyYW0ocHJvZ3JhbSwgdnN0ciwgZnN0cik7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2dsLnByaW50RXJyb3IoXCJzaGFkZXIgX2NyZWF0ZVByb2dyYW1cIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiY291bGQgbm90IGxpbmsgc2hhZGVycHJvZ3JhbVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fY2dsLnByaW50RXJyb3IoXCJzaGFkZXIgX2NyZWF0ZVByb2dyYW1cIik7XG4gICAgcmV0dXJuIHByb2dyYW07XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLmhhc0Vycm9ycyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX2hhc0Vycm9ycztcbn07XG5cblNoYWRlci5wcm90b3R5cGUuX2xpbmtQcm9ncmFtID0gZnVuY3Rpb24gKHByb2dyYW0sIHZzdHIsIGZzdHIpXG57XG4gICAgdGhpcy5fY2dsLnByaW50RXJyb3IoXCJiZWZvcmUgX2xpbmtwcm9ncmFtXCIpO1xuXG4gICAgaWYgKHRoaXMuX2ZlZWRCYWNrTmFtZXMubGVuZ3RoID4gMClcbiAgICB7XG4gICAgICAgIHRoaXMuX2NnbC5nbC50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzKHByb2dyYW0sIHRoaXMuX2ZlZWRCYWNrTmFtZXMsIHRoaXMuX2NnbC5nbC5TRVBBUkFURV9BVFRSSUJTKTtcbiAgICAgICAgLy8gSU5URVJMRUFWRURfQVRUUklCU1xuICAgICAgICAvLyBTRVBBUkFURV9BVFRSSUJTXG4gICAgfVxuXG4gICAgdGhpcy5fY2dsLmdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIHRoaXMuX2NnbC5wcmludEVycm9yKFwiZ2wubGlua3Byb2dyYW1cIik7XG4gICAgdGhpcy5faXNWYWxpZCA9IHRydWU7XG5cbiAgICB0aGlzLl9oYXNFcnJvcnMgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLl9jZ2wucGF0Y2guY29uZmlnLmdsVmFsaWRhdGVTaGFkZXIgIT09IGZhbHNlKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2dsLmdsLnZhbGlkYXRlUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2NnbC5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIHRoaXMuX2NnbC5nbC5WQUxJREFURV9TVEFUVVMpKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyB2YWxpZGF0aW9uIGZhaWxlZFxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJzaGFkZXJwcm9ncmFtIHZhbGlkYXRpb24gZmFpbGVkLi4uXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5fbmFtZSArIFwiIHByb2dyYW1pbmZvOiBcIiwgdGhpcy5fY2dsLmdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fY2dsLmdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgdGhpcy5fY2dsLmdsLkxJTktfU1RBVFVTKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5faGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKHRoaXMuX2NnbC5nbC5nZXRTaGFkZXJJbmZvTG9nKHRoaXMuZnNoYWRlcikgfHwgXCJlbXB0eSBzaGFkZXIgaW5mb2xvZ1wiKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKHRoaXMuX2NnbC5nbC5nZXRTaGFkZXJJbmZvTG9nKHRoaXMudnNoYWRlcikgfHwgXCJlbXB0eSBzaGFkZXIgaW5mb2xvZ1wiKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcih0aGlzLl9uYW1lICsgXCIgc2hhZGVyIGxpbmtpbmcgZmFpbC4uLlwiKTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5fbmFtZSArIFwiIHByb2dyYW1pbmZvOiBcIiwgdGhpcy5fY2dsLmdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgdGhpcy5fbmFtZSA9IFwiZXJyb3JzaGFkZXJcIjtcbiAgICAgICAgICAgIHRoaXMuc2V0U291cmNlKFNoYWRlci5nZXREZWZhdWx0VmVydGV4U2hhZGVyKCksIFNoYWRlci5nZXRFcnJvckZyYWdtZW50U2hhZGVyKCkpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLnByaW50RXJyb3IoXCJzaGFkZXIgbGluayBlcnJcIik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLmdldFByb2dyYW0gPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9wcm9ncmFtO1xufTtcblxuU2hhZGVyLnByb3RvdHlwZS5zZXRGZWVkYmFja05hbWVzID0gZnVuY3Rpb24gKG5hbWVzKVxue1xuICAgIHRoaXMuc2V0V2h5Q29tcGlsZShcInNldEZlZWRiYWNrTmFtZXNcIik7XG4gICAgdGhpcy5fbmVlZHNSZWNvbXBpbGUgPSB0cnVlO1xuICAgIHRoaXMuX2ZlZWRCYWNrTmFtZXMgPSBuYW1lcztcbn07XG5cblNoYWRlci5wcm90b3R5cGUuZ2V0RGVmYXVsdFZlcnRleFNoYWRlciA9IFNoYWRlci5nZXREZWZhdWx0VmVydGV4U2hhZGVyID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gZGVmYXVsdFNoYWRlclNyY1ZlcnQ7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLmdldERlZmF1bHRGcmFnbWVudFNoYWRlciA9IFNoYWRlci5nZXREZWZhdWx0RnJhZ21lbnRTaGFkZXIgPSBmdW5jdGlvbiAociwgZywgYilcbntcbiAgICBpZiAociA9PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICByID0gMC41O1xuICAgICAgICBnID0gMC41O1xuICAgICAgICBiID0gMC41O1xuICAgIH1cbiAgICByZXR1cm4gXCJcIlxuICAgICAgICAuZW5kbCgpICsgXCJJTiB2ZWMyIHRleENvb3JkO1wiXG4gICAgICAgIC5lbmRsKCkgKyBcInt7TU9EVUxFU19IRUFEfX1cIlxuICAgICAgICAuZW5kbCgpICsgXCJ2b2lkIG1haW4oKVwiXG4gICAgICAgIC5lbmRsKCkgKyBcIntcIlxuICAgICAgICAuZW5kbCgpICsgXCIgICAgdmVjNCBjb2w9dmVjNChcIiArIHIgKyBcIixcIiArIGcgKyBcIixcIiArIGIgKyBcIiwxLjApO1wiXG4gICAgICAgIC5lbmRsKCkgKyBcIiAgICB7e01PRFVMRV9DT0xPUn19XCJcbiAgICAgICAgLmVuZGwoKSArIFwiICAgIG91dENvbG9yID0gY29sO1wiXG4gICAgICAgIC5lbmRsKCkgKyBcIn1cIjtcbn07XG5cbi8qKlxuICAqIGFkZHMgYXR0cmlidXRlIGRlZmluaXRpb24gdG8gc2hhZGVyIGhlYWRlciB3aXRob3V0IGNvbGxpZGluZyB3aXRoIG90aGVyIHNoYWRlciBtb2R1bGVzLi4uXG4gKiB3aGVuIGF0dHJGcmFnIGlzIGRlZmluZWQsIHZlcnRleCBzaGFkZXIgd2lsbCBvdXRwdXQgdGhpcyBhdHRyaWJ1dGUgdG8gdGhlIGZyYWdtZW50IHNoYWRlclxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgU2hhZGVyXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJPYmplY3Qge3R5cGU6eCxuYW1lOngsW25hbWVGcmFnOnhdfVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5TaGFkZXIucHJvdG90eXBlLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyKVxue1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzW2ldLm5hbWUgPT0gYXR0ci5uYW1lICYmIHRoaXMuX2F0dHJpYnV0ZXNbaV0ubmFtZUZyYWcgPT0gYXR0ci5uYW1lRnJhZykgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gICAgdGhpcy5fbmVlZHNSZWNvbXBpbGUgPSB0cnVlO1xuICAgIHRoaXMuc2V0V2h5Q29tcGlsZShcImFkZEF0dHJpYnV0ZVwiKTtcbn07XG5cblNoYWRlci5wcm90b3R5cGUuYmluZFRleHR1cmVzID1cblNoYWRlci5wcm90b3R5cGUuX2JpbmRUZXh0dXJlcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX3RleHR1cmVTdGFja1RleC5sZW5ndGggPiB0aGlzLl9jZ2wubWF4VGV4dHVyZVVuaXRzKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJbc2hhZGVyLl9iaW5kVGV4dHVyZXNdIHRvbyBtYW55IHRleHR1cmVzIGJvdW5kXCIsIHRoaXMuX3RleHR1cmVTdGFja1RleC5sZW5ndGggKyBcIi9cIiArIHRoaXMuX2NnbC5tYXhUZXh0dXJlVW5pdHMpO1xuICAgIH1cblxuICAgIC8vIGZvciAobGV0IGkgPSB0aGlzLl90ZXh0dXJlU3RhY2tUZXgubGVuZ3RoICsgMTsgaSA8IHRoaXMuX2NnbC5tYXhUZXh0dXJlVW5pdHM7IGkrKykgdGhpcy5fY2dsLnNldFRleHR1cmUoaSwgbnVsbCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3RleHR1cmVTdGFja1RleC5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuX3RleHR1cmVTdGFja1RleC5sZW5ndGgsIGkpO1xuICAgICAgICBpZiAoIXRoaXMuX3RleHR1cmVTdGFja1RleFtpXSAmJiAhdGhpcy5fdGV4dHVyZVN0YWNrVGV4Q2dsW2ldKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIm5vIHRleHR1cmUgZm9yIHB1c2h0ZXh0dXJlXCIsIHRoaXMuX25hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHQgPSB0aGlzLl90ZXh0dXJlU3RhY2tUZXhbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZVN0YWNrVGV4Q2dsW2ldKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHQgPSB0aGlzLl90ZXh0dXJlU3RhY2tUZXhDZ2xbaV0udGV4IHx8IENHTC5UZXh0dXJlLmdldEVtcHR5VGV4dHVyZSh0aGlzLl9jZ2wpLnRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGJpbmRPayA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fdGV4dHVyZVN0YWNrVW5pW2ldKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIHRocm93KG5ldyBFcnJvcignbm8gdW5pZm9ybSBnaXZlbiB0byB0ZXh0dXJlc3RhY2snKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJubyB1bmlmb3JtIGZvciBwdXNodGV4dHVyZVwiLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgICAgICAgICBiaW5kT2sgPSB0aGlzLl9jZ2wuc2V0VGV4dHVyZShpLCB0LCB0aGlzLl90ZXh0dXJlU3RhY2tUeXBlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlU3RhY2tVbmlbaV0uc2V0VmFsdWUoaSk7XG4gICAgICAgICAgICAgICAgYmluZE9rID0gdGhpcy5fY2dsLnNldFRleHR1cmUoaSwgdCwgdGhpcy5fdGV4dHVyZVN0YWNrVHlwZVtpXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhiaW5kT2ssIGksIHQsIHRoaXMuX3RleHR1cmVTdGFja1R5cGVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFiaW5kT2spIGNvbnNvbGUud2FybihcInRleCBiaW5kIGZhaWxlZFwiLCB0aGlzLmdldE5hbWUoKSwgdGhpcy5fdGV4dHVyZVN0YWNrVW5pW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblNoYWRlci5wcm90b3R5cGUuc2V0VW5pZm9ybVRleHR1cmUgPSBmdW5jdGlvbiAodW5pLCB0ZXgpXG57XG4gICAgdGV4ID0gdGV4IHx8IENHTC5UZXh0dXJlLmdldFRlbXBUZXh0dXJlKHRoaXMuX2NnbCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90ZXh0dXJlU3RhY2tVbmkubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICh0aGlzLl90ZXh0dXJlU3RhY2tVbmlbaV0gPT0gdW5pKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvbGQgPSB0aGlzLl90ZXh0dXJlU3RhY2tUZXhbaV0gfHwgdGhpcy5fdGV4dHVyZVN0YWNrVGV4Q2dsW2ldO1xuICAgICAgICAgICAgaWYgKHRleC5oYXNPd25Qcm9wZXJ0eShcInRleFwiKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlU3RhY2tUZXhDZ2xbaV0gPSB0ZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZVN0YWNrVGV4W2ldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlU3RhY2tUZXhDZ2xbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cmVTdGFja1RleFtpXSA9IHRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhpcy5fdGV4dHVyZVN0YWNrVGV4W2ldID0gdGV4O1xuICAgICAgICAgICAgLy8gdGhpcy5fY2dsLnNldFRleHR1cmUoaSwgdGV4LCB0aGlzLl90ZXh0dXJlU3RhY2tUeXBlW2ldKTtcbiAgICAgICAgICAgIHJldHVybiBvbGQ7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogcHVzaCBhIHRleHR1cmUgb24gdGhlIHN0YWNrLiB0aG9zZSB0ZXh0dXJlcyB3aWxsIGJlIGJvdW5kIHdoZW4gYmluZGluZyB0aGUgc2hhZGVyLiB0ZXh0dXJlIHNsb3RzIGFyZSBhdXRvbWF0aWNhbGx5IHNldFxuICogQHBhcmFtIHt1bmlmb3JtfSB0ZXh0dXJlIHVuaWZvcm1cbiAqIEBwYXJhbSB7dGV4dHVyZX0gdGV4dHVyZVxuICogQHBhcmFtIHt0eXBlfSB0ZXh0dXJlIHR5cGUsIGNhbiBiZSBpZ25vcmVkIHdoZW4gVEVYVFVSRV8yRFxuICogQGZ1bmN0aW9uIHB1c2hUZXh0dXJlXG4gKiBAbWVtYmVyb2YgU2hhZGVyXG4gKiBAaW5zdGFuY2VcbiAqL1xuU2hhZGVyLnByb3RvdHlwZS5wdXNoVGV4dHVyZSA9IGZ1bmN0aW9uICh1bmlmb3JtLCB0LCB0eXBlKVxue1xuICAgIGlmICghdW5pZm9ybSlcbiAgICB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibm8gdW5pZm9ybSBnaXZlbiB0byB0ZXh0dXJlc3RhY2tcIiwgdW5pZm9ybSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0KVxuICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXQuaGFzT3duUHJvcGVydHkoXCJ0ZXhcIikgJiYgISh0IGluc3RhbmNlb2YgV2ViR0xUZXh0dXJlKSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy53YXJuKG5ldyBFcnJvcihcImludmFsaWQgdGV4dHVyZVwiKS5zdGFjayk7XG5cbiAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJbY2dsX3NoYWRlcl0gaW52YWxpZCB0ZXh0dXJlLi4uXCIsIHQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fdGV4dHVyZVN0YWNrVW5pLnB1c2godW5pZm9ybSk7XG5cbiAgICBpZiAodC5oYXNPd25Qcm9wZXJ0eShcInRleFwiKSlcbiAgICB7XG4gICAgICAgIHRoaXMuX3RleHR1cmVTdGFja1RleENnbC5wdXNoKHQpO1xuICAgICAgICB0aGlzLl90ZXh0dXJlU3RhY2tUZXgucHVzaChudWxsKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5fdGV4dHVyZVN0YWNrVGV4Q2dsLnB1c2gobnVsbCk7XG4gICAgICAgIHRoaXMuX3RleHR1cmVTdGFja1RleC5wdXNoKHQpO1xuICAgIH1cblxuICAgIHRoaXMuX3RleHR1cmVTdGFja1R5cGUucHVzaCh0eXBlKTtcbn07XG5cbi8qKlxuICogcG9wIGxhc3QgdGV4dHVyZVxuICogQGZ1bmN0aW9uIHBvcFRleHR1cmVcbiAqIEBtZW1iZXJvZiBTaGFkZXJcbiAqIEBpbnN0YW5jZVxuICovXG5TaGFkZXIucHJvdG90eXBlLnBvcFRleHR1cmUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX3RleHR1cmVTdGFja1VuaS5wb3AoKTtcbiAgICB0aGlzLl90ZXh0dXJlU3RhY2tUZXgucG9wKCk7XG4gICAgdGhpcy5fdGV4dHVyZVN0YWNrVGV4Q2dsLnBvcCgpO1xuICAgIHRoaXMuX3RleHR1cmVTdGFja1R5cGUucG9wKCk7XG59O1xuXG4vKipcbiAqIHBvcCBhbGwgdGV4dHVyZXNcbiAqIEBmdW5jdGlvbiBwb3BUZXh0dXJlc1xuICogQG1lbWJlcm9mIFNoYWRlclxuICogQGluc3RhbmNlXG4gKi9cblNoYWRlci5wcm90b3R5cGUucG9wVGV4dHVyZXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX3RleHR1cmVTdGFja1RleC5sZW5ndGggPVxuICAgIHRoaXMuX3RleHR1cmVTdGFja1RleENnbC5sZW5ndGggPVxuICAgIHRoaXMuX3RleHR1cmVTdGFja1R5cGUubGVuZ3RoID1cbiAgICB0aGlzLl90ZXh0dXJlU3RhY2tVbmkubGVuZ3RoID0gMDtcbn07XG5cblNoYWRlci5wcm90b3R5cGUuZ2V0TWF0ZXJpYWxJZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX21hdGVyaWFsSWQ7XG59O1xuXG5TaGFkZXIucHJvdG90eXBlLmdldEluZm8gPSBmdW5jdGlvbiAoKVxue1xuICAgIGNvbnN0IGluZm8gPSB7fTtcbiAgICBpbmZvLm5hbWUgPSB0aGlzLl9uYW1lO1xuICAgIC8vIGluZm8ubW9kdWxlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5fbW9kdWxlcykpO1xuICAgIC8vIGluZm8uZGVmaW5lcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5fZGVmaW5lcykpO1xuICAgIGluZm8uZGVmaW5lcyA9IHRoaXMuZ2V0RGVmaW5lcygpO1xuICAgIGluZm8uaGFzRXJyb3JzID0gdGhpcy5oYXNFcnJvcnMoKTtcblxuICAgIHJldHVybiBpbmZvO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuU2hhZGVyLmdldEVycm9yRnJhZ21lbnRTaGFkZXIgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiBcIlwiXG4gICAgICAgIC5lbmRsKCkgKyBcInZvaWQgbWFpbigpXCJcbiAgICAgICAgLmVuZGwoKSArIFwie1wiXG4gICAgICAgIC5lbmRsKCkgKyBcIiAgIGZsb2F0IGc9bW9kKChnbF9GcmFnQ29vcmQueStnbF9GcmFnQ29vcmQueCksNTAuMCkvNTAuMDtcIlxuICAgICAgICAuZW5kbCgpICsgXCIgICBnPSBzdGVwKDAuMSxnKTtcIlxuICAgICAgICAuZW5kbCgpICsgXCIgICBvdXRDb2xvciA9IHZlYzQoIGcrMC41LCAwLjAsIDAuMCwgMS4wKTtcIlxuICAgICAgICAuZW5kbCgpICsgXCJ9XCI7XG59O1xuXG5TaGFkZXIuY3JlYXRlU2hhZGVyID0gZnVuY3Rpb24gKGNnbCwgc3RyLCB0eXBlLCBjZ2xTaGFkZXIpXG57XG4gICAgaWYgKGNnbC5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAvLyBjZ2wucHJpbnRFcnJvcihcIltTaGFkZXIuY3JlYXRlU2hhZGVyXSBcIiwgY2dsU2hhZGVyLl9uYW1lKTtcblxuICAgIGZ1bmN0aW9uIGdldEJhZExpbmVzKGluZm9Mb2cpXG4gICAge1xuICAgICAgICBjb25zdCBiYXNMaW5lcyA9IFtdO1xuICAgICAgICBjb25zdCBsaW5lcyA9IGluZm9Mb2cuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIGZvciAoY29uc3QgaSBpbiBsaW5lcylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZGl2aWRlID0gbGluZXNbaV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgaWYgKHBhcnNlSW50KGRpdmlkZVsyXSwgMTApKSBiYXNMaW5lcy5wdXNoKHBhcnNlSW50KGRpdmlkZVsyXSwgMTApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzTGluZXM7XG4gICAgfVxuXG5cbiAgICBjb25zdCBzaGFkZXIgPSBjZ2wuZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICAgIGNnbC5nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzdHIpO1xuICAgIGNnbC5nbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG5cbiAgICBpZiAoIWNnbC5nbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBjZ2wuZ2wuQ09NUElMRV9TVEFUVVMpKVxuICAgIHtcbiAgICAgICAgbGV0IGluZm9Mb2cgPSBjZ2wuZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgICAgICBpZiAoIWluZm9Mb2cpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImVtcHR5IHNoYWRlciBpbmZvIGxvZ1wiLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiY29tcGlsZSBzdGF0dXM6IFwiKTtcblxuICAgICAgICBjb25zdCBiYWRMaW5lcyA9IGdldEJhZExpbmVzKGluZm9Mb2cpO1xuICAgICAgICBsZXQgaHRtbFdhcm5pbmcgPSBcIjxwcmUgc3R5bGU9XFxcIm1hcmdpbi1ib3R0b206MHB4O1xcXCI+PGNvZGUgY2xhc3M9XFxcInNoYWRlckVycm9yQ29kZSBsYW5ndWFnZS1nbHNsXFxcIiBzdHlsZT1cXFwicGFkZGluZy1ib3R0b206MHB4O21heC1oZWlnaHQ6IGluaXRpYWw7bWF4LXdpZHRoOiBpbml0aWFsO1xcXCI+XCI7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gc3RyLm1hdGNoKC9eLiooKFxcclxcbnxcXG58XFxyKXwkKS9nbSk7XG5cbiAgICAgICAgaWYgKCFjZ2wuYWJvcnRlZCAmJiBpbmZvTG9nKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBjZ2wuZ2wuVkVSVEVYX1NIQURFUikgY29uc29sZS5sb2coXCJWRVJURVhfU0hBREVSXCIpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gY2dsLmdsLkZSQUdNRU5UX1NIQURFUikgY29uc29sZS5sb2coXCJGUkFHTUVOVF9TSEFERVJcIik7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiBsaW5lcylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqID0gcGFyc2VJbnQoaSwgMTApICsgMTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gaiArIFwiOiBcIiArIGxpbmVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGxpbmUpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGlzQmFkTGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYmogaW4gYmFkTGluZXMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChiYWRMaW5lc1tial0gPT0gaikgaXNCYWRMaW5lID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0JhZExpbmUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBodG1sV2FybmluZyArPSBcIjwvY29kZT48L3ByZT5cIjtcbiAgICAgICAgICAgICAgICAgICAgLy8gaHRtbFdhcm5pbmcgKz0gXCI8c3BhbiBjbGFzcz1cXFwic2hhZGVyRXJyb3JDb2RlIGVycm9yXFxcIj5cIjtcbiAgICAgICAgICAgICAgICAgICAgaHRtbFdhcm5pbmcgKz0gXCI8cHJlIHN0eWxlPVxcXCJtYXJnaW46MFxcXCI+PGNvZGUgY2xhc3M9XFxcImxhbmd1YWdlLWdsc2xcXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kLWNvbG9yOiM2NjAwMDA7cGFkZGluZy10b3A6MHB4O3BhZGRpbmctYm90dG9tOjBweFxcXCI+XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGh0bWxXYXJuaW5nICs9IGVzY2FwZUhUTUwobGluZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNCYWRMaW5lKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbFdhcm5pbmcgKz0gXCI8L2NvZGU+PC9wcmU+XCI7XG4gICAgICAgICAgICAgICAgICAgIGh0bWxXYXJuaW5nICs9IFwiPHByZSBzdHlsZT1cXFwibWFyZ2luOjBcXFwiPjxjb2RlIGNsYXNzPVxcXCJsYW5ndWFnZS1nbHNsXFxcIiBzdHlsZT1cXFwiO3BhZGRpbmctdG9wOjBweDtwYWRkaW5nLWJvdHRvbTowcHhcXFwiPlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUud2FybihpbmZvTG9nKTtcblxuICAgICAgICBpbmZvTG9nID0gaW5mb0xvZy5yZXBsYWNlKC9cXG4vZywgXCI8YnIvPlwiKTtcbiAgICAgICAgaWYgKGNnbC5wYXRjaC5pc0VkaXRvck1vZGUoKSljb25zb2xlLmxvZyhcIlNoYWRlciBlcnJvciBcIiwgY2dsU2hhZGVyLl9uYW1lLCBpbmZvTG9nLCB0aGlzKTtcblxuICAgICAgICBodG1sV2FybmluZyA9IGluZm9Mb2cgKyBcIjxici8+XCIgKyBodG1sV2FybmluZyArIFwiPGJyLz48YnIvPlwiO1xuICAgICAgICBodG1sV2FybmluZyArPSBcIjwvY29kZT48L3ByZT5cIjtcblxuICAgICAgICBjZ2wucGF0Y2guZW1pdEV2ZW50KFwiY3JpdGljYWxFcnJvclwiLCB7IFwidGl0bGVcIjogXCJTaGFkZXIgZXJyb3IgXCIgKyBjZ2xTaGFkZXIuX25hbWUsIFwidGV4dFwiOiBodG1sV2FybmluZywgXCJleGNlcHRpb25cIjogeyBcIm1lc3NhZ2VcIjogaW5mb0xvZyB9IH0pO1xuXG4gICAgICAgIC8vIHRoaXMuX25hbWUgPSBcImVycm9yc2hhZGVyXCI7XG4gICAgICAgIGNnbFNoYWRlci5zZXRTb3VyY2UoU2hhZGVyLmdldERlZmF1bHRWZXJ0ZXhTaGFkZXIoKSwgU2hhZGVyLmdldEVycm9yRnJhZ21lbnRTaGFkZXIoKSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG5hbWUrJyBzaGFkZXIgY29tcGlsZWQuLi4nKTtcbiAgICB9XG4gICAgLy8gY2dsLnByaW50RXJyb3IoXCJzaGFkZXIgY3JlYXRlMlwiKTtcbiAgICByZXR1cm4gc2hhZGVyO1xufTtcblxuXG5leHBvcnQgeyBTaGFkZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_shader.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_shader_lib.js":
/*!****************************************!*\
  !*** ./src/core/cgl/cgl_shader_lib.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShaderLibMods\": () => (/* binding */ ShaderLibMods)\n/* harmony export */ });\n/* harmony import */ var _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgl_shader_uniform.js */ \"./src/core/cgl/cgl_shader_uniform.js\");\n/* harmony import */ var _cgl_texture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgl_texture.js */ \"./src/core/cgl/cgl_texture.js\");\n/* harmony import */ var _cgl_textureeffect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cgl_textureeffect.js */ \"./src/core/cgl/cgl_textureeffect.js\");\n\n\n\n\nconst ShaderLibMods = {\n    \"CGL.BLENDMODES\": function ()\n    {\n        this.name = \"blendmodes\";\n        this.srcHeadFrag = _cgl_textureeffect_js__WEBPACK_IMPORTED_MODULE_0__.TextureEffect.getBlendCode();\n    },\n    \"CGL.BLENDMODES3\": function ()\n    {\n        this.name = \"blendmodes3\";\n        this.srcHeadFrag = _cgl_textureeffect_js__WEBPACK_IMPORTED_MODULE_0__.TextureEffect.getBlendCode(3);\n    },\n\n    \"CGL.LUMINANCE\": function ()\n    {\n        this.name = \"luminance\";\n        this.srcHeadFrag = \"\".endl()\n            + \"float cgl_luminance(vec3 c)\".endl()\n            + \"{\".endl()\n            + \"    return dot(vec3(0.2126,0.7152,0.0722),c);\".endl()\n            + \"}\".endl();\n    },\n\n\n    // quite good random numbers, but somehow don't work in ANGLE\n    \"CGL.RANDOM_OLD\": function ()\n    {\n        this.name = \"randomNumber\";\n        this.srcHeadFrag = \"\".endl()\n            + \"float cgl_random(vec2 co)\".endl()\n            + \"{\".endl()\n            + \"    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 432758.5453);\".endl()\n            + \"}\".endl()\n            + \"vec3 cgl_random3(vec2 co)\".endl()\n            + \"{\".endl()\n            + \"    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));\".endl()\n            + \"}\";\n    },\n\n\n    // low quality generative ranodm numbers\n    \"CGL.RANDOM_LOW\": function ()\n    {\n        this.name = \"randomNumber\";\n        this.srcHeadFrag = \"\".endl()\n            + \"float cgl_random(vec2 co)\".endl()\n            + \"{\".endl()\n            + \"    return fract(sin(dot(co.xy ,vec2(12.9898,4.1414))) * 358.5453);\".endl()\n            + \"}\".endl()\n            + \"vec3 cgl_random3(vec2 co)\".endl()\n            + \"{\".endl()\n            + \"    return vec3( cgl_random(co),cgl_random(co+0.5711),cgl_random(co+1.5711));\".endl()\n            + \"}\";\n    },\n\n    // texture based random numbers\n    \"CGL.RANDOM_TEX\": function ()\n    {\n        this.name = \"randomNumbertex\";\n        this.srcHeadFrag = \"\".endl()\n            + \"UNI sampler2D CGLRNDTEX;\".endl()\n            + \"float cgl_random(vec2 co)\".endl()\n            + \"{\".endl()\n            + \"    return texture(CGLRNDTEX,co*5711.0).r;\".endl()\n            + \"}\".endl()\n            + \"vec3 cgl_random3(vec2 co)\".endl()\n            + \"{\".endl()\n            + \"    return texture(CGLRNDTEX,co*5711.0).rgb;\".endl()\n            + \"}\";\n\n        this.initUniforms = function (shader)\n        {\n            return [new _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_1__.Uniform(shader, \"t\", \"CGLRNDTEX\", 7)];\n        };\n\n        this.onBind = function (cgl, shader)\n        {\n            _cgl_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture.getRandomTexture(cgl);\n            cgl.setTexture(7, _cgl_texture_js__WEBPACK_IMPORTED_MODULE_2__.Texture.getRandomTexture(cgl).tex);\n        };\n    },\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3NoYWRlcl9saWIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dsL2NnbF9zaGFkZXJfbGliLmpzP2I0YzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVW5pZm9ybSB9IGZyb20gXCIuL2NnbF9zaGFkZXJfdW5pZm9ybS5qc1wiO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gXCIuL2NnbF90ZXh0dXJlLmpzXCI7XG5pbXBvcnQgeyBUZXh0dXJlRWZmZWN0IH0gZnJvbSBcIi4vY2dsX3RleHR1cmVlZmZlY3QuanNcIjtcblxuY29uc3QgU2hhZGVyTGliTW9kcyA9IHtcbiAgICBcIkNHTC5CTEVORE1PREVTXCI6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLm5hbWUgPSBcImJsZW5kbW9kZXNcIjtcbiAgICAgICAgdGhpcy5zcmNIZWFkRnJhZyA9IFRleHR1cmVFZmZlY3QuZ2V0QmxlbmRDb2RlKCk7XG4gICAgfSxcbiAgICBcIkNHTC5CTEVORE1PREVTM1wiOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJibGVuZG1vZGVzM1wiO1xuICAgICAgICB0aGlzLnNyY0hlYWRGcmFnID0gVGV4dHVyZUVmZmVjdC5nZXRCbGVuZENvZGUoMyk7XG4gICAgfSxcblxuICAgIFwiQ0dMLkxVTUlOQU5DRVwiOiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJsdW1pbmFuY2VcIjtcbiAgICAgICAgdGhpcy5zcmNIZWFkRnJhZyA9IFwiXCIuZW5kbCgpXG4gICAgICAgICAgICArIFwiZmxvYXQgY2dsX2x1bWluYW5jZSh2ZWMzIGMpXCIuZW5kbCgpXG4gICAgICAgICAgICArIFwie1wiLmVuZGwoKVxuICAgICAgICAgICAgKyBcIiAgICByZXR1cm4gZG90KHZlYzMoMC4yMTI2LDAuNzE1MiwwLjA3MjIpLGMpO1wiLmVuZGwoKVxuICAgICAgICAgICAgKyBcIn1cIi5lbmRsKCk7XG4gICAgfSxcblxuXG4gICAgLy8gcXVpdGUgZ29vZCByYW5kb20gbnVtYmVycywgYnV0IHNvbWVob3cgZG9uJ3Qgd29yayBpbiBBTkdMRVxuICAgIFwiQ0dMLlJBTkRPTV9PTERcIjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMubmFtZSA9IFwicmFuZG9tTnVtYmVyXCI7XG4gICAgICAgIHRoaXMuc3JjSGVhZEZyYWcgPSBcIlwiLmVuZGwoKVxuICAgICAgICAgICAgKyBcImZsb2F0IGNnbF9yYW5kb20odmVjMiBjbylcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCJ7XCIuZW5kbCgpXG4gICAgICAgICAgICArIFwiICAgIHJldHVybiBmcmFjdChzaW4oZG90KGNvLnh5ICx2ZWMyKDEyLjk4OTgsNC4xNDE0KSkpICogNDMyNzU4LjU0NTMpO1wiLmVuZGwoKVxuICAgICAgICAgICAgKyBcIn1cIi5lbmRsKClcbiAgICAgICAgICAgICsgXCJ2ZWMzIGNnbF9yYW5kb20zKHZlYzIgY28pXCIuZW5kbCgpXG4gICAgICAgICAgICArIFwie1wiLmVuZGwoKVxuICAgICAgICAgICAgKyBcIiAgICByZXR1cm4gdmVjMyggY2dsX3JhbmRvbShjbyksY2dsX3JhbmRvbShjbyswLjU3MTEpLGNnbF9yYW5kb20oY28rMS41NzExKSk7XCIuZW5kbCgpXG4gICAgICAgICAgICArIFwifVwiO1xuICAgIH0sXG5cblxuICAgIC8vIGxvdyBxdWFsaXR5IGdlbmVyYXRpdmUgcmFub2RtIG51bWJlcnNcbiAgICBcIkNHTC5SQU5ET01fTE9XXCI6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB0aGlzLm5hbWUgPSBcInJhbmRvbU51bWJlclwiO1xuICAgICAgICB0aGlzLnNyY0hlYWRGcmFnID0gXCJcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCJmbG9hdCBjZ2xfcmFuZG9tKHZlYzIgY28pXCIuZW5kbCgpXG4gICAgICAgICAgICArIFwie1wiLmVuZGwoKVxuICAgICAgICAgICAgKyBcIiAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChjby54eSAsdmVjMigxMi45ODk4LDQuMTQxNCkpKSAqIDM1OC41NDUzKTtcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCJ9XCIuZW5kbCgpXG4gICAgICAgICAgICArIFwidmVjMyBjZ2xfcmFuZG9tMyh2ZWMyIGNvKVwiLmVuZGwoKVxuICAgICAgICAgICAgKyBcIntcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCIgICAgcmV0dXJuIHZlYzMoIGNnbF9yYW5kb20oY28pLGNnbF9yYW5kb20oY28rMC41NzExKSxjZ2xfcmFuZG9tKGNvKzEuNTcxMSkpO1wiLmVuZGwoKVxuICAgICAgICAgICAgKyBcIn1cIjtcbiAgICB9LFxuXG4gICAgLy8gdGV4dHVyZSBiYXNlZCByYW5kb20gbnVtYmVyc1xuICAgIFwiQ0dMLlJBTkRPTV9URVhcIjogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMubmFtZSA9IFwicmFuZG9tTnVtYmVydGV4XCI7XG4gICAgICAgIHRoaXMuc3JjSGVhZEZyYWcgPSBcIlwiLmVuZGwoKVxuICAgICAgICAgICAgKyBcIlVOSSBzYW1wbGVyMkQgQ0dMUk5EVEVYO1wiLmVuZGwoKVxuICAgICAgICAgICAgKyBcImZsb2F0IGNnbF9yYW5kb20odmVjMiBjbylcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCJ7XCIuZW5kbCgpXG4gICAgICAgICAgICArIFwiICAgIHJldHVybiB0ZXh0dXJlKENHTFJORFRFWCxjbyo1NzExLjApLnI7XCIuZW5kbCgpXG4gICAgICAgICAgICArIFwifVwiLmVuZGwoKVxuICAgICAgICAgICAgKyBcInZlYzMgY2dsX3JhbmRvbTModmVjMiBjbylcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCJ7XCIuZW5kbCgpXG4gICAgICAgICAgICArIFwiICAgIHJldHVybiB0ZXh0dXJlKENHTFJORFRFWCxjbyo1NzExLjApLnJnYjtcIi5lbmRsKClcbiAgICAgICAgICAgICsgXCJ9XCI7XG5cbiAgICAgICAgdGhpcy5pbml0VW5pZm9ybXMgPSBmdW5jdGlvbiAoc2hhZGVyKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBVbmlmb3JtKHNoYWRlciwgXCJ0XCIsIFwiQ0dMUk5EVEVYXCIsIDcpXTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm9uQmluZCA9IGZ1bmN0aW9uIChjZ2wsIHNoYWRlcilcbiAgICAgICAge1xuICAgICAgICAgICAgVGV4dHVyZS5nZXRSYW5kb21UZXh0dXJlKGNnbCk7XG4gICAgICAgICAgICBjZ2wuc2V0VGV4dHVyZSg3LCBUZXh0dXJlLmdldFJhbmRvbVRleHR1cmUoY2dsKS50ZXgpO1xuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5leHBvcnQgeyBTaGFkZXJMaWJNb2RzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_shader_lib.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_shader_uniform.js":
/*!********************************************!*\
  !*** ./src/core/cgl/cgl_shader_uniform.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Uniform\": () => (/* binding */ Uniform)\n/* harmony export */ });\n/* harmony import */ var _cg_cg_uniform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cg/cg_uniform.js */ \"./src/core/cg/cg_uniform.js\");\n\n\n\n\n/**\n * Shader uniforms\n *\n * types:\n * <pre>\n * f    - float\n * 2f   - vec2\n * 3f   - vec3\n * 4f   - vec4\n * i    - integer\n * t    - texture\n * m4   - mat4, 4x4 float matrix\n * f[]  - array of floats\n * 2f[] - array of float vec2\n * 3f[] - array of float vec3\n * 4f[] - array of float vec4\n * </pre>\n *\n * @external CGL\n * @namespace Uniform\n * @class\n * @param {Shader} shader\n * @param {String} [type=f]\n * @param {String} name\n * @param {Number|Port} value  can be a Number,Matrix or Port\n * @example\n * // bind float uniform called myfloat and initialize with value 1.0\n * const unir=new CGL.Uniform(shader,'f','myfloat',1.0);\n * unir.setValue(1.0);\n *\n * // bind float uniform called myfloat and automatically set it to input port value\n * const myPort=op.inFloat(\"input\");\n * const pv=new CGL.Uniform(shader,'f','myfloat',myPort);\n *\n */\n\n\n// export const Uniform(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)\n\nclass Uniform extends _cg_cg_uniform_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n{\n    constructor(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)\n    {\n        super(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName);\n        this._loc = -1;\n        this._cgl = __shader._cgl;\n    }\n\n    get name()\n    {\n        return this._name;\n    }\n\n    copy(newShader)\n    {\n        const uni = new Uniform(newShader, this._type, this._name, this._value, this._port2, this._port3, this._port4, this._structUniformName, this._structName, this._propertyName);\n        uni.shaderType = this.shaderType;\n        return uni;\n    }\n\n    /**\n     * returns type as glsl type string. e.g. 'f' returns 'float'\n     * @function getGlslTypeString\n     * @memberof Uniform\n     * @instance\n     * @return {string} type as string\n     */\n    getGlslTypeString()\n    {\n        return Uniform.glslTypeString(this._type);\n    }\n\n    _isValidLoc()\n    {\n        return this._loc != -1;// && this._loc != null;\n    }\n\n    resetLoc()\n    {\n        this._loc = -1;\n        this.needsUpdate = true;\n    }\n\n    bindTextures() {}\n\n    getLoc()\n    {\n        return this._loc;\n    }\n\n    updateFromPort4f()\n    {\n        this._value[0] = this._port.get();\n        this._value[1] = this._port2.get();\n        this._value[2] = this._port3.get();\n        this._value[3] = this._port4.get();\n        this.setValue(this._value);\n    }\n\n    updateFromPort3f()\n    {\n        this._value[0] = this._port.get();\n        this._value[1] = this._port2.get();\n        this._value[2] = this._port3.get();\n        this.setValue(this._value);\n    }\n\n    updateFromPort2f()\n    {\n        this._value[0] = this._port.get();\n        this._value[1] = this._port2.get();\n        this.setValue(this._value);\n    }\n\n    updateFromPort()\n    {\n        this.setValue(this._port.get());\n    }\n\n    updateValueF()\n    {\n        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n        else this.needsUpdate = false;\n\n        this._shader.getCgl().gl.uniform1f(this._loc, this._value);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValueF(v)\n    {\n        if (v != this._value)\n        {\n            this.needsUpdate = true;\n            this._value = v;\n        }\n    }\n\n    updateValueI()\n    {\n        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n        else this.needsUpdate = false;\n\n        this._shader.getCgl().gl.uniform1i(this._loc, this._value);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    updateValue2I()\n    {\n        if (!this._value) return;\n\n        if (!this._isValidLoc())\n        {\n            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n            this._cgl.profileData.profileShaderGetUniform++;\n            this._cgl.profileData.profileShaderGetUniformName = this._name;\n        }\n\n        this._shader.getCgl().gl.uniform2i(this._loc, this._value[0], this._value[1]);\n\n        this.needsUpdate = false;\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    updateValue3I()\n    {\n        if (!this._value) return;\n        if (!this._isValidLoc())\n        {\n            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n            this._cgl.profileData.profileShaderGetUniform++;\n            this._cgl.profileData.profileShaderGetUniformName = this._name;\n        }\n\n        this._shader.getCgl().gl.uniform3i(this._loc, this._value[0], this._value[1], this._value[2]);\n        this.needsUpdate = false;\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    updateValue4I()\n    {\n        if (!this._isValidLoc())\n        {\n            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n            this._cgl.profileData.profileShaderGetUniform++;\n            this._cgl.profileData.profileShaderGetUniformName = this._name;\n        }\n        this._shader.getCgl().gl.uniform4i(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValueI(v)\n    {\n        if (v != this._value)\n        {\n            this.needsUpdate = true;\n            this._value = v;\n        }\n    }\n\n    setValue2I(v)\n    {\n        if (!v) return;\n        if (!this._oldValue)\n        {\n            this._oldValue = [v[0] - 1, 1];\n            this.needsUpdate = true;\n        }\n        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1])\n        {\n            this._oldValue[0] = v[0];\n            this._oldValue[1] = v[1];\n            this.needsUpdate = true;\n        }\n\n        this._value = v;\n    }\n\n    setValue3I(v)\n    {\n        if (!v) return;\n        if (!this._oldValue)\n        {\n            this._oldValue = [v[0] - 1, 1, 2];\n            this.needsUpdate = true;\n        }\n        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2])\n        {\n            this._oldValue[0] = v[0];\n            this._oldValue[1] = v[1];\n            this._oldValue[2] = v[2];\n            this.needsUpdate = true;\n        }\n\n        this._value = v;\n    }\n\n    setValue4I(v)\n    {\n        this.needsUpdate = true;\n        this._value = v || vec4.create();\n    }\n\n    updateValueBool()\n    {\n        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n        else this.needsUpdate = false;\n        this._shader.getCgl().gl.uniform1i(this._loc, this._value ? 1 : 0);\n\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValueBool(v)\n    {\n        if (v != this._value)\n        {\n            this.needsUpdate = true;\n            this._value = v;\n        }\n    }\n\n    setValueArray4F(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n    updateValueArray4F()\n    {\n        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n        else this.needsUpdate = false;\n\n        if (!this._value) return;\n        this._shader.getCgl().gl.uniform4fv(this._loc, this._value);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValueArray3F(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n    updateValueArray3F()\n    {\n        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n        else this.needsUpdate = false;\n\n        if (!this._value) return;\n        this._shader.getCgl().gl.uniform3fv(this._loc, this._value);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValueArray2F(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n    updateValueArray2F()\n    {\n        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n        else this.needsUpdate = false;\n\n        if (!this._value) return;\n        this._shader.getCgl().gl.uniform2fv(this._loc, this._value);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValueArrayF(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n    updateValueArrayF()\n    {\n        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n        else this.needsUpdate = false;\n\n        if (!this._value) return;\n        this._shader.getCgl().gl.uniform1fv(this._loc, this._value);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValueArrayT(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n\n    updateValue3F()\n    {\n        if (!this._value) return;\n        if (!this._isValidLoc())\n        {\n            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n            this._cgl.profileData.profileShaderGetUniform++;\n            this._cgl.profileData.profileShaderGetUniformName = this._name;\n        }\n\n        this._shader.getCgl().gl.uniform3f(this._loc, this._value[0], this._value[1], this._value[2]);\n        this.needsUpdate = false;\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValue3F(v)\n    {\n        if (!v) return;\n        if (!this._oldValue)\n        {\n            this._oldValue = [v[0] - 1, 1, 2];\n            this.needsUpdate = true;\n        }\n        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2])\n        {\n            this._oldValue[0] = v[0];\n            this._oldValue[1] = v[1];\n            this._oldValue[2] = v[2];\n            this.needsUpdate = true;\n        }\n\n        this._value = v;\n    }\n\n    updateValue2F()\n    {\n        if (!this._value) return;\n\n        if (!this._isValidLoc())\n        {\n            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n            this._cgl.profileData.profileShaderGetUniform++;\n            this._cgl.profileData.profileShaderGetUniformName = this._name;\n        }\n\n        this._shader.getCgl().gl.uniform2f(this._loc, this._value[0], this._value[1]);\n        this.needsUpdate = false;\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValue2F(v)\n    {\n        if (!v) return;\n        if (!this._oldValue)\n        {\n            this._oldValue = [v[0] - 1, 1];\n            this.needsUpdate = true;\n        }\n        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1])\n        {\n            this._oldValue[0] = v[0];\n            this._oldValue[1] = v[1];\n            this.needsUpdate = true;\n        }\n        this._value = v;\n    }\n\n    updateValue4F()\n    {\n        if (!this._isValidLoc())\n        {\n            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n            this._cgl.profileData.profileShaderGetUniform++;\n            this._cgl.profileData.profileShaderGetUniformName = this._name;\n        }\n\n        if (!this._value)\n        {\n            this._log.warn(\"no value for uniform\", this._name, this);\n            this._value = [0, 0, 0, 0];\n        }\n\n        this.needsUpdate = false;\n        this._shader.getCgl().gl.uniform4f(this._loc, this._value[0], this._value[1], this._value[2], this._value[3]);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValue4F(v)\n    {\n        if (typeof this.value == \"number\") this.value = vec4.create(); // this should not be needed, but somehow it crashes with some shadermods\n\n        if (!v) return;\n        if (!this._oldValue)\n        {\n            this._oldValue = [v[0] - 1, 1, 2, 3];\n            this.needsUpdate = true;\n        }\n        else if (v[0] != this._oldValue[0] || v[1] != this._oldValue[1] || v[2] != this._oldValue[2] || v[3] != this._oldValue[3])\n        {\n            this._oldValue[0] = v[0];\n            this._oldValue[1] = v[1];\n            this._oldValue[2] = v[2];\n            this.needsUpdate = true;\n        }\n\n        this._value = v;\n    }\n\n    updateValueM4()\n    {\n        if (!this._isValidLoc())\n        {\n            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n            this._cgl.profileData.profileShaderGetUniform++;\n            this._cgl.profileData.profileShaderGetUniformName = this._name;\n        }\n        if (!this._value || this._value.length % 16 != 0) return console.log(\"this.name\", this._name, this._value);\n\n        this._shader.getCgl().gl.uniformMatrix4fv(this._loc, false, this._value);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    setValueM4(v)\n    {\n        this.needsUpdate = true;\n        this._value = v || mat4.create();\n    }\n\n    updateValueArrayT()\n    {\n        if (!this._isValidLoc()) this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n        else this.needsUpdate = false;\n\n        if (!this._value) return;\n        this._shader.getCgl().gl.uniform1iv(this._loc, this._value);\n        this._cgl.profileData.profileUniformCount++;\n    }\n\n    updateValueT()\n    {\n        if (!this._isValidLoc())\n        {\n            this._loc = this._shader.getCgl().gl.getUniformLocation(this._shader.getProgram(), this._name);\n            this._cgl.profileData.profileShaderGetUniform++;\n            this._cgl.profileData.profileShaderGetUniformName = this._name;\n        }\n\n        this._cgl.profileData.profileUniformCount++;\n        this._shader.getCgl().gl.uniform1i(this._loc, this._value);\n        this.needsUpdate = false;\n    }\n\n    setValueT(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n}\n\n\nUniform.glslTypeString = (t) =>\n{\n    if (t == \"f\") return \"float\";\n    if (t == \"b\") return \"bool\";\n    if (t == \"i\") return \"int\";\n    if (t == \"2i\") return \"ivec2\";\n    if (t == \"2f\") return \"vec2\";\n    if (t == \"3f\") return \"vec3\";\n    if (t == \"4f\") return \"vec4\";\n    if (t == \"m4\") return \"mat4\";\n\n    if (t == \"t\") return \"sampler2D\";\n    if (t == \"tc\") return \"samplerCube\";\n\n    if (t == \"3f[]\") return null; // ignore this for now...\n    if (t == \"m4[]\") return null; // ignore this for now...\n    if (t == \"f[]\") return null; // ignore this for now...\n\n    console.warn(\"[CGL UNIFORM] unknown glsl type string \", t);\n};\n\n\n/**\n * @function setValue\n * @memberof Uniform\n * @instance\n * @param {Number|Array|Matrix|Texture} value\n */\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3NoYWRlcl91bmlmb3JtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZ2wvY2dsX3NoYWRlcl91bmlmb3JtLmpzPzFkNWIiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgQ2dVbmlmb3JtIGZyb20gXCIuLi9jZy9jZ191bmlmb3JtLmpzXCI7XG5pbXBvcnQgeyBQb3J0IH0gZnJvbSBcIi4uL2NvcmVfcG9ydC5qc1wiO1xuXG4vKipcbiAqIFNoYWRlciB1bmlmb3Jtc1xuICpcbiAqIHR5cGVzOlxuICogPHByZT5cbiAqIGYgICAgLSBmbG9hdFxuICogMmYgICAtIHZlYzJcbiAqIDNmICAgLSB2ZWMzXG4gKiA0ZiAgIC0gdmVjNFxuICogaSAgICAtIGludGVnZXJcbiAqIHQgICAgLSB0ZXh0dXJlXG4gKiBtNCAgIC0gbWF0NCwgNHg0IGZsb2F0IG1hdHJpeFxuICogZltdICAtIGFycmF5IG9mIGZsb2F0c1xuICogMmZbXSAtIGFycmF5IG9mIGZsb2F0IHZlYzJcbiAqIDNmW10gLSBhcnJheSBvZiBmbG9hdCB2ZWMzXG4gKiA0ZltdIC0gYXJyYXkgb2YgZmxvYXQgdmVjNFxuICogPC9wcmU+XG4gKlxuICogQGV4dGVybmFsIENHTFxuICogQG5hbWVzcGFjZSBVbmlmb3JtXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7U2hhZGVyfSBzaGFkZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZT1mXVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfFBvcnR9IHZhbHVlICBjYW4gYmUgYSBOdW1iZXIsTWF0cml4IG9yIFBvcnRcbiAqIEBleGFtcGxlXG4gKiAvLyBiaW5kIGZsb2F0IHVuaWZvcm0gY2FsbGVkIG15ZmxvYXQgYW5kIGluaXRpYWxpemUgd2l0aCB2YWx1ZSAxLjBcbiAqIGNvbnN0IHVuaXI9bmV3IENHTC5Vbmlmb3JtKHNoYWRlciwnZicsJ215ZmxvYXQnLDEuMCk7XG4gKiB1bmlyLnNldFZhbHVlKDEuMCk7XG4gKlxuICogLy8gYmluZCBmbG9hdCB1bmlmb3JtIGNhbGxlZCBteWZsb2F0IGFuZCBhdXRvbWF0aWNhbGx5IHNldCBpdCB0byBpbnB1dCBwb3J0IHZhbHVlXG4gKiBjb25zdCBteVBvcnQ9b3AuaW5GbG9hdChcImlucHV0XCIpO1xuICogY29uc3QgcHY9bmV3IENHTC5Vbmlmb3JtKHNoYWRlciwnZicsJ215ZmxvYXQnLG15UG9ydCk7XG4gKlxuICovXG5cblxuLy8gZXhwb3J0IGNvbnN0IFVuaWZvcm0oX19zaGFkZXIsIF9fdHlwZSwgX19uYW1lLCBfdmFsdWUsIF9wb3J0MiwgX3BvcnQzLCBfcG9ydDQsIF9zdHJ1Y3RVbmlmb3JtTmFtZSwgX3N0cnVjdE5hbWUsIF9wcm9wZXJ0eU5hbWUpXG5cbmNsYXNzIFVuaWZvcm0gZXh0ZW5kcyBDZ1VuaWZvcm1cbntcbiAgICBjb25zdHJ1Y3RvcihfX3NoYWRlciwgX190eXBlLCBfX25hbWUsIF92YWx1ZSwgX3BvcnQyLCBfcG9ydDMsIF9wb3J0NCwgX3N0cnVjdFVuaWZvcm1OYW1lLCBfc3RydWN0TmFtZSwgX3Byb3BlcnR5TmFtZSlcbiAgICB7XG4gICAgICAgIHN1cGVyKF9fc2hhZGVyLCBfX3R5cGUsIF9fbmFtZSwgX3ZhbHVlLCBfcG9ydDIsIF9wb3J0MywgX3BvcnQ0LCBfc3RydWN0VW5pZm9ybU5hbWUsIF9zdHJ1Y3ROYW1lLCBfcHJvcGVydHlOYW1lKTtcbiAgICAgICAgdGhpcy5fbG9jID0gLTE7XG4gICAgICAgIHRoaXMuX2NnbCA9IF9fc2hhZGVyLl9jZ2w7XG4gICAgfVxuXG4gICAgZ2V0IG5hbWUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuXG4gICAgY29weShuZXdTaGFkZXIpXG4gICAge1xuICAgICAgICBjb25zdCB1bmkgPSBuZXcgVW5pZm9ybShuZXdTaGFkZXIsIHRoaXMuX3R5cGUsIHRoaXMuX25hbWUsIHRoaXMuX3ZhbHVlLCB0aGlzLl9wb3J0MiwgdGhpcy5fcG9ydDMsIHRoaXMuX3BvcnQ0LCB0aGlzLl9zdHJ1Y3RVbmlmb3JtTmFtZSwgdGhpcy5fc3RydWN0TmFtZSwgdGhpcy5fcHJvcGVydHlOYW1lKTtcbiAgICAgICAgdW5pLnNoYWRlclR5cGUgPSB0aGlzLnNoYWRlclR5cGU7XG4gICAgICAgIHJldHVybiB1bmk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0eXBlIGFzIGdsc2wgdHlwZSBzdHJpbmcuIGUuZy4gJ2YnIHJldHVybnMgJ2Zsb2F0J1xuICAgICAqIEBmdW5jdGlvbiBnZXRHbHNsVHlwZVN0cmluZ1xuICAgICAqIEBtZW1iZXJvZiBVbmlmb3JtXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0eXBlIGFzIHN0cmluZ1xuICAgICAqL1xuICAgIGdldEdsc2xUeXBlU3RyaW5nKClcbiAgICB7XG4gICAgICAgIHJldHVybiBVbmlmb3JtLmdsc2xUeXBlU3RyaW5nKHRoaXMuX3R5cGUpO1xuICAgIH1cblxuICAgIF9pc1ZhbGlkTG9jKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2MgIT0gLTE7Ly8gJiYgdGhpcy5fbG9jICE9IG51bGw7XG4gICAgfVxuXG4gICAgcmVzZXRMb2MoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbG9jID0gLTE7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGJpbmRUZXh0dXJlcygpIHt9XG5cbiAgICBnZXRMb2MoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYztcbiAgICB9XG5cbiAgICB1cGRhdGVGcm9tUG9ydDRmKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3ZhbHVlWzBdID0gdGhpcy5fcG9ydC5nZXQoKTtcbiAgICAgICAgdGhpcy5fdmFsdWVbMV0gPSB0aGlzLl9wb3J0Mi5nZXQoKTtcbiAgICAgICAgdGhpcy5fdmFsdWVbMl0gPSB0aGlzLl9wb3J0My5nZXQoKTtcbiAgICAgICAgdGhpcy5fdmFsdWVbM10gPSB0aGlzLl9wb3J0NC5nZXQoKTtcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLl92YWx1ZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlRnJvbVBvcnQzZigpXG4gICAge1xuICAgICAgICB0aGlzLl92YWx1ZVswXSA9IHRoaXMuX3BvcnQuZ2V0KCk7XG4gICAgICAgIHRoaXMuX3ZhbHVlWzFdID0gdGhpcy5fcG9ydDIuZ2V0KCk7XG4gICAgICAgIHRoaXMuX3ZhbHVlWzJdID0gdGhpcy5fcG9ydDMuZ2V0KCk7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5fdmFsdWUpO1xuICAgIH1cblxuICAgIHVwZGF0ZUZyb21Qb3J0MmYoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdmFsdWVbMF0gPSB0aGlzLl9wb3J0LmdldCgpO1xuICAgICAgICB0aGlzLl92YWx1ZVsxXSA9IHRoaXMuX3BvcnQyLmdldCgpO1xuICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuX3ZhbHVlKTtcbiAgICB9XG5cbiAgICB1cGRhdGVGcm9tUG9ydCgpXG4gICAge1xuICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuX3BvcnQuZ2V0KCkpO1xuICAgIH1cblxuICAgIHVwZGF0ZVZhbHVlRigpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRMb2MoKSkgdGhpcy5fbG9jID0gdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXIuZ2V0UHJvZ3JhbSgpLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgZWxzZSB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLnVuaWZvcm0xZih0aGlzLl9sb2MsIHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVVbmlmb3JtQ291bnQrKztcbiAgICB9XG5cbiAgICBzZXRWYWx1ZUYodilcbiAgICB7XG4gICAgICAgIGlmICh2ICE9IHRoaXMuX3ZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVZhbHVlSSgpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRMb2MoKSkgdGhpcy5fbG9jID0gdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXIuZ2V0UHJvZ3JhbSgpLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgZWxzZSB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLnVuaWZvcm0xaSh0aGlzLl9sb2MsIHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVVbmlmb3JtQ291bnQrKztcbiAgICB9XG5cbiAgICB1cGRhdGVWYWx1ZTJJKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5fdmFsdWUpIHJldHVybjtcblxuICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRMb2MoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9jID0gdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXIuZ2V0UHJvZ3JhbSgpLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlU2hhZGVyR2V0VW5pZm9ybSsrO1xuICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaGFkZXJHZXRVbmlmb3JtTmFtZSA9IHRoaXMuX25hbWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wudW5pZm9ybTJpKHRoaXMuX2xvYywgdGhpcy5fdmFsdWVbMF0sIHRoaXMuX3ZhbHVlWzFdKTtcblxuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlVW5pZm9ybUNvdW50Kys7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWUzSSgpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlKSByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZExvYygpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9sb2MgPSB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlci5nZXRQcm9ncmFtKCksIHRoaXMuX25hbWUpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaGFkZXJHZXRVbmlmb3JtKys7XG4gICAgICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVNoYWRlckdldFVuaWZvcm1OYW1lID0gdGhpcy5fbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC51bmlmb3JtM2kodGhpcy5fbG9jLCB0aGlzLl92YWx1ZVswXSwgdGhpcy5fdmFsdWVbMV0sIHRoaXMuX3ZhbHVlWzJdKTtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVVuaWZvcm1Db3VudCsrO1xuICAgIH1cblxuICAgIHVwZGF0ZVZhbHVlNEkoKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkTG9jKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYyA9IHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyLmdldFByb2dyYW0oKSwgdGhpcy5fbmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVNoYWRlckdldFVuaWZvcm0rKztcbiAgICAgICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlU2hhZGVyR2V0VW5pZm9ybU5hbWUgPSB0aGlzLl9uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC51bmlmb3JtNGkodGhpcy5fbG9jLCB0aGlzLl92YWx1ZVswXSwgdGhpcy5fdmFsdWVbMV0sIHRoaXMuX3ZhbHVlWzJdLCB0aGlzLl92YWx1ZVszXSk7XG4gICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlVW5pZm9ybUNvdW50Kys7XG4gICAgfVxuXG4gICAgc2V0VmFsdWVJKHYpXG4gICAge1xuICAgICAgICBpZiAodiAhPSB0aGlzLl92YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRWYWx1ZTJJKHYpXG4gICAge1xuICAgICAgICBpZiAoIXYpIHJldHVybjtcbiAgICAgICAgaWYgKCF0aGlzLl9vbGRWYWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fb2xkVmFsdWUgPSBbdlswXSAtIDEsIDFdO1xuICAgICAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodlswXSAhPSB0aGlzLl9vbGRWYWx1ZVswXSB8fCB2WzFdICE9IHRoaXMuX29sZFZhbHVlWzFdKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vbGRWYWx1ZVswXSA9IHZbMF07XG4gICAgICAgICAgICB0aGlzLl9vbGRWYWx1ZVsxXSA9IHZbMV07XG4gICAgICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcbiAgICB9XG5cbiAgICBzZXRWYWx1ZTNJKHYpXG4gICAge1xuICAgICAgICBpZiAoIXYpIHJldHVybjtcbiAgICAgICAgaWYgKCF0aGlzLl9vbGRWYWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fb2xkVmFsdWUgPSBbdlswXSAtIDEsIDEsIDJdO1xuICAgICAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodlswXSAhPSB0aGlzLl9vbGRWYWx1ZVswXSB8fCB2WzFdICE9IHRoaXMuX29sZFZhbHVlWzFdIHx8IHZbMl0gIT0gdGhpcy5fb2xkVmFsdWVbMl0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX29sZFZhbHVlWzBdID0gdlswXTtcbiAgICAgICAgICAgIHRoaXMuX29sZFZhbHVlWzFdID0gdlsxXTtcbiAgICAgICAgICAgIHRoaXMuX29sZFZhbHVlWzJdID0gdlsyXTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgIH1cblxuICAgIHNldFZhbHVlNEkodilcbiAgICB7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHYgfHwgdmVjNC5jcmVhdGUoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVWYWx1ZUJvb2woKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkTG9jKCkpIHRoaXMuX2xvYyA9IHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyLmdldFByb2dyYW0oKSwgdGhpcy5fbmFtZSk7XG4gICAgICAgIGVsc2UgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wudW5pZm9ybTFpKHRoaXMuX2xvYywgdGhpcy5fdmFsdWUgPyAxIDogMCk7XG5cbiAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVVbmlmb3JtQ291bnQrKztcbiAgICB9XG5cbiAgICBzZXRWYWx1ZUJvb2wodilcbiAgICB7XG4gICAgICAgIGlmICh2ICE9IHRoaXMuX3ZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFZhbHVlQXJyYXk0Rih2KVxuICAgIHtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcbiAgICB9XG5cbiAgICB1cGRhdGVWYWx1ZUFycmF5NEYoKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkTG9jKCkpIHRoaXMuX2xvYyA9IHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyLmdldFByb2dyYW0oKSwgdGhpcy5fbmFtZSk7XG4gICAgICAgIGVsc2UgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghdGhpcy5fdmFsdWUpIHJldHVybjtcbiAgICAgICAgdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLnVuaWZvcm00ZnYodGhpcy5fbG9jLCB0aGlzLl92YWx1ZSk7XG4gICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlVW5pZm9ybUNvdW50Kys7XG4gICAgfVxuXG4gICAgc2V0VmFsdWVBcnJheTNGKHYpXG4gICAge1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgIH1cblxuICAgIHVwZGF0ZVZhbHVlQXJyYXkzRigpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRMb2MoKSkgdGhpcy5fbG9jID0gdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXIuZ2V0UHJvZ3JhbSgpLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgZWxzZSB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCF0aGlzLl92YWx1ZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wudW5pZm9ybTNmdih0aGlzLl9sb2MsIHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVVbmlmb3JtQ291bnQrKztcbiAgICB9XG5cbiAgICBzZXRWYWx1ZUFycmF5MkYodilcbiAgICB7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWVBcnJheTJGKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZExvYygpKSB0aGlzLl9sb2MgPSB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlci5nZXRQcm9ncmFtKCksIHRoaXMuX25hbWUpO1xuICAgICAgICBlbHNlIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC51bmlmb3JtMmZ2KHRoaXMuX2xvYywgdGhpcy5fdmFsdWUpO1xuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVVuaWZvcm1Db3VudCsrO1xuICAgIH1cblxuICAgIHNldFZhbHVlQXJyYXlGKHYpXG4gICAge1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgIH1cblxuICAgIHVwZGF0ZVZhbHVlQXJyYXlGKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZExvYygpKSB0aGlzLl9sb2MgPSB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlci5nZXRQcm9ncmFtKCksIHRoaXMuX25hbWUpO1xuICAgICAgICBlbHNlIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC51bmlmb3JtMWZ2KHRoaXMuX2xvYywgdGhpcy5fdmFsdWUpO1xuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVVuaWZvcm1Db3VudCsrO1xuICAgIH1cblxuICAgIHNldFZhbHVlQXJyYXlUKHYpXG4gICAge1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgIH1cblxuXG4gICAgdXBkYXRlVmFsdWUzRigpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlKSByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZExvYygpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9sb2MgPSB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlci5nZXRQcm9ncmFtKCksIHRoaXMuX25hbWUpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaGFkZXJHZXRVbmlmb3JtKys7XG4gICAgICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVNoYWRlckdldFVuaWZvcm1OYW1lID0gdGhpcy5fbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC51bmlmb3JtM2YodGhpcy5fbG9jLCB0aGlzLl92YWx1ZVswXSwgdGhpcy5fdmFsdWVbMV0sIHRoaXMuX3ZhbHVlWzJdKTtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVVuaWZvcm1Db3VudCsrO1xuICAgIH1cblxuICAgIHNldFZhbHVlM0YodilcbiAgICB7XG4gICAgICAgIGlmICghdikgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuX29sZFZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vbGRWYWx1ZSA9IFt2WzBdIC0gMSwgMSwgMl07XG4gICAgICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2WzBdICE9IHRoaXMuX29sZFZhbHVlWzBdIHx8IHZbMV0gIT0gdGhpcy5fb2xkVmFsdWVbMV0gfHwgdlsyXSAhPSB0aGlzLl9vbGRWYWx1ZVsyXSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fb2xkVmFsdWVbMF0gPSB2WzBdO1xuICAgICAgICAgICAgdGhpcy5fb2xkVmFsdWVbMV0gPSB2WzFdO1xuICAgICAgICAgICAgdGhpcy5fb2xkVmFsdWVbMl0gPSB2WzJdO1xuICAgICAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWUyRigpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkTG9jKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYyA9IHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyLmdldFByb2dyYW0oKSwgdGhpcy5fbmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVNoYWRlckdldFVuaWZvcm0rKztcbiAgICAgICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlU2hhZGVyR2V0VW5pZm9ybU5hbWUgPSB0aGlzLl9uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLnVuaWZvcm0yZih0aGlzLl9sb2MsIHRoaXMuX3ZhbHVlWzBdLCB0aGlzLl92YWx1ZVsxXSk7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVVbmlmb3JtQ291bnQrKztcbiAgICB9XG5cbiAgICBzZXRWYWx1ZTJGKHYpXG4gICAge1xuICAgICAgICBpZiAoIXYpIHJldHVybjtcbiAgICAgICAgaWYgKCF0aGlzLl9vbGRWYWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fb2xkVmFsdWUgPSBbdlswXSAtIDEsIDFdO1xuICAgICAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodlswXSAhPSB0aGlzLl9vbGRWYWx1ZVswXSB8fCB2WzFdICE9IHRoaXMuX29sZFZhbHVlWzFdKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vbGRWYWx1ZVswXSA9IHZbMF07XG4gICAgICAgICAgICB0aGlzLl9vbGRWYWx1ZVsxXSA9IHZbMV07XG4gICAgICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWU0RigpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRMb2MoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9jID0gdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXIuZ2V0UHJvZ3JhbSgpLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlU2hhZGVyR2V0VW5pZm9ybSsrO1xuICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaGFkZXJHZXRVbmlmb3JtTmFtZSA9IHRoaXMuX25hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIm5vIHZhbHVlIGZvciB1bmlmb3JtXCIsIHRoaXMuX25hbWUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC51bmlmb3JtNGYodGhpcy5fbG9jLCB0aGlzLl92YWx1ZVswXSwgdGhpcy5fdmFsdWVbMV0sIHRoaXMuX3ZhbHVlWzJdLCB0aGlzLl92YWx1ZVszXSk7XG4gICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlVW5pZm9ybUNvdW50Kys7XG4gICAgfVxuXG4gICAgc2V0VmFsdWU0Rih2KVxuICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnZhbHVlID09IFwibnVtYmVyXCIpIHRoaXMudmFsdWUgPSB2ZWM0LmNyZWF0ZSgpOyAvLyB0aGlzIHNob3VsZCBub3QgYmUgbmVlZGVkLCBidXQgc29tZWhvdyBpdCBjcmFzaGVzIHdpdGggc29tZSBzaGFkZXJtb2RzXG5cbiAgICAgICAgaWYgKCF2KSByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5fb2xkVmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX29sZFZhbHVlID0gW3ZbMF0gLSAxLCAxLCAyLCAzXTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZbMF0gIT0gdGhpcy5fb2xkVmFsdWVbMF0gfHwgdlsxXSAhPSB0aGlzLl9vbGRWYWx1ZVsxXSB8fCB2WzJdICE9IHRoaXMuX29sZFZhbHVlWzJdIHx8IHZbM10gIT0gdGhpcy5fb2xkVmFsdWVbM10pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX29sZFZhbHVlWzBdID0gdlswXTtcbiAgICAgICAgICAgIHRoaXMuX29sZFZhbHVlWzFdID0gdlsxXTtcbiAgICAgICAgICAgIHRoaXMuX29sZFZhbHVlWzJdID0gdlsyXTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgIH1cblxuICAgIHVwZGF0ZVZhbHVlTTQoKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkTG9jKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYyA9IHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyLmdldFByb2dyYW0oKSwgdGhpcy5fbmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVNoYWRlckdldFVuaWZvcm0rKztcbiAgICAgICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlU2hhZGVyR2V0VW5pZm9ybU5hbWUgPSB0aGlzLl9uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fdmFsdWUgfHwgdGhpcy5fdmFsdWUubGVuZ3RoICUgMTYgIT0gMCkgcmV0dXJuIGNvbnNvbGUubG9nKFwidGhpcy5uYW1lXCIsIHRoaXMuX25hbWUsIHRoaXMuX3ZhbHVlKTtcblxuICAgICAgICB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLl9sb2MsIGZhbHNlLCB0aGlzLl92YWx1ZSk7XG4gICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlVW5pZm9ybUNvdW50Kys7XG4gICAgfVxuXG4gICAgc2V0VmFsdWVNNCh2KVxuICAgIHtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdiB8fCBtYXQ0LmNyZWF0ZSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVZhbHVlQXJyYXlUKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5faXNWYWxpZExvYygpKSB0aGlzLl9sb2MgPSB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlci5nZXRQcm9ncmFtKCksIHRoaXMuX25hbWUpO1xuICAgICAgICBlbHNlIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3NoYWRlci5nZXRDZ2woKS5nbC51bmlmb3JtMWl2KHRoaXMuX2xvYywgdGhpcy5fdmFsdWUpO1xuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVVuaWZvcm1Db3VudCsrO1xuICAgIH1cblxuICAgIHVwZGF0ZVZhbHVlVCgpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRMb2MoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9jID0gdGhpcy5fc2hhZGVyLmdldENnbCgpLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXIuZ2V0UHJvZ3JhbSgpLCB0aGlzLl9uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlU2hhZGVyR2V0VW5pZm9ybSsrO1xuICAgICAgICAgICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVTaGFkZXJHZXRVbmlmb3JtTmFtZSA9IHRoaXMuX25hbWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVVuaWZvcm1Db3VudCsrO1xuICAgICAgICB0aGlzLl9zaGFkZXIuZ2V0Q2dsKCkuZ2wudW5pZm9ybTFpKHRoaXMuX2xvYywgdGhpcy5fdmFsdWUpO1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgc2V0VmFsdWVUKHYpXG4gICAge1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgIH1cbn1cblxuXG5Vbmlmb3JtLmdsc2xUeXBlU3RyaW5nID0gKHQpID0+XG57XG4gICAgaWYgKHQgPT0gXCJmXCIpIHJldHVybiBcImZsb2F0XCI7XG4gICAgaWYgKHQgPT0gXCJiXCIpIHJldHVybiBcImJvb2xcIjtcbiAgICBpZiAodCA9PSBcImlcIikgcmV0dXJuIFwiaW50XCI7XG4gICAgaWYgKHQgPT0gXCIyaVwiKSByZXR1cm4gXCJpdmVjMlwiO1xuICAgIGlmICh0ID09IFwiMmZcIikgcmV0dXJuIFwidmVjMlwiO1xuICAgIGlmICh0ID09IFwiM2ZcIikgcmV0dXJuIFwidmVjM1wiO1xuICAgIGlmICh0ID09IFwiNGZcIikgcmV0dXJuIFwidmVjNFwiO1xuICAgIGlmICh0ID09IFwibTRcIikgcmV0dXJuIFwibWF0NFwiO1xuXG4gICAgaWYgKHQgPT0gXCJ0XCIpIHJldHVybiBcInNhbXBsZXIyRFwiO1xuICAgIGlmICh0ID09IFwidGNcIikgcmV0dXJuIFwic2FtcGxlckN1YmVcIjtcblxuICAgIGlmICh0ID09IFwiM2ZbXVwiKSByZXR1cm4gbnVsbDsgLy8gaWdub3JlIHRoaXMgZm9yIG5vdy4uLlxuICAgIGlmICh0ID09IFwibTRbXVwiKSByZXR1cm4gbnVsbDsgLy8gaWdub3JlIHRoaXMgZm9yIG5vdy4uLlxuICAgIGlmICh0ID09IFwiZltdXCIpIHJldHVybiBudWxsOyAvLyBpZ25vcmUgdGhpcyBmb3Igbm93Li4uXG5cbiAgICBjb25zb2xlLndhcm4oXCJbQ0dMIFVOSUZPUk1dIHVua25vd24gZ2xzbCB0eXBlIHN0cmluZyBcIiwgdCk7XG59O1xuXG5cbi8qKlxuICogQGZ1bmN0aW9uIHNldFZhbHVlXG4gKiBAbWVtYmVyb2YgVW5pZm9ybVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcnxBcnJheXxNYXRyaXh8VGV4dHVyZX0gdmFsdWVcbiAqL1xuXG5leHBvcnQgeyBVbmlmb3JtIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_shader_uniform.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_simplerect.js":
/*!****************************************!*\
  !*** ./src/core/cgl/cgl_simplerect.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MESHES\": () => (/* binding */ MESHES)\n/* harmony export */ });\n/* harmony import */ var _cg_cg_geom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cg/cg_geom.js */ \"./src/core/cg/cg_geom.js\");\n/* harmony import */ var _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgl_mesh.js */ \"./src/core/cgl/cgl_mesh.js\");\n\n\n\n\nconst MESHES = {};\n\nMESHES.getSimpleRect = function (cgl, name)\n{\n    const geom = new _cg_cg_geom_js__WEBPACK_IMPORTED_MODULE_0__.Geometry(name);\n\n    geom.vertices = [1.0, 1.0, 0.0, -1.0, 1.0, 0.0, 1.0, -1.0, 0.0, -1.0, -1.0, 0.0];\n    geom.texCoords = [1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0];\n    geom.verticesIndices = [0, 1, 2, 2, 1, 3];\n    geom.vertexNormals = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];\n\n    return new _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_1__.Mesh(cgl, geom);\n};\n\n\nMESHES.getSimpleCube = function (cgl, name)\n{\n    const geom = new _cg_cg_geom_js__WEBPACK_IMPORTED_MODULE_0__.Geometry(name);\n    geom.vertices = [-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1];\n    geom.setTexCoords([0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0,]);\n    geom.verticesIndices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\n    geom.vertexNormals = new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0]);\n    geom.tangents = new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);\n    geom.biTangents = new Float32Array([-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]);\n\n    return new _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_1__.Mesh(cgl, geom);\n};\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3NpbXBsZXJlY3QuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnbC9jZ2xfc2ltcGxlcmVjdC5qcz80ZTAzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdlb21ldHJ5IH0gZnJvbSBcIi4uL2NnL2NnX2dlb20uanNcIjtcbmltcG9ydCB7IE1lc2ggfSBmcm9tIFwiLi9jZ2xfbWVzaC5qc1wiO1xuXG5cbmNvbnN0IE1FU0hFUyA9IHt9O1xuXG5NRVNIRVMuZ2V0U2ltcGxlUmVjdCA9IGZ1bmN0aW9uIChjZ2wsIG5hbWUpXG57XG4gICAgY29uc3QgZ2VvbSA9IG5ldyBHZW9tZXRyeShuYW1lKTtcblxuICAgIGdlb20udmVydGljZXMgPSBbMS4wLCAxLjAsIDAuMCwgLTEuMCwgMS4wLCAwLjAsIDEuMCwgLTEuMCwgMC4wLCAtMS4wLCAtMS4wLCAwLjBdO1xuICAgIGdlb20udGV4Q29vcmRzID0gWzEuMCwgMS4wLCAwLjAsIDEuMCwgMS4wLCAwLjAsIDAuMCwgMC4wXTtcbiAgICBnZW9tLnZlcnRpY2VzSW5kaWNlcyA9IFswLCAxLCAyLCAyLCAxLCAzXTtcbiAgICBnZW9tLnZlcnRleE5vcm1hbHMgPSBbMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuMF07XG5cbiAgICByZXR1cm4gbmV3IE1lc2goY2dsLCBnZW9tKTtcbn07XG5cblxuTUVTSEVTLmdldFNpbXBsZUN1YmUgPSBmdW5jdGlvbiAoY2dsLCBuYW1lKVxue1xuICAgIGNvbnN0IGdlb20gPSBuZXcgR2VvbWV0cnkobmFtZSk7XG4gICAgZ2VvbS52ZXJ0aWNlcyA9IFstMSwgLTEsIDEsIDEsIC0xLCAxLCAxLCAxLCAxLCAtMSwgMSwgMSwgLTEsIC0xLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAtMSwgLTEsIDEsIC0xLCAtMSwgMSwgLTEsIDEsIDEsIC0xLCAxLCAxLCAxLCAtMSwgMSwgMSwgLTEsIC0xLCAtMSwgMSwgLTEsIC0xLCAxLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAtMSwgLTEsIDEsIC0xLCAxLCAxLCAxLCAxLCAxLCAxLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAxLCAtMSwgMSwgMSwgLTEsIDEsIC0xXTtcbiAgICBnZW9tLnNldFRleENvb3JkcyhbMCwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMSwgMSwgMSwgMSwgMCwgMCwgMCxdKTtcbiAgICBnZW9tLnZlcnRpY2VzSW5kaWNlcyA9IFswLCAxLCAyLCAwLCAyLCAzLCA0LCA1LCA2LCA0LCA2LCA3LCA4LCA5LCAxMCwgOCwgMTAsIDExLCAxMiwgMTMsIDE0LCAxMiwgMTQsIDE1LCAxNiwgMTcsIDE4LCAxNiwgMTgsIDE5LCAyMCwgMjEsIDIyLCAyMCwgMjIsIDIzXTtcbiAgICBnZW9tLnZlcnRleE5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KFswLjAsIDAuMCwgMS4wLCAwLjAsIDAuMCwgMS4wLCAwLjAsIDAuMCwgMS4wLCAwLjAsIDAuMCwgMS4wLCAwLjAsIDAuMCwgLTEuMCwgMC4wLCAwLjAsIC0xLjAsIDAuMCwgMC4wLCAtMS4wLCAwLjAsIDAuMCwgLTEuMCwgMC4wLCAxLjAsIDAuMCwgMC4wLCAxLjAsIDAuMCwgMC4wLCAxLjAsIDAuMCwgMC4wLCAxLjAsIDAuMCwgMC4wLCAtMS4wLCAwLjAsIDAuMCwgLTEuMCwgMC4wLCAwLjAsIC0xLjAsIDAuMCwgMC4wLCAtMS4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIC0xLjAsIDAuMCwgMC4wLCAtMS4wLCAwLjAsIDAuMCwgLTEuMCwgMC4wLCAwLjAsIC0xLjAsIDAuMCwgMC4wXSk7XG4gICAgZ2VvbS50YW5nZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIC0xLCAwLCAwLCAtMSwgMCwgMCwgLTEsIDAsIDAsIC0xLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAtMSwgMCwgMCwgLTEsIDAsIDAsIC0xLCAwLCAwLCAtMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMV0pO1xuICAgIGdlb20uYmlUYW5nZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAwLCAwLCAtMSwgMCwgMCwgLTEsIDAsIDAsIC0xLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAxLCAwLCAwLCAtMSwgMCwgMCwgLTEsIDAsIDAsIC0xLCAwLCAwLCAtMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgMSwgMCwgMCwgLTEsIDAsIDAsIC0xLCAwLCAwLCAtMSwgMCwgMCwgLTFdKTtcblxuICAgIHJldHVybiBuZXcgTWVzaChjZ2wsIGdlb20pO1xufTtcblxuXG5leHBvcnQgeyBNRVNIRVMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_simplerect.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_state.js":
/*!***********************************!*\
  !*** ./src/core/cgl/cgl_state.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Context\": () => (/* binding */ Context)\n/* harmony export */ });\n/* unused harmony export BLENDS */\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants.js */ \"./src/core/cgl/constants.js\");\n/* harmony import */ var _cgl_shader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cgl_shader.js */ \"./src/core/cgl/cgl_shader.js\");\n/* harmony import */ var _cgl_profiledata_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgl_profiledata.js */ \"./src/core/cgl/cgl_profiledata.js\");\n/* harmony import */ var _cg_cg_state_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cg/cg_state.js */ \"./src/core/cg/cg_state.js\");\n/* harmony import */ var _cg_cg_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cg/cg_constants.js */ \"./src/core/cg/cg_constants.js\");\n\n\n\n\n\n\n\n\n/**\n * cables gl context/state manager\n * @external CGL\n * @namespace Context\n * @class\n * @hideconstructor\n */\n// const Context(_patch)\nclass Context extends _cg_cg_state_js__WEBPACK_IMPORTED_MODULE_0__.CGState\n{\n    constructor(_patch)\n    {\n        super(_patch);\n        // EventTarget.apply(this);\n        // CGState.apply(this);\n\n        this.gApi = _cg_cg_constants_js__WEBPACK_IMPORTED_MODULE_1__.CG.GAPI_WEBGL;\n        this.aborted = false;\n\n        this.pushMvMatrix = this.pushModelMatrix; // deprecated and wrong... still used??\n        this.popMvMatrix = this.popmMatrix = this.popModelMatrix;// deprecated and wrong... still used??\n\n        this.profileData = new _cgl_profiledata_js__WEBPACK_IMPORTED_MODULE_2__.ProfileData(this);\n        this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\"cgl_context\");\n        this._viewPort = [0, 0, 0, 0];\n        this.glVersion = 0;\n        this.glUseHalfFloatTex = false;\n        this.clearCanvasTransparent = true;\n        this.clearCanvasDepth = true;\n        this.debugOneFrame = false;\n        this.checkGlErrors = false; // true is slow // false should be default...\n        this.maxTextureUnits = 0;\n        this.maxVaryingVectors = 0;\n        this.currentProgram = null;\n        this._hadStackError = false;\n        this.glSlowRenderer = false;\n        this._isSafariCrap = false;\n\n        this.temporaryTexture = null;\n        this.frameStore = {};\n        this._onetimeCallbacks = [];\n        this.gl = null;\n\n        this._cursor = \"auto\";\n        this._currentCursor = \"\";\n\n        this._viewPortStack = [];\n        this._glFrameBufferStack = [];\n        this._frameBufferStack = [];\n        this._shaderStack = [];\n        this._stackDepthTest = [];\n        this.mainloopOp = null;\n\n        this._simpleShader = new _cgl_shader_js__WEBPACK_IMPORTED_MODULE_4__.Shader(this, \"simpleshader\");\n        this._simpleShader.setModules([\"MODULE_VERTEX_POSITION\", \"MODULE_COLOR\", \"MODULE_BEGIN_FRAG\", \"MODULE_VERTEX_MOVELVIEW\"]);\n        this._simpleShader.setSource(_cgl_shader_js__WEBPACK_IMPORTED_MODULE_4__.Shader.getDefaultVertexShader(), _cgl_shader_js__WEBPACK_IMPORTED_MODULE_4__.Shader.getDefaultFragmentShader());\n\n        this._currentShader = this._simpleShader;\n\n\n        this._oldCanvasWidth = -1;\n        this._oldCanvasHeight = -1;\n        this._enabledExtensions = {};\n    }\n\n    // set pixelDensity(p)\n    // {\n    //     this._pixelDensity = p;\n    // }\n\n    // get pixelDensity()\n    // {\n    //     return this._pixelDensity;\n    // }\n\n\n\n    get viewPort()\n    {\n        if (this._viewPortStack.length > 3)\n        {\n            const l = this._viewPortStack.length;\n\n            return [\n                this._viewPortStack[l - 4],\n                this._viewPortStack[l - 3],\n                this._viewPortStack[l - 2],\n                this._viewPortStack[l - 1]\n            ];\n        }\n        else\n        {\n            // workaround pre viewport stack times / or+and initial value...\n\n            return this._viewPort;\n        }\n    }\n\n\n\n    get mvMatrix() // deprecate\n    {\n        return this.mMatrix;\n    }\n\n    set mvMatrix(m) // deprecate\n    {\n        this.mMatrix = m;\n    }\n\n\n    exitError(msgId, msg)\n    {\n        console.log(msgId, msg);\n        this.patch.exitError(msgId, msg);\n        this.aborted = true;\n    }\n\n\n    _setCanvas(canv)\n    {\n        if (!canv)\n        {\n            this._log.stack(\"_setCanvas undef\");\n        }\n\n        if (!this.patch.config.canvas) this.patch.config.canvas = {};\n        if (!this.patch.config.canvas.hasOwnProperty(\"preserveDrawingBuffer\")) this.patch.config.canvas.preserveDrawingBuffer = false;\n        if (!this.patch.config.canvas.hasOwnProperty(\"premultipliedAlpha\")) this.patch.config.canvas.premultipliedAlpha = false;\n        if (!this.patch.config.canvas.hasOwnProperty(\"alpha\")) this.patch.config.canvas.alpha = false;\n\n        this.patch.config.canvas.stencil = true;\n\n        if (this.patch.config.hasOwnProperty(\"clearCanvasColor\")) this.clearCanvasTransparent = this.patch.config.clearCanvasColor;\n        if (this.patch.config.hasOwnProperty(\"clearCanvasDepth\")) this.clearCanvasDepth = this.patch.config.clearCanvasDepth;\n\n        // safari stuff..........\n        if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) && (navigator.userAgent.match(/iPhone/i)))\n        {\n            this._isSafariCrap = true;\n            this.glUseHalfFloatTex = true;\n        }\n\n        if (!this.patch.config.canvas.forceWebGl1) this.gl = canv.getContext(\"webgl2\", this.patch.config.canvas);\n\n\n        if (!this.gl || this.gl.isContextLost())\n        {\n            this.aborted = true;\n            this.exitError(\"NO_WEBGL\", \"sorry, could not initialize WebGL. Please check if your Browser supports WebGL or try to restart your browser.\");\n            return;\n        }\n\n        if (this.gl.getParameter(this.gl.VERSION) != \"WebGL 1.0\")\n        {\n            this.glVersion = 2;\n        }\n        else\n        {\n            this.gl = canv.getContext(\"webgl\", this.patch.config.canvas) || canv.getContext(\"experimental-webgl\", this.patch.config.canvas);\n            this.glVersion = 1;\n\n            // safari\n            // if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) && (navigator.userAgent.match(/iPhone/i)))\n            // {\n            //     this.glUseHalfFloatTex = true;\n            // }\n\n            // ios\n            if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream)\n            {\n                if (!this.patch.config.canvas.hasOwnProperty(\"powerPreference\")) this.patch.config.canvas.powerPreference = \"high-performance\";\n            }\n\n            this.enableExtension(\"OES_standard_derivatives\");\n            // this.enableExtension(\"GL_OES_standard_derivatives\");\n            const instancingExt = this.enableExtension(\"ANGLE_instanced_arrays\") || this.gl;\n            if (instancingExt.vertexAttribDivisorANGLE)\n            {\n                this.gl.vertexAttribDivisor = instancingExt.vertexAttribDivisorANGLE.bind(instancingExt);\n                this.gl.drawElementsInstanced = instancingExt.drawElementsInstancedANGLE.bind(instancingExt);\n            }\n        }\n\n        const dbgRenderInfo = this.enableExtension(\"WEBGL_debug_renderer_info\");\n        if (dbgRenderInfo)\n        {\n            this.glRenderer = this.gl.getParameter(dbgRenderInfo.UNMASKED_RENDERER_WEBGL);\n            if (this.glRenderer === \"Google SwiftShader\") this.glSlowRenderer = true;\n        }\n\n        this.canvas.addEventListener(\"webglcontextlost\", (event) =>\n        {\n            if (this.aborted) return console.log(\"[cgl_state] aborted context lost... can be ignored...\");\n            this._log.error(\"canvas lost...\", event);\n            this.emitEvent(\"webglcontextlost\");\n            this.aborted = true;\n        });\n\n\n        this.maxAnisotropic = 0;\n        if (this.enableExtension(\"EXT_texture_filter_anisotropic\"))\n            this.maxAnisotropic = this.gl.getParameter(this.enableExtension(\"EXT_texture_filter_anisotropic\").MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n\n\n        this.maxVaryingVectors = this.gl.getParameter(this.gl.MAX_VARYING_VECTORS);\n        this.maxTextureUnits = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);\n        this.maxTexSize = this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE);\n        this.maxUniformsFrag = this.gl.getParameter(this.gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n        this.maxUniformsVert = this.gl.getParameter(this.gl.MAX_VERTEX_UNIFORM_VECTORS);\n        this.maxSamples = 0;\n        if (this.gl.MAX_SAMPLES) this.maxSamples = this.gl.getParameter(this.gl.MAX_SAMPLES);\n\n        if (this.glVersion == 1)\n        {\n            this.enableExtension(\"OES_standard_derivatives\");\n            const instancingExt = this.enableExtension(\"ANGLE_instanced_arrays\") || this.gl;\n\n            if (instancingExt.vertexAttribDivisorANGLE)\n            {\n                this.gl.vertexAttribDivisor = instancingExt.vertexAttribDivisorANGLE.bind(instancingExt);\n                this.gl.drawElementsInstanced = instancingExt.drawElementsInstancedANGLE.bind(instancingExt);\n            }\n        }\n\n        this.DEPTH_FUNCS = [\n            this.gl.NEVER,\n            this.gl.ALWAYS,\n            this.gl.LESS,\n            this.gl.LEQUAL,\n            this.gl.GREATER,\n            this.gl.GEQUAL,\n            this.gl.EQUAL,\n            this.gl.NOTEQUAL\n        ];\n        this.CULL_MODES = [\n            null,\n            this.gl.BACK,\n            this.gl.FRONT,\n            this.gl.FRONT_AND_BACK\n        ];\n    }\n\n    getInfo()\n    {\n        return {\n            \"glVersion\": this.glVersion,\n            \"glRenderer\": this.glRenderer,\n            \"glUseHalfFloatTex\": this.glUseHalfFloatTex,\n            \"maxVaryingVectors\": this.maxVaryingVectors,\n            \"maxTextureUnits\": this.maxTextureUnits,\n            \"maxTexSize\": this.maxTexSize,\n            \"maxUniformsFrag\": this.maxUniformsFrag,\n            \"maxUniformsVert\": this.maxUniformsVert,\n            \"maxSamples\": this.maxSamples\n        };\n    }\n\n\n\n\n\n    /**\n     * @function popViewPort\n     * @memberof Context\n     * @instance\n     * @description pop viewPort stack\n     */\n\n\n    popViewPort()\n    {\n        this._viewPortStack.pop();\n        this._viewPortStack.pop();\n        this._viewPortStack.pop();\n        this._viewPortStack.pop();\n\n        if (this._viewPortStack.length == 0)\n        {\n            this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight);\n            // this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);\n            // this.setViewPort(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);\n        }\n        else\n        {\n            // this.viewPort = [this._viewPortStack[this._viewPort.length - 4], this._viewPortStack[this._viewPort.length - 3], this._viewPortStack[this._viewPort.length - 2], this._viewPortStack[this._viewPort.length - 1]];\n            // this.gl.viewport(this._viewPortStack[this._viewPort.length - 4], this._viewPortStack[this._viewPort.length - 3], this._viewPortStack[this._viewPort.length - 2], this._viewPortStack[this._viewPort.length - 1]);\n            this.setViewPort(this._viewPortStack[this._viewPort.length - 4], this._viewPortStack[this._viewPort.length - 3], this._viewPortStack[this._viewPort.length - 2], this._viewPortStack[this._viewPort.length - 1]);\n        }\n    }\n\n    /**\n     * @function pushViewPort\n     * @memberof Context\n     * @instance\n     * @description push a new viewport onto stack\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Number} w\n     * @param {Number} h\n     */\n\n    pushViewPort(x, y, w, h)\n    {\n        this._viewPortStack.push(x, y, w, h);\n        this.setViewPort(x, y, w, h);\n    }\n\n\n    // old\n    getViewPort()\n    {\n        return this._viewPort;\n    }\n\n    // old\n    resetViewPort()\n    {\n        this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);\n    }\n\n    // old\n    setViewPort(x, y, w, h)\n    {\n        this._viewPort[0] = Math.round(x);\n        this._viewPort[1] = Math.round(y);\n        this._viewPort[2] = Math.round(w);\n        this._viewPort[3] = Math.round(h);\n        this.gl.viewport(this._viewPort[0], this._viewPort[1], this._viewPort[2], this._viewPort[3]);\n    }\n\n\n    screenShot(cb, doScreenshotClearAlpha, mimeType, quality)\n    {\n        if (doScreenshotClearAlpha)\n        {\n            this.gl.clearColor(1, 1, 1, 1);\n            this.gl.colorMask(false, false, false, true);\n            this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n            this.gl.colorMask(true, true, true, true);\n        }\n\n        if (this.canvas && this.canvas.toBlob)\n        {\n            this.canvas.toBlob((blob) =>\n            {\n                if (cb) cb(blob);\n                else this._log.log(\"no screenshot callback...\");\n            }, mimeType, quality);\n        }\n    }\n\n    endFrame()\n    {\n        if (this.patch.isEditorMode()) CABLES.GL_MARKER.drawMarkerLayer(this);\n\n        this.setPreviousShader();\n\n        if (this._vMatrixStack.length() > 0) this.logStackError(\"view matrix stack length !=0 at end of rendering...\");\n        if (this._mMatrixStack.length() > 0) this.logStackError(\"mvmatrix stack length !=0 at end of rendering...\");\n        if (this._pMatrixStack.length() > 0) this.logStackError(\"pmatrix stack length !=0 at end of rendering...\");\n        if (this._glFrameBufferStack.length > 0) this.logStackError(\"glFrameBuffer stack length !=0 at end of rendering...\");\n        if (this._stackDepthTest.length > 0) this.logStackError(\"depthtest stack length !=0 at end of rendering...\");\n        if (this._stackDepthWrite.length > 0) this.logStackError(\"depthwrite stack length !=0 at end of rendering...\");\n        if (this._stackDepthFunc.length > 0) this.logStackError(\"depthfunc stack length !=0 at end of rendering...\");\n        if (this._stackBlend.length > 0) this.logStackError(\"blend stack length !=0 at end of rendering...\");\n        if (this._stackBlendMode.length > 0) this.logStackError(\"blendMode stack length !=0 at end of rendering...\");\n        if (this._shaderStack.length > 0) this.logStackError(\"this._shaderStack length !=0 at end of rendering...\");\n        if (this._stackCullFace.length > 0) this.logStackError(\"this._stackCullFace length !=0 at end of rendering...\");\n        if (this._stackCullFaceFacing.length > 0) this.logStackError(\"this._stackCullFaceFacing length !=0 at end of rendering...\");\n        if (this._viewPortStack.length > 0) this.logStackError(\"viewport stack length !=0 at end of rendering...\");\n\n        this._frameStarted = false;\n\n        if (this._oldCanvasWidth != this.canvasWidth || this._oldCanvasHeight != this.canvasHeight)\n        {\n            this._oldCanvasWidth = this.canvasWidth;\n            this._oldCanvasHeight = this.canvasHeight;\n            this.emitEvent(\"resize\");\n        }\n\n        if (this._cursor != this._currentCursor)\n        {\n            this._currentCursor = this.canvas.style.cursor = this._cursor;\n        }\n\n        this.emitEvent(\"endframe\");\n\n        this.fpsCounter.endFrame();\n    }\n\n    logStackError(str)\n    {\n        if (!this._hadStackError)\n        {\n            this._hadStackError = true;\n            this._log.warn(\"[\" + this.canvas.id + \"]: \", str);\n        }\n    }\n\n    // shader stack\n    getShader()\n    {\n        if (this._currentShader) if (!this.frameStore || ((this.frameStore.renderOffscreen === true) == this._currentShader.offScreenPass) === true) return this._currentShader;\n\n        for (let i = this._shaderStack.length - 1; i >= 0; i--) if (this._shaderStack[i]) if (this.frameStore.renderOffscreen == this._shaderStack[i].offScreenPass) return this._shaderStack[i];\n    }\n\n    getDefaultShader()\n    {\n        return this._simpleShader;\n    }\n\n    /**\n     * push a shader to the shader stack\n     * @function pushShader\n     * @memberof Context\n     * @instance\n     * @param {Object} shader\n     * @function\n     */\n\n    pushShader(shader)\n    {\n        if (this.frameStore.forceShaderMods)\n        {\n            for (let i = 0; i < this.frameStore.forceShaderMods.length; i++)\n            {\n                // if (!currentShader.forcedMod && currentShader != this.frameStore.forceShaderMods[i])\n                // {\n                //     currentShader.forcedMod = this.frameStore.forceShaderMods[i];\n                shader = this.frameStore.forceShaderMods[i].bind(shader, false);\n                // }\n                // return currentShader;\n                // if (this.frameStore.forceShaderMods[i].currentShader() && shader != this.frameStore.forceShaderMods[i].currentShader().shader)\n            }\n        }\n\n        this._shaderStack.push(shader);\n        this._currentShader = shader;\n    }\n\n\n    /**\n     * pop current used shader from shader stack\n     * @function popShader\n     * @memberof Context\n     * @instance\n     * @function\n     */\n    setPreviousShader()\n    {\n        if (this.frameStore.forceShaderMods)\n        {\n            for (let i = 0; i < this.frameStore.forceShaderMods.length; i++)\n            {\n                // const a =\n                this.frameStore.forceShaderMods[i].unbind(false);\n                // if (a) return;\n                // this.popShader();\n            }\n        }\n\n        if (this._shaderStack.length === 0) throw new Error(\"Invalid shader stack pop!\");\n        this._shaderStack.pop();\n        this._currentShader = this._shaderStack[this._shaderStack.length - 1];\n    }\n\n    /**\n     * push a framebuffer to the framebuffer stack\n     * @function pushGlFrameBuffer\n     * @memberof Context\n     * @instance\n     * @param {Object} framebuffer\n     * @function\n     */\n    pushGlFrameBuffer(fb)\n    {\n        this._glFrameBufferStack.push(fb);\n    }\n\n    /**\n     * pop framebuffer stack\n     * @function popGlFrameBuffer\n     * @memberof Context\n     * @instance\n     * @returns {Object} current framebuffer or null\n     */\n    popGlFrameBuffer()\n    {\n        if (this._glFrameBufferStack.length == 0) return null;\n        this._glFrameBufferStack.pop();\n        return this._glFrameBufferStack[this._glFrameBufferStack.length - 1];\n    }\n\n    /**\n     * get current framebuffer\n     * @function getCurrentFrameBuffer\n     * @memberof Context\n     * @instance\n     * @returns {Object} current framebuffer or null\n     */\n    getCurrentGlFrameBuffer()\n    {\n        if (this._glFrameBufferStack.length === 0) return null;\n        return this._glFrameBufferStack[this._glFrameBufferStack.length - 1];\n    }\n\n    /**\n     * push a framebuffer to the framebuffer stack\n     * @function pushGlFrameBuffer\n     * @memberof Context\n     * @instance\n     * @param {Framebuffer} framebuffer\n     */\n    pushFrameBuffer(fb)\n    {\n        this._frameBufferStack.push(fb);\n    }\n\n    /**\n     * pop framebuffer stack\n     * @function popFrameBuffer\n     * @memberof Context\n     * @instance\n     * @returns {Framebuffer} current framebuffer or null\n     */\n    popFrameBuffer()\n    {\n        if (this._frameBufferStack.length == 0) return null;\n        this._frameBufferStack.pop();\n        return this._frameBufferStack[this._frameBufferStack.length - 1];\n    }\n\n    /**\n     * get current framebuffer\n     * @function getCurrentFrameBuffer\n     * @memberof Context\n     * @instance\n     * @returns {Framebuffer} current framebuffer or null\n     */\n    getCurrentFrameBuffer()\n    {\n        if (this._frameBufferStack.length === 0) return null;\n        return this._frameBufferStack[this._frameBufferStack.length - 1];\n    }\n\n\n    renderStart(cgl, identTranslate, identTranslateView)\n    {\n        this.fpsCounter.startFrame();\n        this.pushDepthTest(true);\n        this.pushDepthWrite(true);\n        this.pushDepthFunc(cgl.gl.LEQUAL);\n        this.pushCullFaceFacing(cgl.gl.BACK);\n        this.pushCullFace(false);\n\n        // if (this.clearCanvasTransparent)\n        // {\n        //     cgl.gl.clearColor(0, 0, 0, 0);\n        //     cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT);\n        // }\n        // if (this.clearCanvasDepth) cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT);\n\n        cgl.setViewPort(0, 0, cgl.canvasWidth, cgl.canvasHeight);\n\n        this._startMatrixStacks(identTranslate, identTranslateView);\n\n        cgl.pushBlendMode(_constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.BLEND_MODES.BLEND_NORMAL, false);\n\n        for (let i = 0; i < this._textureslots.length; i++) this._textureslots[i] = null;\n\n        this.pushShader(this._simpleShader);\n\n        this._frameStarted = true;\n\n        if (this._onetimeCallbacks.length > 0)\n        {\n            for (let i = 0; i < this._onetimeCallbacks.length; i++) this._onetimeCallbacks[i]();\n            this._onetimeCallbacks.length = 0;\n        }\n\n        for (let i = 0; i < this._textureslots.length; i++)\n        {\n            this.gl.activeTexture(this.gl.TEXTURE0 + i);\n            this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n            this._textureslots[i] = null;\n        }\n\n        this.emitEvent(\"beginFrame\");\n    }\n\n    renderEnd(cgl)\n    {\n        this._endMatrixStacks();\n\n        this.popDepthTest();\n        this.popDepthWrite();\n        this.popDepthFunc();\n        this.popCullFaceFacing();\n        this.popCullFace();\n        this.popBlend();\n        this.popBlendMode();\n\n        cgl.endFrame();\n\n        this.emitEvent(\"endFrame\");\n    }\n\n    getTexture(slot)\n    {\n        return this._textureslots[slot];\n    }\n\n    hasFrameStarted()\n    {\n        return this._frameStarted;\n    }\n\n    /**\n     * log warning to console if the rendering of one frame has not been started / handy to check for async problems\n     * @function checkFrameStarted\n     * @memberof Context\n     * @instance\n     */\n    checkFrameStarted(string)\n    {\n        if (!this._frameStarted)\n        {\n            this._log.warn(\"frame not started \" + string);\n            this.patch.printTriggerStack();\n        }\n    }\n\n\n    setTexture(slot, t, type)\n    {\n        this.checkFrameStarted(\"cgl setTexture\");\n\n        if (t === null) t = CGL.Texture.getEmptyTexture(this).tex;\n\n        // if (!this.gl.isTexture(t))\n        // {\n        //     console.log(\"not a texture!!!!\"); return false;\n        //     t = CGL.Texture.getEmptyTexture(this).tex;\n        // }\n\n        // if (!this.gl.isTexture(t))\n        // {\n        //     t = CGL.Texture.getErrorTexture(this).tex;\n        //     // this._log.stack(\"not a texture!!!!\");\n        //     // return false;\n        // }\n\n\n        if (this._textureslots[slot] != t)\n        {\n            this.gl.activeTexture(this.gl.TEXTURE0 + slot);\n            this.gl.bindTexture(type || this.gl.TEXTURE_2D, t);\n            this._textureslots[slot] = t;\n        }\n\n\n        return true;\n    }\n\n    fullScreen()\n    {\n        if (this.canvas.requestFullscreen) this.canvas.requestFullscreen();\n        else if (this.canvas.mozRequestFullScreen) this.canvas.mozRequestFullScreen();\n        else if (this.canvas.webkitRequestFullscreen) this.canvas.webkitRequestFullscreen();\n        else if (this.canvas.msRequestFullscreen) this.canvas.msRequestFullscreen();\n    }\n\n\n    printError(str)\n    {\n        if (!this.checkGlErrors) return;\n        let found = false;\n        let error = this.gl.getError();\n\n        if (error != this.gl.NO_ERROR)\n        {\n            let errStr = \"\";\n            if (error == this.gl.OUT_OF_MEMORY) errStr = \"OUT_OF_MEMORY\";\n            if (error == this.gl.INVALID_ENUM) errStr = \"INVALID_ENUM\";\n            if (error == this.gl.INVALID_OPERATION) errStr = \"INVALID_OPERATION\";\n            if (error == this.gl.INVALID_FRAMEBUFFER_OPERATION) errStr = \"INVALID_FRAMEBUFFER_OPERATION\";\n            if (error == this.gl.INVALID_VALUE) errStr = \"INVALID_VALUE\";\n            if (error == this.gl.CONTEXT_LOST_WEBGL)\n            {\n                this.aborted = true;\n                errStr = \"CONTEXT_LOST_WEBGL\";\n            }\n            if (error == this.gl.NO_ERROR) errStr = \"NO_ERROR\";\n\n            found = true;\n\n\n            this._log.warn(\"gl error [\" + this.canvas.id + \"]: \", str, error, errStr);\n\n            if (this.canvas.id.contains(\"glGuiCanvas\"))\n                if (!this._loggedGlError)\n                {\n                    this.patch.printTriggerStack();\n                    this._log.stack(\"glerror\");\n                    this._loggedGlError = true;\n                }\n        }\n        error = this.gl.getError();\n\n        return found;\n    }\n\n    saveScreenshot(filename, cb, pw, ph, noclearalpha)\n    {\n        this.patch.renderOneFrame();\n\n        let w = this.canvas.clientWidth * this.pixelDensity;\n        let h = this.canvas.clientHeight * this.pixelDensity;\n\n        if (pw)\n        {\n            this.canvas.width = pw;\n            w = pw;\n        }\n        if (ph)\n        {\n            this.canvas.height = ph;\n            h = ph;\n        }\n\n        function padLeft(nr, n, str)\n        {\n            return Array(n - String(nr).length + 1).join(str || \"0\") + nr;\n        }\n\n        const d = new Date();\n\n        const dateStr = \"\".concat(String(d.getFullYear()) + String(d.getMonth() + 1) + String(d.getDate()), \"_\").concat(padLeft(d.getHours(), 2)).concat(padLeft(d.getMinutes(), 2)).concat(padLeft(d.getSeconds(), 2));\n\n        if (!filename) filename = \"cables_\" + dateStr + \".png\";\n        else filename += \".png\";\n\n        this.patch.cgl.screenShot(function (blob)\n        {\n            this.canvas.width = w;\n            this.canvas.height = h;\n\n            if (blob)\n            {\n                const anchor = document.createElement(\"a\");\n\n                anchor.download = filename;\n                anchor.href = URL.createObjectURL(blob);\n\n                setTimeout(function ()\n                {\n                    anchor.click();\n                    if (cb) cb(blob);\n                }, 100);\n            }\n            else\n            {\n                this._log.log(\"screenshot: no blob\");\n            }\n        }.bind(this), noclearalpha);\n    }\n\n    _dispose()\n    {\n        this._simpleShader.dispose();\n        this.gl = null;\n    }\n}\n\n\nContext.prototype.popShader = Context.prototype.setPreviousShader;\nContext.prototype.setShader = Context.prototype.pushShader;\n\n/**\n * execute the callback next frame, once\n * @function addNextFrameOnceCallback\n * @memberof Context\n * @instance\n * @param {function} callback\n */\nContext.prototype.addNextFrameOnceCallback = function (cb)\n{\n    if (cb) this._onetimeCallbacks.push(cb);\n};\n\n// state depthtest\n\n/**\n * push depth testing enabled state\n * @function pushDepthTest\n * @param {Boolean} enabled\n * @memberof Context\n * @instance\n */\nContext.prototype._stackDepthTest = [];\nContext.prototype.pushDepthTest = function (b)\n{\n    this._stackDepthTest.push(b);\n    if (!b) this.gl.disable(this.gl.DEPTH_TEST);\n    else this.gl.enable(this.gl.DEPTH_TEST);\n};\n/**\n * current state of depth testing\n * @function stateCullFace\n * @returns {Boolean} enabled\n * @memberof Context\n * @instance\n */\nContext.prototype.stateDepthTest = function ()\n{\n    return this._stackDepthTest[this._stackDepthTest.length - 1];\n};\n\n/**\n * pop depth testing state\n * @function popCullFace\n * @memberof Context\n * @instance\n */\nContext.prototype.popDepthTest = function ()\n{\n    this._stackDepthTest.pop();\n\n    if (!this._stackDepthTest[this._stackDepthTest.length - 1]) this.gl.disable(this.gl.DEPTH_TEST);\n    else this.gl.enable(this.gl.DEPTH_TEST);\n};\n\n// --------------------------------------\n// state depthwrite\n\n/**\n * push depth write enabled state\n * @function pushDepthTest\n * @param {Boolean} enabled\n * @memberof Context\n * @instance\n */\nContext.prototype._stackDepthWrite = [];\nContext.prototype.pushDepthWrite = function (b)\n{\n    b = b || false;\n    this._stackDepthWrite.push(b);\n    this.gl.depthMask(b);\n};\n\n/**\n * current state of depth writing\n * @function stateCullFace\n * @returns {Boolean} enabled\n * @memberof Context\n * @instance\n */\nContext.prototype.stateDepthWrite = function ()\n{\n    return this._stackDepthWrite[this._stackDepthWrite.length - 1];\n};\n\n/**\n * pop depth writing state\n * @function popCullFace\n * @memberof Context\n * @instance\n */\nContext.prototype.popDepthWrite = function ()\n{\n    this._stackDepthWrite.pop();\n    this.gl.depthMask(this._stackDepthWrite[this._stackDepthWrite.length - 1] || false);\n};\n\n\n// --------------------------------------\n// state CullFace\n\n/**\n * push face culling face enabled state\n * @function pushCullFaceFacing\n * @param {Boolean} enabled\n * @memberof Context\n * @instance\n */\nContext.prototype._stackCullFace = [];\nContext.prototype.pushCullFace = function (b)\n{\n    this._stackCullFace.push(b);\n\n    if (b) this.gl.enable(this.gl.CULL_FACE);\n    else this.gl.disable(this.gl.CULL_FACE);\n};\n\n/**\n * current state of face culling\n * @function stateCullFace\n * @returns {Boolean} enabled\n * @memberof Context\n * @instance\n */\nContext.prototype.stateCullFace = function ()\n{\n    return this._stackCullFace[this._stackCullFace.length - 1];\n};\n\n/**\n * pop face culling enabled state\n * @function popCullFace\n * @memberof Context\n * @instance\n */\nContext.prototype.popCullFace = function ()\n{\n    this._stackCullFace.pop();\n\n    if (this._stackCullFace[this._stackCullFace.length - 1]) this.gl.enable(this.gl.CULL_FACE);\n    else this.gl.disable(this.gl.CULL_FACE);\n};\n\n\n// --------------------------------------\n// state CullFace Facing\n\n\n/**\n * push face culling face side\n * @function pushCullFaceFacing\n * @param {Number} cgl.gl.FRONT_AND_BACK, cgl.gl.BACK or cgl.gl.FRONT\n * @memberof Context\n * @instance\n */\nContext.prototype._stackCullFaceFacing = [];\nContext.prototype.pushCullFaceFacing = function (b)\n{\n    this._stackCullFaceFacing.push(b);\n    this.gl.cullFace(this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1]);\n};\n\n/**\n * current state of face culling side\n * @function stateCullFaceFacing\n * @returns {Boolean} enabled\n * @memberof Context\n * @instance\n */\nContext.prototype.stateCullFaceFacing = function ()\n{\n    return this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1];\n};\n\n/**\n * pop face culling face side\n * @function popCullFaceFacing\n * @memberof Context\n * @instance\n */\nContext.prototype.popCullFaceFacing = function ()\n{\n    this._stackCullFaceFacing.pop();\n    if (this._stackCullFaceFacing.length > 0) this.gl.cullFace(this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1]);\n};\n\n\n// --------------------------------------\n// state depthfunc\n\nContext.prototype._stackDepthFunc = [];\n\n/**\n * enable / disable depth testing\n * like `gl.depthFunc(boolean);`\n * @function pushDepthFunc\n * @memberof Context\n * @instance\n * @param {Boolean} depthtesting\n */\nContext.prototype.pushDepthFunc = function (f)\n{\n    this._stackDepthFunc.push(f);\n    this.gl.depthFunc(f);\n};\n\n/**\n * current state of blend\n * @function stateDepthFunc\n * @memberof Context\n * @instance\n * @returns {Boolean} depth testing enabled/disabled\n */\nContext.prototype.stateDepthFunc = function ()\n{\n    if (this._stackDepthFunc.length > 0) return this._stackDepthFunc[this._stackDepthFunc.length - 1];\n    return false;\n};\n\n/**\n * pop depth testing and set the previous state\n * @function popDepthFunc\n * @memberof Context\n * @instance\n */\nContext.prototype.popDepthFunc = function ()\n{\n    this._stackDepthFunc.pop();\n    if (this._stackDepthFunc.length > 0) this.gl.depthFunc(this._stackDepthFunc[this._stackDepthFunc.length - 1]);\n};\n\n// --------------------------------------\n// state blending\n\nContext.prototype._stackBlend = [];\n\n/**\n * enable / disable blend\n * like gl.enable(gl.BLEND); / gl.disable(gl.BLEND);\n * @function pushBlend\n * @memberof Context\n * @instance\n * @param {Boolean} blending\n */\nContext.prototype.pushBlend = function (b)\n{\n    this._stackBlend.push(b);\n    if (!b) this.gl.disable(this.gl.BLEND);\n    else this.gl.enable(this.gl.BLEND);\n};\n\n/**\n * pop blend state and set the previous state\n * @function popBlend\n * @memberof Context\n * @instance\n */\nContext.prototype.popBlend = function ()\n{\n    this._stackBlend.pop();\n\n    if (!this._stackBlend[this._stackBlend.length - 1]) this.gl.disable(this.gl.BLEND);\n    else this.gl.enable(this.gl.BLEND);\n};\n\n/**\n * current state of blend\n * @function stateBlend\n * @returns {boolean} blending enabled/disabled\n * @memberof Context\n * @instance\n */\nContext.prototype.stateBlend = function ()\n{\n    return this._stackBlend[this._stackBlend.length - 1];\n};\n\nconst BLENDS = {\n    \"BLEND_NONE\": 0,\n    \"BLEND_NORMAL\": 1,\n    \"BLEND_ADD\": 2,\n    \"BLEND_SUB\": 3,\n    \"BLEND_MUL\": 4,\n};\n\nContext.prototype._stackBlendMode = [];\nContext.prototype._stackBlendModePremul = [];\n\n/**\n * push and switch to predefined blendmode (CONSTANTS.BLEND_MODES.BLEND_NONE,CONSTANTS.BLEND_MODES.BLEND_NORMAL,CONSTANTS.BLEND_MODES.BLEND_ADD,CONSTANTS.BLEND_MODES.BLEND_SUB,CONSTANTS.BLEND_MODES.BLEND_MUL)\n * @function pushBlendMode\n * @memberof Context\n * @instance\n * @param {Number} blendmode\n * @param {Boolean} premultiplied mode\n */\nContext.prototype.pushBlendMode = function (blendMode, premul)\n{\n    this._stackBlendMode.push(blendMode);\n    this._stackBlendModePremul.push(premul);\n\n    const n = this._stackBlendMode.length - 1;\n\n    this.pushBlend(this._stackBlendMode[n] !== _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.BLEND_MODES.BLEND_NONE);\n    this._setBlendMode(this._stackBlendMode[n], this._stackBlendModePremul[n]);\n};\n\n/**\n * pop predefined blendmode / switch back to previous blendmode\n * @function popBlendMode\n * @memberof Context\n * @instance\n */\nContext.prototype.popBlendMode = function ()\n{\n    this._stackBlendMode.pop();\n    this._stackBlendModePremul.pop();\n\n    const n = this._stackBlendMode.length - 1;\n\n    this.popBlend(this._stackBlendMode[n] !== _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.BLEND_MODES.BLEND_NONE);\n\n    if (n >= 0) this._setBlendMode(this._stackBlendMode[n], this._stackBlendModePremul[n]);\n};\n\n\n// --------------------------------------\n// state stencil\n\nContext.prototype._stackStencil = [];\n\n/**\n * enable / disable stencil testing\n\n* @function pushStencil\n * @memberof Context\n * @instance\n * @param {Boolean} enable\n */\nContext.prototype.pushStencil = function (b)\n{\n    this._stackStencil.push(b);\n    if (!b) this.gl.disable(this.gl.STENCIL_TEST);\n    else this.gl.enable(this.gl.STENCIL_TEST);\n};\n\n/**\n * pop stencil test state and set the previous state\n * @function popStencil\n * @memberof Context\n * @instance\n */\nContext.prototype.popStencil = function ()\n{\n    this._stackStencil.pop();\n\n    if (!this._stackStencil[this._stackStencil.length - 1]) this.gl.disable(this.gl.STENCIL_TEST);\n    else this.gl.enable(this.gl.STENCIL_TEST);\n};\n\n// --------------------------------------\n\n\nContext.prototype.glGetAttribLocation = function (prog, name)\n{\n    const l = this.gl.getAttribLocation(prog, name);\n    // if (l == -1)\n    // {\n    //     this._log.warn(\"get attr loc -1 \", name);\n    // }\n    return l;\n};\n\n\n/**\n * should an op now draw helpermeshes\n * @function shouldDrawHelpers\n * @memberof Context\n * @instance\n */\nContext.prototype.shouldDrawHelpers = function (op)\n{\n    if (this.frameStore.shadowPass) return false;\n    if (!op.patch.isEditorMode()) return false;\n\n    const fb = this.getCurrentFrameBuffer();\n    if (fb && fb.getWidth)\n    {\n        const fbshould = this.canvasWidth / this.canvasHeight == fb.getWidth() / fb.getHeight();\n        if (!fbshould) return false;\n    }\n\n    return CABLES.UI.renderHelper || (CABLES.UI.renderHelperCurrent && op.isCurrentUiOp());\n};\n\nContext.prototype._setBlendMode = function (blendMode, premul)\n{\n    const gl = this.gl;\n\n    if (blendMode == _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.BLEND_MODES.BLEND_NONE)\n    {\n        // this.gl.disable(this.gl.BLEND);\n    }\n    else if (blendMode == _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.BLEND_MODES.BLEND_ADD)\n    {\n        if (premul)\n        {\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);\n        }\n        else\n        {\n            gl.blendEquation(gl.FUNC_ADD);\n            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n        }\n    }\n    else if (blendMode == _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.BLEND_MODES.BLEND_SUB)\n    {\n        if (premul)\n        {\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);\n        }\n        else\n        {\n            gl.blendEquation(gl.FUNC_ADD);\n            gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);\n        }\n    }\n    else if (blendMode == _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.BLEND_MODES.BLEND_MUL)\n    {\n        if (premul)\n        {\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);\n        }\n        else\n        {\n            gl.blendEquation(gl.FUNC_ADD);\n            gl.blendFunc(gl.ZERO, gl.SRC_COLOR);\n        }\n    }\n    else if (blendMode == _constants_js__WEBPACK_IMPORTED_MODULE_5__.CONSTANTS.BLEND_MODES.BLEND_NORMAL)\n    {\n        if (premul)\n        {\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        }\n        else\n        {\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        }\n    }\n    else\n    {\n        this._log.log(\"setblendmode: unknown blendmode\");\n    }\n};\n\nContext.prototype.createMesh = function (geom, options)\n{\n    if (CABLES.UTILS.isNumeric(options))options = { \"glPrimitive\": options }; // old constructor fallback...\n    return new CGL.Mesh(this, geom, options);\n};\n\n\n/**\n * set cursor\n * @function setCursor\n * @memberof Context\n * @instance\n * @param {String} css cursor string\n */\nContext.prototype.setCursor = function (str)\n{\n    this._cursor = str;\n};\n\n/**\n * enable a webgl extension\n * @function enableExtension\n * @memberof Context\n * @instance\n * @param {String} extension name\n * @returns {Object} extension object or null\n */\nContext.prototype.enableExtension = function (name)\n{\n    if (!this.gl) return null;\n    // const start = performance.now();\n\n    if (this._enabledExtensions.hasOwnProperty(name))\n    {\n        return this._enabledExtensions[name];\n    }\n\n    const o = this.gl.getExtension(name);\n    this._enabledExtensions[name] = o;\n\n    if (!o)\n        this._log.warn(\"[cgl_state] extension not available \" + name);\n    else\n        this._log.log(\"enabled extension\", name);\n\n    return o;\n};\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3N0YXRlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnbC9jZ2xfc3RhdGUuanM/MTk0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiY2FibGVzLXNoYXJlZC1jbGllbnRcIjtcbmltcG9ydCB7IENPTlNUQU5UUyB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgU2hhZGVyIH0gZnJvbSBcIi4vY2dsX3NoYWRlci5qc1wiO1xuaW1wb3J0IHsgUHJvZmlsZURhdGEgfSBmcm9tIFwiLi9jZ2xfcHJvZmlsZWRhdGEuanNcIjtcbmltcG9ydCB7IENHU3RhdGUgfSBmcm9tIFwiLi4vY2cvY2dfc3RhdGUuanNcIjtcbmltcG9ydCB7IENHIH0gZnJvbSBcIi4uL2NnL2NnX2NvbnN0YW50cy5qc1wiO1xuXG5cbi8qKlxuICogY2FibGVzIGdsIGNvbnRleHQvc3RhdGUgbWFuYWdlclxuICogQGV4dGVybmFsIENHTFxuICogQG5hbWVzcGFjZSBDb250ZXh0XG4gKiBAY2xhc3NcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqL1xuLy8gY29uc3QgQ29udGV4dChfcGF0Y2gpXG5jbGFzcyBDb250ZXh0IGV4dGVuZHMgQ0dTdGF0ZVxue1xuICAgIGNvbnN0cnVjdG9yKF9wYXRjaClcbiAgICB7XG4gICAgICAgIHN1cGVyKF9wYXRjaCk7XG4gICAgICAgIC8vIEV2ZW50VGFyZ2V0LmFwcGx5KHRoaXMpO1xuICAgICAgICAvLyBDR1N0YXRlLmFwcGx5KHRoaXMpO1xuXG4gICAgICAgIHRoaXMuZ0FwaSA9IENHLkdBUElfV0VCR0w7XG4gICAgICAgIHRoaXMuYWJvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMucHVzaE12TWF0cml4ID0gdGhpcy5wdXNoTW9kZWxNYXRyaXg7IC8vIGRlcHJlY2F0ZWQgYW5kIHdyb25nLi4uIHN0aWxsIHVzZWQ/P1xuICAgICAgICB0aGlzLnBvcE12TWF0cml4ID0gdGhpcy5wb3BtTWF0cml4ID0gdGhpcy5wb3BNb2RlbE1hdHJpeDsvLyBkZXByZWNhdGVkIGFuZCB3cm9uZy4uLiBzdGlsbCB1c2VkPz9cblxuICAgICAgICB0aGlzLnByb2ZpbGVEYXRhID0gbmV3IFByb2ZpbGVEYXRhKHRoaXMpO1xuICAgICAgICB0aGlzLl9sb2cgPSBuZXcgTG9nZ2VyKFwiY2dsX2NvbnRleHRcIik7XG4gICAgICAgIHRoaXMuX3ZpZXdQb3J0ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB0aGlzLmdsVmVyc2lvbiA9IDA7XG4gICAgICAgIHRoaXMuZ2xVc2VIYWxmRmxvYXRUZXggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jbGVhckNhbnZhc1RyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbGVhckNhbnZhc0RlcHRoID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWJ1Z09uZUZyYW1lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hlY2tHbEVycm9ycyA9IGZhbHNlOyAvLyB0cnVlIGlzIHNsb3cgLy8gZmFsc2Ugc2hvdWxkIGJlIGRlZmF1bHQuLi5cbiAgICAgICAgdGhpcy5tYXhUZXh0dXJlVW5pdHMgPSAwO1xuICAgICAgICB0aGlzLm1heFZhcnlpbmdWZWN0b3JzID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hhZFN0YWNrRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5nbFNsb3dSZW5kZXJlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pc1NhZmFyaUNyYXAgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnRlbXBvcmFyeVRleHR1cmUgPSBudWxsO1xuICAgICAgICB0aGlzLmZyYW1lU3RvcmUgPSB7fTtcbiAgICAgICAgdGhpcy5fb25ldGltZUNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmdsID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9jdXJzb3IgPSBcImF1dG9cIjtcbiAgICAgICAgdGhpcy5fY3VycmVudEN1cnNvciA9IFwiXCI7XG5cbiAgICAgICAgdGhpcy5fdmlld1BvcnRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9nbEZyYW1lQnVmZmVyU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5fZnJhbWVCdWZmZXJTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9zaGFkZXJTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9zdGFja0RlcHRoVGVzdCA9IFtdO1xuICAgICAgICB0aGlzLm1haW5sb29wT3AgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3NpbXBsZVNoYWRlciA9IG5ldyBTaGFkZXIodGhpcywgXCJzaW1wbGVzaGFkZXJcIik7XG4gICAgICAgIHRoaXMuX3NpbXBsZVNoYWRlci5zZXRNb2R1bGVzKFtcIk1PRFVMRV9WRVJURVhfUE9TSVRJT05cIiwgXCJNT0RVTEVfQ09MT1JcIiwgXCJNT0RVTEVfQkVHSU5fRlJBR1wiLCBcIk1PRFVMRV9WRVJURVhfTU9WRUxWSUVXXCJdKTtcbiAgICAgICAgdGhpcy5fc2ltcGxlU2hhZGVyLnNldFNvdXJjZShTaGFkZXIuZ2V0RGVmYXVsdFZlcnRleFNoYWRlcigpLCBTaGFkZXIuZ2V0RGVmYXVsdEZyYWdtZW50U2hhZGVyKCkpO1xuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTaGFkZXIgPSB0aGlzLl9zaW1wbGVTaGFkZXI7XG5cblxuICAgICAgICB0aGlzLl9vbGRDYW52YXNXaWR0aCA9IC0xO1xuICAgICAgICB0aGlzLl9vbGRDYW52YXNIZWlnaHQgPSAtMTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZEV4dGVuc2lvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBzZXQgcGl4ZWxEZW5zaXR5KHApXG4gICAgLy8ge1xuICAgIC8vICAgICB0aGlzLl9waXhlbERlbnNpdHkgPSBwO1xuICAgIC8vIH1cblxuICAgIC8vIGdldCBwaXhlbERlbnNpdHkoKVxuICAgIC8vIHtcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMuX3BpeGVsRGVuc2l0eTtcbiAgICAvLyB9XG5cblxuXG4gICAgZ2V0IHZpZXdQb3J0KClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl92aWV3UG9ydFN0YWNrLmxlbmd0aCA+IDMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSB0aGlzLl92aWV3UG9ydFN0YWNrLmxlbmd0aDtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3UG9ydFN0YWNrW2wgLSA0XSxcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3UG9ydFN0YWNrW2wgLSAzXSxcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3UG9ydFN0YWNrW2wgLSAyXSxcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3UG9ydFN0YWNrW2wgLSAxXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHdvcmthcm91bmQgcHJlIHZpZXdwb3J0IHN0YWNrIHRpbWVzIC8gb3IrYW5kIGluaXRpYWwgdmFsdWUuLi5cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdQb3J0O1xuICAgICAgICB9XG4gICAgfVxuXG5cblxuICAgIGdldCBtdk1hdHJpeCgpIC8vIGRlcHJlY2F0ZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubU1hdHJpeDtcbiAgICB9XG5cbiAgICBzZXQgbXZNYXRyaXgobSkgLy8gZGVwcmVjYXRlXG4gICAge1xuICAgICAgICB0aGlzLm1NYXRyaXggPSBtO1xuICAgIH1cblxuXG4gICAgZXhpdEVycm9yKG1zZ0lkLCBtc2cpXG4gICAge1xuICAgICAgICBjb25zb2xlLmxvZyhtc2dJZCwgbXNnKTtcbiAgICAgICAgdGhpcy5wYXRjaC5leGl0RXJyb3IobXNnSWQsIG1zZyk7XG4gICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7XG4gICAgfVxuXG5cbiAgICBfc2V0Q2FudmFzKGNhbnYpXG4gICAge1xuICAgICAgICBpZiAoIWNhbnYpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5zdGFjayhcIl9zZXRDYW52YXMgdW5kZWZcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMucGF0Y2guY29uZmlnLmNhbnZhcykgdGhpcy5wYXRjaC5jb25maWcuY2FudmFzID0ge307XG4gICAgICAgIGlmICghdGhpcy5wYXRjaC5jb25maWcuY2FudmFzLmhhc093blByb3BlcnR5KFwicHJlc2VydmVEcmF3aW5nQnVmZmVyXCIpKSB0aGlzLnBhdGNoLmNvbmZpZy5jYW52YXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5wYXRjaC5jb25maWcuY2FudmFzLmhhc093blByb3BlcnR5KFwicHJlbXVsdGlwbGllZEFscGhhXCIpKSB0aGlzLnBhdGNoLmNvbmZpZy5jYW52YXMucHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5wYXRjaC5jb25maWcuY2FudmFzLmhhc093blByb3BlcnR5KFwiYWxwaGFcIikpIHRoaXMucGF0Y2guY29uZmlnLmNhbnZhcy5hbHBoYSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMucGF0Y2guY29uZmlnLmNhbnZhcy5zdGVuY2lsID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5wYXRjaC5jb25maWcuaGFzT3duUHJvcGVydHkoXCJjbGVhckNhbnZhc0NvbG9yXCIpKSB0aGlzLmNsZWFyQ2FudmFzVHJhbnNwYXJlbnQgPSB0aGlzLnBhdGNoLmNvbmZpZy5jbGVhckNhbnZhc0NvbG9yO1xuICAgICAgICBpZiAodGhpcy5wYXRjaC5jb25maWcuaGFzT3duUHJvcGVydHkoXCJjbGVhckNhbnZhc0RlcHRoXCIpKSB0aGlzLmNsZWFyQ2FudmFzRGVwdGggPSB0aGlzLnBhdGNoLmNvbmZpZy5jbGVhckNhbnZhc0RlcHRoO1xuXG4gICAgICAgIC8vIHNhZmFyaSBzdHVmZi4uLi4uLi4uLi5cbiAgICAgICAgaWYgKC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQaG9uZS9pKSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2FmYXJpQ3JhcCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmdsVXNlSGFsZkZsb2F0VGV4ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5wYXRjaC5jb25maWcuY2FudmFzLmZvcmNlV2ViR2wxKSB0aGlzLmdsID0gY2Fudi5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIHRoaXMucGF0Y2guY29uZmlnLmNhbnZhcyk7XG5cblxuICAgICAgICBpZiAoIXRoaXMuZ2wgfHwgdGhpcy5nbC5pc0NvbnRleHRMb3N0KCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV4aXRFcnJvcihcIk5PX1dFQkdMXCIsIFwic29ycnksIGNvdWxkIG5vdCBpbml0aWFsaXplIFdlYkdMLiBQbGVhc2UgY2hlY2sgaWYgeW91ciBCcm93c2VyIHN1cHBvcnRzIFdlYkdMIG9yIHRyeSB0byByZXN0YXJ0IHlvdXIgYnJvd3Nlci5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5WRVJTSU9OKSAhPSBcIldlYkdMIDEuMFwiKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdsVmVyc2lvbiA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdsID0gY2Fudi5nZXRDb250ZXh0KFwid2ViZ2xcIiwgdGhpcy5wYXRjaC5jb25maWcuY2FudmFzKSB8fCBjYW52LmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIiwgdGhpcy5wYXRjaC5jb25maWcuY2FudmFzKTtcbiAgICAgICAgICAgIHRoaXMuZ2xWZXJzaW9uID0gMTtcblxuICAgICAgICAgICAgLy8gc2FmYXJpXG4gICAgICAgICAgICAvLyBpZiAoL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvaVBob25lL2kpKSlcbiAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLmdsVXNlSGFsZkZsb2F0VGV4ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgLy8gaW9zXG4gICAgICAgICAgICBpZiAoL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGF0Y2guY29uZmlnLmNhbnZhcy5oYXNPd25Qcm9wZXJ0eShcInBvd2VyUHJlZmVyZW5jZVwiKSkgdGhpcy5wYXRjaC5jb25maWcuY2FudmFzLnBvd2VyUHJlZmVyZW5jZSA9IFwiaGlnaC1wZXJmb3JtYW5jZVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmVuYWJsZUV4dGVuc2lvbihcIk9FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1wiKTtcbiAgICAgICAgICAgIC8vIHRoaXMuZW5hYmxlRXh0ZW5zaW9uKFwiR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXCIpO1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2luZ0V4dCA9IHRoaXMuZW5hYmxlRXh0ZW5zaW9uKFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiKSB8fCB0aGlzLmdsO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNpbmdFeHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wudmVydGV4QXR0cmliRGl2aXNvciA9IGluc3RhbmNpbmdFeHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFLmJpbmQoaW5zdGFuY2luZ0V4dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5nbC5kcmF3RWxlbWVudHNJbnN0YW5jZWQgPSBpbnN0YW5jaW5nRXh0LmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFLmJpbmQoaW5zdGFuY2luZ0V4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYmdSZW5kZXJJbmZvID0gdGhpcy5lbmFibGVFeHRlbnNpb24oXCJXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvXCIpO1xuICAgICAgICBpZiAoZGJnUmVuZGVySW5mbylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5nbFJlbmRlcmVyID0gdGhpcy5nbC5nZXRQYXJhbWV0ZXIoZGJnUmVuZGVySW5mby5VTk1BU0tFRF9SRU5ERVJFUl9XRUJHTCk7XG4gICAgICAgICAgICBpZiAodGhpcy5nbFJlbmRlcmVyID09PSBcIkdvb2dsZSBTd2lmdFNoYWRlclwiKSB0aGlzLmdsU2xvd1JlbmRlcmVyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIChldmVudCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWJvcnRlZCkgcmV0dXJuIGNvbnNvbGUubG9nKFwiW2NnbF9zdGF0ZV0gYWJvcnRlZCBjb250ZXh0IGxvc3QuLi4gY2FuIGJlIGlnbm9yZWQuLi5cIik7XG4gICAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJjYW52YXMgbG9zdC4uLlwiLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcIndlYmdsY29udGV4dGxvc3RcIik7XG4gICAgICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIHRoaXMubWF4QW5pc290cm9waWMgPSAwO1xuICAgICAgICBpZiAodGhpcy5lbmFibGVFeHRlbnNpb24oXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIikpXG4gICAgICAgICAgICB0aGlzLm1heEFuaXNvdHJvcGljID0gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5lbmFibGVFeHRlbnNpb24oXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIikuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKTtcblxuXG4gICAgICAgIHRoaXMubWF4VmFyeWluZ1ZlY3RvcnMgPSB0aGlzLmdsLmdldFBhcmFtZXRlcih0aGlzLmdsLk1BWF9WQVJZSU5HX1ZFQ1RPUlMpO1xuICAgICAgICB0aGlzLm1heFRleHR1cmVVbml0cyA9IHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuICAgICAgICB0aGlzLm1heFRleFNpemUgPSB0aGlzLmdsLmdldFBhcmFtZXRlcih0aGlzLmdsLk1BWF9URVhUVVJFX1NJWkUpO1xuICAgICAgICB0aGlzLm1heFVuaWZvcm1zRnJhZyA9IHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyk7XG4gICAgICAgIHRoaXMubWF4VW5pZm9ybXNWZXJ0ID0gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyk7XG4gICAgICAgIHRoaXMubWF4U2FtcGxlcyA9IDA7XG4gICAgICAgIGlmICh0aGlzLmdsLk1BWF9TQU1QTEVTKSB0aGlzLm1heFNhbXBsZXMgPSB0aGlzLmdsLmdldFBhcmFtZXRlcih0aGlzLmdsLk1BWF9TQU1QTEVTKTtcblxuICAgICAgICBpZiAodGhpcy5nbFZlcnNpb24gPT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVFeHRlbnNpb24oXCJPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcIik7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jaW5nRXh0ID0gdGhpcy5lbmFibGVFeHRlbnNpb24oXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIpIHx8IHRoaXMuZ2w7XG5cbiAgICAgICAgICAgIGlmIChpbnN0YW5jaW5nRXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdsLnZlcnRleEF0dHJpYkRpdmlzb3IgPSBpbnN0YW5jaW5nRXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRS5iaW5kKGluc3RhbmNpbmdFeHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2wuZHJhd0VsZW1lbnRzSW5zdGFuY2VkID0gaW5zdGFuY2luZ0V4dC5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRS5iaW5kKGluc3RhbmNpbmdFeHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ERVBUSF9GVU5DUyA9IFtcbiAgICAgICAgICAgIHRoaXMuZ2wuTkVWRVIsXG4gICAgICAgICAgICB0aGlzLmdsLkFMV0FZUyxcbiAgICAgICAgICAgIHRoaXMuZ2wuTEVTUyxcbiAgICAgICAgICAgIHRoaXMuZ2wuTEVRVUFMLFxuICAgICAgICAgICAgdGhpcy5nbC5HUkVBVEVSLFxuICAgICAgICAgICAgdGhpcy5nbC5HRVFVQUwsXG4gICAgICAgICAgICB0aGlzLmdsLkVRVUFMLFxuICAgICAgICAgICAgdGhpcy5nbC5OT1RFUVVBTFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLkNVTExfTU9ERVMgPSBbXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdGhpcy5nbC5CQUNLLFxuICAgICAgICAgICAgdGhpcy5nbC5GUk9OVCxcbiAgICAgICAgICAgIHRoaXMuZ2wuRlJPTlRfQU5EX0JBQ0tcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBnZXRJbmZvKClcbiAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcImdsVmVyc2lvblwiOiB0aGlzLmdsVmVyc2lvbixcbiAgICAgICAgICAgIFwiZ2xSZW5kZXJlclwiOiB0aGlzLmdsUmVuZGVyZXIsXG4gICAgICAgICAgICBcImdsVXNlSGFsZkZsb2F0VGV4XCI6IHRoaXMuZ2xVc2VIYWxmRmxvYXRUZXgsXG4gICAgICAgICAgICBcIm1heFZhcnlpbmdWZWN0b3JzXCI6IHRoaXMubWF4VmFyeWluZ1ZlY3RvcnMsXG4gICAgICAgICAgICBcIm1heFRleHR1cmVVbml0c1wiOiB0aGlzLm1heFRleHR1cmVVbml0cyxcbiAgICAgICAgICAgIFwibWF4VGV4U2l6ZVwiOiB0aGlzLm1heFRleFNpemUsXG4gICAgICAgICAgICBcIm1heFVuaWZvcm1zRnJhZ1wiOiB0aGlzLm1heFVuaWZvcm1zRnJhZyxcbiAgICAgICAgICAgIFwibWF4VW5pZm9ybXNWZXJ0XCI6IHRoaXMubWF4VW5pZm9ybXNWZXJ0LFxuICAgICAgICAgICAgXCJtYXhTYW1wbGVzXCI6IHRoaXMubWF4U2FtcGxlc1xuICAgICAgICB9O1xuICAgIH1cblxuXG5cblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHBvcFZpZXdQb3J0XG4gICAgICogQG1lbWJlcm9mIENvbnRleHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAZGVzY3JpcHRpb24gcG9wIHZpZXdQb3J0IHN0YWNrXG4gICAgICovXG5cblxuICAgIHBvcFZpZXdQb3J0KClcbiAgICB7XG4gICAgICAgIHRoaXMuX3ZpZXdQb3J0U3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMuX3ZpZXdQb3J0U3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMuX3ZpZXdQb3J0U3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMuX3ZpZXdQb3J0U3RhY2sucG9wKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3ZpZXdQb3J0U3RhY2subGVuZ3RoID09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Vmlld1BvcnQoMCwgMCwgdGhpcy5jYW52YXNXaWR0aCwgdGhpcy5jYW52YXNIZWlnaHQpO1xuICAgICAgICAgICAgLy8gdGhpcy5nbC52aWV3cG9ydCh0aGlzLl92aWV3UG9ydFswXSwgdGhpcy5fdmlld1BvcnRbMV0sIHRoaXMuX3ZpZXdQb3J0WzJdLCB0aGlzLl92aWV3UG9ydFszXSk7XG4gICAgICAgICAgICAvLyB0aGlzLnNldFZpZXdQb3J0KHRoaXMuX3ZpZXdQb3J0WzBdLCB0aGlzLl92aWV3UG9ydFsxXSwgdGhpcy5fdmlld1BvcnRbMl0sIHRoaXMuX3ZpZXdQb3J0WzNdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHRoaXMudmlld1BvcnQgPSBbdGhpcy5fdmlld1BvcnRTdGFja1t0aGlzLl92aWV3UG9ydC5sZW5ndGggLSA0XSwgdGhpcy5fdmlld1BvcnRTdGFja1t0aGlzLl92aWV3UG9ydC5sZW5ndGggLSAzXSwgdGhpcy5fdmlld1BvcnRTdGFja1t0aGlzLl92aWV3UG9ydC5sZW5ndGggLSAyXSwgdGhpcy5fdmlld1BvcnRTdGFja1t0aGlzLl92aWV3UG9ydC5sZW5ndGggLSAxXV07XG4gICAgICAgICAgICAvLyB0aGlzLmdsLnZpZXdwb3J0KHRoaXMuX3ZpZXdQb3J0U3RhY2tbdGhpcy5fdmlld1BvcnQubGVuZ3RoIC0gNF0sIHRoaXMuX3ZpZXdQb3J0U3RhY2tbdGhpcy5fdmlld1BvcnQubGVuZ3RoIC0gM10sIHRoaXMuX3ZpZXdQb3J0U3RhY2tbdGhpcy5fdmlld1BvcnQubGVuZ3RoIC0gMl0sIHRoaXMuX3ZpZXdQb3J0U3RhY2tbdGhpcy5fdmlld1BvcnQubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgdGhpcy5zZXRWaWV3UG9ydCh0aGlzLl92aWV3UG9ydFN0YWNrW3RoaXMuX3ZpZXdQb3J0Lmxlbmd0aCAtIDRdLCB0aGlzLl92aWV3UG9ydFN0YWNrW3RoaXMuX3ZpZXdQb3J0Lmxlbmd0aCAtIDNdLCB0aGlzLl92aWV3UG9ydFN0YWNrW3RoaXMuX3ZpZXdQb3J0Lmxlbmd0aCAtIDJdLCB0aGlzLl92aWV3UG9ydFN0YWNrW3RoaXMuX3ZpZXdQb3J0Lmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBwdXNoVmlld1BvcnRcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBkZXNjcmlwdGlvbiBwdXNoIGEgbmV3IHZpZXdwb3J0IG9udG8gc3RhY2tcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaFxuICAgICAqL1xuXG4gICAgcHVzaFZpZXdQb3J0KHgsIHksIHcsIGgpXG4gICAge1xuICAgICAgICB0aGlzLl92aWV3UG9ydFN0YWNrLnB1c2goeCwgeSwgdywgaCk7XG4gICAgICAgIHRoaXMuc2V0Vmlld1BvcnQoeCwgeSwgdywgaCk7XG4gICAgfVxuXG5cbiAgICAvLyBvbGRcbiAgICBnZXRWaWV3UG9ydCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlld1BvcnQ7XG4gICAgfVxuXG4gICAgLy8gb2xkXG4gICAgcmVzZXRWaWV3UG9ydCgpXG4gICAge1xuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KHRoaXMuX3ZpZXdQb3J0WzBdLCB0aGlzLl92aWV3UG9ydFsxXSwgdGhpcy5fdmlld1BvcnRbMl0sIHRoaXMuX3ZpZXdQb3J0WzNdKTtcbiAgICB9XG5cbiAgICAvLyBvbGRcbiAgICBzZXRWaWV3UG9ydCh4LCB5LCB3LCBoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdmlld1BvcnRbMF0gPSBNYXRoLnJvdW5kKHgpO1xuICAgICAgICB0aGlzLl92aWV3UG9ydFsxXSA9IE1hdGgucm91bmQoeSk7XG4gICAgICAgIHRoaXMuX3ZpZXdQb3J0WzJdID0gTWF0aC5yb3VuZCh3KTtcbiAgICAgICAgdGhpcy5fdmlld1BvcnRbM10gPSBNYXRoLnJvdW5kKGgpO1xuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KHRoaXMuX3ZpZXdQb3J0WzBdLCB0aGlzLl92aWV3UG9ydFsxXSwgdGhpcy5fdmlld1BvcnRbMl0sIHRoaXMuX3ZpZXdQb3J0WzNdKTtcbiAgICB9XG5cblxuICAgIHNjcmVlblNob3QoY2IsIGRvU2NyZWVuc2hvdENsZWFyQWxwaGEsIG1pbWVUeXBlLCBxdWFsaXR5KVxuICAgIHtcbiAgICAgICAgaWYgKGRvU2NyZWVuc2hvdENsZWFyQWxwaGEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ2wuY2xlYXJDb2xvcigxLCAxLCAxLCAxKTtcbiAgICAgICAgICAgIHRoaXMuZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgdGhpcy5nbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudG9CbG9iKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy50b0Jsb2IoKGJsb2IpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGNiKSBjYihibG9iKTtcbiAgICAgICAgICAgICAgICBlbHNlIHRoaXMuX2xvZy5sb2coXCJubyBzY3JlZW5zaG90IGNhbGxiYWNrLi4uXCIpO1xuICAgICAgICAgICAgfSwgbWltZVR5cGUsIHF1YWxpdHkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZW5kRnJhbWUoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMucGF0Y2guaXNFZGl0b3JNb2RlKCkpIENBQkxFUy5HTF9NQVJLRVIuZHJhd01hcmtlckxheWVyKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2V0UHJldmlvdXNTaGFkZXIoKTtcblxuICAgICAgICBpZiAodGhpcy5fdk1hdHJpeFN0YWNrLmxlbmd0aCgpID4gMCkgdGhpcy5sb2dTdGFja0Vycm9yKFwidmlldyBtYXRyaXggc3RhY2sgbGVuZ3RoICE9MCBhdCBlbmQgb2YgcmVuZGVyaW5nLi4uXCIpO1xuICAgICAgICBpZiAodGhpcy5fbU1hdHJpeFN0YWNrLmxlbmd0aCgpID4gMCkgdGhpcy5sb2dTdGFja0Vycm9yKFwibXZtYXRyaXggc3RhY2sgbGVuZ3RoICE9MCBhdCBlbmQgb2YgcmVuZGVyaW5nLi4uXCIpO1xuICAgICAgICBpZiAodGhpcy5fcE1hdHJpeFN0YWNrLmxlbmd0aCgpID4gMCkgdGhpcy5sb2dTdGFja0Vycm9yKFwicG1hdHJpeCBzdGFjayBsZW5ndGggIT0wIGF0IGVuZCBvZiByZW5kZXJpbmcuLi5cIik7XG4gICAgICAgIGlmICh0aGlzLl9nbEZyYW1lQnVmZmVyU3RhY2subGVuZ3RoID4gMCkgdGhpcy5sb2dTdGFja0Vycm9yKFwiZ2xGcmFtZUJ1ZmZlciBzdGFjayBsZW5ndGggIT0wIGF0IGVuZCBvZiByZW5kZXJpbmcuLi5cIik7XG4gICAgICAgIGlmICh0aGlzLl9zdGFja0RlcHRoVGVzdC5sZW5ndGggPiAwKSB0aGlzLmxvZ1N0YWNrRXJyb3IoXCJkZXB0aHRlc3Qgc3RhY2sgbGVuZ3RoICE9MCBhdCBlbmQgb2YgcmVuZGVyaW5nLi4uXCIpO1xuICAgICAgICBpZiAodGhpcy5fc3RhY2tEZXB0aFdyaXRlLmxlbmd0aCA+IDApIHRoaXMubG9nU3RhY2tFcnJvcihcImRlcHRod3JpdGUgc3RhY2sgbGVuZ3RoICE9MCBhdCBlbmQgb2YgcmVuZGVyaW5nLi4uXCIpO1xuICAgICAgICBpZiAodGhpcy5fc3RhY2tEZXB0aEZ1bmMubGVuZ3RoID4gMCkgdGhpcy5sb2dTdGFja0Vycm9yKFwiZGVwdGhmdW5jIHN0YWNrIGxlbmd0aCAhPTAgYXQgZW5kIG9mIHJlbmRlcmluZy4uLlwiKTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YWNrQmxlbmQubGVuZ3RoID4gMCkgdGhpcy5sb2dTdGFja0Vycm9yKFwiYmxlbmQgc3RhY2sgbGVuZ3RoICE9MCBhdCBlbmQgb2YgcmVuZGVyaW5nLi4uXCIpO1xuICAgICAgICBpZiAodGhpcy5fc3RhY2tCbGVuZE1vZGUubGVuZ3RoID4gMCkgdGhpcy5sb2dTdGFja0Vycm9yKFwiYmxlbmRNb2RlIHN0YWNrIGxlbmd0aCAhPTAgYXQgZW5kIG9mIHJlbmRlcmluZy4uLlwiKTtcbiAgICAgICAgaWYgKHRoaXMuX3NoYWRlclN0YWNrLmxlbmd0aCA+IDApIHRoaXMubG9nU3RhY2tFcnJvcihcInRoaXMuX3NoYWRlclN0YWNrIGxlbmd0aCAhPTAgYXQgZW5kIG9mIHJlbmRlcmluZy4uLlwiKTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YWNrQ3VsbEZhY2UubGVuZ3RoID4gMCkgdGhpcy5sb2dTdGFja0Vycm9yKFwidGhpcy5fc3RhY2tDdWxsRmFjZSBsZW5ndGggIT0wIGF0IGVuZCBvZiByZW5kZXJpbmcuLi5cIik7XG4gICAgICAgIGlmICh0aGlzLl9zdGFja0N1bGxGYWNlRmFjaW5nLmxlbmd0aCA+IDApIHRoaXMubG9nU3RhY2tFcnJvcihcInRoaXMuX3N0YWNrQ3VsbEZhY2VGYWNpbmcgbGVuZ3RoICE9MCBhdCBlbmQgb2YgcmVuZGVyaW5nLi4uXCIpO1xuICAgICAgICBpZiAodGhpcy5fdmlld1BvcnRTdGFjay5sZW5ndGggPiAwKSB0aGlzLmxvZ1N0YWNrRXJyb3IoXCJ2aWV3cG9ydCBzdGFjayBsZW5ndGggIT0wIGF0IGVuZCBvZiByZW5kZXJpbmcuLi5cIik7XG5cbiAgICAgICAgdGhpcy5fZnJhbWVTdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuX29sZENhbnZhc1dpZHRoICE9IHRoaXMuY2FudmFzV2lkdGggfHwgdGhpcy5fb2xkQ2FudmFzSGVpZ2h0ICE9IHRoaXMuY2FudmFzSGVpZ2h0KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vbGRDYW52YXNXaWR0aCA9IHRoaXMuY2FudmFzV2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9vbGRDYW52YXNIZWlnaHQgPSB0aGlzLmNhbnZhc0hlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwicmVzaXplXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvciAhPSB0aGlzLl9jdXJyZW50Q3Vyc29yKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yID0gdGhpcy5jYW52YXMuc3R5bGUuY3Vyc29yID0gdGhpcy5fY3Vyc29yO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJlbmRmcmFtZVwiKTtcblxuICAgICAgICB0aGlzLmZwc0NvdW50ZXIuZW5kRnJhbWUoKTtcbiAgICB9XG5cbiAgICBsb2dTdGFja0Vycm9yKHN0cilcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5faGFkU3RhY2tFcnJvcilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5faGFkU3RhY2tFcnJvciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIltcIiArIHRoaXMuY2FudmFzLmlkICsgXCJdOiBcIiwgc3RyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNoYWRlciBzdGFja1xuICAgIGdldFNoYWRlcigpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudFNoYWRlcikgaWYgKCF0aGlzLmZyYW1lU3RvcmUgfHwgKCh0aGlzLmZyYW1lU3RvcmUucmVuZGVyT2Zmc2NyZWVuID09PSB0cnVlKSA9PSB0aGlzLl9jdXJyZW50U2hhZGVyLm9mZlNjcmVlblBhc3MpID09PSB0cnVlKSByZXR1cm4gdGhpcy5fY3VycmVudFNoYWRlcjtcblxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fc2hhZGVyU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmICh0aGlzLl9zaGFkZXJTdGFja1tpXSkgaWYgKHRoaXMuZnJhbWVTdG9yZS5yZW5kZXJPZmZzY3JlZW4gPT0gdGhpcy5fc2hhZGVyU3RhY2tbaV0ub2ZmU2NyZWVuUGFzcykgcmV0dXJuIHRoaXMuX3NoYWRlclN0YWNrW2ldO1xuICAgIH1cblxuICAgIGdldERlZmF1bHRTaGFkZXIoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZVNoYWRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwdXNoIGEgc2hhZGVyIHRvIHRoZSBzaGFkZXIgc3RhY2tcbiAgICAgKiBAZnVuY3Rpb24gcHVzaFNoYWRlclxuICAgICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNoYWRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gICAgcHVzaFNoYWRlcihzaGFkZXIpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5mcmFtZVN0b3JlLmZvcmNlU2hhZGVyTW9kcylcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZyYW1lU3RvcmUuZm9yY2VTaGFkZXJNb2RzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGlmICghY3VycmVudFNoYWRlci5mb3JjZWRNb2QgJiYgY3VycmVudFNoYWRlciAhPSB0aGlzLmZyYW1lU3RvcmUuZm9yY2VTaGFkZXJNb2RzW2ldKVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgY3VycmVudFNoYWRlci5mb3JjZWRNb2QgPSB0aGlzLmZyYW1lU3RvcmUuZm9yY2VTaGFkZXJNb2RzW2ldO1xuICAgICAgICAgICAgICAgIHNoYWRlciA9IHRoaXMuZnJhbWVTdG9yZS5mb3JjZVNoYWRlck1vZHNbaV0uYmluZChzaGFkZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGN1cnJlbnRTaGFkZXI7XG4gICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuZnJhbWVTdG9yZS5mb3JjZVNoYWRlck1vZHNbaV0uY3VycmVudFNoYWRlcigpICYmIHNoYWRlciAhPSB0aGlzLmZyYW1lU3RvcmUuZm9yY2VTaGFkZXJNb2RzW2ldLmN1cnJlbnRTaGFkZXIoKS5zaGFkZXIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zaGFkZXJTdGFjay5wdXNoKHNoYWRlcik7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRTaGFkZXIgPSBzaGFkZXI7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBwb3AgY3VycmVudCB1c2VkIHNoYWRlciBmcm9tIHNoYWRlciBzdGFja1xuICAgICAqIEBmdW5jdGlvbiBwb3BTaGFkZXJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIHNldFByZXZpb3VzU2hhZGVyKClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmZyYW1lU3RvcmUuZm9yY2VTaGFkZXJNb2RzKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZnJhbWVTdG9yZS5mb3JjZVNoYWRlck1vZHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgYSA9XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZVN0b3JlLmZvcmNlU2hhZGVyTW9kc1tpXS51bmJpbmQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIC8vIGlmIChhKSByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5wb3BTaGFkZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zaGFkZXJTdGFjay5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2hhZGVyIHN0YWNrIHBvcCFcIik7XG4gICAgICAgIHRoaXMuX3NoYWRlclN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLl9jdXJyZW50U2hhZGVyID0gdGhpcy5fc2hhZGVyU3RhY2tbdGhpcy5fc2hhZGVyU3RhY2subGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHVzaCBhIGZyYW1lYnVmZmVyIHRvIHRoZSBmcmFtZWJ1ZmZlciBzdGFja1xuICAgICAqIEBmdW5jdGlvbiBwdXNoR2xGcmFtZUJ1ZmZlclxuICAgICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZyYW1lYnVmZmVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgcHVzaEdsRnJhbWVCdWZmZXIoZmIpXG4gICAge1xuICAgICAgICB0aGlzLl9nbEZyYW1lQnVmZmVyU3RhY2sucHVzaChmYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcG9wIGZyYW1lYnVmZmVyIHN0YWNrXG4gICAgICogQGZ1bmN0aW9uIHBvcEdsRnJhbWVCdWZmZXJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGN1cnJlbnQgZnJhbWVidWZmZXIgb3IgbnVsbFxuICAgICAqL1xuICAgIHBvcEdsRnJhbWVCdWZmZXIoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2dsRnJhbWVCdWZmZXJTdGFjay5sZW5ndGggPT0gMCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHRoaXMuX2dsRnJhbWVCdWZmZXJTdGFjay5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dsRnJhbWVCdWZmZXJTdGFja1t0aGlzLl9nbEZyYW1lQnVmZmVyU3RhY2subGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IGN1cnJlbnQgZnJhbWVidWZmZXJcbiAgICAgKiBAZnVuY3Rpb24gZ2V0Q3VycmVudEZyYW1lQnVmZmVyXG4gICAgICogQG1lbWJlcm9mIENvbnRleHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBjdXJyZW50IGZyYW1lYnVmZmVyIG9yIG51bGxcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50R2xGcmFtZUJ1ZmZlcigpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fZ2xGcmFtZUJ1ZmZlclN0YWNrLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLl9nbEZyYW1lQnVmZmVyU3RhY2tbdGhpcy5fZ2xGcmFtZUJ1ZmZlclN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHB1c2ggYSBmcmFtZWJ1ZmZlciB0byB0aGUgZnJhbWVidWZmZXIgc3RhY2tcbiAgICAgKiBAZnVuY3Rpb24gcHVzaEdsRnJhbWVCdWZmZXJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnJhbWVidWZmZXJ9IGZyYW1lYnVmZmVyXG4gICAgICovXG4gICAgcHVzaEZyYW1lQnVmZmVyKGZiKVxuICAgIHtcbiAgICAgICAgdGhpcy5fZnJhbWVCdWZmZXJTdGFjay5wdXNoKGZiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwb3AgZnJhbWVidWZmZXIgc3RhY2tcbiAgICAgKiBAZnVuY3Rpb24gcG9wRnJhbWVCdWZmZXJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtGcmFtZWJ1ZmZlcn0gY3VycmVudCBmcmFtZWJ1ZmZlciBvciBudWxsXG4gICAgICovXG4gICAgcG9wRnJhbWVCdWZmZXIoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lQnVmZmVyU3RhY2subGVuZ3RoID09IDApIHJldHVybiBudWxsO1xuICAgICAgICB0aGlzLl9mcmFtZUJ1ZmZlclN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVCdWZmZXJTdGFja1t0aGlzLl9mcmFtZUJ1ZmZlclN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCBjdXJyZW50IGZyYW1lYnVmZmVyXG4gICAgICogQGZ1bmN0aW9uIGdldEN1cnJlbnRGcmFtZUJ1ZmZlclxuICAgICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0ZyYW1lYnVmZmVyfSBjdXJyZW50IGZyYW1lYnVmZmVyIG9yIG51bGxcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50RnJhbWVCdWZmZXIoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lQnVmZmVyU3RhY2subGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lQnVmZmVyU3RhY2tbdGhpcy5fZnJhbWVCdWZmZXJTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9XG5cblxuICAgIHJlbmRlclN0YXJ0KGNnbCwgaWRlbnRUcmFuc2xhdGUsIGlkZW50VHJhbnNsYXRlVmlldylcbiAgICB7XG4gICAgICAgIHRoaXMuZnBzQ291bnRlci5zdGFydEZyYW1lKCk7XG4gICAgICAgIHRoaXMucHVzaERlcHRoVGVzdCh0cnVlKTtcbiAgICAgICAgdGhpcy5wdXNoRGVwdGhXcml0ZSh0cnVlKTtcbiAgICAgICAgdGhpcy5wdXNoRGVwdGhGdW5jKGNnbC5nbC5MRVFVQUwpO1xuICAgICAgICB0aGlzLnB1c2hDdWxsRmFjZUZhY2luZyhjZ2wuZ2wuQkFDSyk7XG4gICAgICAgIHRoaXMucHVzaEN1bGxGYWNlKGZhbHNlKTtcblxuICAgICAgICAvLyBpZiAodGhpcy5jbGVhckNhbnZhc1RyYW5zcGFyZW50KVxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgICBjZ2wuZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICAgICAgLy8gICAgIGNnbC5nbC5jbGVhcihjZ2wuZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYgKHRoaXMuY2xlYXJDYW52YXNEZXB0aCkgY2dsLmdsLmNsZWFyKGNnbC5nbC5ERVBUSF9CVUZGRVJfQklUKTtcblxuICAgICAgICBjZ2wuc2V0Vmlld1BvcnQoMCwgMCwgY2dsLmNhbnZhc1dpZHRoLCBjZ2wuY2FudmFzSGVpZ2h0KTtcblxuICAgICAgICB0aGlzLl9zdGFydE1hdHJpeFN0YWNrcyhpZGVudFRyYW5zbGF0ZSwgaWRlbnRUcmFuc2xhdGVWaWV3KTtcblxuICAgICAgICBjZ2wucHVzaEJsZW5kTW9kZShDT05TVEFOVFMuQkxFTkRfTU9ERVMuQkxFTkRfTk9STUFMLCBmYWxzZSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90ZXh0dXJlc2xvdHMubGVuZ3RoOyBpKyspIHRoaXMuX3RleHR1cmVzbG90c1tpXSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5wdXNoU2hhZGVyKHRoaXMuX3NpbXBsZVNoYWRlcik7XG5cbiAgICAgICAgdGhpcy5fZnJhbWVTdGFydGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5fb25ldGltZUNhbGxiYWNrcy5sZW5ndGggPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX29uZXRpbWVDYWxsYmFja3MubGVuZ3RoOyBpKyspIHRoaXMuX29uZXRpbWVDYWxsYmFja3NbaV0oKTtcbiAgICAgICAgICAgIHRoaXMuX29uZXRpbWVDYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGV4dHVyZXNsb3RzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdsLmFjdGl2ZVRleHR1cmUodGhpcy5nbC5URVhUVVJFMCArIGkpO1xuICAgICAgICAgICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXNsb3RzW2ldID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwiYmVnaW5GcmFtZVwiKTtcbiAgICB9XG5cbiAgICByZW5kZXJFbmQoY2dsKVxuICAgIHtcbiAgICAgICAgdGhpcy5fZW5kTWF0cml4U3RhY2tzKCk7XG5cbiAgICAgICAgdGhpcy5wb3BEZXB0aFRlc3QoKTtcbiAgICAgICAgdGhpcy5wb3BEZXB0aFdyaXRlKCk7XG4gICAgICAgIHRoaXMucG9wRGVwdGhGdW5jKCk7XG4gICAgICAgIHRoaXMucG9wQ3VsbEZhY2VGYWNpbmcoKTtcbiAgICAgICAgdGhpcy5wb3BDdWxsRmFjZSgpO1xuICAgICAgICB0aGlzLnBvcEJsZW5kKCk7XG4gICAgICAgIHRoaXMucG9wQmxlbmRNb2RlKCk7XG5cbiAgICAgICAgY2dsLmVuZEZyYW1lKCk7XG5cbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJlbmRGcmFtZVwiKTtcbiAgICB9XG5cbiAgICBnZXRUZXh0dXJlKHNsb3QpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZXNsb3RzW3Nsb3RdO1xuICAgIH1cblxuICAgIGhhc0ZyYW1lU3RhcnRlZCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVTdGFydGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGxvZyB3YXJuaW5nIHRvIGNvbnNvbGUgaWYgdGhlIHJlbmRlcmluZyBvZiBvbmUgZnJhbWUgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgLyBoYW5keSB0byBjaGVjayBmb3IgYXN5bmMgcHJvYmxlbXNcbiAgICAgKiBAZnVuY3Rpb24gY2hlY2tGcmFtZVN0YXJ0ZWRcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNoZWNrRnJhbWVTdGFydGVkKHN0cmluZylcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5fZnJhbWVTdGFydGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcImZyYW1lIG5vdCBzdGFydGVkIFwiICsgc3RyaW5nKTtcbiAgICAgICAgICAgIHRoaXMucGF0Y2gucHJpbnRUcmlnZ2VyU3RhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgc2V0VGV4dHVyZShzbG90LCB0LCB0eXBlKVxuICAgIHtcbiAgICAgICAgdGhpcy5jaGVja0ZyYW1lU3RhcnRlZChcImNnbCBzZXRUZXh0dXJlXCIpO1xuXG4gICAgICAgIGlmICh0ID09PSBudWxsKSB0ID0gQ0dMLlRleHR1cmUuZ2V0RW1wdHlUZXh0dXJlKHRoaXMpLnRleDtcblxuICAgICAgICAvLyBpZiAoIXRoaXMuZ2wuaXNUZXh0dXJlKHQpKVxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcIm5vdCBhIHRleHR1cmUhISEhXCIpOyByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vICAgICB0ID0gQ0dMLlRleHR1cmUuZ2V0RW1wdHlUZXh0dXJlKHRoaXMpLnRleDtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmICghdGhpcy5nbC5pc1RleHR1cmUodCkpXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICAgIHQgPSBDR0wuVGV4dHVyZS5nZXRFcnJvclRleHR1cmUodGhpcykudGV4O1xuICAgICAgICAvLyAgICAgLy8gdGhpcy5fbG9nLnN0YWNrKFwibm90IGEgdGV4dHVyZSEhISFcIik7XG4gICAgICAgIC8vICAgICAvLyByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIH1cblxuXG4gICAgICAgIGlmICh0aGlzLl90ZXh0dXJlc2xvdHNbc2xvdF0gIT0gdClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRTAgKyBzbG90KTtcbiAgICAgICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodHlwZSB8fCB0aGlzLmdsLlRFWFRVUkVfMkQsIHQpO1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXNsb3RzW3Nsb3RdID0gdDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVsbFNjcmVlbigpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5jYW52YXMucmVxdWVzdEZ1bGxzY3JlZW4pIHRoaXMuY2FudmFzLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY2FudmFzLm1velJlcXVlc3RGdWxsU2NyZWVuKSB0aGlzLmNhbnZhcy5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmNhbnZhcy53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikgdGhpcy5jYW52YXMud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jYW52YXMubXNSZXF1ZXN0RnVsbHNjcmVlbikgdGhpcy5jYW52YXMubXNSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgIH1cblxuXG4gICAgcHJpbnRFcnJvcihzdHIpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tHbEVycm9ycykgcmV0dXJuO1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGVycm9yID0gdGhpcy5nbC5nZXRFcnJvcigpO1xuXG4gICAgICAgIGlmIChlcnJvciAhPSB0aGlzLmdsLk5PX0VSUk9SKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgZXJyU3RyID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChlcnJvciA9PSB0aGlzLmdsLk9VVF9PRl9NRU1PUlkpIGVyclN0ciA9IFwiT1VUX09GX01FTU9SWVwiO1xuICAgICAgICAgICAgaWYgKGVycm9yID09IHRoaXMuZ2wuSU5WQUxJRF9FTlVNKSBlcnJTdHIgPSBcIklOVkFMSURfRU5VTVwiO1xuICAgICAgICAgICAgaWYgKGVycm9yID09IHRoaXMuZ2wuSU5WQUxJRF9PUEVSQVRJT04pIGVyclN0ciA9IFwiSU5WQUxJRF9PUEVSQVRJT05cIjtcbiAgICAgICAgICAgIGlmIChlcnJvciA9PSB0aGlzLmdsLklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OKSBlcnJTdHIgPSBcIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OXCI7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPT0gdGhpcy5nbC5JTlZBTElEX1ZBTFVFKSBlcnJTdHIgPSBcIklOVkFMSURfVkFMVUVcIjtcbiAgICAgICAgICAgIGlmIChlcnJvciA9PSB0aGlzLmdsLkNPTlRFWFRfTE9TVF9XRUJHTClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVyclN0ciA9IFwiQ09OVEVYVF9MT1NUX1dFQkdMXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IgPT0gdGhpcy5nbC5OT19FUlJPUikgZXJyU3RyID0gXCJOT19FUlJPUlwiO1xuXG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG5cblxuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJnbCBlcnJvciBbXCIgKyB0aGlzLmNhbnZhcy5pZCArIFwiXTogXCIsIHN0ciwgZXJyb3IsIGVyclN0cik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcy5pZC5jb250YWlucyhcImdsR3VpQ2FudmFzXCIpKVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbG9nZ2VkR2xFcnJvcilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0Y2gucHJpbnRUcmlnZ2VyU3RhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLnN0YWNrKFwiZ2xlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VkR2xFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yID0gdGhpcy5nbC5nZXRFcnJvcigpO1xuXG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG5cbiAgICBzYXZlU2NyZWVuc2hvdChmaWxlbmFtZSwgY2IsIHB3LCBwaCwgbm9jbGVhcmFscGhhKVxuICAgIHtcbiAgICAgICAgdGhpcy5wYXRjaC5yZW5kZXJPbmVGcmFtZSgpO1xuXG4gICAgICAgIGxldCB3ID0gdGhpcy5jYW52YXMuY2xpZW50V2lkdGggKiB0aGlzLnBpeGVsRGVuc2l0eTtcbiAgICAgICAgbGV0IGggPSB0aGlzLmNhbnZhcy5jbGllbnRIZWlnaHQgKiB0aGlzLnBpeGVsRGVuc2l0eTtcblxuICAgICAgICBpZiAocHcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gcHc7XG4gICAgICAgICAgICB3ID0gcHc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBwaDtcbiAgICAgICAgICAgIGggPSBwaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhZExlZnQobnIsIG4sIHN0cilcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5KG4gLSBTdHJpbmcobnIpLmxlbmd0aCArIDEpLmpvaW4oc3RyIHx8IFwiMFwiKSArIG5yO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgY29uc3QgZGF0ZVN0ciA9IFwiXCIuY29uY2F0KFN0cmluZyhkLmdldEZ1bGxZZWFyKCkpICsgU3RyaW5nKGQuZ2V0TW9udGgoKSArIDEpICsgU3RyaW5nKGQuZ2V0RGF0ZSgpKSwgXCJfXCIpLmNvbmNhdChwYWRMZWZ0KGQuZ2V0SG91cnMoKSwgMikpLmNvbmNhdChwYWRMZWZ0KGQuZ2V0TWludXRlcygpLCAyKSkuY29uY2F0KHBhZExlZnQoZC5nZXRTZWNvbmRzKCksIDIpKTtcblxuICAgICAgICBpZiAoIWZpbGVuYW1lKSBmaWxlbmFtZSA9IFwiY2FibGVzX1wiICsgZGF0ZVN0ciArIFwiLnBuZ1wiO1xuICAgICAgICBlbHNlIGZpbGVuYW1lICs9IFwiLnBuZ1wiO1xuXG4gICAgICAgIHRoaXMucGF0Y2guY2dsLnNjcmVlblNob3QoZnVuY3Rpb24gKGJsb2IpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdztcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGg7XG5cbiAgICAgICAgICAgIGlmIChibG9iKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXG4gICAgICAgICAgICAgICAgYW5jaG9yLmRvd25sb2FkID0gZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgYW5jaG9yLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYikgY2IoYmxvYik7XG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cubG9nKFwic2NyZWVuc2hvdDogbm8gYmxvYlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpLCBub2NsZWFyYWxwaGEpO1xuICAgIH1cblxuICAgIF9kaXNwb3NlKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3NpbXBsZVNoYWRlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgIH1cbn1cblxuXG5Db250ZXh0LnByb3RvdHlwZS5wb3BTaGFkZXIgPSBDb250ZXh0LnByb3RvdHlwZS5zZXRQcmV2aW91c1NoYWRlcjtcbkNvbnRleHQucHJvdG90eXBlLnNldFNoYWRlciA9IENvbnRleHQucHJvdG90eXBlLnB1c2hTaGFkZXI7XG5cbi8qKlxuICogZXhlY3V0ZSB0aGUgY2FsbGJhY2sgbmV4dCBmcmFtZSwgb25jZVxuICogQGZ1bmN0aW9uIGFkZE5leHRGcmFtZU9uY2VDYWxsYmFja1xuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuYWRkTmV4dEZyYW1lT25jZUNhbGxiYWNrID0gZnVuY3Rpb24gKGNiKVxue1xuICAgIGlmIChjYikgdGhpcy5fb25ldGltZUNhbGxiYWNrcy5wdXNoKGNiKTtcbn07XG5cbi8vIHN0YXRlIGRlcHRodGVzdFxuXG4vKipcbiAqIHB1c2ggZGVwdGggdGVzdGluZyBlbmFibGVkIHN0YXRlXG4gKiBAZnVuY3Rpb24gcHVzaERlcHRoVGVzdFxuICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLl9zdGFja0RlcHRoVGVzdCA9IFtdO1xuQ29udGV4dC5wcm90b3R5cGUucHVzaERlcHRoVGVzdCA9IGZ1bmN0aW9uIChiKVxue1xuICAgIHRoaXMuX3N0YWNrRGVwdGhUZXN0LnB1c2goYik7XG4gICAgaWYgKCFiKSB0aGlzLmdsLmRpc2FibGUodGhpcy5nbC5ERVBUSF9URVNUKTtcbiAgICBlbHNlIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuREVQVEhfVEVTVCk7XG59O1xuLyoqXG4gKiBjdXJyZW50IHN0YXRlIG9mIGRlcHRoIHRlc3RpbmdcbiAqIEBmdW5jdGlvbiBzdGF0ZUN1bGxGYWNlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZW5hYmxlZFxuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICovXG5Db250ZXh0LnByb3RvdHlwZS5zdGF0ZURlcHRoVGVzdCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrRGVwdGhUZXN0W3RoaXMuX3N0YWNrRGVwdGhUZXN0Lmxlbmd0aCAtIDFdO1xufTtcblxuLyoqXG4gKiBwb3AgZGVwdGggdGVzdGluZyBzdGF0ZVxuICogQGZ1bmN0aW9uIHBvcEN1bGxGYWNlXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnBvcERlcHRoVGVzdCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fc3RhY2tEZXB0aFRlc3QucG9wKCk7XG5cbiAgICBpZiAoIXRoaXMuX3N0YWNrRGVwdGhUZXN0W3RoaXMuX3N0YWNrRGVwdGhUZXN0Lmxlbmd0aCAtIDFdKSB0aGlzLmdsLmRpc2FibGUodGhpcy5nbC5ERVBUSF9URVNUKTtcbiAgICBlbHNlIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuREVQVEhfVEVTVCk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc3RhdGUgZGVwdGh3cml0ZVxuXG4vKipcbiAqIHB1c2ggZGVwdGggd3JpdGUgZW5hYmxlZCBzdGF0ZVxuICogQGZ1bmN0aW9uIHB1c2hEZXB0aFRlc3RcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICovXG5Db250ZXh0LnByb3RvdHlwZS5fc3RhY2tEZXB0aFdyaXRlID0gW107XG5Db250ZXh0LnByb3RvdHlwZS5wdXNoRGVwdGhXcml0ZSA9IGZ1bmN0aW9uIChiKVxue1xuICAgIGIgPSBiIHx8IGZhbHNlO1xuICAgIHRoaXMuX3N0YWNrRGVwdGhXcml0ZS5wdXNoKGIpO1xuICAgIHRoaXMuZ2wuZGVwdGhNYXNrKGIpO1xufTtcblxuLyoqXG4gKiBjdXJyZW50IHN0YXRlIG9mIGRlcHRoIHdyaXRpbmdcbiAqIEBmdW5jdGlvbiBzdGF0ZUN1bGxGYWNlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZW5hYmxlZFxuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICovXG5Db250ZXh0LnByb3RvdHlwZS5zdGF0ZURlcHRoV3JpdGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9zdGFja0RlcHRoV3JpdGVbdGhpcy5fc3RhY2tEZXB0aFdyaXRlLmxlbmd0aCAtIDFdO1xufTtcblxuLyoqXG4gKiBwb3AgZGVwdGggd3JpdGluZyBzdGF0ZVxuICogQGZ1bmN0aW9uIHBvcEN1bGxGYWNlXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnBvcERlcHRoV3JpdGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX3N0YWNrRGVwdGhXcml0ZS5wb3AoKTtcbiAgICB0aGlzLmdsLmRlcHRoTWFzayh0aGlzLl9zdGFja0RlcHRoV3JpdGVbdGhpcy5fc3RhY2tEZXB0aFdyaXRlLmxlbmd0aCAtIDFdIHx8IGZhbHNlKTtcbn07XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHN0YXRlIEN1bGxGYWNlXG5cbi8qKlxuICogcHVzaCBmYWNlIGN1bGxpbmcgZmFjZSBlbmFibGVkIHN0YXRlXG4gKiBAZnVuY3Rpb24gcHVzaEN1bGxGYWNlRmFjaW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuX3N0YWNrQ3VsbEZhY2UgPSBbXTtcbkNvbnRleHQucHJvdG90eXBlLnB1c2hDdWxsRmFjZSA9IGZ1bmN0aW9uIChiKVxue1xuICAgIHRoaXMuX3N0YWNrQ3VsbEZhY2UucHVzaChiKTtcblxuICAgIGlmIChiKSB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkNVTExfRkFDRSk7XG4gICAgZWxzZSB0aGlzLmdsLmRpc2FibGUodGhpcy5nbC5DVUxMX0ZBQ0UpO1xufTtcblxuLyoqXG4gKiBjdXJyZW50IHN0YXRlIG9mIGZhY2UgY3VsbGluZ1xuICogQGZ1bmN0aW9uIHN0YXRlQ3VsbEZhY2VcbiAqIEByZXR1cm5zIHtCb29sZWFufSBlbmFibGVkXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnN0YXRlQ3VsbEZhY2UgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9zdGFja0N1bGxGYWNlW3RoaXMuX3N0YWNrQ3VsbEZhY2UubGVuZ3RoIC0gMV07XG59O1xuXG4vKipcbiAqIHBvcCBmYWNlIGN1bGxpbmcgZW5hYmxlZCBzdGF0ZVxuICogQGZ1bmN0aW9uIHBvcEN1bGxGYWNlXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnBvcEN1bGxGYWNlID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9zdGFja0N1bGxGYWNlLnBvcCgpO1xuXG4gICAgaWYgKHRoaXMuX3N0YWNrQ3VsbEZhY2VbdGhpcy5fc3RhY2tDdWxsRmFjZS5sZW5ndGggLSAxXSkgdGhpcy5nbC5lbmFibGUodGhpcy5nbC5DVUxMX0ZBQ0UpO1xuICAgIGVsc2UgdGhpcy5nbC5kaXNhYmxlKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcbn07XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHN0YXRlIEN1bGxGYWNlIEZhY2luZ1xuXG5cbi8qKlxuICogcHVzaCBmYWNlIGN1bGxpbmcgZmFjZSBzaWRlXG4gKiBAZnVuY3Rpb24gcHVzaEN1bGxGYWNlRmFjaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gY2dsLmdsLkZST05UX0FORF9CQUNLLCBjZ2wuZ2wuQkFDSyBvciBjZ2wuZ2wuRlJPTlRcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuX3N0YWNrQ3VsbEZhY2VGYWNpbmcgPSBbXTtcbkNvbnRleHQucHJvdG90eXBlLnB1c2hDdWxsRmFjZUZhY2luZyA9IGZ1bmN0aW9uIChiKVxue1xuICAgIHRoaXMuX3N0YWNrQ3VsbEZhY2VGYWNpbmcucHVzaChiKTtcbiAgICB0aGlzLmdsLmN1bGxGYWNlKHRoaXMuX3N0YWNrQ3VsbEZhY2VGYWNpbmdbdGhpcy5fc3RhY2tDdWxsRmFjZUZhY2luZy5sZW5ndGggLSAxXSk7XG59O1xuXG4vKipcbiAqIGN1cnJlbnQgc3RhdGUgb2YgZmFjZSBjdWxsaW5nIHNpZGVcbiAqIEBmdW5jdGlvbiBzdGF0ZUN1bGxGYWNlRmFjaW5nXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZW5hYmxlZFxuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICovXG5Db250ZXh0LnByb3RvdHlwZS5zdGF0ZUN1bGxGYWNlRmFjaW5nID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fc3RhY2tDdWxsRmFjZUZhY2luZ1t0aGlzLl9zdGFja0N1bGxGYWNlRmFjaW5nLmxlbmd0aCAtIDFdO1xufTtcblxuLyoqXG4gKiBwb3AgZmFjZSBjdWxsaW5nIGZhY2Ugc2lkZVxuICogQGZ1bmN0aW9uIHBvcEN1bGxGYWNlRmFjaW5nXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnBvcEN1bGxGYWNlRmFjaW5nID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9zdGFja0N1bGxGYWNlRmFjaW5nLnBvcCgpO1xuICAgIGlmICh0aGlzLl9zdGFja0N1bGxGYWNlRmFjaW5nLmxlbmd0aCA+IDApIHRoaXMuZ2wuY3VsbEZhY2UodGhpcy5fc3RhY2tDdWxsRmFjZUZhY2luZ1t0aGlzLl9zdGFja0N1bGxGYWNlRmFjaW5nLmxlbmd0aCAtIDFdKTtcbn07XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHN0YXRlIGRlcHRoZnVuY1xuXG5Db250ZXh0LnByb3RvdHlwZS5fc3RhY2tEZXB0aEZ1bmMgPSBbXTtcblxuLyoqXG4gKiBlbmFibGUgLyBkaXNhYmxlIGRlcHRoIHRlc3RpbmdcbiAqIGxpa2UgYGdsLmRlcHRoRnVuYyhib29sZWFuKTtgXG4gKiBAZnVuY3Rpb24gcHVzaERlcHRoRnVuY1xuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtCb29sZWFufSBkZXB0aHRlc3RpbmdcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUucHVzaERlcHRoRnVuYyA9IGZ1bmN0aW9uIChmKVxue1xuICAgIHRoaXMuX3N0YWNrRGVwdGhGdW5jLnB1c2goZik7XG4gICAgdGhpcy5nbC5kZXB0aEZ1bmMoZik7XG59O1xuXG4vKipcbiAqIGN1cnJlbnQgc3RhdGUgb2YgYmxlbmRcbiAqIEBmdW5jdGlvbiBzdGF0ZURlcHRoRnVuY1xuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybnMge0Jvb2xlYW59IGRlcHRoIHRlc3RpbmcgZW5hYmxlZC9kaXNhYmxlZFxuICovXG5Db250ZXh0LnByb3RvdHlwZS5zdGF0ZURlcHRoRnVuYyA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX3N0YWNrRGVwdGhGdW5jLmxlbmd0aCA+IDApIHJldHVybiB0aGlzLl9zdGFja0RlcHRoRnVuY1t0aGlzLl9zdGFja0RlcHRoRnVuYy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIHBvcCBkZXB0aCB0ZXN0aW5nIGFuZCBzZXQgdGhlIHByZXZpb3VzIHN0YXRlXG4gKiBAZnVuY3Rpb24gcG9wRGVwdGhGdW5jXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnBvcERlcHRoRnVuYyA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fc3RhY2tEZXB0aEZ1bmMucG9wKCk7XG4gICAgaWYgKHRoaXMuX3N0YWNrRGVwdGhGdW5jLmxlbmd0aCA+IDApIHRoaXMuZ2wuZGVwdGhGdW5jKHRoaXMuX3N0YWNrRGVwdGhGdW5jW3RoaXMuX3N0YWNrRGVwdGhGdW5jLmxlbmd0aCAtIDFdKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzdGF0ZSBibGVuZGluZ1xuXG5Db250ZXh0LnByb3RvdHlwZS5fc3RhY2tCbGVuZCA9IFtdO1xuXG4vKipcbiAqIGVuYWJsZSAvIGRpc2FibGUgYmxlbmRcbiAqIGxpa2UgZ2wuZW5hYmxlKGdsLkJMRU5EKTsgLyBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAqIEBmdW5jdGlvbiBwdXNoQmxlbmRcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYmxlbmRpbmdcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUucHVzaEJsZW5kID0gZnVuY3Rpb24gKGIpXG57XG4gICAgdGhpcy5fc3RhY2tCbGVuZC5wdXNoKGIpO1xuICAgIGlmICghYikgdGhpcy5nbC5kaXNhYmxlKHRoaXMuZ2wuQkxFTkQpO1xuICAgIGVsc2UgdGhpcy5nbC5lbmFibGUodGhpcy5nbC5CTEVORCk7XG59O1xuXG4vKipcbiAqIHBvcCBibGVuZCBzdGF0ZSBhbmQgc2V0IHRoZSBwcmV2aW91cyBzdGF0ZVxuICogQGZ1bmN0aW9uIHBvcEJsZW5kXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnBvcEJsZW5kID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9zdGFja0JsZW5kLnBvcCgpO1xuXG4gICAgaWYgKCF0aGlzLl9zdGFja0JsZW5kW3RoaXMuX3N0YWNrQmxlbmQubGVuZ3RoIC0gMV0pIHRoaXMuZ2wuZGlzYWJsZSh0aGlzLmdsLkJMRU5EKTtcbiAgICBlbHNlIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQkxFTkQpO1xufTtcblxuLyoqXG4gKiBjdXJyZW50IHN0YXRlIG9mIGJsZW5kXG4gKiBAZnVuY3Rpb24gc3RhdGVCbGVuZFxuICogQHJldHVybnMge2Jvb2xlYW59IGJsZW5kaW5nIGVuYWJsZWQvZGlzYWJsZWRcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuc3RhdGVCbGVuZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrQmxlbmRbdGhpcy5fc3RhY2tCbGVuZC5sZW5ndGggLSAxXTtcbn07XG5cbmV4cG9ydCBjb25zdCBCTEVORFMgPSB7XG4gICAgXCJCTEVORF9OT05FXCI6IDAsXG4gICAgXCJCTEVORF9OT1JNQUxcIjogMSxcbiAgICBcIkJMRU5EX0FERFwiOiAyLFxuICAgIFwiQkxFTkRfU1VCXCI6IDMsXG4gICAgXCJCTEVORF9NVUxcIjogNCxcbn07XG5cbkNvbnRleHQucHJvdG90eXBlLl9zdGFja0JsZW5kTW9kZSA9IFtdO1xuQ29udGV4dC5wcm90b3R5cGUuX3N0YWNrQmxlbmRNb2RlUHJlbXVsID0gW107XG5cbi8qKlxuICogcHVzaCBhbmQgc3dpdGNoIHRvIHByZWRlZmluZWQgYmxlbmRtb2RlIChDT05TVEFOVFMuQkxFTkRfTU9ERVMuQkxFTkRfTk9ORSxDT05TVEFOVFMuQkxFTkRfTU9ERVMuQkxFTkRfTk9STUFMLENPTlNUQU5UUy5CTEVORF9NT0RFUy5CTEVORF9BREQsQ09OU1RBTlRTLkJMRU5EX01PREVTLkJMRU5EX1NVQixDT05TVEFOVFMuQkxFTkRfTU9ERVMuQkxFTkRfTVVMKVxuICogQGZ1bmN0aW9uIHB1c2hCbGVuZE1vZGVcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBibGVuZG1vZGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlbXVsdGlwbGllZCBtb2RlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnB1c2hCbGVuZE1vZGUgPSBmdW5jdGlvbiAoYmxlbmRNb2RlLCBwcmVtdWwpXG57XG4gICAgdGhpcy5fc3RhY2tCbGVuZE1vZGUucHVzaChibGVuZE1vZGUpO1xuICAgIHRoaXMuX3N0YWNrQmxlbmRNb2RlUHJlbXVsLnB1c2gocHJlbXVsKTtcblxuICAgIGNvbnN0IG4gPSB0aGlzLl9zdGFja0JsZW5kTW9kZS5sZW5ndGggLSAxO1xuXG4gICAgdGhpcy5wdXNoQmxlbmQodGhpcy5fc3RhY2tCbGVuZE1vZGVbbl0gIT09IENPTlNUQU5UUy5CTEVORF9NT0RFUy5CTEVORF9OT05FKTtcbiAgICB0aGlzLl9zZXRCbGVuZE1vZGUodGhpcy5fc3RhY2tCbGVuZE1vZGVbbl0sIHRoaXMuX3N0YWNrQmxlbmRNb2RlUHJlbXVsW25dKTtcbn07XG5cbi8qKlxuICogcG9wIHByZWRlZmluZWQgYmxlbmRtb2RlIC8gc3dpdGNoIGJhY2sgdG8gcHJldmlvdXMgYmxlbmRtb2RlXG4gKiBAZnVuY3Rpb24gcG9wQmxlbmRNb2RlXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnBvcEJsZW5kTW9kZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fc3RhY2tCbGVuZE1vZGUucG9wKCk7XG4gICAgdGhpcy5fc3RhY2tCbGVuZE1vZGVQcmVtdWwucG9wKCk7XG5cbiAgICBjb25zdCBuID0gdGhpcy5fc3RhY2tCbGVuZE1vZGUubGVuZ3RoIC0gMTtcblxuICAgIHRoaXMucG9wQmxlbmQodGhpcy5fc3RhY2tCbGVuZE1vZGVbbl0gIT09IENPTlNUQU5UUy5CTEVORF9NT0RFUy5CTEVORF9OT05FKTtcblxuICAgIGlmIChuID49IDApIHRoaXMuX3NldEJsZW5kTW9kZSh0aGlzLl9zdGFja0JsZW5kTW9kZVtuXSwgdGhpcy5fc3RhY2tCbGVuZE1vZGVQcmVtdWxbbl0pO1xufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc3RhdGUgc3RlbmNpbFxuXG5Db250ZXh0LnByb3RvdHlwZS5fc3RhY2tTdGVuY2lsID0gW107XG5cbi8qKlxuICogZW5hYmxlIC8gZGlzYWJsZSBzdGVuY2lsIHRlc3RpbmdcblxuKiBAZnVuY3Rpb24gcHVzaFN0ZW5jaWxcbiAqIEBtZW1iZXJvZiBDb250ZXh0XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnB1c2hTdGVuY2lsID0gZnVuY3Rpb24gKGIpXG57XG4gICAgdGhpcy5fc3RhY2tTdGVuY2lsLnB1c2goYik7XG4gICAgaWYgKCFiKSB0aGlzLmdsLmRpc2FibGUodGhpcy5nbC5TVEVOQ0lMX1RFU1QpO1xuICAgIGVsc2UgdGhpcy5nbC5lbmFibGUodGhpcy5nbC5TVEVOQ0lMX1RFU1QpO1xufTtcblxuLyoqXG4gKiBwb3Agc3RlbmNpbCB0ZXN0IHN0YXRlIGFuZCBzZXQgdGhlIHByZXZpb3VzIHN0YXRlXG4gKiBAZnVuY3Rpb24gcG9wU3RlbmNpbFxuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICovXG5Db250ZXh0LnByb3RvdHlwZS5wb3BTdGVuY2lsID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9zdGFja1N0ZW5jaWwucG9wKCk7XG5cbiAgICBpZiAoIXRoaXMuX3N0YWNrU3RlbmNpbFt0aGlzLl9zdGFja1N0ZW5jaWwubGVuZ3RoIC0gMV0pIHRoaXMuZ2wuZGlzYWJsZSh0aGlzLmdsLlNURU5DSUxfVEVTVCk7XG4gICAgZWxzZSB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLlNURU5DSUxfVEVTVCk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbkNvbnRleHQucHJvdG90eXBlLmdsR2V0QXR0cmliTG9jYXRpb24gPSBmdW5jdGlvbiAocHJvZywgbmFtZSlcbntcbiAgICBjb25zdCBsID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9nLCBuYW1lKTtcbiAgICAvLyBpZiAobCA9PSAtMSlcbiAgICAvLyB7XG4gICAgLy8gICAgIHRoaXMuX2xvZy53YXJuKFwiZ2V0IGF0dHIgbG9jIC0xIFwiLCBuYW1lKTtcbiAgICAvLyB9XG4gICAgcmV0dXJuIGw7XG59O1xuXG5cbi8qKlxuICogc2hvdWxkIGFuIG9wIG5vdyBkcmF3IGhlbHBlcm1lc2hlc1xuICogQGZ1bmN0aW9uIHNob3VsZERyYXdIZWxwZXJzXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnNob3VsZERyYXdIZWxwZXJzID0gZnVuY3Rpb24gKG9wKVxue1xuICAgIGlmICh0aGlzLmZyYW1lU3RvcmUuc2hhZG93UGFzcykgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghb3AucGF0Y2guaXNFZGl0b3JNb2RlKCkpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IGZiID0gdGhpcy5nZXRDdXJyZW50RnJhbWVCdWZmZXIoKTtcbiAgICBpZiAoZmIgJiYgZmIuZ2V0V2lkdGgpXG4gICAge1xuICAgICAgICBjb25zdCBmYnNob3VsZCA9IHRoaXMuY2FudmFzV2lkdGggLyB0aGlzLmNhbnZhc0hlaWdodCA9PSBmYi5nZXRXaWR0aCgpIC8gZmIuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIGlmICghZmJzaG91bGQpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gQ0FCTEVTLlVJLnJlbmRlckhlbHBlciB8fCAoQ0FCTEVTLlVJLnJlbmRlckhlbHBlckN1cnJlbnQgJiYgb3AuaXNDdXJyZW50VWlPcCgpKTtcbn07XG5cbkNvbnRleHQucHJvdG90eXBlLl9zZXRCbGVuZE1vZGUgPSBmdW5jdGlvbiAoYmxlbmRNb2RlLCBwcmVtdWwpXG57XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgaWYgKGJsZW5kTW9kZSA9PSBDT05TVEFOVFMuQkxFTkRfTU9ERVMuQkxFTkRfTk9ORSlcbiAgICB7XG4gICAgICAgIC8vIHRoaXMuZ2wuZGlzYWJsZSh0aGlzLmdsLkJMRU5EKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmxlbmRNb2RlID09IENPTlNUQU5UUy5CTEVORF9NT0RFUy5CTEVORF9BREQpXG4gICAge1xuICAgICAgICBpZiAocHJlbXVsKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREKTtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLk9ORSwgZ2wuT05FLCBnbC5PTkUsIGdsLk9ORSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uKGdsLkZVTkNfQUREKTtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYmxlbmRNb2RlID09IENPTlNUQU5UUy5CTEVORF9NT0RFUy5CTEVORF9TVUIpXG4gICAge1xuICAgICAgICBpZiAocHJlbXVsKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREKTtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLlpFUk8sIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbihnbC5GVU5DX0FERCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYmxlbmRNb2RlID09IENPTlNUQU5UUy5CTEVORF9NT0RFUy5CTEVORF9NVUwpXG4gICAge1xuICAgICAgICBpZiAocHJlbXVsKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREKTtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLlpFUk8sIGdsLlNSQ19DT0xPUiwgZ2wuWkVSTywgZ2wuU1JDX0FMUEhBKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb24oZ2wuRlVOQ19BREQpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlpFUk8sIGdsLlNSQ19DT0xPUik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYmxlbmRNb2RlID09IENPTlNUQU5UUy5CTEVORF9NT0RFUy5CTEVORF9OT1JNQUwpXG4gICAge1xuICAgICAgICBpZiAocHJlbXVsKVxuICAgICAgICB7XG4gICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREKTtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy5sb2coXCJzZXRibGVuZG1vZGU6IHVua25vd24gYmxlbmRtb2RlXCIpO1xuICAgIH1cbn07XG5cbkNvbnRleHQucHJvdG90eXBlLmNyZWF0ZU1lc2ggPSBmdW5jdGlvbiAoZ2VvbSwgb3B0aW9ucylcbntcbiAgICBpZiAoQ0FCTEVTLlVUSUxTLmlzTnVtZXJpYyhvcHRpb25zKSlvcHRpb25zID0geyBcImdsUHJpbWl0aXZlXCI6IG9wdGlvbnMgfTsgLy8gb2xkIGNvbnN0cnVjdG9yIGZhbGxiYWNrLi4uXG4gICAgcmV0dXJuIG5ldyBDR0wuTWVzaCh0aGlzLCBnZW9tLCBvcHRpb25zKTtcbn07XG5cblxuLyoqXG4gKiBzZXQgY3Vyc29yXG4gKiBAZnVuY3Rpb24gc2V0Q3Vyc29yXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gY3NzIGN1cnNvciBzdHJpbmdcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuc2V0Q3Vyc29yID0gZnVuY3Rpb24gKHN0cilcbntcbiAgICB0aGlzLl9jdXJzb3IgPSBzdHI7XG59O1xuXG4vKipcbiAqIGVuYWJsZSBhIHdlYmdsIGV4dGVuc2lvblxuICogQGZ1bmN0aW9uIGVuYWJsZUV4dGVuc2lvblxuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IGV4dGVuc2lvbiBuYW1lXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBleHRlbnNpb24gb2JqZWN0IG9yIG51bGxcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuZW5hYmxlRXh0ZW5zaW9uID0gZnVuY3Rpb24gKG5hbWUpXG57XG4gICAgaWYgKCF0aGlzLmdsKSByZXR1cm4gbnVsbDtcbiAgICAvLyBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgaWYgKHRoaXMuX2VuYWJsZWRFeHRlbnNpb25zLmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWRFeHRlbnNpb25zW25hbWVdO1xuICAgIH1cblxuICAgIGNvbnN0IG8gPSB0aGlzLmdsLmdldEV4dGVuc2lvbihuYW1lKTtcbiAgICB0aGlzLl9lbmFibGVkRXh0ZW5zaW9uc1tuYW1lXSA9IG87XG5cbiAgICBpZiAoIW8pXG4gICAgICAgIHRoaXMuX2xvZy53YXJuKFwiW2NnbF9zdGF0ZV0gZXh0ZW5zaW9uIG5vdCBhdmFpbGFibGUgXCIgKyBuYW1lKTtcbiAgICBlbHNlXG4gICAgICAgIHRoaXMuX2xvZy5sb2coXCJlbmFibGVkIGV4dGVuc2lvblwiLCBuYW1lKTtcblxuICAgIHJldHVybiBvO1xufTtcblxuXG5cblxuZXhwb3J0IHsgQ29udGV4dCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_state.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_texture.js":
/*!*************************************!*\
  !*** ./src/core/cgl/cgl_texture.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Texture\": () => (/* binding */ Texture)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n\n\n\n\n\nconst DEFAULT_TEXTURE_SIZE = 8;\n\n/**\n * A Texture\n * @external CGL\n * @namespace Texture\n * @constructor\n * @param {Context} cgl\n * @param {Object} [options]\n * @hideconstructor\n * @class\n * @example\n * // generate a 256x256 pixel texture of random colors\n * const size=256;\n * const data = new Uint8Array(size*size*4);\n *\n * for(var x=0;x<size*size*4;x++) data[ x*4+3]=255;\n *\n * const tex=new CGL.Texture(cgl);\n * tex.initFromData(data,size,size,CGL.Texture.FILTER_NEAREST,CGL.Texture.WRAP_REPEAT);\n */\nconst Texture = function (__cgl, options = {})\n{\n    if (!__cgl) throw new Error(\"no cgl\");\n    this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"cgl_texture\");\n    this._cgl = __cgl;\n    this.pixelFormat = options.pixelFormat || Texture.PFORMATSTR_RGBA8UB;\n    this.tex = this._cgl.gl.createTexture();\n    this.id = CABLES.uuid();\n    this.width = 0;\n    this.height = 0;\n    this.loading = false;\n    this.flip = true;\n    this.flipped = false;\n    this.shadowMap = false;\n    this.deleted = false;\n    this.image = null;\n    this.anisotropic = 0;\n    this.filter = Texture.FILTER_NEAREST;\n    this.wrap = Texture.WRAP_CLAMP_TO_EDGE;\n    this.texTarget = this._cgl.gl.TEXTURE_2D;\n    if (options && options.type) this.texTarget = options.type;\n    this.textureType = Texture.TYPE_DEFAULT;\n    this.unpackAlpha = true;\n    this._fromData = true;\n    this.name = \"unknown\";\n\n    this._glDataType = -1;\n    this._glInternalFormat = -1;\n    this._glDataFormat = -1;\n\n\n    if (options)\n    {\n        this.name = options.name || this.name;\n        if (options.isDepthTexture)\n        {\n            this.textureType = Texture.TYPE_DEPTH;\n        }\n        if (options.isFloatingPointTexture === true) this.textureType = Texture.TYPE_FLOAT;\n\n        if (\"textureType\" in options) this.textureType = options.textureType;\n        if (\"filter\" in options) this.filter = options.filter;\n        if (\"wrap\" in options) this.wrap = options.wrap;\n        if (\"unpackAlpha\" in options) this.unpackAlpha = options.unpackAlpha;\n        if (\"flip\" in options) this.flip = options.flip;\n        if (\"shadowMap\" in options) this.shadowMap = options.shadowMap;\n        if (\"anisotropic\" in options) this.anisotropic = options.anisotropic;\n    }\n    else\n    {\n        options = {};\n    }\n\n    if (!options.pixelFormat && options.isFloatingPointTexture) this.pixelFormat = Texture.PFORMATSTR_RGBA32F;\n\n    if (this.textureType == Texture.TYPE_DEPTH) this.pixelFormat = Texture.PFORMATSTR_DEPTH;\n\n\n\n    if (!options.width) options.width = DEFAULT_TEXTURE_SIZE;\n    if (!options.height) options.height = DEFAULT_TEXTURE_SIZE;\n\n    this._cgl.profileData.profileTextureNew++;\n\n\n    this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));\n    this._cgl.profileData.addHeavyEvent(\"texture created\", this.name, options.width + \"x\" + options.height);\n\n    this.setSize(options.width, options.height);\n    this.getInfoOneLine();\n};\n\nTexture.prototype.isFloatingPoint = function ()\n{\n    return Texture.isPixelFormatFloat(this.pixelFormat);\n};\n\n/**\n * returns true if otherTexture has same options (width/height/filter/wrap etc)\n * @function compareSettings\n * @memberof Texture\n * @instance\n * @param {Texture} otherTexture\n * @returns {Boolean}\n */\nTexture.prototype.compareSettings = function (tex)\n{\n    // if (!tex) { this._log.warn(\"compare: no tex\"); return false; }\n    // if (tex.width != this.width) this._log.warn(\"tex.width not equal\", tex.width, this.width);\n    // if (tex.height != this.height) this._log.warn(\"tex.height not equal\", tex.height, this.height);\n    // if (tex.filter != this.filter) this._log.warn(\"tex.filter not equal\");\n    // if (tex.wrap != this.wrap) this._log.warn(\"tex.wrap not equal\");\n    // if (tex.textureType != this.textureType) this._log.warn(\"tex.textureType not equal\");\n    // if (tex.unpackAlpha != this.unpackAlpha) this._log.warn(\"tex.unpackAlpha not equal\");\n    // if (tex.anisotropic != this.anisotropic) this._log.warn(\"tex.anisotropic not equal\");\n    // if (tex.shadowMap != this.shadowMap) this._log.warn(\"tex.shadowMap not equal\");\n    // if (tex.texTarget != this.texTarget) this._log.warn(\"tex.texTarget not equal\");\n    // if (tex.flip != this.flip) this._log.warn(\"tex.flip not equal\");\n\n    if (!tex) return false;\n    return (\n        tex.width == this.width &&\n        tex.height == this.height &&\n        tex.filter == this.filter &&\n        tex.wrap == this.wrap &&\n        tex.textureType == this.textureType &&\n        tex.unpackAlpha == this.unpackAlpha &&\n        tex.anisotropic == this.anisotropic &&\n        tex.shadowMap == this.shadowMap &&\n        tex.texTarget == this.texTarget &&\n        tex.flip == this.flip\n    );\n};\n\n/**\n * returns a new texture with the same settings (does not copy texture itself)\n * @function clone\n * @memberof Texture\n * @instance\n * @returns {Texture}\n */\nTexture.prototype.clone = function ()\n{\n    const newTex = new Texture(this._cgl, {\n        \"name\": this.name,\n        \"filter\": this.filter,\n        \"anisotropic\": this.anisotropic,\n        \"wrap\": this.wrap,\n        \"textureType\": this.textureType,\n        \"pixelFormat\": this.pixelFormat,\n        \"unpackAlpha\": this.unpackAlpha,\n        \"flip\": this.flip,\n        \"width\": this.width,\n        \"height\": this.height,\n    });\n\n    this._cgl.profileData.addHeavyEvent(\"texture created\", this.name, this.width + \"x\" + this.height);\n\n    if (!this.compareSettings(newTex))\n    {\n        this._log.error(\"Cloned texture settings do not compare!\");\n        this._log.error(this);\n        this._log.error(newTex);\n    }\n\n    return newTex;\n};\n\n\nTexture.prototype.setFormat = function (o)\n{\n    this.pixelFormat = o.pixelFormat;\n    this._glDataFormat = o.glDataFormat;\n    this._glInternalFormat = o.glInternalFormat;\n    this._glDataType = o.glDataType;\n};\n\n\nTexture.setUpGlPixelFormat = function (cgl, pixelFormatStr)\n{\n    const o = {};\n\n    if (!pixelFormatStr)\n    {\n        console.log(\"no pixelformatstr!\");\n        console.log((new Error()).stack);\n        pixelFormatStr = Texture.PFORMATSTR_RGBA8UB;\n    }\n\n    o.pixelFormatBase = pixelFormatStr;\n\n\n    o.pixelFormat = pixelFormatStr;\n    o.glDataType = cgl.gl.UNSIGNED_BYTE;\n    o.glInternalFormat = cgl.gl.RGBA8;\n    o.glDataFormat = cgl.gl.RGBA;\n\n    let floatDatatype = cgl.gl.FLOAT;\n\n    if (cgl.glUseHalfFloatTex)\n    {\n        if (pixelFormatStr == Texture.PFORMATSTR_RGBA32F) pixelFormatStr = Texture.PFORMATSTR_RGBA16F;\n        if (pixelFormatStr == Texture.PFORMATSTR_RG32F) pixelFormatStr = Texture.PFORMATSTR_RG16F;\n        if (pixelFormatStr == Texture.PFORMATSTR_R32F) pixelFormatStr = Texture.PFORMATSTR_R16F;\n    }\n\n    if (pixelFormatStr.contains(\"16bit\"))\n    {\n        if (cgl.glVersion == 2)\n        {\n            // cgl.enableExtension(\"OES_texture_half_float\");\n            const hasExt = cgl.enableExtension(\"EXT_color_buffer_half_float\");\n\n            if (!hasExt)\n            {\n                console.warn(\"no 16bit extension, fallback to 32bit\");\n                // fallback to 32 bit?\n                if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F) pixelFormatStr = Texture.PFORMATSTR_RGBA32F;\n                if (pixelFormatStr == Texture.PFORMATSTR_RGB16F) pixelFormatStr = Texture.PFORMATSTR_RGB32F;\n                if (pixelFormatStr == Texture.PFORMATSTR_RG16F) pixelFormatStr = Texture.PFORMATSTR_RG32F;\n                if (pixelFormatStr == Texture.PFORMATSTR_R16F) pixelFormatStr = Texture.PFORMATSTR_R32F;\n            }\n            else\n            {\n                floatDatatype = cgl.gl.HALF_FLOAT;\n            }\n        }\n    }\n\n    if (cgl.glVersion == 1)\n    {\n        o.glInternalFormat = cgl.gl.RGBA;\n\n        if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F || pixelFormatStr == Texture.PFORMATSTR_RG16F || pixelFormatStr == Texture.PFORMATSTR_R16F)\n        {\n            const ext = cgl.enableExtension(\"OES_texture_half_float\");\n            if (!ext) throw new Error(\"no half float texture extension\");\n\n            floatDatatype = ext.HALF_FLOAT_OES;\n        }\n    }\n\n\n\n\n\n    if (pixelFormatStr == Texture.PFORMATSTR_RGBA8UB)\n    {\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_RGB565)\n    {\n        o.glInternalFormat = cgl.gl.RGB565;\n        o.glDataFormat = cgl.gl.RGB;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_R8UB)\n    {\n        o.glInternalFormat = cgl.gl.R8;\n        o.glDataFormat = cgl.gl.RED;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_RG8UB)\n    {\n        o.glInternalFormat = cgl.gl.RG8;\n        o.glDataFormat = cgl.gl.RG;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_RGB8UB)\n    {\n        o.glInternalFormat = cgl.gl.RGB8;\n        o.glDataFormat = cgl.gl.RGB;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_SRGBA8)\n    {\n        o.glInternalFormat = cgl.gl.SRGB8_ALPHA8;\n    }\n\n    else if (pixelFormatStr == Texture.PFORMATSTR_R32F)\n    {\n        o.glInternalFormat = cgl.gl.R32F;\n        o.glDataFormat = cgl.gl.RED;\n        o.glDataType = floatDatatype;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_R16F)\n    {\n        o.glInternalFormat = cgl.gl.R16F;\n        o.glDataType = floatDatatype;\n        o.glDataFormat = cgl.gl.RED;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_RG16F)\n    {\n        o.glInternalFormat = cgl.gl.RG16F;\n        o.glDataType = floatDatatype;\n        o.glDataFormat = cgl.gl.RG;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_RGBA16F)\n    {\n        if (cgl.glVersion == 1) o.glInternalFormat = cgl.gl.RGBA;\n        else o.glInternalFormat = cgl.gl.RGBA16F;\n        o.glDataType = floatDatatype;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_R11FG11FB10F)\n    {\n        o.glInternalFormat = cgl.gl.R11F_G11F_B10F;\n        o.glDataType = floatDatatype;\n        o.glDataFormat = cgl.gl.RGB;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_RGBA32F)\n    {\n        if (cgl.glVersion == 1) o.glInternalFormat = cgl.gl.RGBA;\n        else o.glInternalFormat = cgl.gl.RGBA32F;\n        o.glDataType = floatDatatype;\n    }\n    else if (pixelFormatStr == Texture.PFORMATSTR_DEPTH)\n    {\n        if (cgl.glVersion == 1)\n        {\n            o.glInternalFormat = cgl.gl.DEPTH_COMPONENT;\n            o.glDataType = cgl.gl.UNSIGNED_SHORT;\n            o.glDataFormat = cgl.gl.DEPTH_COMPONENT;\n        }\n        else\n        {\n            o.glInternalFormat = cgl.gl.DEPTH_COMPONENT32F;\n            o.glDataType = cgl.gl.FLOAT;\n            o.glDataFormat = cgl.gl.DEPTH_COMPONENT;\n        }\n    }\n    else\n    {\n        console.log(\"unknown pixelformat \", pixelFormatStr);\n    }\n\n    /// //////\n\n    if (pixelFormatStr.contains(\"32bit\") || pixelFormatStr == Texture.PFORMATSTR_R11FG11FB10F)\n    {\n        if (cgl.glVersion == 2) cgl.enableExtension(\"EXT_color_buffer_float\");\n        if (cgl.glVersion == 2) cgl.enableExtension(\"EXT_float_blend\");\n\n        cgl.enableExtension(\"OES_texture_float_linear\"); // yes, i am sure, this is a webgl 1 and 2 ext\n    }\n\n\n    o.numColorChannels = 1;\n    if (pixelFormatStr.startsWith(\"R\"))o.numColorChannels = 1;\n    if (pixelFormatStr.startsWith(\"RG\"))o.numColorChannels = 2;\n    if (pixelFormatStr.startsWith(\"RGB\"))o.numColorChannels = 3;\n    if (pixelFormatStr.startsWith(\"RGBA\"))o.numColorChannels = 4;\n\n\n    // console.log(pixelFormatStr, this.name);\n\n    if (!o.glDataType || !o.glInternalFormat || !o.glDataFormat) console.log(\"pixelformat wrong ?!\", pixelFormatStr, o.glDataType, o.glInternalFormat, o.glDataFormat, this);\n\n    return o;\n};\n\n/**\n * set pixel size of texture\n * @function setSize\n * @memberof Texture\n * @instance\n * @param {Number} width\n * @param {Number} height\n */\nTexture.prototype.setSize = function (w, h)\n{\n    if (this._cgl.aborted) return;\n    if (w != w || w <= 0 || !w) w = DEFAULT_TEXTURE_SIZE;\n    if (h != h || h <= 0 || !h) h = DEFAULT_TEXTURE_SIZE;\n\n    if (w > this._cgl.maxTexSize || h > this._cgl.maxTexSize) this._log.error(\"texture size too big! \" + w + \"x\" + h + \" / max: \" + this._cgl.maxTexSize);\n\n    w = Math.min(w, this._cgl.maxTexSize);\n    h = Math.min(h, this._cgl.maxTexSize);\n\n    w = Math.floor(w);\n    h = Math.floor(h);\n    if (this.width == w && this.height == h) return;\n\n    // console.log(\"tex setsize\", this.name, w, h, this.id);\n\n    this.width = w;\n    this.height = h;\n    this.deleted = false;\n\n\n    this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));\n\n\n    this.shortInfoString = this.getInfoOneLine();// w + \"x\" + h + \"\";\n    // if (this.textureType == Texture.TYPE_FLOAT) this.shortInfoString += \" Float\";\n\n    // if (this._cgl.printError(\"cgltex before\"))\n    // {\n    //     this.printInfo();\n    //     console.log((new Error()).stack);\n    // }\n\n    this._cgl.gl.bindTexture(this.texTarget, this.tex);\n    this._cgl.profileData.profileTextureResize++;\n\n    const uarr = null;\n\n\n    // if (\n    //     this._cgl.glVersion == 1 &&\n    //     this.textureType == Texture.TYPE_FLOAT && this.filter == Texture.FILTER_LINEAR &&\n    //     (!this._cgl.enableExtension(\"OES_texture_float_linear\"))\n    // )\n    // {\n    //     console.warn(\"this graphics card does not support floating point texture linear interpolation! using NEAREST\");\n    //     this.filter = Texture.FILTER_NEAREST;\n    // }\n\n\n    // else\n    // {\n    //     dataType = this._cgl.gl.UNSIGNED_BYTE;\n    //     internalFormat = this._cgl.gl.RGBA;\n    //     dataFormat = this._cgl.gl.RGBA;\n    //     // this._cgl.gl.texImage2D(this.texTarget, 0, this._cgl.gl.RGBA, w, h, 0, this._cgl.gl.RGBA, this._cgl.gl.UNSIGNED_BYTE, uarr);\n    // }\n\n    this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, w, h, 0, this._glDataFormat, this._glDataType, uarr);\n\n    this._setFilter();\n\n    // if (this._cgl.printError(\"cgltex\"))\n    // {\n    //     this.printInfo();\n    //     console.log((new Error()).stack);\n    // }\n\n    this.updateMipMap();\n\n    this._cgl.gl.bindTexture(this.texTarget, null);\n};\n\n\n\n/**\n * @function initFromData\n * @memberof Texture\n * @instance\n * @description create texturem from rgb data\n * @param {Array<Number>} data rgb color array [r,g,b,a,r,g,b,a,...]\n * @param {Number} width\n * @param {Number} height\n * @param {Number} filter\n * @param {Number} wrap\n */\nTexture.prototype.initFromData = function (data, w, h, filter, wrap)\n{\n    this.filter = filter;\n    this.wrap = wrap;\n    if (filter == undefined) this.filter = Texture.FILTER_LINEAR;\n    if (wrap == undefined) this.wrap = Texture.WRAP_CLAMP_TO_EDGE;\n    this.width = w;\n    this.height = h;\n    this._fromData = true;\n    this.deleted = false;\n\n    if (this.height > this._cgl.maxTexSize || this.width > this._cgl.maxTexSize)\n    {\n        const t = CGL.Texture.getTempTexture(this._cgl);\n        this.width = t.width;\n        this.height = t.height;\n        this.tex = t.tex;\n        this._log.error(\"[cgl_texture] texture size to big!!!\", this.width, this.height, this._cgl.maxTexSize);\n        return;\n    }\n\n    if (this.flip) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flip);\n\n    this._cgl.gl.bindTexture(this.texTarget, this.tex);\n\n    this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));\n\n    this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, w, h, 0, this._glDataFormat, this._glDataType, data);\n\n    this._setFilter();\n    this.updateMipMap();\n\n    if (this.flip) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, false);\n    this._cgl.gl.bindTexture(this.texTarget, null);\n};\n\nTexture.prototype.updateMipMap = function ()\n{\n    if ((this._cgl.glVersion == 2 || this.isPowerOfTwo()) && this.filter == Texture.FILTER_MIPMAP)\n    {\n        this._cgl.gl.generateMipmap(this.texTarget);\n        this._cgl.profileData.profileGenMipMap++;\n    }\n};\n\n/**\n * set texture data from an image/canvas object\n * @function initTexture\n * @memberof Texture\n * @instance\n * @param {Object} image\n * @param {Number} filter\n */\nTexture.prototype.initTexture = function (img, filter)\n{\n    this._cgl.printError(\"before initTexture\");\n    this._cgl.checkFrameStarted(\"texture inittexture\");\n    this._fromData = false;\n\n    this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.unpackAlpha);\n    if (img.width) this.width = img.width;\n    if (img.height) this.height = img.height;\n\n    if (filter !== undefined) this.filter = filter; // todo: can we remove this filter param?\n\n    if (img.height > this._cgl.maxTexSize || img.width > this._cgl.maxTexSize)\n    {\n        const t = CGL.Texture.getTempTexture(this._cgl);\n        this.width = t.width;\n        this.height = t.height;\n        this.tex = t.tex;\n        this._log.error(\"[cgl_texture] texture size to big!!!\", img.width, img.height, this._cgl.maxTexSize);\n        return;\n    }\n\n\n    // console.log(\"loaded texture\", img.width, img.height);\n\n    this._cgl.gl.bindTexture(this.texTarget, this.tex);\n\n    this.deleted = false;\n    this.flipped = !this.flip;\n    if (this.flipped) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, this.flipped);\n\n\n    this.setFormat(Texture.setUpGlPixelFormat(this._cgl, this.pixelFormat));\n\n    this._cgl.gl.texImage2D(this.texTarget, 0, this._glInternalFormat, this._glDataFormat, this._glDataType, img);\n    // this._cgl.gl.texImage2D(this.texTarget, 0, this._cgl.gl.RGBA, this._cgl.gl.RGBA, this._cgl.gl.UNSIGNED_BYTE, img);\n\n    // if (this._cgl.printError(\"[cgl_texture] init \" + this.name));\n\n    this._setFilter();\n    this.updateMipMap();\n\n    // if (this._cgl.printError(\"[cgl_texture] init2\"));\n\n    this._cgl.gl.bindTexture(this.texTarget, null);\n    this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    if (this.flipped) this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_FLIP_Y_WEBGL, false);\n\n    this.getInfoOneLine();\n    this._cgl.printError(\"initTexture\");\n};\n\n/**\n * delete texture. use this when texture is no longer needed\n * @function delete\n * @memberof Texture\n * @instance\n */\nTexture.prototype.dispose =\nTexture.prototype.delete = function ()\n{\n    if (this.loading)\n    {\n        // cant delete texture when still loading\n        // setTimeout(this.delete.bind(this), 50);\n        return;\n    }\n\n    this.deleted = true;\n    this.width = 0;\n    this.height = 0;\n    this._cgl.profileData.profileTextureDelete++;\n    this._cgl.gl.deleteTexture(this.tex);\n    this.image = null;\n\n    this.tex = null;\n};\n\n/**\n * @function isPowerOfTwo\n * @memberof Texture\n * @instance\n * @description return true if texture width and height are both power of two\n * @return {Boolean}\n */\nTexture.prototype.isPowerOfTwo = function ()\n{\n    return Texture.isPowerOfTwo(this.width) && Texture.isPowerOfTwo(this.height);\n};\n\nTexture.prototype.printInfo = function ()\n{\n    console.log(this.getInfo());\n};\n\nTexture.prototype.getInfoReadable = function ()\n{\n    const info = this.getInfo();\n    let html = \"\";\n\n    info.name = info.name.substr(0, info.name.indexOf(\"?rnd=\"));\n\n    for (const i in info)\n    {\n        html += \"* \" + i + \":  **\" + info[i] + \"**\\n\";\n    }\n\n    return html;\n};\n\nTexture.prototype.getInfoOneLine = function ()\n{\n    let txt = \"\" + this.width + \"x\" + this.height;\n    txt += \" \";\n    // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += \" 32bit\"; else txt += \" 8bit\";\n    // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += \" 32bit\"; else txt += \" 8bit\";\n    txt += this.pixelFormat;\n\n    if (this.filter === CGL.Texture.FILTER_NEAREST) txt += \" nearest\";\n    if (this.filter === CGL.Texture.FILTER_LINEAR) txt += \" linear\";\n    if (this.filter === CGL.Texture.FILTER_MIPMAP) txt += \" mipmap\";\n\n    if (this.wrap === CGL.Texture.WRAP_CLAMP_TO_EDGE) txt += \" clamp\";\n    if (this.wrap === CGL.Texture.WRAP_REPEAT) txt += \" repeat\";\n    if (this.wrap === CGL.Texture.WRAP_MIRRORED_REPEAT) txt += \" repeatmir\";\n\n    this.shortInfoString = txt;\n\n    return txt;\n};\n\nTexture.prototype.getInfoOneLineShort = function ()\n{\n    let txt = \"\" + this.width + \"x\" + this.height;\n    // if (this.textureType === CGL.Texture.TYPE_FLOAT) txt += \" 32bit\"; else txt += \" 8bit\";\n    txt += \" \";\n    txt += this.pixelFormat;\n\n    this.shortInfoString = txt;\n\n    return txt;\n};\n\n\nTexture.prototype.getInfo = function ()\n{\n    return Texture.getTexInfo(this);\n};\n\n\nTexture.prototype._setFilter = function ()\n{\n    this._cgl.printError(\"before _setFilter\");\n\n    if (!this._fromData)\n    {\n        this._cgl.gl.pixelStorei(this._cgl.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.unpackAlpha);\n    }\n\n    if (this.shadowMap)\n    {\n        this._cgl.gl.texParameteri(this._cgl.gl.TEXTURE_2D, this._cgl.gl.TEXTURE_COMPARE_MODE, this._cgl.gl.COMPARE_REF_TO_TEXTURE);\n        this._cgl.gl.texParameteri(this._cgl.gl.TEXTURE_2D, this._cgl.gl.TEXTURE_COMPARE_FUNC, this._cgl.gl.LEQUAL);\n    }\n\n    if (this.textureType == Texture.TYPE_FLOAT && this.filter == Texture.FILTER_MIPMAP)\n    {\n        this.filter = Texture.FILTER_LINEAR;\n        this._log.stack(\"texture: HDR and mipmap filtering at the same time is not possible\");\n    }\n\n    if (this._cgl.glVersion == 1 && !this.isPowerOfTwo())\n    {\n        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.NEAREST);\n        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.NEAREST);\n\n        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.CLAMP_TO_EDGE);\n        this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.CLAMP_TO_EDGE);\n\n        this.filter = Texture.FILTER_NEAREST;\n        this.wrap = Texture.WRAP_CLAMP_TO_EDGE;\n    }\n    else\n    {\n        if (this.wrap == Texture.WRAP_CLAMP_TO_EDGE)\n        {\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.CLAMP_TO_EDGE);\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.CLAMP_TO_EDGE);\n        }\n        else if (this.wrap == Texture.WRAP_REPEAT)\n        {\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.REPEAT);\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.REPEAT);\n        }\n        else if (this.wrap == Texture.WRAP_MIRRORED_REPEAT)\n        {\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_S, this._cgl.gl.MIRRORED_REPEAT);\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_WRAP_T, this._cgl.gl.MIRRORED_REPEAT);\n        }\n\n        if (this.filter == Texture.FILTER_NEAREST)\n        {\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.NEAREST);\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.NEAREST);\n        }\n        else if (this.filter == Texture.FILTER_LINEAR)\n        {\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.LINEAR);\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.LINEAR);\n        }\n        else if (this.filter == Texture.FILTER_MIPMAP)\n        {\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MAG_FILTER, this._cgl.gl.LINEAR);\n            this._cgl.gl.texParameteri(this.texTarget, this._cgl.gl.TEXTURE_MIN_FILTER, this._cgl.gl.LINEAR_MIPMAP_LINEAR);\n        }\n        else\n        {\n            this._log.log(\"unknown texture filter!\", this.filter);\n            throw new Error(\"unknown texture filter!\" + this.filter);\n        }\n\n        if (this.anisotropic)\n        {\n            const ext = this._cgl.enableExtension(\"EXT_texture_filter_anisotropic\");\n\n\n\n            if (this._cgl.maxAnisotropic)\n            {\n                const aniso = Math.min(this._cgl.maxAnisotropic, this.anisotropic);\n                this._cgl.gl.texParameterf(this._cgl.gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, aniso);\n            }\n        }\n    }\n    this.getInfoOneLine();\n    this._cgl.printError(\"_setFilter\");\n};\n\n\n/**\n * @function load\n * @static\n * @memberof Texture\n * @description load an image from an url\n * @param {Context} cgl\n * @param {String} url\n * @param {Function} onFinished\n * @param {Object} options\n * @return {Texture}\n */\nTexture.load = function (cgl, url, finishedCallback, settings)\n{\n    if (!url) return finishedCallback({ \"error\": true });\n    let loadingId = null;\n    if (!cgl.patch.loading.existByName(url)) loadingId = cgl.patch.loading.start(\"texture\", url);\n\n    const texture = new Texture(cgl);\n    texture.name = url;\n\n    // texture.pixelFormat = Texture.PFORMATSTR_;\n\n    if (cgl.patch.isEditorMode()) gui.jobs().start({ \"id\": \"loadtexture\" + loadingId, \"title\": \"loading texture \" + CABLES.basename(url) });\n\n    texture.image = new Image();\n    texture.image.crossOrigin = \"anonymous\";\n    texture.loading = true;\n\n    if (settings && settings.hasOwnProperty(\"filter\")) texture.filter = settings.filter;\n    if (settings && settings.hasOwnProperty(\"flip\")) texture.flip = settings.flip;\n    if (settings && settings.hasOwnProperty(\"wrap\")) texture.wrap = settings.wrap;\n    if (settings && settings.hasOwnProperty(\"anisotropic\")) texture.anisotropic = settings.anisotropic;\n    if (settings && settings.hasOwnProperty(\"unpackAlpha\")) texture.unpackAlpha = settings.unpackAlpha;\n    if (settings && settings.hasOwnProperty(\"pixelFormat\")) texture.pixelFormat = settings.pixelFormat;\n\n    texture.image.onabort = texture.image.onerror = (e) =>\n    {\n        console.warn(\"[cgl.texture.load] error loading texture\", url, e);\n        texture.loading = false;\n        if (loadingId) cgl.patch.loading.finished(loadingId);\n        const error = { \"error\": true };\n        if (finishedCallback) finishedCallback(error, texture);\n        if (cgl.patch.isEditorMode()) gui.jobs().finish(\"loadtexture\" + loadingId);\n    };\n\n    texture.image.onload = function (e)\n    {\n        cgl.addNextFrameOnceCallback(() =>\n        {\n            texture.initTexture(texture.image);\n            if (loadingId) cgl.patch.loading.finished(loadingId);\n            texture.loading = false;\n            if (cgl.patch.isEditorMode()) gui.jobs().finish(\"loadtexture\" + loadingId);\n\n            if (finishedCallback) finishedCallback(null, texture);\n        });\n    };\n    texture.image.src = url;\n\n    return texture;\n};\n\n/**\n * @static\n * @function getTempTexture\n * @memberof Texture\n * @description returns the default temporary texture (grey diagonal stipes)\n * @param {Context} cgl\n * @return {Texture}\n */\nTexture.getTempTexture = function (cgl)\n{\n    if (!cgl) console.error(\"[getTempTexture] no cgl!\");\n    if (!cgl.tempTexture) cgl.tempTexture = Texture.getTemporaryTexture(cgl, 256, Texture.FILTER_LINEAR, Texture.REPEAT);\n    return cgl.tempTexture;\n};\n\n/**\n * @static\n * @function getErrorTexture\n * @memberof Texture\n * @description returns the default temporary texture (grey diagonal stipes)\n * @param {Context} cgl\n * @return {Texture}\n */\nTexture.getErrorTexture = function (cgl)\n{\n    if (!cgl) console.error(\"[getTempTexture] no cgl!\");\n    if (!cgl.errorTexture) cgl.errorTexture = Texture.getTemporaryTexture(cgl, 256, Texture.FILTER_LINEAR, Texture.REPEAT, 1, 0.2, 0.2);\n    return cgl.errorTexture;\n};\n\n\n/**\n * @function getEmptyTexture\n * @memberof Texture\n * @instance\n * @description returns a reference to a small empty (transparent) texture\n * @return {Texture}\n */\nTexture.getEmptyTexture = function (cgl, fp)\n{\n    if (fp) return Texture.getEmptyTextureFloat(cgl);\n    if (!cgl) console.error(\"[getEmptyTexture] no cgl!\");\n    if (cgl.tempTextureEmpty) return cgl.tempTextureEmpty;\n\n    cgl.tempTextureEmpty = new Texture(cgl, { \"name\": \"emptyTexture\" });\n    const data = new Uint8Array(8 * 8 * 4).fill(0);\n    for (let i = 0; i < 8 * 8 * 4; i += 4) data[i + 3] = 0;\n\n    cgl.tempTextureEmpty.initFromData(data, 8, 8, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);\n\n    return cgl.tempTextureEmpty;\n};\n\n/**\n * @function getEmptyTextureFloat\n * @memberof Texture\n * @instance\n * @description returns a reference to a small empty (transparent) 32bit texture\n * @return {Texture}\n */\nTexture.getEmptyTextureFloat = function (cgl)\n{\n    if (!cgl) console.error(\"[getEmptyTextureFloat] no cgl!\");\n    if (cgl.tempTextureEmptyFloat) return cgl.tempTextureEmptyFloat;\n\n    cgl.tempTextureEmptyFloat = new Texture(cgl, { \"name\": \"emptyTexture\", \"isFloatingPointTexture\": true });\n    const data = new Float32Array(8 * 8 * 4).fill(1);\n    for (let i = 0; i < 8 * 8 * 4; i += 4) data[i + 3] = 0;\n\n    cgl.tempTextureEmptyFloat.initFromData(data, 8, 8, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);\n\n    return cgl.tempTextureEmptyFloat;\n};\n\n\n/**\n * @function getRandomTexture\n * @memberof Texture\n * @static\n * @description returns a reference to a random texture\n * @return {Texture}\n */\nTexture.getRandomTexture = function (cgl)\n{\n    if (!cgl) console.error(\"[getRandomTexture] no cgl!\");\n    if (cgl.randomTexture) return cgl.randomTexture;\n\n    const size = 256;\n    const data = new Uint8Array(size * size * 4);\n\n    for (let x = 0; x < size * size; x++)\n    {\n        data[x * 4 + 0] = Math.random() * 255;\n        data[x * 4 + 1] = Math.random() * 255;\n        data[x * 4 + 2] = Math.random() * 255;\n        data[x * 4 + 3] = 255;\n    }\n\n    cgl.randomTexture = new Texture(cgl);\n    cgl.randomTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);\n\n    return cgl.randomTexture;\n};\n\n/**\n * @function getRandomFloatTexture\n * @memberof Texture\n * @static\n * @description returns a reference to a texture containing random numbers between -1 and 1\n * @return {Texture}\n */\nTexture.getRandomFloatTexture = function (cgl)\n{\n    if (!cgl) console.error(\"[getRandomTexture] no cgl!\");\n    if (cgl.getRandomFloatTexture) return cgl.getRandomFloatTexture;\n\n    const size = 256;\n    const data = new Float32Array(size * size * 4);\n\n    for (let x = 0; x < size * size; x++)\n    {\n        data[x * 4 + 0] = (Math.random() - 0.5) * 2.0;\n        data[x * 4 + 1] = (Math.random() - 0.5) * 2.0;\n        data[x * 4 + 2] = (Math.random() - 0.5) * 2.0;\n        data[x * 4 + 3] = 1;\n    }\n\n    cgl.getRandomFloatTexture = new Texture(cgl, { \"isFloatingPointTexture\": true });\n    cgl.getRandomFloatTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);\n\n    return cgl.getRandomFloatTexture;\n};\n\n/**\n * @function getBlackTexture\n * @memberof Texture\n * @static\n * @description returns a reference to a black texture\n * @return {Texture}\n */\nTexture.getBlackTexture = function (cgl)\n{\n    if (!cgl) this._log.error(\"[getBlackTexture] no cgl!\");\n    if (cgl.blackTexture) return cgl.blackTexture;\n\n    const size = 8;\n    const data = new Uint8Array(size * size * 4);\n\n    for (let x = 0; x < size * size; x++)\n    {\n        data[x * 4 + 0] = data[x * 4 + 1] = data[x * 4 + 2] = 0;\n        data[x * 4 + 3] = 255;\n    }\n\n    cgl.blackTexture = new Texture(cgl);\n    cgl.blackTexture.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);\n\n    return cgl.blackTexture;\n};\n\n\n/**\n * @function getEmptyCubemapTexture\n * @memberof Texture\n * @static\n * @description returns an empty cubemap texture with rgba = [0, 0, 0, 0]\n * @return {Texture}\n */\nTexture.getEmptyCubemapTexture = function (cgl)\n{\n    const faces = [\n        cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_X,\n        cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\n        cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\n        cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n        cgl.gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\n        cgl.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z\n    ];\n\n    const tex = cgl.gl.createTexture();\n    const target = cgl.gl.TEXTURE_CUBE_MAP;\n    const filter = Texture.FILTER_NEAREST;\n    const wrap = Texture.WRAP_CLAMP_TO_EDGE;\n    const width = 8;\n    const height = 8;\n\n    cgl.profileData.profileTextureNew++;\n\n\n    cgl.gl.bindTexture(target, tex);\n    cgl.profileData.profileTextureResize++;\n\n    for (let i = 0; i < 6; i += 1)\n    {\n        const data = new Uint8Array(8 * 8 * 4);\n\n        cgl.gl.texImage2D(faces[i], 0, cgl.gl.RGBA, 8, 8, 0, cgl.gl.RGBA, cgl.gl.UNSIGNED_BYTE, data);\n        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_MAG_FILTER, cgl.gl.NEAREST);\n        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_MIN_FILTER, cgl.gl.NEAREST);\n\n        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_WRAP_S, cgl.gl.CLAMP_TO_EDGE);\n        cgl.gl.texParameteri(target, cgl.gl.TEXTURE_WRAP_T, cgl.gl.CLAMP_TO_EDGE);\n    }\n\n\n    cgl.gl.bindTexture(target, null);\n\n    return {\n        \"id\": CABLES.uuid(),\n        \"tex\": tex,\n        \"cubemap\": tex,\n        \"width\": width,\n        \"height\": height,\n        \"filter\": filter,\n        \"wrap\": wrap,\n        \"unpackAlpha\": true,\n        \"flip\": true,\n        \"_fromData\": true,\n        \"name\": \"emptyCubemapTexture\",\n        \"anisotropic\": 0,\n    };\n};\n\n/**\n * @static\n * @function getTempGradientTexture\n * @memberof Texture\n * @description returns a gradient texture from black to white\n * @param {Context} cgl\n * @return {Texture}\n */\nTexture.getTempGradientTexture = function (cgl)\n{\n    if (!cgl) console.error(\"[getTempGradientTexture] no cgl!\");\n\n    if (cgl.tempTextureGradient) return cgl.tempTextureGradient;\n    const temptex = new Texture(cgl);\n    const size = 256;\n    const data = new Uint8Array(size * size * 4); // .fill(0);\n\n    for (let y = 0; y < size; y++)\n    {\n        for (let x = 0; x < size; x++)\n        {\n            data[(x + y * size) * 4 + 0] = data[(x + y * size) * 4 + 1] = data[(x + y * size) * 4 + 2] = 255 - y;\n            data[(x + y * size) * 4 + 3] = 255;\n        }\n    }\n\n    temptex.initFromData(data, size, size, Texture.FILTER_NEAREST, Texture.WRAP_REPEAT);\n    cgl.tempTextureGradient = temptex;\n    return temptex;\n};\n\nTexture.getTemporaryTexture = function (cgl, size, filter, wrap, r, g, b)\n{\n    if (r === undefined)r = 1;\n    if (g === undefined)g = 1;\n    if (b === undefined)b = 1;\n    const temptex = new Texture(cgl);\n    const arr = [];\n    for (let y = 0; y < size; y++)\n    {\n        for (let x = 0; x < size; x++)\n        {\n            if ((x + y) % 64 < 32)\n            {\n                arr.push((200 + (y / size) * 25 + (x / size) * 25) * r);\n                arr.push((200 + (y / size) * 25 + (x / size) * 25) * g);\n                arr.push((200 + (y / size) * 25 + (x / size) * 25) * b);\n            }\n            else\n            {\n                arr.push((40 + (y / size) * 25 + (x / size) * 25) * r);\n                arr.push((40 + (y / size) * 25 + (x / size) * 25) * g);\n                arr.push((40 + (y / size) * 25 + (x / size) * 25) * b);\n            }\n            arr.push(255);\n        }\n    }\n\n    const data = new Uint8Array(arr);\n    temptex.initFromData(data, size, size, filter, wrap);\n\n    return temptex;\n};\n\n/**\n * @static\n * @function createFromImage\n * @memberof Texture\n * @description create texturem from image data (e.g. image or canvas)\n * @param {Context} cgl\n * @param {Object} image\n * @param {Object} options\n */\nTexture.createFromImage = function (cgl, img, options)\n{\n    options = options || {};\n    const texture = new Texture(cgl, options);\n    texture.flip = false;\n    texture.image = img;\n    texture.width = img.width;\n    texture.height = img.height;\n    if (options.hasOwnProperty(\"wrap\"))texture.wrap = options.wrap;\n\n    console.log(\"createFromImage\", options);\n    texture.initTexture(img, options.filter);\n\n    return texture;\n};\n\n// deprecated!\nTexture.fromImage = function (cgl, img, filter, wrap)\n{\n    console.error(\"deprecated texture from image...\");\n\n    const texture = new Texture(cgl);\n    texture.flip = false;\n    if (filter) texture.filter = filter;\n    if (wrap) texture.wrap = wrap;\n    texture.image = img;\n    texture.initTexture(img);\n    return texture;\n};\n\n/**\n * @static\n * @function isPowerOfTwo\n * @memberof Texture\n * @description returns true if x is power of two\n * @param {Number} x\n * @return {Boolean}\n */\nTexture.isPowerOfTwo = function (x)\n{\n    return x == 1 || x == 2 || x == 4 || x == 8 || x == 16 || x == 32 || x == 64 || x == 128 || x == 256 || x == 512 || x == 1024 || x == 2048 || x == 4096 || x == 8192 || x == 16384;\n};\n\nTexture.getTexInfo = function (tex)\n{\n    const obj = {};\n\n    obj.name = tex.name;\n    obj[\"power of two\"] = tex.isPowerOfTwo();\n    obj.size = tex.width + \" x \" + tex.height;\n\n    let targetString = tex.texTarget;\n    if (tex.texTarget == tex._cgl.gl.TEXTURE_2D) targetString = \"TEXTURE_2D\";\n    obj.target = targetString;\n\n    obj.unpackAlpha = tex.unpackAlpha;\n\n    if (tex.cubemap)obj.cubemap = true;\n\n    if (tex.textureType == Texture.TYPE_FLOAT) obj.textureType = \"TYPE_FLOAT\";\n    if (tex.textureType == Texture.TYPE_HALF_FLOAT) obj.textureType = \"TYPE_HALF_FLOAT\";\n    else if (tex.textureType == Texture.TYPE_DEPTH) obj.textureType = \"TYPE_DEPTH\";\n    else if (tex.textureType == Texture.TYPE_DEFAULT) obj.textureType = \"TYPE_DEFAULT\";\n    else obj.textureType = \"UNKNOWN \" + this.textureType;\n\n    if (tex.wrap == Texture.WRAP_CLAMP_TO_EDGE) obj.wrap = \"CLAMP_TO_EDGE\";\n    else if (tex.wrap == Texture.WRAP_REPEAT) obj.wrap = \"WRAP_REPEAT\";\n    else if (tex.wrap == Texture.WRAP_MIRRORED_REPEAT) obj.wrap = \"WRAP_MIRRORED_REPEAT\";\n    else obj.wrap = \"UNKNOWN\";\n\n    if (tex.filter == Texture.FILTER_NEAREST) obj.filter = \"FILTER_NEAREST\";\n    else if (tex.filter == Texture.FILTER_LINEAR) obj.filter = \"FILTER_LINEAR\";\n    else if (tex.filter == Texture.FILTER_MIPMAP) obj.filter = \"FILTER_MIPMAP\";\n    else obj.filter = \"UNKNOWN\";\n\n    obj.pixelFormat = tex.pixelFormat || \"unknown\";\n\n    return obj;\n};\n\n\nTexture.FILTER_NEAREST = 0;\nTexture.FILTER_LINEAR = 1;\nTexture.FILTER_MIPMAP = 2;\n\nTexture.WRAP_REPEAT = 0;\nTexture.WRAP_MIRRORED_REPEAT = 1;\nTexture.WRAP_CLAMP_TO_EDGE = 2;\n\nTexture.TYPE_DEFAULT = 0;\nTexture.TYPE_DEPTH = 1;\nTexture.TYPE_FLOAT = 2;\n\n\nTexture.PFORMATSTR_RGB565 = \"RGB 5/6/5bit ubyte\";\n\nTexture.PFORMATSTR_R8UB = \"R 8bit ubyte\";\nTexture.PFORMATSTR_RG8UB = \"RG 8bit ubyte\";\nTexture.PFORMATSTR_RGB8UB = \"RGB 8bit ubyte\";\nTexture.PFORMATSTR_RGBA8UB = \"RGBA 8bit ubyte\";\n\nTexture.PFORMATSTR_SRGBA8 = \"SRGBA 8bit ubyte\";\n\nTexture.PFORMATSTR_R11FG11FB10F = \"RGB 11/11/10bit float\";\n\nTexture.PFORMATSTR_R16F = \"R 16bit float\";\nTexture.PFORMATSTR_RG16F = \"RG 16bit float\";\nTexture.PFORMATSTR_RGB16F = \"RGB 16bit float\";\nTexture.PFORMATSTR_RGBA16F = \"RGBA 16bit float\";\n\n\nTexture.PFORMATSTR_R32F = \"R 32bit float\";\nTexture.PFORMATSTR_RGBA32F = \"RGBA 32bit float\";\n\nTexture.PFORMATSTR_DEPTH = \"DEPTH\";\n\n\nTexture.PIXELFORMATS = [\n\n    Texture.PFORMATSTR_RGB565,\n\n    Texture.PFORMATSTR_R8UB,\n    Texture.PFORMATSTR_RG8UB,\n    Texture.PFORMATSTR_RGB8UB,\n    Texture.PFORMATSTR_RGBA8UB,\n\n    Texture.PFORMATSTR_SRGBA8,\n\n    Texture.PFORMATSTR_R11FG11FB10F,\n    Texture.PFORMATSTR_R16F,\n    Texture.PFORMATSTR_RG16F,\n    Texture.PFORMATSTR_RGBA16F,\n\n    Texture.PFORMATSTR_R32F,\n    Texture.PFORMATSTR_RGBA32F\n\n];\n\nTexture.isPixelFormatFloat =\n    (pxlfrmt) =>\n    {\n        return (pxlfrmt || \"\").contains(\"float\");\n    };\n\nTexture.isPixelFormatHalfFloat =\n    (pxlfrmt) =>\n    {\n        return (pxlfrmt || \"\").contains(\"float\") && (pxlfrmt || \"\").contains(\"16bit\");\n    };\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3RleHR1cmUuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnbC9jZ2xfdGV4dHVyZS5qcz8yMzgyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJjYWJsZXMtc2hhcmVkLWNsaWVudFwiO1xuaW1wb3J0IHsgdXVpZCB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuXG5cblxuY29uc3QgREVGQVVMVF9URVhUVVJFX1NJWkUgPSA4O1xuXG4vKipcbiAqIEEgVGV4dHVyZVxuICogQGV4dGVybmFsIENHTFxuICogQG5hbWVzcGFjZSBUZXh0dXJlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Q29udGV4dH0gY2dsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKiBAY2xhc3NcbiAqIEBleGFtcGxlXG4gKiAvLyBnZW5lcmF0ZSBhIDI1NngyNTYgcGl4ZWwgdGV4dHVyZSBvZiByYW5kb20gY29sb3JzXG4gKiBjb25zdCBzaXplPTI1NjtcbiAqIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShzaXplKnNpemUqNCk7XG4gKlxuICogZm9yKHZhciB4PTA7eDxzaXplKnNpemUqNDt4KyspIGRhdGFbIHgqNCszXT0yNTU7XG4gKlxuICogY29uc3QgdGV4PW5ldyBDR0wuVGV4dHVyZShjZ2wpO1xuICogdGV4LmluaXRGcm9tRGF0YShkYXRhLHNpemUsc2l6ZSxDR0wuVGV4dHVyZS5GSUxURVJfTkVBUkVTVCxDR0wuVGV4dHVyZS5XUkFQX1JFUEVBVCk7XG4gKi9cbmNvbnN0IFRleHR1cmUgPSBmdW5jdGlvbiAoX19jZ2wsIG9wdGlvbnMgPSB7fSlcbntcbiAgICBpZiAoIV9fY2dsKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBjZ2xcIik7XG4gICAgdGhpcy5fbG9nID0gbmV3IExvZ2dlcihcImNnbF90ZXh0dXJlXCIpO1xuICAgIHRoaXMuX2NnbCA9IF9fY2dsO1xuICAgIHRoaXMucGl4ZWxGb3JtYXQgPSBvcHRpb25zLnBpeGVsRm9ybWF0IHx8IFRleHR1cmUuUEZPUk1BVFNUUl9SR0JBOFVCO1xuICAgIHRoaXMudGV4ID0gdGhpcy5fY2dsLmdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICB0aGlzLmlkID0gQ0FCTEVTLnV1aWQoKTtcbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5mbGlwID0gdHJ1ZTtcbiAgICB0aGlzLmZsaXBwZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNoYWRvd01hcCA9IGZhbHNlO1xuICAgIHRoaXMuZGVsZXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW1hZ2UgPSBudWxsO1xuICAgIHRoaXMuYW5pc290cm9waWMgPSAwO1xuICAgIHRoaXMuZmlsdGVyID0gVGV4dHVyZS5GSUxURVJfTkVBUkVTVDtcbiAgICB0aGlzLndyYXAgPSBUZXh0dXJlLldSQVBfQ0xBTVBfVE9fRURHRTtcbiAgICB0aGlzLnRleFRhcmdldCA9IHRoaXMuX2NnbC5nbC5URVhUVVJFXzJEO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHlwZSkgdGhpcy50ZXhUYXJnZXQgPSBvcHRpb25zLnR5cGU7XG4gICAgdGhpcy50ZXh0dXJlVHlwZSA9IFRleHR1cmUuVFlQRV9ERUZBVUxUO1xuICAgIHRoaXMudW5wYWNrQWxwaGEgPSB0cnVlO1xuICAgIHRoaXMuX2Zyb21EYXRhID0gdHJ1ZTtcbiAgICB0aGlzLm5hbWUgPSBcInVua25vd25cIjtcblxuICAgIHRoaXMuX2dsRGF0YVR5cGUgPSAtMTtcbiAgICB0aGlzLl9nbEludGVybmFsRm9ybWF0ID0gLTE7XG4gICAgdGhpcy5fZ2xEYXRhRm9ybWF0ID0gLTE7XG5cblxuICAgIGlmIChvcHRpb25zKVxuICAgIHtcbiAgICAgICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IHRoaXMubmFtZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaXNEZXB0aFRleHR1cmUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZVR5cGUgPSBUZXh0dXJlLlRZUEVfREVQVEg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaXNGbG9hdGluZ1BvaW50VGV4dHVyZSA9PT0gdHJ1ZSkgdGhpcy50ZXh0dXJlVHlwZSA9IFRleHR1cmUuVFlQRV9GTE9BVDtcblxuICAgICAgICBpZiAoXCJ0ZXh0dXJlVHlwZVwiIGluIG9wdGlvbnMpIHRoaXMudGV4dHVyZVR5cGUgPSBvcHRpb25zLnRleHR1cmVUeXBlO1xuICAgICAgICBpZiAoXCJmaWx0ZXJcIiBpbiBvcHRpb25zKSB0aGlzLmZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBpZiAoXCJ3cmFwXCIgaW4gb3B0aW9ucykgdGhpcy53cmFwID0gb3B0aW9ucy53cmFwO1xuICAgICAgICBpZiAoXCJ1bnBhY2tBbHBoYVwiIGluIG9wdGlvbnMpIHRoaXMudW5wYWNrQWxwaGEgPSBvcHRpb25zLnVucGFja0FscGhhO1xuICAgICAgICBpZiAoXCJmbGlwXCIgaW4gb3B0aW9ucykgdGhpcy5mbGlwID0gb3B0aW9ucy5mbGlwO1xuICAgICAgICBpZiAoXCJzaGFkb3dNYXBcIiBpbiBvcHRpb25zKSB0aGlzLnNoYWRvd01hcCA9IG9wdGlvbnMuc2hhZG93TWFwO1xuICAgICAgICBpZiAoXCJhbmlzb3Ryb3BpY1wiIGluIG9wdGlvbnMpIHRoaXMuYW5pc290cm9waWMgPSBvcHRpb25zLmFuaXNvdHJvcGljO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnBpeGVsRm9ybWF0ICYmIG9wdGlvbnMuaXNGbG9hdGluZ1BvaW50VGV4dHVyZSkgdGhpcy5waXhlbEZvcm1hdCA9IFRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMzJGO1xuXG4gICAgaWYgKHRoaXMudGV4dHVyZVR5cGUgPT0gVGV4dHVyZS5UWVBFX0RFUFRIKSB0aGlzLnBpeGVsRm9ybWF0ID0gVGV4dHVyZS5QRk9STUFUU1RSX0RFUFRIO1xuXG5cblxuICAgIGlmICghb3B0aW9ucy53aWR0aCkgb3B0aW9ucy53aWR0aCA9IERFRkFVTFRfVEVYVFVSRV9TSVpFO1xuICAgIGlmICghb3B0aW9ucy5oZWlnaHQpIG9wdGlvbnMuaGVpZ2h0ID0gREVGQVVMVF9URVhUVVJFX1NJWkU7XG5cbiAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZVRleHR1cmVOZXcrKztcblxuXG4gICAgdGhpcy5zZXRGb3JtYXQoVGV4dHVyZS5zZXRVcEdsUGl4ZWxGb3JtYXQodGhpcy5fY2dsLCB0aGlzLnBpeGVsRm9ybWF0KSk7XG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLmFkZEhlYXZ5RXZlbnQoXCJ0ZXh0dXJlIGNyZWF0ZWRcIiwgdGhpcy5uYW1lLCBvcHRpb25zLndpZHRoICsgXCJ4XCIgKyBvcHRpb25zLmhlaWdodCk7XG5cbiAgICB0aGlzLnNldFNpemUob3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQpO1xuICAgIHRoaXMuZ2V0SW5mb09uZUxpbmUoKTtcbn07XG5cblRleHR1cmUucHJvdG90eXBlLmlzRmxvYXRpbmdQb2ludCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIFRleHR1cmUuaXNQaXhlbEZvcm1hdEZsb2F0KHRoaXMucGl4ZWxGb3JtYXQpO1xufTtcblxuLyoqXG4gKiByZXR1cm5zIHRydWUgaWYgb3RoZXJUZXh0dXJlIGhhcyBzYW1lIG9wdGlvbnMgKHdpZHRoL2hlaWdodC9maWx0ZXIvd3JhcCBldGMpXG4gKiBAZnVuY3Rpb24gY29tcGFyZVNldHRpbmdzXG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1RleHR1cmV9IG90aGVyVGV4dHVyZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblRleHR1cmUucHJvdG90eXBlLmNvbXBhcmVTZXR0aW5ncyA9IGZ1bmN0aW9uICh0ZXgpXG57XG4gICAgLy8gaWYgKCF0ZXgpIHsgdGhpcy5fbG9nLndhcm4oXCJjb21wYXJlOiBubyB0ZXhcIik7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIGlmICh0ZXgud2lkdGggIT0gdGhpcy53aWR0aCkgdGhpcy5fbG9nLndhcm4oXCJ0ZXgud2lkdGggbm90IGVxdWFsXCIsIHRleC53aWR0aCwgdGhpcy53aWR0aCk7XG4gICAgLy8gaWYgKHRleC5oZWlnaHQgIT0gdGhpcy5oZWlnaHQpIHRoaXMuX2xvZy53YXJuKFwidGV4LmhlaWdodCBub3QgZXF1YWxcIiwgdGV4LmhlaWdodCwgdGhpcy5oZWlnaHQpO1xuICAgIC8vIGlmICh0ZXguZmlsdGVyICE9IHRoaXMuZmlsdGVyKSB0aGlzLl9sb2cud2FybihcInRleC5maWx0ZXIgbm90IGVxdWFsXCIpO1xuICAgIC8vIGlmICh0ZXgud3JhcCAhPSB0aGlzLndyYXApIHRoaXMuX2xvZy53YXJuKFwidGV4LndyYXAgbm90IGVxdWFsXCIpO1xuICAgIC8vIGlmICh0ZXgudGV4dHVyZVR5cGUgIT0gdGhpcy50ZXh0dXJlVHlwZSkgdGhpcy5fbG9nLndhcm4oXCJ0ZXgudGV4dHVyZVR5cGUgbm90IGVxdWFsXCIpO1xuICAgIC8vIGlmICh0ZXgudW5wYWNrQWxwaGEgIT0gdGhpcy51bnBhY2tBbHBoYSkgdGhpcy5fbG9nLndhcm4oXCJ0ZXgudW5wYWNrQWxwaGEgbm90IGVxdWFsXCIpO1xuICAgIC8vIGlmICh0ZXguYW5pc290cm9waWMgIT0gdGhpcy5hbmlzb3Ryb3BpYykgdGhpcy5fbG9nLndhcm4oXCJ0ZXguYW5pc290cm9waWMgbm90IGVxdWFsXCIpO1xuICAgIC8vIGlmICh0ZXguc2hhZG93TWFwICE9IHRoaXMuc2hhZG93TWFwKSB0aGlzLl9sb2cud2FybihcInRleC5zaGFkb3dNYXAgbm90IGVxdWFsXCIpO1xuICAgIC8vIGlmICh0ZXgudGV4VGFyZ2V0ICE9IHRoaXMudGV4VGFyZ2V0KSB0aGlzLl9sb2cud2FybihcInRleC50ZXhUYXJnZXQgbm90IGVxdWFsXCIpO1xuICAgIC8vIGlmICh0ZXguZmxpcCAhPSB0aGlzLmZsaXApIHRoaXMuX2xvZy53YXJuKFwidGV4LmZsaXAgbm90IGVxdWFsXCIpO1xuXG4gICAgaWYgKCF0ZXgpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKFxuICAgICAgICB0ZXgud2lkdGggPT0gdGhpcy53aWR0aCAmJlxuICAgICAgICB0ZXguaGVpZ2h0ID09IHRoaXMuaGVpZ2h0ICYmXG4gICAgICAgIHRleC5maWx0ZXIgPT0gdGhpcy5maWx0ZXIgJiZcbiAgICAgICAgdGV4LndyYXAgPT0gdGhpcy53cmFwICYmXG4gICAgICAgIHRleC50ZXh0dXJlVHlwZSA9PSB0aGlzLnRleHR1cmVUeXBlICYmXG4gICAgICAgIHRleC51bnBhY2tBbHBoYSA9PSB0aGlzLnVucGFja0FscGhhICYmXG4gICAgICAgIHRleC5hbmlzb3Ryb3BpYyA9PSB0aGlzLmFuaXNvdHJvcGljICYmXG4gICAgICAgIHRleC5zaGFkb3dNYXAgPT0gdGhpcy5zaGFkb3dNYXAgJiZcbiAgICAgICAgdGV4LnRleFRhcmdldCA9PSB0aGlzLnRleFRhcmdldCAmJlxuICAgICAgICB0ZXguZmxpcCA9PSB0aGlzLmZsaXBcbiAgICApO1xufTtcblxuLyoqXG4gKiByZXR1cm5zIGEgbmV3IHRleHR1cmUgd2l0aCB0aGUgc2FtZSBzZXR0aW5ncyAoZG9lcyBub3QgY29weSB0ZXh0dXJlIGl0c2VsZilcbiAqIEBmdW5jdGlvbiBjbG9uZVxuICogQG1lbWJlcm9mIFRleHR1cmVcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybnMge1RleHR1cmV9XG4gKi9cblRleHR1cmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKClcbntcbiAgICBjb25zdCBuZXdUZXggPSBuZXcgVGV4dHVyZSh0aGlzLl9jZ2wsIHtcbiAgICAgICAgXCJuYW1lXCI6IHRoaXMubmFtZSxcbiAgICAgICAgXCJmaWx0ZXJcIjogdGhpcy5maWx0ZXIsXG4gICAgICAgIFwiYW5pc290cm9waWNcIjogdGhpcy5hbmlzb3Ryb3BpYyxcbiAgICAgICAgXCJ3cmFwXCI6IHRoaXMud3JhcCxcbiAgICAgICAgXCJ0ZXh0dXJlVHlwZVwiOiB0aGlzLnRleHR1cmVUeXBlLFxuICAgICAgICBcInBpeGVsRm9ybWF0XCI6IHRoaXMucGl4ZWxGb3JtYXQsXG4gICAgICAgIFwidW5wYWNrQWxwaGFcIjogdGhpcy51bnBhY2tBbHBoYSxcbiAgICAgICAgXCJmbGlwXCI6IHRoaXMuZmxpcCxcbiAgICAgICAgXCJ3aWR0aFwiOiB0aGlzLndpZHRoLFxuICAgICAgICBcImhlaWdodFwiOiB0aGlzLmhlaWdodCxcbiAgICB9KTtcblxuICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5hZGRIZWF2eUV2ZW50KFwidGV4dHVyZSBjcmVhdGVkXCIsIHRoaXMubmFtZSwgdGhpcy53aWR0aCArIFwieFwiICsgdGhpcy5oZWlnaHQpO1xuXG4gICAgaWYgKCF0aGlzLmNvbXBhcmVTZXR0aW5ncyhuZXdUZXgpKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwiQ2xvbmVkIHRleHR1cmUgc2V0dGluZ3MgZG8gbm90IGNvbXBhcmUhXCIpO1xuICAgICAgICB0aGlzLl9sb2cuZXJyb3IodGhpcyk7XG4gICAgICAgIHRoaXMuX2xvZy5lcnJvcihuZXdUZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdUZXg7XG59O1xuXG5cblRleHR1cmUucHJvdG90eXBlLnNldEZvcm1hdCA9IGZ1bmN0aW9uIChvKVxue1xuICAgIHRoaXMucGl4ZWxGb3JtYXQgPSBvLnBpeGVsRm9ybWF0O1xuICAgIHRoaXMuX2dsRGF0YUZvcm1hdCA9IG8uZ2xEYXRhRm9ybWF0O1xuICAgIHRoaXMuX2dsSW50ZXJuYWxGb3JtYXQgPSBvLmdsSW50ZXJuYWxGb3JtYXQ7XG4gICAgdGhpcy5fZ2xEYXRhVHlwZSA9IG8uZ2xEYXRhVHlwZTtcbn07XG5cblxuVGV4dHVyZS5zZXRVcEdsUGl4ZWxGb3JtYXQgPSBmdW5jdGlvbiAoY2dsLCBwaXhlbEZvcm1hdFN0cilcbntcbiAgICBjb25zdCBvID0ge307XG5cbiAgICBpZiAoIXBpeGVsRm9ybWF0U3RyKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJubyBwaXhlbGZvcm1hdHN0ciFcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICBwaXhlbEZvcm1hdFN0ciA9IFRleHR1cmUuUEZPUk1BVFNUUl9SR0JBOFVCO1xuICAgIH1cblxuICAgIG8ucGl4ZWxGb3JtYXRCYXNlID0gcGl4ZWxGb3JtYXRTdHI7XG5cblxuICAgIG8ucGl4ZWxGb3JtYXQgPSBwaXhlbEZvcm1hdFN0cjtcbiAgICBvLmdsRGF0YVR5cGUgPSBjZ2wuZ2wuVU5TSUdORURfQllURTtcbiAgICBvLmdsSW50ZXJuYWxGb3JtYXQgPSBjZ2wuZ2wuUkdCQTg7XG4gICAgby5nbERhdGFGb3JtYXQgPSBjZ2wuZ2wuUkdCQTtcblxuICAgIGxldCBmbG9hdERhdGF0eXBlID0gY2dsLmdsLkZMT0FUO1xuXG4gICAgaWYgKGNnbC5nbFVzZUhhbGZGbG9hdFRleClcbiAgICB7XG4gICAgICAgIGlmIChwaXhlbEZvcm1hdFN0ciA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUkdCQTMyRikgcGl4ZWxGb3JtYXRTdHIgPSBUZXh0dXJlLlBGT1JNQVRTVFJfUkdCQTE2RjtcbiAgICAgICAgaWYgKHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9SRzMyRikgcGl4ZWxGb3JtYXRTdHIgPSBUZXh0dXJlLlBGT1JNQVRTVFJfUkcxNkY7XG4gICAgICAgIGlmIChwaXhlbEZvcm1hdFN0ciA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUjMyRikgcGl4ZWxGb3JtYXRTdHIgPSBUZXh0dXJlLlBGT1JNQVRTVFJfUjE2RjtcbiAgICB9XG5cbiAgICBpZiAocGl4ZWxGb3JtYXRTdHIuY29udGFpbnMoXCIxNmJpdFwiKSlcbiAgICB7XG4gICAgICAgIGlmIChjZ2wuZ2xWZXJzaW9uID09IDIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNnbC5lbmFibGVFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpO1xuICAgICAgICAgICAgY29uc3QgaGFzRXh0ID0gY2dsLmVuYWJsZUV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKTtcblxuICAgICAgICAgICAgaWYgKCFoYXNFeHQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwibm8gMTZiaXQgZXh0ZW5zaW9uLCBmYWxsYmFjayB0byAzMmJpdFwiKTtcbiAgICAgICAgICAgICAgICAvLyBmYWxsYmFjayB0byAzMiBiaXQ/XG4gICAgICAgICAgICAgICAgaWYgKHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMTZGKSBwaXhlbEZvcm1hdFN0ciA9IFRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMzJGO1xuICAgICAgICAgICAgICAgIGlmIChwaXhlbEZvcm1hdFN0ciA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUkdCMTZGKSBwaXhlbEZvcm1hdFN0ciA9IFRleHR1cmUuUEZPUk1BVFNUUl9SR0IzMkY7XG4gICAgICAgICAgICAgICAgaWYgKHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9SRzE2RikgcGl4ZWxGb3JtYXRTdHIgPSBUZXh0dXJlLlBGT1JNQVRTVFJfUkczMkY7XG4gICAgICAgICAgICAgICAgaWYgKHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9SMTZGKSBwaXhlbEZvcm1hdFN0ciA9IFRleHR1cmUuUEZPUk1BVFNUUl9SMzJGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZsb2F0RGF0YXR5cGUgPSBjZ2wuZ2wuSEFMRl9GTE9BVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjZ2wuZ2xWZXJzaW9uID09IDEpXG4gICAge1xuICAgICAgICBvLmdsSW50ZXJuYWxGb3JtYXQgPSBjZ2wuZ2wuUkdCQTtcblxuICAgICAgICBpZiAocGl4ZWxGb3JtYXRTdHIgPT0gVGV4dHVyZS5QRk9STUFUU1RSX1JHQkExNkYgfHwgcGl4ZWxGb3JtYXRTdHIgPT0gVGV4dHVyZS5QRk9STUFUU1RSX1JHMTZGIHx8IHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9SMTZGKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBleHQgPSBjZ2wuZW5hYmxlRXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKTtcbiAgICAgICAgICAgIGlmICghZXh0KSB0aHJvdyBuZXcgRXJyb3IoXCJubyBoYWxmIGZsb2F0IHRleHR1cmUgZXh0ZW5zaW9uXCIpO1xuXG4gICAgICAgICAgICBmbG9hdERhdGF0eXBlID0gZXh0LkhBTEZfRkxPQVRfT0VTO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxuXG5cbiAgICBpZiAocGl4ZWxGb3JtYXRTdHIgPT0gVGV4dHVyZS5QRk9STUFUU1RSX1JHQkE4VUIpXG4gICAge1xuICAgIH1cbiAgICBlbHNlIGlmIChwaXhlbEZvcm1hdFN0ciA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUkdCNTY1KVxuICAgIHtcbiAgICAgICAgby5nbEludGVybmFsRm9ybWF0ID0gY2dsLmdsLlJHQjU2NTtcbiAgICAgICAgby5nbERhdGFGb3JtYXQgPSBjZ2wuZ2wuUkdCO1xuICAgIH1cbiAgICBlbHNlIGlmIChwaXhlbEZvcm1hdFN0ciA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUjhVQilcbiAgICB7XG4gICAgICAgIG8uZ2xJbnRlcm5hbEZvcm1hdCA9IGNnbC5nbC5SODtcbiAgICAgICAgby5nbERhdGFGb3JtYXQgPSBjZ2wuZ2wuUkVEO1xuICAgIH1cbiAgICBlbHNlIGlmIChwaXhlbEZvcm1hdFN0ciA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUkc4VUIpXG4gICAge1xuICAgICAgICBvLmdsSW50ZXJuYWxGb3JtYXQgPSBjZ2wuZ2wuUkc4O1xuICAgICAgICBvLmdsRGF0YUZvcm1hdCA9IGNnbC5nbC5SRztcbiAgICB9XG4gICAgZWxzZSBpZiAocGl4ZWxGb3JtYXRTdHIgPT0gVGV4dHVyZS5QRk9STUFUU1RSX1JHQjhVQilcbiAgICB7XG4gICAgICAgIG8uZ2xJbnRlcm5hbEZvcm1hdCA9IGNnbC5nbC5SR0I4O1xuICAgICAgICBvLmdsRGF0YUZvcm1hdCA9IGNnbC5nbC5SR0I7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9TUkdCQTgpXG4gICAge1xuICAgICAgICBvLmdsSW50ZXJuYWxGb3JtYXQgPSBjZ2wuZ2wuU1JHQjhfQUxQSEE4O1xuICAgIH1cblxuICAgIGVsc2UgaWYgKHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9SMzJGKVxuICAgIHtcbiAgICAgICAgby5nbEludGVybmFsRm9ybWF0ID0gY2dsLmdsLlIzMkY7XG4gICAgICAgIG8uZ2xEYXRhRm9ybWF0ID0gY2dsLmdsLlJFRDtcbiAgICAgICAgby5nbERhdGFUeXBlID0gZmxvYXREYXRhdHlwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGl4ZWxGb3JtYXRTdHIgPT0gVGV4dHVyZS5QRk9STUFUU1RSX1IxNkYpXG4gICAge1xuICAgICAgICBvLmdsSW50ZXJuYWxGb3JtYXQgPSBjZ2wuZ2wuUjE2RjtcbiAgICAgICAgby5nbERhdGFUeXBlID0gZmxvYXREYXRhdHlwZTtcbiAgICAgICAgby5nbERhdGFGb3JtYXQgPSBjZ2wuZ2wuUkVEO1xuICAgIH1cbiAgICBlbHNlIGlmIChwaXhlbEZvcm1hdFN0ciA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUkcxNkYpXG4gICAge1xuICAgICAgICBvLmdsSW50ZXJuYWxGb3JtYXQgPSBjZ2wuZ2wuUkcxNkY7XG4gICAgICAgIG8uZ2xEYXRhVHlwZSA9IGZsb2F0RGF0YXR5cGU7XG4gICAgICAgIG8uZ2xEYXRhRm9ybWF0ID0gY2dsLmdsLlJHO1xuICAgIH1cbiAgICBlbHNlIGlmIChwaXhlbEZvcm1hdFN0ciA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUkdCQTE2RilcbiAgICB7XG4gICAgICAgIGlmIChjZ2wuZ2xWZXJzaW9uID09IDEpIG8uZ2xJbnRlcm5hbEZvcm1hdCA9IGNnbC5nbC5SR0JBO1xuICAgICAgICBlbHNlIG8uZ2xJbnRlcm5hbEZvcm1hdCA9IGNnbC5nbC5SR0JBMTZGO1xuICAgICAgICBvLmdsRGF0YVR5cGUgPSBmbG9hdERhdGF0eXBlO1xuICAgIH1cbiAgICBlbHNlIGlmIChwaXhlbEZvcm1hdFN0ciA9PSBUZXh0dXJlLlBGT1JNQVRTVFJfUjExRkcxMUZCMTBGKVxuICAgIHtcbiAgICAgICAgby5nbEludGVybmFsRm9ybWF0ID0gY2dsLmdsLlIxMUZfRzExRl9CMTBGO1xuICAgICAgICBvLmdsRGF0YVR5cGUgPSBmbG9hdERhdGF0eXBlO1xuICAgICAgICBvLmdsRGF0YUZvcm1hdCA9IGNnbC5nbC5SR0I7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMzJGKVxuICAgIHtcbiAgICAgICAgaWYgKGNnbC5nbFZlcnNpb24gPT0gMSkgby5nbEludGVybmFsRm9ybWF0ID0gY2dsLmdsLlJHQkE7XG4gICAgICAgIGVsc2Ugby5nbEludGVybmFsRm9ybWF0ID0gY2dsLmdsLlJHQkEzMkY7XG4gICAgICAgIG8uZ2xEYXRhVHlwZSA9IGZsb2F0RGF0YXR5cGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9ERVBUSClcbiAgICB7XG4gICAgICAgIGlmIChjZ2wuZ2xWZXJzaW9uID09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG8uZ2xJbnRlcm5hbEZvcm1hdCA9IGNnbC5nbC5ERVBUSF9DT01QT05FTlQ7XG4gICAgICAgICAgICBvLmdsRGF0YVR5cGUgPSBjZ2wuZ2wuVU5TSUdORURfU0hPUlQ7XG4gICAgICAgICAgICBvLmdsRGF0YUZvcm1hdCA9IGNnbC5nbC5ERVBUSF9DT01QT05FTlQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBvLmdsSW50ZXJuYWxGb3JtYXQgPSBjZ2wuZ2wuREVQVEhfQ09NUE9ORU5UMzJGO1xuICAgICAgICAgICAgby5nbERhdGFUeXBlID0gY2dsLmdsLkZMT0FUO1xuICAgICAgICAgICAgby5nbERhdGFGb3JtYXQgPSBjZ2wuZ2wuREVQVEhfQ09NUE9ORU5UO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwidW5rbm93biBwaXhlbGZvcm1hdCBcIiwgcGl4ZWxGb3JtYXRTdHIpO1xuICAgIH1cblxuICAgIC8vLyAvLy8vLy9cblxuICAgIGlmIChwaXhlbEZvcm1hdFN0ci5jb250YWlucyhcIjMyYml0XCIpIHx8IHBpeGVsRm9ybWF0U3RyID09IFRleHR1cmUuUEZPUk1BVFNUUl9SMTFGRzExRkIxMEYpXG4gICAge1xuICAgICAgICBpZiAoY2dsLmdsVmVyc2lvbiA9PSAyKSBjZ2wuZW5hYmxlRXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKTtcbiAgICAgICAgaWYgKGNnbC5nbFZlcnNpb24gPT0gMikgY2dsLmVuYWJsZUV4dGVuc2lvbihcIkVYVF9mbG9hdF9ibGVuZFwiKTtcblxuICAgICAgICBjZ2wuZW5hYmxlRXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXCIpOyAvLyB5ZXMsIGkgYW0gc3VyZSwgdGhpcyBpcyBhIHdlYmdsIDEgYW5kIDIgZXh0XG4gICAgfVxuXG5cbiAgICBvLm51bUNvbG9yQ2hhbm5lbHMgPSAxO1xuICAgIGlmIChwaXhlbEZvcm1hdFN0ci5zdGFydHNXaXRoKFwiUlwiKSlvLm51bUNvbG9yQ2hhbm5lbHMgPSAxO1xuICAgIGlmIChwaXhlbEZvcm1hdFN0ci5zdGFydHNXaXRoKFwiUkdcIikpby5udW1Db2xvckNoYW5uZWxzID0gMjtcbiAgICBpZiAocGl4ZWxGb3JtYXRTdHIuc3RhcnRzV2l0aChcIlJHQlwiKSlvLm51bUNvbG9yQ2hhbm5lbHMgPSAzO1xuICAgIGlmIChwaXhlbEZvcm1hdFN0ci5zdGFydHNXaXRoKFwiUkdCQVwiKSlvLm51bUNvbG9yQ2hhbm5lbHMgPSA0O1xuXG5cbiAgICAvLyBjb25zb2xlLmxvZyhwaXhlbEZvcm1hdFN0ciwgdGhpcy5uYW1lKTtcblxuICAgIGlmICghby5nbERhdGFUeXBlIHx8ICFvLmdsSW50ZXJuYWxGb3JtYXQgfHwgIW8uZ2xEYXRhRm9ybWF0KSBjb25zb2xlLmxvZyhcInBpeGVsZm9ybWF0IHdyb25nID8hXCIsIHBpeGVsRm9ybWF0U3RyLCBvLmdsRGF0YVR5cGUsIG8uZ2xJbnRlcm5hbEZvcm1hdCwgby5nbERhdGFGb3JtYXQsIHRoaXMpO1xuXG4gICAgcmV0dXJuIG87XG59O1xuXG4vKipcbiAqIHNldCBwaXhlbCBzaXplIG9mIHRleHR1cmVcbiAqIEBmdW5jdGlvbiBzZXRTaXplXG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uICh3LCBoKVxue1xuICAgIGlmICh0aGlzLl9jZ2wuYWJvcnRlZCkgcmV0dXJuO1xuICAgIGlmICh3ICE9IHcgfHwgdyA8PSAwIHx8ICF3KSB3ID0gREVGQVVMVF9URVhUVVJFX1NJWkU7XG4gICAgaWYgKGggIT0gaCB8fCBoIDw9IDAgfHwgIWgpIGggPSBERUZBVUxUX1RFWFRVUkVfU0laRTtcblxuICAgIGlmICh3ID4gdGhpcy5fY2dsLm1heFRleFNpemUgfHwgaCA+IHRoaXMuX2NnbC5tYXhUZXhTaXplKSB0aGlzLl9sb2cuZXJyb3IoXCJ0ZXh0dXJlIHNpemUgdG9vIGJpZyEgXCIgKyB3ICsgXCJ4XCIgKyBoICsgXCIgLyBtYXg6IFwiICsgdGhpcy5fY2dsLm1heFRleFNpemUpO1xuXG4gICAgdyA9IE1hdGgubWluKHcsIHRoaXMuX2NnbC5tYXhUZXhTaXplKTtcbiAgICBoID0gTWF0aC5taW4oaCwgdGhpcy5fY2dsLm1heFRleFNpemUpO1xuXG4gICAgdyA9IE1hdGguZmxvb3Iodyk7XG4gICAgaCA9IE1hdGguZmxvb3IoaCk7XG4gICAgaWYgKHRoaXMud2lkdGggPT0gdyAmJiB0aGlzLmhlaWdodCA9PSBoKSByZXR1cm47XG5cbiAgICAvLyBjb25zb2xlLmxvZyhcInRleCBzZXRzaXplXCIsIHRoaXMubmFtZSwgdywgaCwgdGhpcy5pZCk7XG5cbiAgICB0aGlzLndpZHRoID0gdztcbiAgICB0aGlzLmhlaWdodCA9IGg7XG4gICAgdGhpcy5kZWxldGVkID0gZmFsc2U7XG5cblxuICAgIHRoaXMuc2V0Rm9ybWF0KFRleHR1cmUuc2V0VXBHbFBpeGVsRm9ybWF0KHRoaXMuX2NnbCwgdGhpcy5waXhlbEZvcm1hdCkpO1xuXG5cbiAgICB0aGlzLnNob3J0SW5mb1N0cmluZyA9IHRoaXMuZ2V0SW5mb09uZUxpbmUoKTsvLyB3ICsgXCJ4XCIgKyBoICsgXCJcIjtcbiAgICAvLyBpZiAodGhpcy50ZXh0dXJlVHlwZSA9PSBUZXh0dXJlLlRZUEVfRkxPQVQpIHRoaXMuc2hvcnRJbmZvU3RyaW5nICs9IFwiIEZsb2F0XCI7XG5cbiAgICAvLyBpZiAodGhpcy5fY2dsLnByaW50RXJyb3IoXCJjZ2x0ZXggYmVmb3JlXCIpKVxuICAgIC8vIHtcbiAgICAvLyAgICAgdGhpcy5wcmludEluZm8oKTtcbiAgICAvLyAgICAgY29uc29sZS5sb2coKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgLy8gfVxuXG4gICAgdGhpcy5fY2dsLmdsLmJpbmRUZXh0dXJlKHRoaXMudGV4VGFyZ2V0LCB0aGlzLnRleCk7XG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVUZXh0dXJlUmVzaXplKys7XG5cbiAgICBjb25zdCB1YXJyID0gbnVsbDtcblxuXG4gICAgLy8gaWYgKFxuICAgIC8vICAgICB0aGlzLl9jZ2wuZ2xWZXJzaW9uID09IDEgJiZcbiAgICAvLyAgICAgdGhpcy50ZXh0dXJlVHlwZSA9PSBUZXh0dXJlLlRZUEVfRkxPQVQgJiYgdGhpcy5maWx0ZXIgPT0gVGV4dHVyZS5GSUxURVJfTElORUFSICYmXG4gICAgLy8gICAgICghdGhpcy5fY2dsLmVuYWJsZUV4dGVuc2lvbihcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiKSlcbiAgICAvLyApXG4gICAgLy8ge1xuICAgIC8vICAgICBjb25zb2xlLndhcm4oXCJ0aGlzIGdyYXBoaWNzIGNhcmQgZG9lcyBub3Qgc3VwcG9ydCBmbG9hdGluZyBwb2ludCB0ZXh0dXJlIGxpbmVhciBpbnRlcnBvbGF0aW9uISB1c2luZyBORUFSRVNUXCIpO1xuICAgIC8vICAgICB0aGlzLmZpbHRlciA9IFRleHR1cmUuRklMVEVSX05FQVJFU1Q7XG4gICAgLy8gfVxuXG5cbiAgICAvLyBlbHNlXG4gICAgLy8ge1xuICAgIC8vICAgICBkYXRhVHlwZSA9IHRoaXMuX2NnbC5nbC5VTlNJR05FRF9CWVRFO1xuICAgIC8vICAgICBpbnRlcm5hbEZvcm1hdCA9IHRoaXMuX2NnbC5nbC5SR0JBO1xuICAgIC8vICAgICBkYXRhRm9ybWF0ID0gdGhpcy5fY2dsLmdsLlJHQkE7XG4gICAgLy8gICAgIC8vIHRoaXMuX2NnbC5nbC50ZXhJbWFnZTJEKHRoaXMudGV4VGFyZ2V0LCAwLCB0aGlzLl9jZ2wuZ2wuUkdCQSwgdywgaCwgMCwgdGhpcy5fY2dsLmdsLlJHQkEsIHRoaXMuX2NnbC5nbC5VTlNJR05FRF9CWVRFLCB1YXJyKTtcbiAgICAvLyB9XG5cbiAgICB0aGlzLl9jZ2wuZ2wudGV4SW1hZ2UyRCh0aGlzLnRleFRhcmdldCwgMCwgdGhpcy5fZ2xJbnRlcm5hbEZvcm1hdCwgdywgaCwgMCwgdGhpcy5fZ2xEYXRhRm9ybWF0LCB0aGlzLl9nbERhdGFUeXBlLCB1YXJyKTtcblxuICAgIHRoaXMuX3NldEZpbHRlcigpO1xuXG4gICAgLy8gaWYgKHRoaXMuX2NnbC5wcmludEVycm9yKFwiY2dsdGV4XCIpKVxuICAgIC8vIHtcbiAgICAvLyAgICAgdGhpcy5wcmludEluZm8oKTtcbiAgICAvLyAgICAgY29uc29sZS5sb2coKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgLy8gfVxuXG4gICAgdGhpcy51cGRhdGVNaXBNYXAoKTtcblxuICAgIHRoaXMuX2NnbC5nbC5iaW5kVGV4dHVyZSh0aGlzLnRleFRhcmdldCwgbnVsbCk7XG59O1xuXG5cblxuLyoqXG4gKiBAZnVuY3Rpb24gaW5pdEZyb21EYXRhXG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gY3JlYXRlIHRleHR1cmVtIGZyb20gcmdiIGRhdGFcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gZGF0YSByZ2IgY29sb3IgYXJyYXkgW3IsZyxiLGEscixnLGIsYSwuLi5dXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBmaWx0ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3cmFwXG4gKi9cblRleHR1cmUucHJvdG90eXBlLmluaXRGcm9tRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCB3LCBoLCBmaWx0ZXIsIHdyYXApXG57XG4gICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgdGhpcy53cmFwID0gd3JhcDtcbiAgICBpZiAoZmlsdGVyID09IHVuZGVmaW5lZCkgdGhpcy5maWx0ZXIgPSBUZXh0dXJlLkZJTFRFUl9MSU5FQVI7XG4gICAgaWYgKHdyYXAgPT0gdW5kZWZpbmVkKSB0aGlzLndyYXAgPSBUZXh0dXJlLldSQVBfQ0xBTVBfVE9fRURHRTtcbiAgICB0aGlzLndpZHRoID0gdztcbiAgICB0aGlzLmhlaWdodCA9IGg7XG4gICAgdGhpcy5fZnJvbURhdGEgPSB0cnVlO1xuICAgIHRoaXMuZGVsZXRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuaGVpZ2h0ID4gdGhpcy5fY2dsLm1heFRleFNpemUgfHwgdGhpcy53aWR0aCA+IHRoaXMuX2NnbC5tYXhUZXhTaXplKVxuICAgIHtcbiAgICAgICAgY29uc3QgdCA9IENHTC5UZXh0dXJlLmdldFRlbXBUZXh0dXJlKHRoaXMuX2NnbCk7XG4gICAgICAgIHRoaXMud2lkdGggPSB0LndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHQuaGVpZ2h0O1xuICAgICAgICB0aGlzLnRleCA9IHQudGV4O1xuICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJbY2dsX3RleHR1cmVdIHRleHR1cmUgc2l6ZSB0byBiaWchISFcIiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuX2NnbC5tYXhUZXhTaXplKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZsaXApIHRoaXMuX2NnbC5nbC5waXhlbFN0b3JlaSh0aGlzLl9jZ2wuZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGhpcy5mbGlwKTtcblxuICAgIHRoaXMuX2NnbC5nbC5iaW5kVGV4dHVyZSh0aGlzLnRleFRhcmdldCwgdGhpcy50ZXgpO1xuXG4gICAgdGhpcy5zZXRGb3JtYXQoVGV4dHVyZS5zZXRVcEdsUGl4ZWxGb3JtYXQodGhpcy5fY2dsLCB0aGlzLnBpeGVsRm9ybWF0KSk7XG5cbiAgICB0aGlzLl9jZ2wuZ2wudGV4SW1hZ2UyRCh0aGlzLnRleFRhcmdldCwgMCwgdGhpcy5fZ2xJbnRlcm5hbEZvcm1hdCwgdywgaCwgMCwgdGhpcy5fZ2xEYXRhRm9ybWF0LCB0aGlzLl9nbERhdGFUeXBlLCBkYXRhKTtcblxuICAgIHRoaXMuX3NldEZpbHRlcigpO1xuICAgIHRoaXMudXBkYXRlTWlwTWFwKCk7XG5cbiAgICBpZiAodGhpcy5mbGlwKSB0aGlzLl9jZ2wuZ2wucGl4ZWxTdG9yZWkodGhpcy5fY2dsLmdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICB0aGlzLl9jZ2wuZ2wuYmluZFRleHR1cmUodGhpcy50ZXhUYXJnZXQsIG51bGwpO1xufTtcblxuVGV4dHVyZS5wcm90b3R5cGUudXBkYXRlTWlwTWFwID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoKHRoaXMuX2NnbC5nbFZlcnNpb24gPT0gMiB8fCB0aGlzLmlzUG93ZXJPZlR3bygpKSAmJiB0aGlzLmZpbHRlciA9PSBUZXh0dXJlLkZJTFRFUl9NSVBNQVApXG4gICAge1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuZ2VuZXJhdGVNaXBtYXAodGhpcy50ZXhUYXJnZXQpO1xuICAgICAgICB0aGlzLl9jZ2wucHJvZmlsZURhdGEucHJvZmlsZUdlbk1pcE1hcCsrO1xuICAgIH1cbn07XG5cbi8qKlxuICogc2V0IHRleHR1cmUgZGF0YSBmcm9tIGFuIGltYWdlL2NhbnZhcyBvYmplY3RcbiAqIEBmdW5jdGlvbiBpbml0VGV4dHVyZVxuICogQG1lbWJlcm9mIFRleHR1cmVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IGltYWdlXG4gKiBAcGFyYW0ge051bWJlcn0gZmlsdGVyXG4gKi9cblRleHR1cmUucHJvdG90eXBlLmluaXRUZXh0dXJlID0gZnVuY3Rpb24gKGltZywgZmlsdGVyKVxue1xuICAgIHRoaXMuX2NnbC5wcmludEVycm9yKFwiYmVmb3JlIGluaXRUZXh0dXJlXCIpO1xuICAgIHRoaXMuX2NnbC5jaGVja0ZyYW1lU3RhcnRlZChcInRleHR1cmUgaW5pdHRleHR1cmVcIik7XG4gICAgdGhpcy5fZnJvbURhdGEgPSBmYWxzZTtcblxuICAgIHRoaXMuX2NnbC5nbC5waXhlbFN0b3JlaSh0aGlzLl9jZ2wuZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0aGlzLnVucGFja0FscGhhKTtcbiAgICBpZiAoaW1nLndpZHRoKSB0aGlzLndpZHRoID0gaW1nLndpZHRoO1xuICAgIGlmIChpbWcuaGVpZ2h0KSB0aGlzLmhlaWdodCA9IGltZy5oZWlnaHQ7XG5cbiAgICBpZiAoZmlsdGVyICE9PSB1bmRlZmluZWQpIHRoaXMuZmlsdGVyID0gZmlsdGVyOyAvLyB0b2RvOiBjYW4gd2UgcmVtb3ZlIHRoaXMgZmlsdGVyIHBhcmFtP1xuXG4gICAgaWYgKGltZy5oZWlnaHQgPiB0aGlzLl9jZ2wubWF4VGV4U2l6ZSB8fCBpbWcud2lkdGggPiB0aGlzLl9jZ2wubWF4VGV4U2l6ZSlcbiAgICB7XG4gICAgICAgIGNvbnN0IHQgPSBDR0wuVGV4dHVyZS5nZXRUZW1wVGV4dHVyZSh0aGlzLl9jZ2wpO1xuICAgICAgICB0aGlzLndpZHRoID0gdC53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0LmhlaWdodDtcbiAgICAgICAgdGhpcy50ZXggPSB0LnRleDtcbiAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwiW2NnbF90ZXh0dXJlXSB0ZXh0dXJlIHNpemUgdG8gYmlnISEhXCIsIGltZy53aWR0aCwgaW1nLmhlaWdodCwgdGhpcy5fY2dsLm1heFRleFNpemUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICAvLyBjb25zb2xlLmxvZyhcImxvYWRlZCB0ZXh0dXJlXCIsIGltZy53aWR0aCwgaW1nLmhlaWdodCk7XG5cbiAgICB0aGlzLl9jZ2wuZ2wuYmluZFRleHR1cmUodGhpcy50ZXhUYXJnZXQsIHRoaXMudGV4KTtcblxuICAgIHRoaXMuZGVsZXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuZmxpcHBlZCA9ICF0aGlzLmZsaXA7XG4gICAgaWYgKHRoaXMuZmxpcHBlZCkgdGhpcy5fY2dsLmdsLnBpeGVsU3RvcmVpKHRoaXMuX2NnbC5nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0aGlzLmZsaXBwZWQpO1xuXG5cbiAgICB0aGlzLnNldEZvcm1hdChUZXh0dXJlLnNldFVwR2xQaXhlbEZvcm1hdCh0aGlzLl9jZ2wsIHRoaXMucGl4ZWxGb3JtYXQpKTtcblxuICAgIHRoaXMuX2NnbC5nbC50ZXhJbWFnZTJEKHRoaXMudGV4VGFyZ2V0LCAwLCB0aGlzLl9nbEludGVybmFsRm9ybWF0LCB0aGlzLl9nbERhdGFGb3JtYXQsIHRoaXMuX2dsRGF0YVR5cGUsIGltZyk7XG4gICAgLy8gdGhpcy5fY2dsLmdsLnRleEltYWdlMkQodGhpcy50ZXhUYXJnZXQsIDAsIHRoaXMuX2NnbC5nbC5SR0JBLCB0aGlzLl9jZ2wuZ2wuUkdCQSwgdGhpcy5fY2dsLmdsLlVOU0lHTkVEX0JZVEUsIGltZyk7XG5cbiAgICAvLyBpZiAodGhpcy5fY2dsLnByaW50RXJyb3IoXCJbY2dsX3RleHR1cmVdIGluaXQgXCIgKyB0aGlzLm5hbWUpKTtcblxuICAgIHRoaXMuX3NldEZpbHRlcigpO1xuICAgIHRoaXMudXBkYXRlTWlwTWFwKCk7XG5cbiAgICAvLyBpZiAodGhpcy5fY2dsLnByaW50RXJyb3IoXCJbY2dsX3RleHR1cmVdIGluaXQyXCIpKTtcblxuICAgIHRoaXMuX2NnbC5nbC5iaW5kVGV4dHVyZSh0aGlzLnRleFRhcmdldCwgbnVsbCk7XG4gICAgdGhpcy5fY2dsLmdsLnBpeGVsU3RvcmVpKHRoaXMuX2NnbC5nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGZhbHNlKTtcbiAgICBpZiAodGhpcy5mbGlwcGVkKSB0aGlzLl9jZ2wuZ2wucGl4ZWxTdG9yZWkodGhpcy5fY2dsLmdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcblxuICAgIHRoaXMuZ2V0SW5mb09uZUxpbmUoKTtcbiAgICB0aGlzLl9jZ2wucHJpbnRFcnJvcihcImluaXRUZXh0dXJlXCIpO1xufTtcblxuLyoqXG4gKiBkZWxldGUgdGV4dHVyZS4gdXNlIHRoaXMgd2hlbiB0ZXh0dXJlIGlzIG5vIGxvbmdlciBuZWVkZWRcbiAqIEBmdW5jdGlvbiBkZWxldGVcbiAqIEBtZW1iZXJvZiBUZXh0dXJlXG4gKiBAaW5zdGFuY2VcbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuZGlzcG9zZSA9XG5UZXh0dXJlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLmxvYWRpbmcpXG4gICAge1xuICAgICAgICAvLyBjYW50IGRlbGV0ZSB0ZXh0dXJlIHdoZW4gc3RpbGwgbG9hZGluZ1xuICAgICAgICAvLyBzZXRUaW1lb3V0KHRoaXMuZGVsZXRlLmJpbmQodGhpcyksIDUwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZGVsZXRlZCA9IHRydWU7XG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlVGV4dHVyZURlbGV0ZSsrO1xuICAgIHRoaXMuX2NnbC5nbC5kZWxldGVUZXh0dXJlKHRoaXMudGV4KTtcbiAgICB0aGlzLmltYWdlID0gbnVsbDtcblxuICAgIHRoaXMudGV4ID0gbnVsbDtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGlzUG93ZXJPZlR3b1xuICogQG1lbWJlcm9mIFRleHR1cmVcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIHJldHVybiB0cnVlIGlmIHRleHR1cmUgd2lkdGggYW5kIGhlaWdodCBhcmUgYm90aCBwb3dlciBvZiB0d29cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblRleHR1cmUucHJvdG90eXBlLmlzUG93ZXJPZlR3byA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIFRleHR1cmUuaXNQb3dlck9mVHdvKHRoaXMud2lkdGgpICYmIFRleHR1cmUuaXNQb3dlck9mVHdvKHRoaXMuaGVpZ2h0KTtcbn07XG5cblRleHR1cmUucHJvdG90eXBlLnByaW50SW5mbyA9IGZ1bmN0aW9uICgpXG57XG4gICAgY29uc29sZS5sb2codGhpcy5nZXRJbmZvKCkpO1xufTtcblxuVGV4dHVyZS5wcm90b3R5cGUuZ2V0SW5mb1JlYWRhYmxlID0gZnVuY3Rpb24gKClcbntcbiAgICBjb25zdCBpbmZvID0gdGhpcy5nZXRJbmZvKCk7XG4gICAgbGV0IGh0bWwgPSBcIlwiO1xuXG4gICAgaW5mby5uYW1lID0gaW5mby5uYW1lLnN1YnN0cigwLCBpbmZvLm5hbWUuaW5kZXhPZihcIj9ybmQ9XCIpKTtcblxuICAgIGZvciAoY29uc3QgaSBpbiBpbmZvKVxuICAgIHtcbiAgICAgICAgaHRtbCArPSBcIiogXCIgKyBpICsgXCI6ICAqKlwiICsgaW5mb1tpXSArIFwiKipcXG5cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbDtcbn07XG5cblRleHR1cmUucHJvdG90eXBlLmdldEluZm9PbmVMaW5lID0gZnVuY3Rpb24gKClcbntcbiAgICBsZXQgdHh0ID0gXCJcIiArIHRoaXMud2lkdGggKyBcInhcIiArIHRoaXMuaGVpZ2h0O1xuICAgIHR4dCArPSBcIiBcIjtcbiAgICAvLyBpZiAodGhpcy50ZXh0dXJlVHlwZSA9PT0gQ0dMLlRleHR1cmUuVFlQRV9GTE9BVCkgdHh0ICs9IFwiIDMyYml0XCI7IGVsc2UgdHh0ICs9IFwiIDhiaXRcIjtcbiAgICAvLyBpZiAodGhpcy50ZXh0dXJlVHlwZSA9PT0gQ0dMLlRleHR1cmUuVFlQRV9GTE9BVCkgdHh0ICs9IFwiIDMyYml0XCI7IGVsc2UgdHh0ICs9IFwiIDhiaXRcIjtcbiAgICB0eHQgKz0gdGhpcy5waXhlbEZvcm1hdDtcblxuICAgIGlmICh0aGlzLmZpbHRlciA9PT0gQ0dMLlRleHR1cmUuRklMVEVSX05FQVJFU1QpIHR4dCArPSBcIiBuZWFyZXN0XCI7XG4gICAgaWYgKHRoaXMuZmlsdGVyID09PSBDR0wuVGV4dHVyZS5GSUxURVJfTElORUFSKSB0eHQgKz0gXCIgbGluZWFyXCI7XG4gICAgaWYgKHRoaXMuZmlsdGVyID09PSBDR0wuVGV4dHVyZS5GSUxURVJfTUlQTUFQKSB0eHQgKz0gXCIgbWlwbWFwXCI7XG5cbiAgICBpZiAodGhpcy53cmFwID09PSBDR0wuVGV4dHVyZS5XUkFQX0NMQU1QX1RPX0VER0UpIHR4dCArPSBcIiBjbGFtcFwiO1xuICAgIGlmICh0aGlzLndyYXAgPT09IENHTC5UZXh0dXJlLldSQVBfUkVQRUFUKSB0eHQgKz0gXCIgcmVwZWF0XCI7XG4gICAgaWYgKHRoaXMud3JhcCA9PT0gQ0dMLlRleHR1cmUuV1JBUF9NSVJST1JFRF9SRVBFQVQpIHR4dCArPSBcIiByZXBlYXRtaXJcIjtcblxuICAgIHRoaXMuc2hvcnRJbmZvU3RyaW5nID0gdHh0O1xuXG4gICAgcmV0dXJuIHR4dDtcbn07XG5cblRleHR1cmUucHJvdG90eXBlLmdldEluZm9PbmVMaW5lU2hvcnQgPSBmdW5jdGlvbiAoKVxue1xuICAgIGxldCB0eHQgPSBcIlwiICsgdGhpcy53aWR0aCArIFwieFwiICsgdGhpcy5oZWlnaHQ7XG4gICAgLy8gaWYgKHRoaXMudGV4dHVyZVR5cGUgPT09IENHTC5UZXh0dXJlLlRZUEVfRkxPQVQpIHR4dCArPSBcIiAzMmJpdFwiOyBlbHNlIHR4dCArPSBcIiA4Yml0XCI7XG4gICAgdHh0ICs9IFwiIFwiO1xuICAgIHR4dCArPSB0aGlzLnBpeGVsRm9ybWF0O1xuXG4gICAgdGhpcy5zaG9ydEluZm9TdHJpbmcgPSB0eHQ7XG5cbiAgICByZXR1cm4gdHh0O1xufTtcblxuXG5UZXh0dXJlLnByb3RvdHlwZS5nZXRJbmZvID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gVGV4dHVyZS5nZXRUZXhJbmZvKHRoaXMpO1xufTtcblxuXG5UZXh0dXJlLnByb3RvdHlwZS5fc2V0RmlsdGVyID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9jZ2wucHJpbnRFcnJvcihcImJlZm9yZSBfc2V0RmlsdGVyXCIpO1xuXG4gICAgaWYgKCF0aGlzLl9mcm9tRGF0YSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5waXhlbFN0b3JlaSh0aGlzLl9jZ2wuZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0aGlzLnVucGFja0FscGhhKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zaGFkb3dNYXApXG4gICAge1xuICAgICAgICB0aGlzLl9jZ2wuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLl9jZ2wuZ2wuVEVYVFVSRV8yRCwgdGhpcy5fY2dsLmdsLlRFWFRVUkVfQ09NUEFSRV9NT0RFLCB0aGlzLl9jZ2wuZ2wuQ09NUEFSRV9SRUZfVE9fVEVYVFVSRSk7XG4gICAgICAgIHRoaXMuX2NnbC5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2NnbC5nbC5URVhUVVJFXzJELCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV9DT01QQVJFX0ZVTkMsIHRoaXMuX2NnbC5nbC5MRVFVQUwpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRleHR1cmVUeXBlID09IFRleHR1cmUuVFlQRV9GTE9BVCAmJiB0aGlzLmZpbHRlciA9PSBUZXh0dXJlLkZJTFRFUl9NSVBNQVApXG4gICAge1xuICAgICAgICB0aGlzLmZpbHRlciA9IFRleHR1cmUuRklMVEVSX0xJTkVBUjtcbiAgICAgICAgdGhpcy5fbG9nLnN0YWNrKFwidGV4dHVyZTogSERSIGFuZCBtaXBtYXAgZmlsdGVyaW5nIGF0IHRoZSBzYW1lIHRpbWUgaXMgbm90IHBvc3NpYmxlXCIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jZ2wuZ2xWZXJzaW9uID09IDEgJiYgIXRoaXMuaXNQb3dlck9mVHdvKCkpXG4gICAge1xuICAgICAgICB0aGlzLl9jZ2wuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleFRhcmdldCwgdGhpcy5fY2dsLmdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5fY2dsLmdsLk5FQVJFU1QpO1xuICAgICAgICB0aGlzLl9jZ2wuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleFRhcmdldCwgdGhpcy5fY2dsLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5fY2dsLmdsLk5FQVJFU1QpO1xuXG4gICAgICAgIHRoaXMuX2NnbC5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4VGFyZ2V0LCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuX2NnbC5nbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXhUYXJnZXQsIHRoaXMuX2NnbC5nbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5fY2dsLmdsLkNMQU1QX1RPX0VER0UpO1xuXG4gICAgICAgIHRoaXMuZmlsdGVyID0gVGV4dHVyZS5GSUxURVJfTkVBUkVTVDtcbiAgICAgICAgdGhpcy53cmFwID0gVGV4dHVyZS5XUkFQX0NMQU1QX1RPX0VER0U7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLndyYXAgPT0gVGV4dHVyZS5XUkFQX0NMQU1QX1RPX0VER0UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4VGFyZ2V0LCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuX2NnbC5nbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4VGFyZ2V0LCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuX2NnbC5nbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLndyYXAgPT0gVGV4dHVyZS5XUkFQX1JFUEVBVClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXhUYXJnZXQsIHRoaXMuX2NnbC5nbC5URVhUVVJFX1dSQVBfUywgdGhpcy5fY2dsLmdsLlJFUEVBVCk7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleFRhcmdldCwgdGhpcy5fY2dsLmdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLl9jZ2wuZ2wuUkVQRUFUKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLndyYXAgPT0gVGV4dHVyZS5XUkFQX01JUlJPUkVEX1JFUEVBVClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXhUYXJnZXQsIHRoaXMuX2NnbC5nbC5URVhUVVJFX1dSQVBfUywgdGhpcy5fY2dsLmdsLk1JUlJPUkVEX1JFUEVBVCk7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleFRhcmdldCwgdGhpcy5fY2dsLmdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLl9jZ2wuZ2wuTUlSUk9SRURfUkVQRUFUKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZpbHRlciA9PSBUZXh0dXJlLkZJTFRFUl9ORUFSRVNUKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleFRhcmdldCwgdGhpcy5fY2dsLmdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5fY2dsLmdsLk5FQVJFU1QpO1xuICAgICAgICAgICAgdGhpcy5fY2dsLmdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXhUYXJnZXQsIHRoaXMuX2NnbC5nbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuX2NnbC5nbC5ORUFSRVNUKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZpbHRlciA9PSBUZXh0dXJlLkZJTFRFUl9MSU5FQVIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4VGFyZ2V0LCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLl9jZ2wuZ2wuTElORUFSKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4VGFyZ2V0LCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLl9jZ2wuZ2wuTElORUFSKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZpbHRlciA9PSBUZXh0dXJlLkZJTFRFUl9NSVBNQVApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4VGFyZ2V0LCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLl9jZ2wuZ2wuTElORUFSKTtcbiAgICAgICAgICAgIHRoaXMuX2NnbC5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4VGFyZ2V0LCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLl9jZ2wuZ2wuTElORUFSX01JUE1BUF9MSU5FQVIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9nLmxvZyhcInVua25vd24gdGV4dHVyZSBmaWx0ZXIhXCIsIHRoaXMuZmlsdGVyKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdGV4dHVyZSBmaWx0ZXIhXCIgKyB0aGlzLmZpbHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbmlzb3Ryb3BpYylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZXh0ID0gdGhpcy5fY2dsLmVuYWJsZUV4dGVuc2lvbihcIkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKTtcblxuXG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9jZ2wubWF4QW5pc290cm9waWMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5pc28gPSBNYXRoLm1pbih0aGlzLl9jZ2wubWF4QW5pc290cm9waWMsIHRoaXMuYW5pc290cm9waWMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NnbC5nbC50ZXhQYXJhbWV0ZXJmKHRoaXMuX2NnbC5nbC5URVhUVVJFXzJELCBleHQuVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIGFuaXNvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmdldEluZm9PbmVMaW5lKCk7XG4gICAgdGhpcy5fY2dsLnByaW50RXJyb3IoXCJfc2V0RmlsdGVyXCIpO1xufTtcblxuXG4vKipcbiAqIEBmdW5jdGlvbiBsb2FkXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQGRlc2NyaXB0aW9uIGxvYWQgYW4gaW1hZ2UgZnJvbSBhbiB1cmxcbiAqIEBwYXJhbSB7Q29udGV4dH0gY2dsXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZpbmlzaGVkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7VGV4dHVyZX1cbiAqL1xuVGV4dHVyZS5sb2FkID0gZnVuY3Rpb24gKGNnbCwgdXJsLCBmaW5pc2hlZENhbGxiYWNrLCBzZXR0aW5ncylcbntcbiAgICBpZiAoIXVybCkgcmV0dXJuIGZpbmlzaGVkQ2FsbGJhY2soeyBcImVycm9yXCI6IHRydWUgfSk7XG4gICAgbGV0IGxvYWRpbmdJZCA9IG51bGw7XG4gICAgaWYgKCFjZ2wucGF0Y2gubG9hZGluZy5leGlzdEJ5TmFtZSh1cmwpKSBsb2FkaW5nSWQgPSBjZ2wucGF0Y2gubG9hZGluZy5zdGFydChcInRleHR1cmVcIiwgdXJsKTtcblxuICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZShjZ2wpO1xuICAgIHRleHR1cmUubmFtZSA9IHVybDtcblxuICAgIC8vIHRleHR1cmUucGl4ZWxGb3JtYXQgPSBUZXh0dXJlLlBGT1JNQVRTVFJfO1xuXG4gICAgaWYgKGNnbC5wYXRjaC5pc0VkaXRvck1vZGUoKSkgZ3VpLmpvYnMoKS5zdGFydCh7IFwiaWRcIjogXCJsb2FkdGV4dHVyZVwiICsgbG9hZGluZ0lkLCBcInRpdGxlXCI6IFwibG9hZGluZyB0ZXh0dXJlIFwiICsgQ0FCTEVTLmJhc2VuYW1lKHVybCkgfSk7XG5cbiAgICB0ZXh0dXJlLmltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgdGV4dHVyZS5pbWFnZS5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgdGV4dHVyZS5sb2FkaW5nID0gdHJ1ZTtcblxuICAgIGlmIChzZXR0aW5ncyAmJiBzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShcImZpbHRlclwiKSkgdGV4dHVyZS5maWx0ZXIgPSBzZXR0aW5ncy5maWx0ZXI7XG4gICAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzLmhhc093blByb3BlcnR5KFwiZmxpcFwiKSkgdGV4dHVyZS5mbGlwID0gc2V0dGluZ3MuZmxpcDtcbiAgICBpZiAoc2V0dGluZ3MgJiYgc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoXCJ3cmFwXCIpKSB0ZXh0dXJlLndyYXAgPSBzZXR0aW5ncy53cmFwO1xuICAgIGlmIChzZXR0aW5ncyAmJiBzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShcImFuaXNvdHJvcGljXCIpKSB0ZXh0dXJlLmFuaXNvdHJvcGljID0gc2V0dGluZ3MuYW5pc290cm9waWM7XG4gICAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzLmhhc093blByb3BlcnR5KFwidW5wYWNrQWxwaGFcIikpIHRleHR1cmUudW5wYWNrQWxwaGEgPSBzZXR0aW5ncy51bnBhY2tBbHBoYTtcbiAgICBpZiAoc2V0dGluZ3MgJiYgc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoXCJwaXhlbEZvcm1hdFwiKSkgdGV4dHVyZS5waXhlbEZvcm1hdCA9IHNldHRpbmdzLnBpeGVsRm9ybWF0O1xuXG4gICAgdGV4dHVyZS5pbWFnZS5vbmFib3J0ID0gdGV4dHVyZS5pbWFnZS5vbmVycm9yID0gKGUpID0+XG4gICAge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbY2dsLnRleHR1cmUubG9hZF0gZXJyb3IgbG9hZGluZyB0ZXh0dXJlXCIsIHVybCwgZSk7XG4gICAgICAgIHRleHR1cmUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAobG9hZGluZ0lkKSBjZ2wucGF0Y2gubG9hZGluZy5maW5pc2hlZChsb2FkaW5nSWQpO1xuICAgICAgICBjb25zdCBlcnJvciA9IHsgXCJlcnJvclwiOiB0cnVlIH07XG4gICAgICAgIGlmIChmaW5pc2hlZENhbGxiYWNrKSBmaW5pc2hlZENhbGxiYWNrKGVycm9yLCB0ZXh0dXJlKTtcbiAgICAgICAgaWYgKGNnbC5wYXRjaC5pc0VkaXRvck1vZGUoKSkgZ3VpLmpvYnMoKS5maW5pc2goXCJsb2FkdGV4dHVyZVwiICsgbG9hZGluZ0lkKTtcbiAgICB9O1xuXG4gICAgdGV4dHVyZS5pbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoZSlcbiAgICB7XG4gICAgICAgIGNnbC5hZGROZXh0RnJhbWVPbmNlQ2FsbGJhY2soKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGV4dHVyZS5pbml0VGV4dHVyZSh0ZXh0dXJlLmltYWdlKTtcbiAgICAgICAgICAgIGlmIChsb2FkaW5nSWQpIGNnbC5wYXRjaC5sb2FkaW5nLmZpbmlzaGVkKGxvYWRpbmdJZCk7XG4gICAgICAgICAgICB0ZXh0dXJlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjZ2wucGF0Y2guaXNFZGl0b3JNb2RlKCkpIGd1aS5qb2JzKCkuZmluaXNoKFwibG9hZHRleHR1cmVcIiArIGxvYWRpbmdJZCk7XG5cbiAgICAgICAgICAgIGlmIChmaW5pc2hlZENhbGxiYWNrKSBmaW5pc2hlZENhbGxiYWNrKG51bGwsIHRleHR1cmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRleHR1cmUuaW1hZ2Uuc3JjID0gdXJsO1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBmdW5jdGlvbiBnZXRUZW1wVGV4dHVyZVxuICogQG1lbWJlcm9mIFRleHR1cmVcbiAqIEBkZXNjcmlwdGlvbiByZXR1cm5zIHRoZSBkZWZhdWx0IHRlbXBvcmFyeSB0ZXh0dXJlIChncmV5IGRpYWdvbmFsIHN0aXBlcylcbiAqIEBwYXJhbSB7Q29udGV4dH0gY2dsXG4gKiBAcmV0dXJuIHtUZXh0dXJlfVxuICovXG5UZXh0dXJlLmdldFRlbXBUZXh0dXJlID0gZnVuY3Rpb24gKGNnbClcbntcbiAgICBpZiAoIWNnbCkgY29uc29sZS5lcnJvcihcIltnZXRUZW1wVGV4dHVyZV0gbm8gY2dsIVwiKTtcbiAgICBpZiAoIWNnbC50ZW1wVGV4dHVyZSkgY2dsLnRlbXBUZXh0dXJlID0gVGV4dHVyZS5nZXRUZW1wb3JhcnlUZXh0dXJlKGNnbCwgMjU2LCBUZXh0dXJlLkZJTFRFUl9MSU5FQVIsIFRleHR1cmUuUkVQRUFUKTtcbiAgICByZXR1cm4gY2dsLnRlbXBUZXh0dXJlO1xufTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAZnVuY3Rpb24gZ2V0RXJyb3JUZXh0dXJlXG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQGRlc2NyaXB0aW9uIHJldHVybnMgdGhlIGRlZmF1bHQgdGVtcG9yYXJ5IHRleHR1cmUgKGdyZXkgZGlhZ29uYWwgc3RpcGVzKVxuICogQHBhcmFtIHtDb250ZXh0fSBjZ2xcbiAqIEByZXR1cm4ge1RleHR1cmV9XG4gKi9cblRleHR1cmUuZ2V0RXJyb3JUZXh0dXJlID0gZnVuY3Rpb24gKGNnbClcbntcbiAgICBpZiAoIWNnbCkgY29uc29sZS5lcnJvcihcIltnZXRUZW1wVGV4dHVyZV0gbm8gY2dsIVwiKTtcbiAgICBpZiAoIWNnbC5lcnJvclRleHR1cmUpIGNnbC5lcnJvclRleHR1cmUgPSBUZXh0dXJlLmdldFRlbXBvcmFyeVRleHR1cmUoY2dsLCAyNTYsIFRleHR1cmUuRklMVEVSX0xJTkVBUiwgVGV4dHVyZS5SRVBFQVQsIDEsIDAuMiwgMC4yKTtcbiAgICByZXR1cm4gY2dsLmVycm9yVGV4dHVyZTtcbn07XG5cblxuLyoqXG4gKiBAZnVuY3Rpb24gZ2V0RW1wdHlUZXh0dXJlXG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gcmV0dXJucyBhIHJlZmVyZW5jZSB0byBhIHNtYWxsIGVtcHR5ICh0cmFuc3BhcmVudCkgdGV4dHVyZVxuICogQHJldHVybiB7VGV4dHVyZX1cbiAqL1xuVGV4dHVyZS5nZXRFbXB0eVRleHR1cmUgPSBmdW5jdGlvbiAoY2dsLCBmcClcbntcbiAgICBpZiAoZnApIHJldHVybiBUZXh0dXJlLmdldEVtcHR5VGV4dHVyZUZsb2F0KGNnbCk7XG4gICAgaWYgKCFjZ2wpIGNvbnNvbGUuZXJyb3IoXCJbZ2V0RW1wdHlUZXh0dXJlXSBubyBjZ2whXCIpO1xuICAgIGlmIChjZ2wudGVtcFRleHR1cmVFbXB0eSkgcmV0dXJuIGNnbC50ZW1wVGV4dHVyZUVtcHR5O1xuXG4gICAgY2dsLnRlbXBUZXh0dXJlRW1wdHkgPSBuZXcgVGV4dHVyZShjZ2wsIHsgXCJuYW1lXCI6IFwiZW1wdHlUZXh0dXJlXCIgfSk7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KDggKiA4ICogNCkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDggKiA4ICogNDsgaSArPSA0KSBkYXRhW2kgKyAzXSA9IDA7XG5cbiAgICBjZ2wudGVtcFRleHR1cmVFbXB0eS5pbml0RnJvbURhdGEoZGF0YSwgOCwgOCwgVGV4dHVyZS5GSUxURVJfTkVBUkVTVCwgVGV4dHVyZS5XUkFQX1JFUEVBVCk7XG5cbiAgICByZXR1cm4gY2dsLnRlbXBUZXh0dXJlRW1wdHk7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBnZXRFbXB0eVRleHR1cmVGbG9hdFxuICogQG1lbWJlcm9mIFRleHR1cmVcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIHJldHVybnMgYSByZWZlcmVuY2UgdG8gYSBzbWFsbCBlbXB0eSAodHJhbnNwYXJlbnQpIDMyYml0IHRleHR1cmVcbiAqIEByZXR1cm4ge1RleHR1cmV9XG4gKi9cblRleHR1cmUuZ2V0RW1wdHlUZXh0dXJlRmxvYXQgPSBmdW5jdGlvbiAoY2dsKVxue1xuICAgIGlmICghY2dsKSBjb25zb2xlLmVycm9yKFwiW2dldEVtcHR5VGV4dHVyZUZsb2F0XSBubyBjZ2whXCIpO1xuICAgIGlmIChjZ2wudGVtcFRleHR1cmVFbXB0eUZsb2F0KSByZXR1cm4gY2dsLnRlbXBUZXh0dXJlRW1wdHlGbG9hdDtcblxuICAgIGNnbC50ZW1wVGV4dHVyZUVtcHR5RmxvYXQgPSBuZXcgVGV4dHVyZShjZ2wsIHsgXCJuYW1lXCI6IFwiZW1wdHlUZXh0dXJlXCIsIFwiaXNGbG9hdGluZ1BvaW50VGV4dHVyZVwiOiB0cnVlIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDggKiA4ICogNCkuZmlsbCgxKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDggKiA4ICogNDsgaSArPSA0KSBkYXRhW2kgKyAzXSA9IDA7XG5cbiAgICBjZ2wudGVtcFRleHR1cmVFbXB0eUZsb2F0LmluaXRGcm9tRGF0YShkYXRhLCA4LCA4LCBUZXh0dXJlLkZJTFRFUl9ORUFSRVNULCBUZXh0dXJlLldSQVBfUkVQRUFUKTtcblxuICAgIHJldHVybiBjZ2wudGVtcFRleHR1cmVFbXB0eUZsb2F0O1xufTtcblxuXG4vKipcbiAqIEBmdW5jdGlvbiBnZXRSYW5kb21UZXh0dXJlXG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQHN0YXRpY1xuICogQGRlc2NyaXB0aW9uIHJldHVybnMgYSByZWZlcmVuY2UgdG8gYSByYW5kb20gdGV4dHVyZVxuICogQHJldHVybiB7VGV4dHVyZX1cbiAqL1xuVGV4dHVyZS5nZXRSYW5kb21UZXh0dXJlID0gZnVuY3Rpb24gKGNnbClcbntcbiAgICBpZiAoIWNnbCkgY29uc29sZS5lcnJvcihcIltnZXRSYW5kb21UZXh0dXJlXSBubyBjZ2whXCIpO1xuICAgIGlmIChjZ2wucmFuZG9tVGV4dHVyZSkgcmV0dXJuIGNnbC5yYW5kb21UZXh0dXJlO1xuXG4gICAgY29uc3Qgc2l6ZSA9IDI1NjtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSAqIHNpemUgKiA0KTtcblxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgc2l6ZSAqIHNpemU7IHgrKylcbiAgICB7XG4gICAgICAgIGRhdGFbeCAqIDQgKyAwXSA9IE1hdGgucmFuZG9tKCkgKiAyNTU7XG4gICAgICAgIGRhdGFbeCAqIDQgKyAxXSA9IE1hdGgucmFuZG9tKCkgKiAyNTU7XG4gICAgICAgIGRhdGFbeCAqIDQgKyAyXSA9IE1hdGgucmFuZG9tKCkgKiAyNTU7XG4gICAgICAgIGRhdGFbeCAqIDQgKyAzXSA9IDI1NTtcbiAgICB9XG5cbiAgICBjZ2wucmFuZG9tVGV4dHVyZSA9IG5ldyBUZXh0dXJlKGNnbCk7XG4gICAgY2dsLnJhbmRvbVRleHR1cmUuaW5pdEZyb21EYXRhKGRhdGEsIHNpemUsIHNpemUsIFRleHR1cmUuRklMVEVSX05FQVJFU1QsIFRleHR1cmUuV1JBUF9SRVBFQVQpO1xuXG4gICAgcmV0dXJuIGNnbC5yYW5kb21UZXh0dXJlO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gZ2V0UmFuZG9tRmxvYXRUZXh0dXJlXG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQHN0YXRpY1xuICogQGRlc2NyaXB0aW9uIHJldHVybnMgYSByZWZlcmVuY2UgdG8gYSB0ZXh0dXJlIGNvbnRhaW5pbmcgcmFuZG9tIG51bWJlcnMgYmV0d2VlbiAtMSBhbmQgMVxuICogQHJldHVybiB7VGV4dHVyZX1cbiAqL1xuVGV4dHVyZS5nZXRSYW5kb21GbG9hdFRleHR1cmUgPSBmdW5jdGlvbiAoY2dsKVxue1xuICAgIGlmICghY2dsKSBjb25zb2xlLmVycm9yKFwiW2dldFJhbmRvbVRleHR1cmVdIG5vIGNnbCFcIik7XG4gICAgaWYgKGNnbC5nZXRSYW5kb21GbG9hdFRleHR1cmUpIHJldHVybiBjZ2wuZ2V0UmFuZG9tRmxvYXRUZXh0dXJlO1xuXG4gICAgY29uc3Qgc2l6ZSA9IDI1NjtcbiAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShzaXplICogc2l6ZSAqIDQpO1xuXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCBzaXplICogc2l6ZTsgeCsrKVxuICAgIHtcbiAgICAgICAgZGF0YVt4ICogNCArIDBdID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMi4wO1xuICAgICAgICBkYXRhW3ggKiA0ICsgMV0gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLjA7XG4gICAgICAgIGRhdGFbeCAqIDQgKyAyXSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIuMDtcbiAgICAgICAgZGF0YVt4ICogNCArIDNdID0gMTtcbiAgICB9XG5cbiAgICBjZ2wuZ2V0UmFuZG9tRmxvYXRUZXh0dXJlID0gbmV3IFRleHR1cmUoY2dsLCB7IFwiaXNGbG9hdGluZ1BvaW50VGV4dHVyZVwiOiB0cnVlIH0pO1xuICAgIGNnbC5nZXRSYW5kb21GbG9hdFRleHR1cmUuaW5pdEZyb21EYXRhKGRhdGEsIHNpemUsIHNpemUsIFRleHR1cmUuRklMVEVSX05FQVJFU1QsIFRleHR1cmUuV1JBUF9SRVBFQVQpO1xuXG4gICAgcmV0dXJuIGNnbC5nZXRSYW5kb21GbG9hdFRleHR1cmU7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBnZXRCbGFja1RleHR1cmVcbiAqIEBtZW1iZXJvZiBUZXh0dXJlXG4gKiBAc3RhdGljXG4gKiBAZGVzY3JpcHRpb24gcmV0dXJucyBhIHJlZmVyZW5jZSB0byBhIGJsYWNrIHRleHR1cmVcbiAqIEByZXR1cm4ge1RleHR1cmV9XG4gKi9cblRleHR1cmUuZ2V0QmxhY2tUZXh0dXJlID0gZnVuY3Rpb24gKGNnbClcbntcbiAgICBpZiAoIWNnbCkgdGhpcy5fbG9nLmVycm9yKFwiW2dldEJsYWNrVGV4dHVyZV0gbm8gY2dsIVwiKTtcbiAgICBpZiAoY2dsLmJsYWNrVGV4dHVyZSkgcmV0dXJuIGNnbC5ibGFja1RleHR1cmU7XG5cbiAgICBjb25zdCBzaXplID0gODtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSAqIHNpemUgKiA0KTtcblxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgc2l6ZSAqIHNpemU7IHgrKylcbiAgICB7XG4gICAgICAgIGRhdGFbeCAqIDQgKyAwXSA9IGRhdGFbeCAqIDQgKyAxXSA9IGRhdGFbeCAqIDQgKyAyXSA9IDA7XG4gICAgICAgIGRhdGFbeCAqIDQgKyAzXSA9IDI1NTtcbiAgICB9XG5cbiAgICBjZ2wuYmxhY2tUZXh0dXJlID0gbmV3IFRleHR1cmUoY2dsKTtcbiAgICBjZ2wuYmxhY2tUZXh0dXJlLmluaXRGcm9tRGF0YShkYXRhLCBzaXplLCBzaXplLCBUZXh0dXJlLkZJTFRFUl9ORUFSRVNULCBUZXh0dXJlLldSQVBfUkVQRUFUKTtcblxuICAgIHJldHVybiBjZ2wuYmxhY2tUZXh0dXJlO1xufTtcblxuXG4vKipcbiAqIEBmdW5jdGlvbiBnZXRFbXB0eUN1YmVtYXBUZXh0dXJlXG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQHN0YXRpY1xuICogQGRlc2NyaXB0aW9uIHJldHVybnMgYW4gZW1wdHkgY3ViZW1hcCB0ZXh0dXJlIHdpdGggcmdiYSA9IFswLCAwLCAwLCAwXVxuICogQHJldHVybiB7VGV4dHVyZX1cbiAqL1xuVGV4dHVyZS5nZXRFbXB0eUN1YmVtYXBUZXh0dXJlID0gZnVuY3Rpb24gKGNnbClcbntcbiAgICBjb25zdCBmYWNlcyA9IFtcbiAgICAgICAgY2dsLmdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCxcbiAgICAgICAgY2dsLmdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWCxcbiAgICAgICAgY2dsLmdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSxcbiAgICAgICAgY2dsLmdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWSxcbiAgICAgICAgY2dsLmdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWixcbiAgICAgICAgY2dsLmdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWlxuICAgIF07XG5cbiAgICBjb25zdCB0ZXggPSBjZ2wuZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGNvbnN0IHRhcmdldCA9IGNnbC5nbC5URVhUVVJFX0NVQkVfTUFQO1xuICAgIGNvbnN0IGZpbHRlciA9IFRleHR1cmUuRklMVEVSX05FQVJFU1Q7XG4gICAgY29uc3Qgd3JhcCA9IFRleHR1cmUuV1JBUF9DTEFNUF9UT19FREdFO1xuICAgIGNvbnN0IHdpZHRoID0gODtcbiAgICBjb25zdCBoZWlnaHQgPSA4O1xuXG4gICAgY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVUZXh0dXJlTmV3Kys7XG5cblxuICAgIGNnbC5nbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleCk7XG4gICAgY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVUZXh0dXJlUmVzaXplKys7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkgKz0gMSlcbiAgICB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSg4ICogOCAqIDQpO1xuXG4gICAgICAgIGNnbC5nbC50ZXhJbWFnZTJEKGZhY2VzW2ldLCAwLCBjZ2wuZ2wuUkdCQSwgOCwgOCwgMCwgY2dsLmdsLlJHQkEsIGNnbC5nbC5VTlNJR05FRF9CWVRFLCBkYXRhKTtcbiAgICAgICAgY2dsLmdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBjZ2wuZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBjZ2wuZ2wuTkVBUkVTVCk7XG4gICAgICAgIGNnbC5nbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgY2dsLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgY2dsLmdsLk5FQVJFU1QpO1xuXG4gICAgICAgIGNnbC5nbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgY2dsLmdsLlRFWFRVUkVfV1JBUF9TLCBjZ2wuZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGNnbC5nbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgY2dsLmdsLlRFWFRVUkVfV1JBUF9ULCBjZ2wuZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgfVxuXG5cbiAgICBjZ2wuZ2wuYmluZFRleHR1cmUodGFyZ2V0LCBudWxsKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIFwiaWRcIjogQ0FCTEVTLnV1aWQoKSxcbiAgICAgICAgXCJ0ZXhcIjogdGV4LFxuICAgICAgICBcImN1YmVtYXBcIjogdGV4LFxuICAgICAgICBcIndpZHRoXCI6IHdpZHRoLFxuICAgICAgICBcImhlaWdodFwiOiBoZWlnaHQsXG4gICAgICAgIFwiZmlsdGVyXCI6IGZpbHRlcixcbiAgICAgICAgXCJ3cmFwXCI6IHdyYXAsXG4gICAgICAgIFwidW5wYWNrQWxwaGFcIjogdHJ1ZSxcbiAgICAgICAgXCJmbGlwXCI6IHRydWUsXG4gICAgICAgIFwiX2Zyb21EYXRhXCI6IHRydWUsXG4gICAgICAgIFwibmFtZVwiOiBcImVtcHR5Q3ViZW1hcFRleHR1cmVcIixcbiAgICAgICAgXCJhbmlzb3Ryb3BpY1wiOiAwLFxuICAgIH07XG59O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBmdW5jdGlvbiBnZXRUZW1wR3JhZGllbnRUZXh0dXJlXG4gKiBAbWVtYmVyb2YgVGV4dHVyZVxuICogQGRlc2NyaXB0aW9uIHJldHVybnMgYSBncmFkaWVudCB0ZXh0dXJlIGZyb20gYmxhY2sgdG8gd2hpdGVcbiAqIEBwYXJhbSB7Q29udGV4dH0gY2dsXG4gKiBAcmV0dXJuIHtUZXh0dXJlfVxuICovXG5UZXh0dXJlLmdldFRlbXBHcmFkaWVudFRleHR1cmUgPSBmdW5jdGlvbiAoY2dsKVxue1xuICAgIGlmICghY2dsKSBjb25zb2xlLmVycm9yKFwiW2dldFRlbXBHcmFkaWVudFRleHR1cmVdIG5vIGNnbCFcIik7XG5cbiAgICBpZiAoY2dsLnRlbXBUZXh0dXJlR3JhZGllbnQpIHJldHVybiBjZ2wudGVtcFRleHR1cmVHcmFkaWVudDtcbiAgICBjb25zdCB0ZW1wdGV4ID0gbmV3IFRleHR1cmUoY2dsKTtcbiAgICBjb25zdCBzaXplID0gMjU2O1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShzaXplICogc2l6ZSAqIDQpOyAvLyAuZmlsbCgwKTtcblxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc2l6ZTsgeSsrKVxuICAgIHtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBzaXplOyB4KyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRhdGFbKHggKyB5ICogc2l6ZSkgKiA0ICsgMF0gPSBkYXRhWyh4ICsgeSAqIHNpemUpICogNCArIDFdID0gZGF0YVsoeCArIHkgKiBzaXplKSAqIDQgKyAyXSA9IDI1NSAtIHk7XG4gICAgICAgICAgICBkYXRhWyh4ICsgeSAqIHNpemUpICogNCArIDNdID0gMjU1O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGVtcHRleC5pbml0RnJvbURhdGEoZGF0YSwgc2l6ZSwgc2l6ZSwgVGV4dHVyZS5GSUxURVJfTkVBUkVTVCwgVGV4dHVyZS5XUkFQX1JFUEVBVCk7XG4gICAgY2dsLnRlbXBUZXh0dXJlR3JhZGllbnQgPSB0ZW1wdGV4O1xuICAgIHJldHVybiB0ZW1wdGV4O1xufTtcblxuVGV4dHVyZS5nZXRUZW1wb3JhcnlUZXh0dXJlID0gZnVuY3Rpb24gKGNnbCwgc2l6ZSwgZmlsdGVyLCB3cmFwLCByLCBnLCBiKVxue1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpciA9IDE7XG4gICAgaWYgKGcgPT09IHVuZGVmaW5lZClnID0gMTtcbiAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKWIgPSAxO1xuICAgIGNvbnN0IHRlbXB0ZXggPSBuZXcgVGV4dHVyZShjZ2wpO1xuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgc2l6ZTsgeSsrKVxuICAgIHtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBzaXplOyB4KyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICgoeCArIHkpICUgNjQgPCAzMilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaCgoMjAwICsgKHkgLyBzaXplKSAqIDI1ICsgKHggLyBzaXplKSAqIDI1KSAqIHIpO1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKCgyMDAgKyAoeSAvIHNpemUpICogMjUgKyAoeCAvIHNpemUpICogMjUpICogZyk7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goKDIwMCArICh5IC8gc2l6ZSkgKiAyNSArICh4IC8gc2l6ZSkgKiAyNSkgKiBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaCgoNDAgKyAoeSAvIHNpemUpICogMjUgKyAoeCAvIHNpemUpICogMjUpICogcik7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goKDQwICsgKHkgLyBzaXplKSAqIDI1ICsgKHggLyBzaXplKSAqIDI1KSAqIGcpO1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKCg0MCArICh5IC8gc2l6ZSkgKiAyNSArICh4IC8gc2l6ZSkgKiAyNSkgKiBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyci5wdXNoKDI1NSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYXJyKTtcbiAgICB0ZW1wdGV4LmluaXRGcm9tRGF0YShkYXRhLCBzaXplLCBzaXplLCBmaWx0ZXIsIHdyYXApO1xuXG4gICAgcmV0dXJuIHRlbXB0ZXg7XG59O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBmdW5jdGlvbiBjcmVhdGVGcm9tSW1hZ2VcbiAqIEBtZW1iZXJvZiBUZXh0dXJlXG4gKiBAZGVzY3JpcHRpb24gY3JlYXRlIHRleHR1cmVtIGZyb20gaW1hZ2UgZGF0YSAoZS5nLiBpbWFnZSBvciBjYW52YXMpXG4gKiBAcGFyYW0ge0NvbnRleHR9IGNnbFxuICogQHBhcmFtIHtPYmplY3R9IGltYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5UZXh0dXJlLmNyZWF0ZUZyb21JbWFnZSA9IGZ1bmN0aW9uIChjZ2wsIGltZywgb3B0aW9ucylcbntcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoY2dsLCBvcHRpb25zKTtcbiAgICB0ZXh0dXJlLmZsaXAgPSBmYWxzZTtcbiAgICB0ZXh0dXJlLmltYWdlID0gaW1nO1xuICAgIHRleHR1cmUud2lkdGggPSBpbWcud2lkdGg7XG4gICAgdGV4dHVyZS5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KFwid3JhcFwiKSl0ZXh0dXJlLndyYXAgPSBvcHRpb25zLndyYXA7XG5cbiAgICBjb25zb2xlLmxvZyhcImNyZWF0ZUZyb21JbWFnZVwiLCBvcHRpb25zKTtcbiAgICB0ZXh0dXJlLmluaXRUZXh0dXJlKGltZywgb3B0aW9ucy5maWx0ZXIpO1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG59O1xuXG4vLyBkZXByZWNhdGVkIVxuVGV4dHVyZS5mcm9tSW1hZ2UgPSBmdW5jdGlvbiAoY2dsLCBpbWcsIGZpbHRlciwgd3JhcClcbntcbiAgICBjb25zb2xlLmVycm9yKFwiZGVwcmVjYXRlZCB0ZXh0dXJlIGZyb20gaW1hZ2UuLi5cIik7XG5cbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoY2dsKTtcbiAgICB0ZXh0dXJlLmZsaXAgPSBmYWxzZTtcbiAgICBpZiAoZmlsdGVyKSB0ZXh0dXJlLmZpbHRlciA9IGZpbHRlcjtcbiAgICBpZiAod3JhcCkgdGV4dHVyZS53cmFwID0gd3JhcDtcbiAgICB0ZXh0dXJlLmltYWdlID0gaW1nO1xuICAgIHRleHR1cmUuaW5pdFRleHR1cmUoaW1nKTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbn07XG5cbi8qKlxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uIGlzUG93ZXJPZlR3b1xuICogQG1lbWJlcm9mIFRleHR1cmVcbiAqIEBkZXNjcmlwdGlvbiByZXR1cm5zIHRydWUgaWYgeCBpcyBwb3dlciBvZiB0d29cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5UZXh0dXJlLmlzUG93ZXJPZlR3byA9IGZ1bmN0aW9uICh4KVxue1xuICAgIHJldHVybiB4ID09IDEgfHwgeCA9PSAyIHx8IHggPT0gNCB8fCB4ID09IDggfHwgeCA9PSAxNiB8fCB4ID09IDMyIHx8IHggPT0gNjQgfHwgeCA9PSAxMjggfHwgeCA9PSAyNTYgfHwgeCA9PSA1MTIgfHwgeCA9PSAxMDI0IHx8IHggPT0gMjA0OCB8fCB4ID09IDQwOTYgfHwgeCA9PSA4MTkyIHx8IHggPT0gMTYzODQ7XG59O1xuXG5UZXh0dXJlLmdldFRleEluZm8gPSBmdW5jdGlvbiAodGV4KVxue1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuXG4gICAgb2JqLm5hbWUgPSB0ZXgubmFtZTtcbiAgICBvYmpbXCJwb3dlciBvZiB0d29cIl0gPSB0ZXguaXNQb3dlck9mVHdvKCk7XG4gICAgb2JqLnNpemUgPSB0ZXgud2lkdGggKyBcIiB4IFwiICsgdGV4LmhlaWdodDtcblxuICAgIGxldCB0YXJnZXRTdHJpbmcgPSB0ZXgudGV4VGFyZ2V0O1xuICAgIGlmICh0ZXgudGV4VGFyZ2V0ID09IHRleC5fY2dsLmdsLlRFWFRVUkVfMkQpIHRhcmdldFN0cmluZyA9IFwiVEVYVFVSRV8yRFwiO1xuICAgIG9iai50YXJnZXQgPSB0YXJnZXRTdHJpbmc7XG5cbiAgICBvYmoudW5wYWNrQWxwaGEgPSB0ZXgudW5wYWNrQWxwaGE7XG5cbiAgICBpZiAodGV4LmN1YmVtYXApb2JqLmN1YmVtYXAgPSB0cnVlO1xuXG4gICAgaWYgKHRleC50ZXh0dXJlVHlwZSA9PSBUZXh0dXJlLlRZUEVfRkxPQVQpIG9iai50ZXh0dXJlVHlwZSA9IFwiVFlQRV9GTE9BVFwiO1xuICAgIGlmICh0ZXgudGV4dHVyZVR5cGUgPT0gVGV4dHVyZS5UWVBFX0hBTEZfRkxPQVQpIG9iai50ZXh0dXJlVHlwZSA9IFwiVFlQRV9IQUxGX0ZMT0FUXCI7XG4gICAgZWxzZSBpZiAodGV4LnRleHR1cmVUeXBlID09IFRleHR1cmUuVFlQRV9ERVBUSCkgb2JqLnRleHR1cmVUeXBlID0gXCJUWVBFX0RFUFRIXCI7XG4gICAgZWxzZSBpZiAodGV4LnRleHR1cmVUeXBlID09IFRleHR1cmUuVFlQRV9ERUZBVUxUKSBvYmoudGV4dHVyZVR5cGUgPSBcIlRZUEVfREVGQVVMVFwiO1xuICAgIGVsc2Ugb2JqLnRleHR1cmVUeXBlID0gXCJVTktOT1dOIFwiICsgdGhpcy50ZXh0dXJlVHlwZTtcblxuICAgIGlmICh0ZXgud3JhcCA9PSBUZXh0dXJlLldSQVBfQ0xBTVBfVE9fRURHRSkgb2JqLndyYXAgPSBcIkNMQU1QX1RPX0VER0VcIjtcbiAgICBlbHNlIGlmICh0ZXgud3JhcCA9PSBUZXh0dXJlLldSQVBfUkVQRUFUKSBvYmoud3JhcCA9IFwiV1JBUF9SRVBFQVRcIjtcbiAgICBlbHNlIGlmICh0ZXgud3JhcCA9PSBUZXh0dXJlLldSQVBfTUlSUk9SRURfUkVQRUFUKSBvYmoud3JhcCA9IFwiV1JBUF9NSVJST1JFRF9SRVBFQVRcIjtcbiAgICBlbHNlIG9iai53cmFwID0gXCJVTktOT1dOXCI7XG5cbiAgICBpZiAodGV4LmZpbHRlciA9PSBUZXh0dXJlLkZJTFRFUl9ORUFSRVNUKSBvYmouZmlsdGVyID0gXCJGSUxURVJfTkVBUkVTVFwiO1xuICAgIGVsc2UgaWYgKHRleC5maWx0ZXIgPT0gVGV4dHVyZS5GSUxURVJfTElORUFSKSBvYmouZmlsdGVyID0gXCJGSUxURVJfTElORUFSXCI7XG4gICAgZWxzZSBpZiAodGV4LmZpbHRlciA9PSBUZXh0dXJlLkZJTFRFUl9NSVBNQVApIG9iai5maWx0ZXIgPSBcIkZJTFRFUl9NSVBNQVBcIjtcbiAgICBlbHNlIG9iai5maWx0ZXIgPSBcIlVOS05PV05cIjtcblxuICAgIG9iai5waXhlbEZvcm1hdCA9IHRleC5waXhlbEZvcm1hdCB8fCBcInVua25vd25cIjtcblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5cblRleHR1cmUuRklMVEVSX05FQVJFU1QgPSAwO1xuVGV4dHVyZS5GSUxURVJfTElORUFSID0gMTtcblRleHR1cmUuRklMVEVSX01JUE1BUCA9IDI7XG5cblRleHR1cmUuV1JBUF9SRVBFQVQgPSAwO1xuVGV4dHVyZS5XUkFQX01JUlJPUkVEX1JFUEVBVCA9IDE7XG5UZXh0dXJlLldSQVBfQ0xBTVBfVE9fRURHRSA9IDI7XG5cblRleHR1cmUuVFlQRV9ERUZBVUxUID0gMDtcblRleHR1cmUuVFlQRV9ERVBUSCA9IDE7XG5UZXh0dXJlLlRZUEVfRkxPQVQgPSAyO1xuXG5cblRleHR1cmUuUEZPUk1BVFNUUl9SR0I1NjUgPSBcIlJHQiA1LzYvNWJpdCB1Ynl0ZVwiO1xuXG5UZXh0dXJlLlBGT1JNQVRTVFJfUjhVQiA9IFwiUiA4Yml0IHVieXRlXCI7XG5UZXh0dXJlLlBGT1JNQVRTVFJfUkc4VUIgPSBcIlJHIDhiaXQgdWJ5dGVcIjtcblRleHR1cmUuUEZPUk1BVFNUUl9SR0I4VUIgPSBcIlJHQiA4Yml0IHVieXRlXCI7XG5UZXh0dXJlLlBGT1JNQVRTVFJfUkdCQThVQiA9IFwiUkdCQSA4Yml0IHVieXRlXCI7XG5cblRleHR1cmUuUEZPUk1BVFNUUl9TUkdCQTggPSBcIlNSR0JBIDhiaXQgdWJ5dGVcIjtcblxuVGV4dHVyZS5QRk9STUFUU1RSX1IxMUZHMTFGQjEwRiA9IFwiUkdCIDExLzExLzEwYml0IGZsb2F0XCI7XG5cblRleHR1cmUuUEZPUk1BVFNUUl9SMTZGID0gXCJSIDE2Yml0IGZsb2F0XCI7XG5UZXh0dXJlLlBGT1JNQVRTVFJfUkcxNkYgPSBcIlJHIDE2Yml0IGZsb2F0XCI7XG5UZXh0dXJlLlBGT1JNQVRTVFJfUkdCMTZGID0gXCJSR0IgMTZiaXQgZmxvYXRcIjtcblRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMTZGID0gXCJSR0JBIDE2Yml0IGZsb2F0XCI7XG5cblxuVGV4dHVyZS5QRk9STUFUU1RSX1IzMkYgPSBcIlIgMzJiaXQgZmxvYXRcIjtcblRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMzJGID0gXCJSR0JBIDMyYml0IGZsb2F0XCI7XG5cblRleHR1cmUuUEZPUk1BVFNUUl9ERVBUSCA9IFwiREVQVEhcIjtcblxuXG5UZXh0dXJlLlBJWEVMRk9STUFUUyA9IFtcblxuICAgIFRleHR1cmUuUEZPUk1BVFNUUl9SR0I1NjUsXG5cbiAgICBUZXh0dXJlLlBGT1JNQVRTVFJfUjhVQixcbiAgICBUZXh0dXJlLlBGT1JNQVRTVFJfUkc4VUIsXG4gICAgVGV4dHVyZS5QRk9STUFUU1RSX1JHQjhVQixcbiAgICBUZXh0dXJlLlBGT1JNQVRTVFJfUkdCQThVQixcblxuICAgIFRleHR1cmUuUEZPUk1BVFNUUl9TUkdCQTgsXG5cbiAgICBUZXh0dXJlLlBGT1JNQVRTVFJfUjExRkcxMUZCMTBGLFxuICAgIFRleHR1cmUuUEZPUk1BVFNUUl9SMTZGLFxuICAgIFRleHR1cmUuUEZPUk1BVFNUUl9SRzE2RixcbiAgICBUZXh0dXJlLlBGT1JNQVRTVFJfUkdCQTE2RixcblxuICAgIFRleHR1cmUuUEZPUk1BVFNUUl9SMzJGLFxuICAgIFRleHR1cmUuUEZPUk1BVFNUUl9SR0JBMzJGXG5cbl07XG5cblRleHR1cmUuaXNQaXhlbEZvcm1hdEZsb2F0ID1cbiAgICAocHhsZnJtdCkgPT5cbiAgICB7XG4gICAgICAgIHJldHVybiAocHhsZnJtdCB8fCBcIlwiKS5jb250YWlucyhcImZsb2F0XCIpO1xuICAgIH07XG5cblRleHR1cmUuaXNQaXhlbEZvcm1hdEhhbGZGbG9hdCA9XG4gICAgKHB4bGZybXQpID0+XG4gICAge1xuICAgICAgICByZXR1cm4gKHB4bGZybXQgfHwgXCJcIikuY29udGFpbnMoXCJmbG9hdFwiKSAmJiAocHhsZnJtdCB8fCBcIlwiKS5jb250YWlucyhcIjE2Yml0XCIpO1xuICAgIH07XG5cblxuXG5cbmV4cG9ydCB7IFRleHR1cmUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_texture.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_textureeffect.js":
/*!*******************************************!*\
  !*** ./src/core/cgl/cgl_textureeffect.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TextureEffect\": () => (/* binding */ TextureEffect)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n/* harmony import */ var _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgl_texture.js */ \"./src/core/cgl/cgl_texture.js\");\n/* harmony import */ var _cgl_simplerect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgl_simplerect.js */ \"./src/core/cgl/cgl_simplerect.js\");\n\n\n\n\nconst TextureEffect = function (cgl, options)\n{\n    this._cgl = cgl;\n    this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"cgl_TextureEffect\");\n\n    if (!cgl.TextureEffectMesh) this.createMesh();\n\n    this._textureSource = null;\n    this._options = options;\n    this.name = options.name || \"unknown\";\n\n    // TODO: do we still need the options ?\n    // var opts=options ||\n    //     {\n    //         isFloatingPointTexture:false,\n    //         filter:CGL.Texture.FILTER_LINEAR\n    //     };\n    // if(options && options.fp)opts.isFloatingPointTexture=true;\n\n    this.imgCompVer = 0;\n    this.aspectRatio = 1;\n    this._textureTarget = null; // new CGL.Texture(this._cgl,opts);\n    this._frameBuf = this._cgl.gl.createFramebuffer();\n    this._frameBuf2 = this._cgl.gl.createFramebuffer();\n    this._renderbuffer = this._cgl.gl.createRenderbuffer();\n    this._renderbuffer2 = this._cgl.gl.createRenderbuffer();\n    this.switched = false;\n    this.depth = false;\n};\n\nTextureEffect.prototype.dispose = function ()\n{\n    if (this._renderbuffer) this._cgl.gl.deleteRenderbuffer(this._renderbuffer);\n    if (this._frameBuf) this._cgl.gl.deleteFramebuffer(this._frameBuf);\n    if (this._renderbuffer2) this._cgl.gl.deleteRenderbuffer(this._renderbuffer2);\n    if (this._frameBuf2) this._cgl.gl.deleteFramebuffer(this._frameBuf2);\n};\n\nTextureEffect.prototype.getWidth = function ()\n{\n    return this._textureSource.width;\n};\n\nTextureEffect.prototype.getHeight = function ()\n{\n    return this._textureSource.height;\n};\n\nTextureEffect.prototype.setSourceTexture = function (tex)\n{\n    if (tex === null)\n    {\n        this._textureSource = new _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture(this._cgl);\n        this._textureSource.setSize(16, 16);\n    }\n    else\n    {\n        this._textureSource = tex;\n    }\n\n    if (!this._textureSource.compareSettings(this._textureTarget))\n    {\n        if (this._textureTarget) this._textureTarget.delete();\n\n        this._textureTarget = this._textureSource.clone();\n\n        this._cgl.profileData.profileEffectBuffercreate++;\n\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf);\n\n        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._renderbuffer);\n\n        // if(tex.textureType==CGL.Texture.TYPE_FLOAT) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA32F, this._textureSource.width,this._textureSource.height);\n        // else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA8, this._textureSource.width,this._textureSource.height);\n\n        if (this.depth) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, this._cgl.gl.DEPTH_COMPONENT16, this._textureSource.width, this._textureSource.height);\n        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureTarget.tex, 0);\n        if (this.depth) this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._renderbuffer);\n\n        // this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureTarget.tex, 0);\n\n        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);\n        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);\n\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2);\n\n        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, this._renderbuffer2);\n\n        // if(tex.textureType==CGL.Texture.TYPE_FLOAT) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA32F, this._textureSource.width,this._textureSource.height);\n        // else this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER,this._cgl.gl.RGBA8, this._textureSource.width,this._textureSource.height);\n\n        if (this.depth) this._cgl.gl.renderbufferStorage(this._cgl.gl.RENDERBUFFER, this._cgl.gl.DEPTH_COMPONENT16, this._textureSource.width, this._textureSource.height);\n        this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureSource.tex, 0);\n\n        if (this.depth) this._cgl.gl.framebufferRenderbuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.DEPTH_ATTACHMENT, this._cgl.gl.RENDERBUFFER, this._renderbuffer2);\n\n        // this._cgl.gl.framebufferTexture2D(this._cgl.gl.FRAMEBUFFER, this._cgl.gl.COLOR_ATTACHMENT0, this._cgl.gl.TEXTURE_2D, this._textureSource.tex, 0);\n\n        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);\n        this._cgl.gl.bindRenderbuffer(this._cgl.gl.RENDERBUFFER, null);\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, null);\n    }\n\n    this.aspectRatio = this._textureSource.width / this._textureSource.height;\n};\nTextureEffect.prototype.continueEffect = function ()\n{\n    this._cgl.pushDepthTest(false);\n    this._cgl.pushModelMatrix();\n    this._cgl.pushPMatrix();\n    // todo why two pushs?\n\n\n    this._cgl.pushViewPort(0, 0, this.getCurrentTargetTexture().width, this.getCurrentTargetTexture().height);\n\n\n\n    mat4.perspective(this._cgl.pMatrix, 45, this.getCurrentTargetTexture().width / this.getCurrentTargetTexture().height, 0.1, 1100.0); // todo: why?\n\n    this._cgl.pushPMatrix();\n    mat4.identity(this._cgl.pMatrix);\n\n    this._cgl.pushViewMatrix();\n    mat4.identity(this._cgl.vMatrix);\n\n    this._cgl.pushModelMatrix();\n    mat4.identity(this._cgl.mMatrix);\n};\n\n\nTextureEffect.prototype.startEffect = function (bgTex)\n{\n    if (!this._textureTarget)\n    {\n        this._log.warn(\"effect has no target\");\n        return;\n    }\n\n    this.switched = false;\n\n    this.continueEffect();\n\n    if (bgTex)\n    {\n        this._bgTex = bgTex;\n    }\n    this._countEffects = 0;\n};\n\nTextureEffect.prototype.endEffect = function ()\n{\n    this._cgl.popDepthTest();\n    this._cgl.popModelMatrix();\n\n    this._cgl.popPMatrix();\n    this._cgl.popModelMatrix();\n    this._cgl.popViewMatrix();\n\n    this._cgl.popPMatrix();\n    this._cgl.popViewPort();\n};\n\nTextureEffect.prototype.bind = function ()\n{\n    if (this._textureSource === null)\n    {\n        this._log.warn(\"no base texture set!\");\n        return;\n    }\n\n    if (!this.switched)\n    {\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf);\n        this._cgl.pushGlFrameBuffer(this._frameBuf);\n    }\n    else\n    {\n        this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._frameBuf2);\n        this._cgl.pushGlFrameBuffer(this._frameBuf2);\n    }\n};\n\nTextureEffect.prototype.finish = function ()\n{\n    if (this._textureSource === null)\n    {\n        this._log.warn(\"no base texture set!\");\n        return;\n    }\n\n    this._cgl.TextureEffectMesh.render(this._cgl.getShader());\n\n    this._cgl.gl.bindFramebuffer(this._cgl.gl.FRAMEBUFFER, this._cgl.popGlFrameBuffer());\n\n    this._cgl.profileData.profileTextureEffect++;\n\n    if (this._textureTarget.filter == _cgl_texture_js__WEBPACK_IMPORTED_MODULE_1__.Texture.FILTER_MIPMAP)\n    {\n        if (!this.switched)\n        {\n            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._textureTarget.tex);\n            this._textureTarget.updateMipMap();\n        }\n        else\n        {\n            this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, this._textureSource.tex);\n            this._textureSource.updateMipMap();\n        }\n\n        this._cgl.gl.bindTexture(this._cgl.gl.TEXTURE_2D, null);\n    }\n\n    this.switched = !this.switched;\n    this._countEffects++;\n};\n\nTextureEffect.prototype.getCurrentTargetTexture = function ()\n{\n    if (this.switched) return this._textureSource;\n    return this._textureTarget;\n};\n\nTextureEffect.prototype.getCurrentSourceTexture = function ()\n{\n    if (this._countEffects == 0 && this._bgTex) return this._bgTex;\n\n    if (this.switched) return this._textureTarget;\n    return this._textureSource;\n};\n\nTextureEffect.prototype.delete = function ()\n{\n    if (this._textureTarget) this._textureTarget.delete();\n    if (this._textureSource) this._textureSource.delete();\n    this._cgl.gl.deleteRenderbuffer(this._renderbuffer);\n    this._cgl.gl.deleteFramebuffer(this._frameBuf);\n};\n\nTextureEffect.prototype.createMesh = function ()\n{\n    this._cgl.TextureEffectMesh = _cgl_simplerect_js__WEBPACK_IMPORTED_MODULE_2__.MESHES.getSimpleRect(this._cgl, \"texEffectRect\");\n};\n\n// ---------------------------------------------------------------------------------\n\nTextureEffect.checkOpNotInTextureEffect = function (op)\n{\n    if (!op.patch.cgl) return true;\n    if (op.uiAttribs.error && !op.patch.cgl.currentTextureEffect)\n    {\n        op.setUiError(\"textureeffect\", null);\n        return true;\n    }\n    if (!op.patch.cgl.currentTextureEffect) return true;\n\n    if (op.patch.cgl.currentTextureEffect && !op.uiAttribs.error)\n    {\n        op.setUiError(\"textureeffect\", \"This op can not be a child of a ImageCompose/texture effect! imagecompose should only have textureeffect childs.\", 0);\n        return false;\n    }\n\n    if (op.patch.cgl.currentTextureEffect) return false;\n    return true;\n};\n\nTextureEffect.checkOpInEffect = function (op, minver)\n{\n    minver = minver || 0;\n\n    if (op.patch.cgl.currentTextureEffect)\n    {\n        if (op.uiAttribs.uierrors && op.patch.cgl.currentTextureEffect.imgCompVer >= minver)\n        {\n            op.setUiError(\"texeffect\", null);\n            return true;\n        }\n\n        if (minver && op.patch.cgl.currentTextureEffect.imgCompVer < minver)\n        {\n            op.setUiError(\"texeffect\", \"This op must be a child of an ImageCompose op with version >=\" + minver + \" <span class=\\\"button-small\\\" onclick=\\\"gui.patchView.downGradeOp('\" + op.id + \"','\" + op.name + \"')\\\">Downgrade</span> to previous version\", 1);\n        }\n    }\n\n    if (op.patch.cgl.currentTextureEffect) return true;\n\n    if (!op.patch.cgl.currentTextureEffect && (!op.uiAttribs.uierrors || op.uiAttribs.uierrors.length == 0))\n    {\n        op.setUiError(\"texeffect\", \"This op must be a child of an ImageCompose op! More infos <a href=\\\"https://docs.cables.gl/image_composition/image_composition.html\\\" target=\\\"_blank\\\">here</a>. \", 1);\n        return false;\n    }\n\n    if (!op.patch.cgl.currentTextureEffect) return false;\n    return true;\n};\n\nTextureEffect.getBlendCode = function (ver)\n{\n    let src = \"\".endl()\n        + \"vec3 _blend(vec3 base,vec3 blend)\".endl()\n        + \"{\".endl()\n        + \"   vec3 colNew=blend;\".endl()\n        + \"   #ifdef BM_MULTIPLY\".endl()\n        + \"       colNew=base*blend;\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_MULTIPLY_INV\".endl()\n        + \"       colNew=base* vec3(1.0)-blend;\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_AVERAGE\".endl()\n        + \"       colNew=((base + blend) / 2.0);\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_ADD\".endl()\n        + \"       colNew=min(base + blend, vec3(1.0));\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_SUBTRACT_ONE\".endl()\n        + \"       colNew=max(base + blend - vec3(1.0), vec3(0.0));\".endl()\n        + \"   #endif\".endl()\n\n        + \"   #ifdef BM_SUBTRACT\".endl()\n        + \"       colNew=base - blend;\".endl()\n        + \"   #endif\".endl()\n\n        + \"   #ifdef BM_DIFFERENCE\".endl()\n        + \"       colNew=abs(base - blend);\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_NEGATION\".endl()\n        + \"       colNew=(vec3(1.0) - abs(vec3(1.0) - base - blend));\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_EXCLUSION\".endl()\n        + \"       colNew=(base + blend - 2.0 * base * blend);\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_LIGHTEN\".endl()\n        + \"       colNew=max(blend, base);\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_DARKEN\".endl()\n        + \"       colNew=min(blend, base);\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_OVERLAY\".endl()\n        + \"      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))\"\n            // .endl()+'       #define BlendOverlay(base, blend)       Blend(base, blend, BlendOverlayf)'\n            //    .endl()+'      colNew=Blend(base, blend, BlendOverlayf);'\n            .endl()\n        + \"      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_SCREEN\".endl()\n        + \"      #define BlendScreenf(base, blend)       (1.0 - ((1.0 - base) * (1.0 - blend)))\"\n            // .endl()+'       #define BlendScreen(base, blend)        Blend(base, blend, BlendScreenf)'\n            // .endl()+'      colNew=Blend(base, blend, BlendScreenf);'\n            .endl()\n        + \"      colNew=vec3(BlendScreenf(base.r, blend.r),BlendScreenf(base.g, blend.g),BlendScreenf(base.b, blend.b));\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_SOFTLIGHT\".endl()\n        + \"      #define BlendSoftLightf(base, blend)    ((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))\"\n            // .endl()+'       #define BlendSoftLight(base, blend)     Blend(base, blend, BlendSoftLightf)'\n            //    .endl()+'      colNew=Blend(base, blend, BlendSoftLightf);'\n            .endl()\n        + \"      colNew=vec3(BlendSoftLightf(base.r, blend.r),BlendSoftLightf(base.g, blend.g),BlendSoftLightf(base.b, blend.b));\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_HARDLIGHT\".endl()\n        + \"      #define BlendOverlayf(base, blend)  (base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))\"\n            // .endl()+'       #define BlendOverlay(base, blend)       Blend(base, blend, BlendOverlayf)'\n            // .endl()+'      colNew=Blend(blend, base, BlendOverlayf);'\n            .endl()\n        + \"      colNew=vec3(BlendOverlayf(base.r, blend.r),BlendOverlayf(base.g, blend.g),BlendOverlayf(base.b, blend.b));\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_COLORDODGE\".endl()\n        + \"      #define BlendColorDodgef(base, blend)   ((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0))\"\n            // .endl()+'      colNew=Blend(base, blend, BlendColorDodgef);'\n            .endl()\n        + \"      colNew=vec3(BlendColorDodgef(base.r, blend.r),BlendColorDodgef(base.g, blend.g),BlendColorDodgef(base.b, blend.b));\".endl()\n        + \"   #endif\".endl()\n        + \"   #ifdef BM_COLORBURN\".endl()\n        + \"      #define BlendColorBurnf(base, blend)    ((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0))\"\n            // .endl()+'      colNew=Blend(base, blend, BlendColorBurnf);'\n            .endl()\n        + \"      colNew=vec3(BlendColorBurnf(base.r, blend.r),BlendColorBurnf(base.g, blend.g),BlendColorBurnf(base.b, blend.b));\".endl()\n        + \"   #endif\".endl()\n\n\n\n\n\n\n\n\n\n\n        + \"   return colNew;\".endl()\n        + \"}\".endl();\n\n    if (!ver)\n        src += \"vec4 cgl_blend(vec4 oldColor,vec4 newColor,float amount)\".endl()\n                + \"{\".endl()\n                    + \"vec4 col=vec4( _blend(oldColor.rgb,newColor.rgb) ,1.0);\".endl()\n                    + \"col=vec4( mix( col.rgb, oldColor.rgb ,1.0-oldColor.a*amount),1.0);\".endl()\n                    + \"return col;\".endl()\n                + \"}\".endl();\n\n    if (ver >= 3)\n        src += \"vec4 cgl_blendPixel(vec4 base,vec4 col,float amount)\".endl() +\n                \"{\".endl() +\n\n                \"#ifdef BM_MATH_ADD\".endl() +\n                \"   return vec4(base.rgb+col.rgb*amount,1.0);\".endl() +\n                \"#endif\".endl() +\n\n                \"#ifdef BM_MATH_SUB\".endl() +\n                \"   return vec4(base.rgb-col.rgb*amount,1.0);\".endl() +\n                \"#endif\".endl() +\n\n                \"#ifdef BM_MATH_MUL\".endl() +\n                \"   return vec4(base.rgb*col.rgb*amount,1.0);\".endl() +\n                \"#endif\".endl() +\n\n                \"#ifdef BM_MATH_DIV\".endl() +\n                \"   return vec4(base.rgb/col.rgb*amount,1.0);\".endl() +\n                \"#endif\".endl() +\n\n\n                    \"#ifndef BM_MATH\".endl() +\n                        \"vec3 colNew=_blend(base.rgb,col.rgb);\".endl() +\n\n                        \"float newA=clamp(base.a+(col.a*amount),0.,1.);\".endl() +\n\n                        \"#ifdef BM_ALPHAMASKED\".endl() +\n                            \"newA=base.a;\".endl() +\n                        \"#endif\".endl() +\n\n                        \"return vec4(\".endl() +\n                            \"mix(colNew,base.rgb,1.0-(amount*col.a)),\".endl() +\n                            \"newA);\".endl() +\n\n                    \"#endif\".endl() +\n    \"}\".endl();\n\n    return src;\n};\n\nTextureEffect.onChangeBlendSelect = function (shader, blendName, maskAlpha = false)\n{\n    blendName = String(blendName);\n    shader.toggleDefine(\"BM_NORMAL\", blendName == \"normal\");\n    shader.toggleDefine(\"BM_MULTIPLY\", blendName == \"multiply\");\n    shader.toggleDefine(\"BM_MULTIPLY_INV\", blendName == \"multiply invert\");\n    shader.toggleDefine(\"BM_AVERAGE\", blendName == \"average\");\n    shader.toggleDefine(\"BM_ADD\", blendName == \"add\");\n    shader.toggleDefine(\"BM_SUBTRACT_ONE\", blendName == \"subtract one\");\n    shader.toggleDefine(\"BM_SUBTRACT\", blendName == \"subtract\");\n    shader.toggleDefine(\"BM_DIFFERENCE\", blendName == \"difference\");\n    shader.toggleDefine(\"BM_NEGATION\", blendName == \"negation\");\n    shader.toggleDefine(\"BM_EXCLUSION\", blendName == \"exclusion\");\n    shader.toggleDefine(\"BM_LIGHTEN\", blendName == \"lighten\");\n    shader.toggleDefine(\"BM_DARKEN\", blendName == \"darken\");\n    shader.toggleDefine(\"BM_OVERLAY\", blendName == \"overlay\");\n    shader.toggleDefine(\"BM_SCREEN\", blendName == \"screen\");\n    shader.toggleDefine(\"BM_SOFTLIGHT\", blendName == \"softlight\");\n    shader.toggleDefine(\"BM_HARDLIGHT\", blendName == \"hardlight\");\n    shader.toggleDefine(\"BM_COLORDODGE\", blendName == \"color dodge\");\n    shader.toggleDefine(\"BM_COLORBURN\", blendName == \"color burn\");\n\n    shader.toggleDefine(\"BM_MATH_ADD\", blendName == \"Math Add\");\n    shader.toggleDefine(\"BM_MATH_SUB\", blendName == \"Math Subtract\");\n    shader.toggleDefine(\"BM_MATH_MUL\", blendName == \"Math Multiply\");\n    shader.toggleDefine(\"BM_MATH_DIV\", blendName == \"Math Divide\");\n\n    shader.toggleDefine(\"BM_MATH\", blendName.indexOf(\"Math \") == 0);\n\n\n    shader.toggleDefine(\"BM_ALPHAMASKED\", maskAlpha);\n};\n\nTextureEffect.AddBlendSelect = function (op, name, defaultMode)\n{\n    const p = op.inValueSelect(name || \"Blend Mode\", [\n        \"normal\", \"lighten\", \"darken\", \"multiply\", \"multiply invert\", \"average\", \"add\", \"subtract\", \"difference\", \"negation\", \"exclusion\", \"overlay\", \"screen\", \"color dodge\", \"color burn\", \"softlight\", \"hardlight\", \"subtract one\",\n        \"Math Add\",\n        \"Math Subtract\",\n        \"Math Multiply\",\n        \"Math Divide\",\n\n    ], defaultMode || \"normal\");\n    return p;\n};\n\nTextureEffect.AddBlendAlphaMask = function (op, name, defaultMode)\n{\n    const p = op.inSwitch(name || \"Alpha Mask\", [\"Off\", \"On\"], defaultMode || \"Off\");\n    return p;\n};\n\nTextureEffect.setupBlending = function (op, shader, blendPort, amountPort, alphaMaskPort)\n{\n    const onChange = () =>\n    {\n        let maskAlpha = false;\n        if (alphaMaskPort) maskAlpha = alphaMaskPort.get() == \"On\";\n        TextureEffect.onChangeBlendSelect(shader, blendPort.get(), maskAlpha);\n\n        let str = blendPort.get();\n        if (str == \"normal\") str = null;\n        else if (str == \"multiply\") str = \"mul\";\n        else if (str == \"multiply invert\") str = \"mulinv\";\n        else if (str == \"lighten\") str = \"light\";\n        else if (str == \"darken\") str = \"darken\";\n        else if (str == \"average\") str = \"avg\";\n        else if (str == \"subtract one\") str = \"sub one\";\n        else if (str == \"subtract\") str = \"sub\";\n        else if (str == \"difference\") str = \"diff\";\n        else if (str == \"negation\") str = \"neg\";\n        else if (str == \"exclusion\") str = \"exc\";\n        else if (str == \"overlay\") str = \"ovl\";\n        else if (str == \"color dodge\") str = \"dodge\";\n        else if (str == \"color burn\") str = \"burn\";\n        else if (str == \"softlight\") str = \"soft\";\n        else if (str == \"hardlight\") str = \"hard\";\n        else if (str == \"Math Add\") str = \"+\";\n        else if (str == \"Math Subtract\") str = \"-\";\n        else if (str == \"Math Multiply\") str = \"*\";\n        else if (str == \"Math Divide\") str = \"/\";\n\n        op.setUiAttrib({ \"extendTitle\": str });\n    };\n    op.setPortGroup(\"Blending\", [blendPort, amountPort, alphaMaskPort]);\n\n    let maskAlpha = false;\n\n    blendPort.onChange = onChange;\n    if (alphaMaskPort)\n    {\n        alphaMaskPort.onChange = onChange;\n        maskAlpha = alphaMaskPort.get() == \"On\";\n    }\n\n    TextureEffect.onChangeBlendSelect(shader, blendPort.get(), maskAlpha);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3RleHR1cmVlZmZlY3QuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZ2wvY2dsX3RleHR1cmVlZmZlY3QuanM/NTA5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiY2FibGVzLXNoYXJlZC1jbGllbnRcIjtcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tIFwiLi9jZ2xfdGV4dHVyZS5qc1wiO1xuaW1wb3J0IHsgTUVTSEVTIH0gZnJvbSBcIi4vY2dsX3NpbXBsZXJlY3QuanNcIjtcblxuY29uc3QgVGV4dHVyZUVmZmVjdCA9IGZ1bmN0aW9uIChjZ2wsIG9wdGlvbnMpXG57XG4gICAgdGhpcy5fY2dsID0gY2dsO1xuICAgIHRoaXMuX2xvZyA9IG5ldyBMb2dnZXIoXCJjZ2xfVGV4dHVyZUVmZmVjdFwiKTtcblxuICAgIGlmICghY2dsLlRleHR1cmVFZmZlY3RNZXNoKSB0aGlzLmNyZWF0ZU1lc2goKTtcblxuICAgIHRoaXMuX3RleHR1cmVTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBcInVua25vd25cIjtcblxuICAgIC8vIFRPRE86IGRvIHdlIHN0aWxsIG5lZWQgdGhlIG9wdGlvbnMgP1xuICAgIC8vIHZhciBvcHRzPW9wdGlvbnMgfHxcbiAgICAvLyAgICAge1xuICAgIC8vICAgICAgICAgaXNGbG9hdGluZ1BvaW50VGV4dHVyZTpmYWxzZSxcbiAgICAvLyAgICAgICAgIGZpbHRlcjpDR0wuVGV4dHVyZS5GSUxURVJfTElORUFSXG4gICAgLy8gICAgIH07XG4gICAgLy8gaWYob3B0aW9ucyAmJiBvcHRpb25zLmZwKW9wdHMuaXNGbG9hdGluZ1BvaW50VGV4dHVyZT10cnVlO1xuXG4gICAgdGhpcy5pbWdDb21wVmVyID0gMDtcbiAgICB0aGlzLmFzcGVjdFJhdGlvID0gMTtcbiAgICB0aGlzLl90ZXh0dXJlVGFyZ2V0ID0gbnVsbDsgLy8gbmV3IENHTC5UZXh0dXJlKHRoaXMuX2NnbCxvcHRzKTtcbiAgICB0aGlzLl9mcmFtZUJ1ZiA9IHRoaXMuX2NnbC5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIHRoaXMuX2ZyYW1lQnVmMiA9IHRoaXMuX2NnbC5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIHRoaXMuX3JlbmRlcmJ1ZmZlciA9IHRoaXMuX2NnbC5nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICB0aGlzLl9yZW5kZXJidWZmZXIyID0gdGhpcy5fY2dsLmdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgIHRoaXMuc3dpdGNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlcHRoID0gZmFsc2U7XG59O1xuXG5UZXh0dXJlRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fcmVuZGVyYnVmZmVyKSB0aGlzLl9jZ2wuZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKHRoaXMuX3JlbmRlcmJ1ZmZlcik7XG4gICAgaWYgKHRoaXMuX2ZyYW1lQnVmKSB0aGlzLl9jZ2wuZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5fZnJhbWVCdWYpO1xuICAgIGlmICh0aGlzLl9yZW5kZXJidWZmZXIyKSB0aGlzLl9jZ2wuZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKHRoaXMuX3JlbmRlcmJ1ZmZlcjIpO1xuICAgIGlmICh0aGlzLl9mcmFtZUJ1ZjIpIHRoaXMuX2NnbC5nbC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLl9mcmFtZUJ1ZjIpO1xufTtcblxuVGV4dHVyZUVmZmVjdC5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl90ZXh0dXJlU291cmNlLndpZHRoO1xufTtcblxuVGV4dHVyZUVmZmVjdC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZVNvdXJjZS5oZWlnaHQ7XG59O1xuXG5UZXh0dXJlRWZmZWN0LnByb3RvdHlwZS5zZXRTb3VyY2VUZXh0dXJlID0gZnVuY3Rpb24gKHRleClcbntcbiAgICBpZiAodGV4ID09PSBudWxsKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdGV4dHVyZVNvdXJjZSA9IG5ldyBUZXh0dXJlKHRoaXMuX2NnbCk7XG4gICAgICAgIHRoaXMuX3RleHR1cmVTb3VyY2Uuc2V0U2l6ZSgxNiwgMTYpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLl90ZXh0dXJlU291cmNlID0gdGV4O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdGV4dHVyZVNvdXJjZS5jb21wYXJlU2V0dGluZ3ModGhpcy5fdGV4dHVyZVRhcmdldCkpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZVRhcmdldCkgdGhpcy5fdGV4dHVyZVRhcmdldC5kZWxldGUoKTtcblxuICAgICAgICB0aGlzLl90ZXh0dXJlVGFyZ2V0ID0gdGhpcy5fdGV4dHVyZVNvdXJjZS5jbG9uZSgpO1xuXG4gICAgICAgIHRoaXMuX2NnbC5wcm9maWxlRGF0YS5wcm9maWxlRWZmZWN0QnVmZmVyY3JlYXRlKys7XG5cbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lQnVmKTtcblxuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZFJlbmRlcmJ1ZmZlcih0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9yZW5kZXJidWZmZXIpO1xuXG4gICAgICAgIC8vIGlmKHRleC50ZXh0dXJlVHlwZT09Q0dMLlRleHR1cmUuVFlQRV9GTE9BVCkgdGhpcy5fY2dsLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UodGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUix0aGlzLl9jZ2wuZ2wuUkdCQTMyRiwgdGhpcy5fdGV4dHVyZVNvdXJjZS53aWR0aCx0aGlzLl90ZXh0dXJlU291cmNlLmhlaWdodCk7XG4gICAgICAgIC8vIGVsc2UgdGhpcy5fY2dsLmdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UodGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUix0aGlzLl9jZ2wuZ2wuUkdCQTgsIHRoaXMuX3RleHR1cmVTb3VyY2Uud2lkdGgsdGhpcy5fdGV4dHVyZVNvdXJjZS5oZWlnaHQpO1xuXG4gICAgICAgIGlmICh0aGlzLmRlcHRoKSB0aGlzLl9jZ2wuZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSh0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9jZ2wuZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHRoaXMuX3RleHR1cmVTb3VyY2Uud2lkdGgsIHRoaXMuX3RleHR1cmVTb3VyY2UuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fY2dsLmdsLkNPTE9SX0FUVEFDSE1FTlQwLCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZVRhcmdldC50ZXgsIDApO1xuICAgICAgICBpZiAodGhpcy5kZXB0aCkgdGhpcy5fY2dsLmdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fY2dsLmdsLkRFUFRIX0FUVEFDSE1FTlQsIHRoaXMuX2NnbC5nbC5SRU5ERVJCVUZGRVIsIHRoaXMuX3JlbmRlcmJ1ZmZlcik7XG5cbiAgICAgICAgLy8gdGhpcy5fY2dsLmdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgdGhpcy5fY2dsLmdsLkNPTE9SX0FUVEFDSE1FTlQwLCB0aGlzLl9jZ2wuZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZVRhcmdldC50ZXgsIDApO1xuXG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kVGV4dHVyZSh0aGlzLl9jZ2wuZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kUmVuZGVyYnVmZmVyKHRoaXMuX2NnbC5nbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuX2NnbC5nbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lQnVmMik7XG5cbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRSZW5kZXJidWZmZXIodGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUiwgdGhpcy5fcmVuZGVyYnVmZmVyMik7XG5cbiAgICAgICAgLy8gaWYodGV4LnRleHR1cmVUeXBlPT1DR0wuVGV4dHVyZS5UWVBFX0ZMT0FUKSB0aGlzLl9jZ2wuZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSh0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLHRoaXMuX2NnbC5nbC5SR0JBMzJGLCB0aGlzLl90ZXh0dXJlU291cmNlLndpZHRoLHRoaXMuX3RleHR1cmVTb3VyY2UuaGVpZ2h0KTtcbiAgICAgICAgLy8gZWxzZSB0aGlzLl9jZ2wuZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSh0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLHRoaXMuX2NnbC5nbC5SR0JBOCwgdGhpcy5fdGV4dHVyZVNvdXJjZS53aWR0aCx0aGlzLl90ZXh0dXJlU291cmNlLmhlaWdodCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGVwdGgpIHRoaXMuX2NnbC5nbC5yZW5kZXJidWZmZXJTdG9yYWdlKHRoaXMuX2NnbC5nbC5SRU5ERVJCVUZGRVIsIHRoaXMuX2NnbC5nbC5ERVBUSF9DT01QT05FTlQxNiwgdGhpcy5fdGV4dHVyZVNvdXJjZS53aWR0aCwgdGhpcy5fdGV4dHVyZVNvdXJjZS5oZWlnaHQpO1xuICAgICAgICB0aGlzLl9jZ2wuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9jZ2wuZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRoaXMuX2NnbC5nbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlU291cmNlLnRleCwgMCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGVwdGgpIHRoaXMuX2NnbC5nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2NnbC5nbC5ERVBUSF9BVFRBQ0hNRU5ULCB0aGlzLl9jZ2wuZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9yZW5kZXJidWZmZXIyKTtcblxuICAgICAgICAvLyB0aGlzLl9jZ2wuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9jZ2wuZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRoaXMuX2NnbC5nbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlU291cmNlLnRleCwgMCk7XG5cbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRUZXh0dXJlKHRoaXMuX2NnbC5nbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRSZW5kZXJidWZmZXIodGhpcy5fY2dsLmdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG4gICAgICAgIHRoaXMuX2NnbC5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY2dsLmdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzcGVjdFJhdGlvID0gdGhpcy5fdGV4dHVyZVNvdXJjZS53aWR0aCAvIHRoaXMuX3RleHR1cmVTb3VyY2UuaGVpZ2h0O1xufTtcblRleHR1cmVFZmZlY3QucHJvdG90eXBlLmNvbnRpbnVlRWZmZWN0ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9jZ2wucHVzaERlcHRoVGVzdChmYWxzZSk7XG4gICAgdGhpcy5fY2dsLnB1c2hNb2RlbE1hdHJpeCgpO1xuICAgIHRoaXMuX2NnbC5wdXNoUE1hdHJpeCgpO1xuICAgIC8vIHRvZG8gd2h5IHR3byBwdXNocz9cblxuXG4gICAgdGhpcy5fY2dsLnB1c2hWaWV3UG9ydCgwLCAwLCB0aGlzLmdldEN1cnJlbnRUYXJnZXRUZXh0dXJlKCkud2lkdGgsIHRoaXMuZ2V0Q3VycmVudFRhcmdldFRleHR1cmUoKS5oZWlnaHQpO1xuXG5cblxuICAgIG1hdDQucGVyc3BlY3RpdmUodGhpcy5fY2dsLnBNYXRyaXgsIDQ1LCB0aGlzLmdldEN1cnJlbnRUYXJnZXRUZXh0dXJlKCkud2lkdGggLyB0aGlzLmdldEN1cnJlbnRUYXJnZXRUZXh0dXJlKCkuaGVpZ2h0LCAwLjEsIDExMDAuMCk7IC8vIHRvZG86IHdoeT9cblxuICAgIHRoaXMuX2NnbC5wdXNoUE1hdHJpeCgpO1xuICAgIG1hdDQuaWRlbnRpdHkodGhpcy5fY2dsLnBNYXRyaXgpO1xuXG4gICAgdGhpcy5fY2dsLnB1c2hWaWV3TWF0cml4KCk7XG4gICAgbWF0NC5pZGVudGl0eSh0aGlzLl9jZ2wudk1hdHJpeCk7XG5cbiAgICB0aGlzLl9jZ2wucHVzaE1vZGVsTWF0cml4KCk7XG4gICAgbWF0NC5pZGVudGl0eSh0aGlzLl9jZ2wubU1hdHJpeCk7XG59O1xuXG5cblRleHR1cmVFZmZlY3QucHJvdG90eXBlLnN0YXJ0RWZmZWN0ID0gZnVuY3Rpb24gKGJnVGV4KVxue1xuICAgIGlmICghdGhpcy5fdGV4dHVyZVRhcmdldClcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy53YXJuKFwiZWZmZWN0IGhhcyBubyB0YXJnZXRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN3aXRjaGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLmNvbnRpbnVlRWZmZWN0KCk7XG5cbiAgICBpZiAoYmdUZXgpXG4gICAge1xuICAgICAgICB0aGlzLl9iZ1RleCA9IGJnVGV4O1xuICAgIH1cbiAgICB0aGlzLl9jb3VudEVmZmVjdHMgPSAwO1xufTtcblxuVGV4dHVyZUVmZmVjdC5wcm90b3R5cGUuZW5kRWZmZWN0ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9jZ2wucG9wRGVwdGhUZXN0KCk7XG4gICAgdGhpcy5fY2dsLnBvcE1vZGVsTWF0cml4KCk7XG5cbiAgICB0aGlzLl9jZ2wucG9wUE1hdHJpeCgpO1xuICAgIHRoaXMuX2NnbC5wb3BNb2RlbE1hdHJpeCgpO1xuICAgIHRoaXMuX2NnbC5wb3BWaWV3TWF0cml4KCk7XG5cbiAgICB0aGlzLl9jZ2wucG9wUE1hdHJpeCgpO1xuICAgIHRoaXMuX2NnbC5wb3BWaWV3UG9ydCgpO1xufTtcblxuVGV4dHVyZUVmZmVjdC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX3RleHR1cmVTb3VyY2UgPT09IG51bGwpXG4gICAge1xuICAgICAgICB0aGlzLl9sb2cud2FybihcIm5vIGJhc2UgdGV4dHVyZSBzZXQhXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN3aXRjaGVkKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lQnVmKTtcbiAgICAgICAgdGhpcy5fY2dsLnB1c2hHbEZyYW1lQnVmZmVyKHRoaXMuX2ZyYW1lQnVmKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lQnVmMik7XG4gICAgICAgIHRoaXMuX2NnbC5wdXNoR2xGcmFtZUJ1ZmZlcih0aGlzLl9mcmFtZUJ1ZjIpO1xuICAgIH1cbn07XG5cblRleHR1cmVFZmZlY3QucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX3RleHR1cmVTb3VyY2UgPT09IG51bGwpXG4gICAge1xuICAgICAgICB0aGlzLl9sb2cud2FybihcIm5vIGJhc2UgdGV4dHVyZSBzZXQhXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY2dsLlRleHR1cmVFZmZlY3RNZXNoLnJlbmRlcih0aGlzLl9jZ2wuZ2V0U2hhZGVyKCkpO1xuXG4gICAgdGhpcy5fY2dsLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jZ2wuZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2NnbC5wb3BHbEZyYW1lQnVmZmVyKCkpO1xuXG4gICAgdGhpcy5fY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVUZXh0dXJlRWZmZWN0Kys7XG5cbiAgICBpZiAodGhpcy5fdGV4dHVyZVRhcmdldC5maWx0ZXIgPT0gVGV4dHVyZS5GSUxURVJfTUlQTUFQKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnN3aXRjaGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZFRleHR1cmUodGhpcy5fY2dsLmdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmVUYXJnZXQudGV4KTtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVUYXJnZXQudXBkYXRlTWlwTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZFRleHR1cmUodGhpcy5fY2dsLmdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmVTb3VyY2UudGV4KTtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVTb3VyY2UudXBkYXRlTWlwTWFwKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jZ2wuZ2wuYmluZFRleHR1cmUodGhpcy5fY2dsLmdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgIH1cblxuICAgIHRoaXMuc3dpdGNoZWQgPSAhdGhpcy5zd2l0Y2hlZDtcbiAgICB0aGlzLl9jb3VudEVmZmVjdHMrKztcbn07XG5cblRleHR1cmVFZmZlY3QucHJvdG90eXBlLmdldEN1cnJlbnRUYXJnZXRUZXh0dXJlID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5zd2l0Y2hlZCkgcmV0dXJuIHRoaXMuX3RleHR1cmVTb3VyY2U7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVUYXJnZXQ7XG59O1xuXG5UZXh0dXJlRWZmZWN0LnByb3RvdHlwZS5nZXRDdXJyZW50U291cmNlVGV4dHVyZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX2NvdW50RWZmZWN0cyA9PSAwICYmIHRoaXMuX2JnVGV4KSByZXR1cm4gdGhpcy5fYmdUZXg7XG5cbiAgICBpZiAodGhpcy5zd2l0Y2hlZCkgcmV0dXJuIHRoaXMuX3RleHR1cmVUYXJnZXQ7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVTb3VyY2U7XG59O1xuXG5UZXh0dXJlRWZmZWN0LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLl90ZXh0dXJlVGFyZ2V0KSB0aGlzLl90ZXh0dXJlVGFyZ2V0LmRlbGV0ZSgpO1xuICAgIGlmICh0aGlzLl90ZXh0dXJlU291cmNlKSB0aGlzLl90ZXh0dXJlU291cmNlLmRlbGV0ZSgpO1xuICAgIHRoaXMuX2NnbC5nbC5kZWxldGVSZW5kZXJidWZmZXIodGhpcy5fcmVuZGVyYnVmZmVyKTtcbiAgICB0aGlzLl9jZ2wuZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5fZnJhbWVCdWYpO1xufTtcblxuVGV4dHVyZUVmZmVjdC5wcm90b3R5cGUuY3JlYXRlTWVzaCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fY2dsLlRleHR1cmVFZmZlY3RNZXNoID0gTUVTSEVTLmdldFNpbXBsZVJlY3QodGhpcy5fY2dsLCBcInRleEVmZmVjdFJlY3RcIik7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuVGV4dHVyZUVmZmVjdC5jaGVja09wTm90SW5UZXh0dXJlRWZmZWN0ID0gZnVuY3Rpb24gKG9wKVxue1xuICAgIGlmICghb3AucGF0Y2guY2dsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAob3AudWlBdHRyaWJzLmVycm9yICYmICFvcC5wYXRjaC5jZ2wuY3VycmVudFRleHR1cmVFZmZlY3QpXG4gICAge1xuICAgICAgICBvcC5zZXRVaUVycm9yKFwidGV4dHVyZWVmZmVjdFwiLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghb3AucGF0Y2guY2dsLmN1cnJlbnRUZXh0dXJlRWZmZWN0KSByZXR1cm4gdHJ1ZTtcblxuICAgIGlmIChvcC5wYXRjaC5jZ2wuY3VycmVudFRleHR1cmVFZmZlY3QgJiYgIW9wLnVpQXR0cmlicy5lcnJvcilcbiAgICB7XG4gICAgICAgIG9wLnNldFVpRXJyb3IoXCJ0ZXh0dXJlZWZmZWN0XCIsIFwiVGhpcyBvcCBjYW4gbm90IGJlIGEgY2hpbGQgb2YgYSBJbWFnZUNvbXBvc2UvdGV4dHVyZSBlZmZlY3QhIGltYWdlY29tcG9zZSBzaG91bGQgb25seSBoYXZlIHRleHR1cmVlZmZlY3QgY2hpbGRzLlwiLCAwKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvcC5wYXRjaC5jZ2wuY3VycmVudFRleHR1cmVFZmZlY3QpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblRleHR1cmVFZmZlY3QuY2hlY2tPcEluRWZmZWN0ID0gZnVuY3Rpb24gKG9wLCBtaW52ZXIpXG57XG4gICAgbWludmVyID0gbWludmVyIHx8IDA7XG5cbiAgICBpZiAob3AucGF0Y2guY2dsLmN1cnJlbnRUZXh0dXJlRWZmZWN0KVxuICAgIHtcbiAgICAgICAgaWYgKG9wLnVpQXR0cmlicy51aWVycm9ycyAmJiBvcC5wYXRjaC5jZ2wuY3VycmVudFRleHR1cmVFZmZlY3QuaW1nQ29tcFZlciA+PSBtaW52ZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG9wLnNldFVpRXJyb3IoXCJ0ZXhlZmZlY3RcIiwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaW52ZXIgJiYgb3AucGF0Y2guY2dsLmN1cnJlbnRUZXh0dXJlRWZmZWN0LmltZ0NvbXBWZXIgPCBtaW52ZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG9wLnNldFVpRXJyb3IoXCJ0ZXhlZmZlY3RcIiwgXCJUaGlzIG9wIG11c3QgYmUgYSBjaGlsZCBvZiBhbiBJbWFnZUNvbXBvc2Ugb3Agd2l0aCB2ZXJzaW9uID49XCIgKyBtaW52ZXIgKyBcIiA8c3BhbiBjbGFzcz1cXFwiYnV0dG9uLXNtYWxsXFxcIiBvbmNsaWNrPVxcXCJndWkucGF0Y2hWaWV3LmRvd25HcmFkZU9wKCdcIiArIG9wLmlkICsgXCInLCdcIiArIG9wLm5hbWUgKyBcIicpXFxcIj5Eb3duZ3JhZGU8L3NwYW4+IHRvIHByZXZpb3VzIHZlcnNpb25cIiwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3AucGF0Y2guY2dsLmN1cnJlbnRUZXh0dXJlRWZmZWN0KSByZXR1cm4gdHJ1ZTtcblxuICAgIGlmICghb3AucGF0Y2guY2dsLmN1cnJlbnRUZXh0dXJlRWZmZWN0ICYmICghb3AudWlBdHRyaWJzLnVpZXJyb3JzIHx8IG9wLnVpQXR0cmlicy51aWVycm9ycy5sZW5ndGggPT0gMCkpXG4gICAge1xuICAgICAgICBvcC5zZXRVaUVycm9yKFwidGV4ZWZmZWN0XCIsIFwiVGhpcyBvcCBtdXN0IGJlIGEgY2hpbGQgb2YgYW4gSW1hZ2VDb21wb3NlIG9wISBNb3JlIGluZm9zIDxhIGhyZWY9XFxcImh0dHBzOi8vZG9jcy5jYWJsZXMuZ2wvaW1hZ2VfY29tcG9zaXRpb24vaW1hZ2VfY29tcG9zaXRpb24uaHRtbFxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPmhlcmU8L2E+LiBcIiwgMSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIW9wLnBhdGNoLmNnbC5jdXJyZW50VGV4dHVyZUVmZmVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuVGV4dHVyZUVmZmVjdC5nZXRCbGVuZENvZGUgPSBmdW5jdGlvbiAodmVyKVxue1xuICAgIGxldCBzcmMgPSBcIlwiLmVuZGwoKVxuICAgICAgICArIFwidmVjMyBfYmxlbmQodmVjMyBiYXNlLHZlYzMgYmxlbmQpXCIuZW5kbCgpXG4gICAgICAgICsgXCJ7XCIuZW5kbCgpXG4gICAgICAgICsgXCIgICB2ZWMzIGNvbE5ldz1ibGVuZDtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNpZmRlZiBCTV9NVUxUSVBMWVwiLmVuZGwoKVxuICAgICAgICArIFwiICAgICAgIGNvbE5ldz1iYXNlKmJsZW5kO1wiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2VuZGlmXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjaWZkZWYgQk1fTVVMVElQTFlfSU5WXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAgICAgY29sTmV3PWJhc2UqIHZlYzMoMS4wKS1ibGVuZDtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNlbmRpZlwiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2lmZGVmIEJNX0FWRVJBR0VcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICAgICBjb2xOZXc9KChiYXNlICsgYmxlbmQpIC8gMi4wKTtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNlbmRpZlwiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2lmZGVmIEJNX0FERFwiLmVuZGwoKVxuICAgICAgICArIFwiICAgICAgIGNvbE5ldz1taW4oYmFzZSArIGJsZW5kLCB2ZWMzKDEuMCkpO1wiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2VuZGlmXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjaWZkZWYgQk1fU1VCVFJBQ1RfT05FXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAgICAgY29sTmV3PW1heChiYXNlICsgYmxlbmQgLSB2ZWMzKDEuMCksIHZlYzMoMC4wKSk7XCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjZW5kaWZcIi5lbmRsKClcblxuICAgICAgICArIFwiICAgI2lmZGVmIEJNX1NVQlRSQUNUXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAgICAgY29sTmV3PWJhc2UgLSBibGVuZDtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNlbmRpZlwiLmVuZGwoKVxuXG4gICAgICAgICsgXCIgICAjaWZkZWYgQk1fRElGRkVSRU5DRVwiLmVuZGwoKVxuICAgICAgICArIFwiICAgICAgIGNvbE5ldz1hYnMoYmFzZSAtIGJsZW5kKTtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNlbmRpZlwiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2lmZGVmIEJNX05FR0FUSU9OXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAgICAgY29sTmV3PSh2ZWMzKDEuMCkgLSBhYnModmVjMygxLjApIC0gYmFzZSAtIGJsZW5kKSk7XCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjZW5kaWZcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNpZmRlZiBCTV9FWENMVVNJT05cIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICAgICBjb2xOZXc9KGJhc2UgKyBibGVuZCAtIDIuMCAqIGJhc2UgKiBibGVuZCk7XCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjZW5kaWZcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNpZmRlZiBCTV9MSUdIVEVOXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAgICAgY29sTmV3PW1heChibGVuZCwgYmFzZSk7XCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjZW5kaWZcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNpZmRlZiBCTV9EQVJLRU5cIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICAgICBjb2xOZXc9bWluKGJsZW5kLCBiYXNlKTtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNlbmRpZlwiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2lmZGVmIEJNX09WRVJMQVlcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICAgICNkZWZpbmUgQmxlbmRPdmVybGF5ZihiYXNlLCBibGVuZCkgIChiYXNlIDwgMC41ID8gKDIuMCAqIGJhc2UgKiBibGVuZCkgOiAoMS4wIC0gMi4wICogKDEuMCAtIGJhc2UpICogKDEuMCAtIGJsZW5kKSkpXCJcbiAgICAgICAgICAgIC8vIC5lbmRsKCkrJyAgICAgICAjZGVmaW5lIEJsZW5kT3ZlcmxheShiYXNlLCBibGVuZCkgICAgICAgQmxlbmQoYmFzZSwgYmxlbmQsIEJsZW5kT3ZlcmxheWYpJ1xuICAgICAgICAgICAgLy8gICAgLmVuZGwoKSsnICAgICAgY29sTmV3PUJsZW5kKGJhc2UsIGJsZW5kLCBCbGVuZE92ZXJsYXlmKTsnXG4gICAgICAgICAgICAuZW5kbCgpXG4gICAgICAgICsgXCIgICAgICBjb2xOZXc9dmVjMyhCbGVuZE92ZXJsYXlmKGJhc2UuciwgYmxlbmQuciksQmxlbmRPdmVybGF5ZihiYXNlLmcsIGJsZW5kLmcpLEJsZW5kT3ZlcmxheWYoYmFzZS5iLCBibGVuZC5iKSk7XCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjZW5kaWZcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNpZmRlZiBCTV9TQ1JFRU5cIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICAgICNkZWZpbmUgQmxlbmRTY3JlZW5mKGJhc2UsIGJsZW5kKSAgICAgICAoMS4wIC0gKCgxLjAgLSBiYXNlKSAqICgxLjAgLSBibGVuZCkpKVwiXG4gICAgICAgICAgICAvLyAuZW5kbCgpKycgICAgICAgI2RlZmluZSBCbGVuZFNjcmVlbihiYXNlLCBibGVuZCkgICAgICAgIEJsZW5kKGJhc2UsIGJsZW5kLCBCbGVuZFNjcmVlbmYpJ1xuICAgICAgICAgICAgLy8gLmVuZGwoKSsnICAgICAgY29sTmV3PUJsZW5kKGJhc2UsIGJsZW5kLCBCbGVuZFNjcmVlbmYpOydcbiAgICAgICAgICAgIC5lbmRsKClcbiAgICAgICAgKyBcIiAgICAgIGNvbE5ldz12ZWMzKEJsZW5kU2NyZWVuZihiYXNlLnIsIGJsZW5kLnIpLEJsZW5kU2NyZWVuZihiYXNlLmcsIGJsZW5kLmcpLEJsZW5kU2NyZWVuZihiYXNlLmIsIGJsZW5kLmIpKTtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNlbmRpZlwiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2lmZGVmIEJNX1NPRlRMSUdIVFwiLmVuZGwoKVxuICAgICAgICArIFwiICAgICAgI2RlZmluZSBCbGVuZFNvZnRMaWdodGYoYmFzZSwgYmxlbmQpICAgICgoYmxlbmQgPCAwLjUpID8gKDIuMCAqIGJhc2UgKiBibGVuZCArIGJhc2UgKiBiYXNlICogKDEuMCAtIDIuMCAqIGJsZW5kKSkgOiAoc3FydChiYXNlKSAqICgyLjAgKiBibGVuZCAtIDEuMCkgKyAyLjAgKiBiYXNlICogKDEuMCAtIGJsZW5kKSkpXCJcbiAgICAgICAgICAgIC8vIC5lbmRsKCkrJyAgICAgICAjZGVmaW5lIEJsZW5kU29mdExpZ2h0KGJhc2UsIGJsZW5kKSAgICAgQmxlbmQoYmFzZSwgYmxlbmQsIEJsZW5kU29mdExpZ2h0ZiknXG4gICAgICAgICAgICAvLyAgICAuZW5kbCgpKycgICAgICBjb2xOZXc9QmxlbmQoYmFzZSwgYmxlbmQsIEJsZW5kU29mdExpZ2h0Zik7J1xuICAgICAgICAgICAgLmVuZGwoKVxuICAgICAgICArIFwiICAgICAgY29sTmV3PXZlYzMoQmxlbmRTb2Z0TGlnaHRmKGJhc2UuciwgYmxlbmQuciksQmxlbmRTb2Z0TGlnaHRmKGJhc2UuZywgYmxlbmQuZyksQmxlbmRTb2Z0TGlnaHRmKGJhc2UuYiwgYmxlbmQuYikpO1wiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2VuZGlmXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjaWZkZWYgQk1fSEFSRExJR0hUXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAgICAjZGVmaW5lIEJsZW5kT3ZlcmxheWYoYmFzZSwgYmxlbmQpICAoYmFzZSA8IDAuNSA/ICgyLjAgKiBiYXNlICogYmxlbmQpIDogKDEuMCAtIDIuMCAqICgxLjAgLSBiYXNlKSAqICgxLjAgLSBibGVuZCkpKVwiXG4gICAgICAgICAgICAvLyAuZW5kbCgpKycgICAgICAgI2RlZmluZSBCbGVuZE92ZXJsYXkoYmFzZSwgYmxlbmQpICAgICAgIEJsZW5kKGJhc2UsIGJsZW5kLCBCbGVuZE92ZXJsYXlmKSdcbiAgICAgICAgICAgIC8vIC5lbmRsKCkrJyAgICAgIGNvbE5ldz1CbGVuZChibGVuZCwgYmFzZSwgQmxlbmRPdmVybGF5Zik7J1xuICAgICAgICAgICAgLmVuZGwoKVxuICAgICAgICArIFwiICAgICAgY29sTmV3PXZlYzMoQmxlbmRPdmVybGF5ZihiYXNlLnIsIGJsZW5kLnIpLEJsZW5kT3ZlcmxheWYoYmFzZS5nLCBibGVuZC5nKSxCbGVuZE92ZXJsYXlmKGJhc2UuYiwgYmxlbmQuYikpO1wiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2VuZGlmXCIuZW5kbCgpXG4gICAgICAgICsgXCIgICAjaWZkZWYgQk1fQ09MT1JET0RHRVwiLmVuZGwoKVxuICAgICAgICArIFwiICAgICAgI2RlZmluZSBCbGVuZENvbG9yRG9kZ2VmKGJhc2UsIGJsZW5kKSAgICgoYmxlbmQgPT0gMS4wKSA/IGJsZW5kIDogbWluKGJhc2UgLyAoMS4wIC0gYmxlbmQpLCAxLjApKVwiXG4gICAgICAgICAgICAvLyAuZW5kbCgpKycgICAgICBjb2xOZXc9QmxlbmQoYmFzZSwgYmxlbmQsIEJsZW5kQ29sb3JEb2RnZWYpOydcbiAgICAgICAgICAgIC5lbmRsKClcbiAgICAgICAgKyBcIiAgICAgIGNvbE5ldz12ZWMzKEJsZW5kQ29sb3JEb2RnZWYoYmFzZS5yLCBibGVuZC5yKSxCbGVuZENvbG9yRG9kZ2VmKGJhc2UuZywgYmxlbmQuZyksQmxlbmRDb2xvckRvZGdlZihiYXNlLmIsIGJsZW5kLmIpKTtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNlbmRpZlwiLmVuZGwoKVxuICAgICAgICArIFwiICAgI2lmZGVmIEJNX0NPTE9SQlVSTlwiLmVuZGwoKVxuICAgICAgICArIFwiICAgICAgI2RlZmluZSBCbGVuZENvbG9yQnVybmYoYmFzZSwgYmxlbmQpICAgICgoYmxlbmQgPT0gMC4wKSA/IGJsZW5kIDogbWF4KCgxLjAgLSAoKDEuMCAtIGJhc2UpIC8gYmxlbmQpKSwgMC4wKSlcIlxuICAgICAgICAgICAgLy8gLmVuZGwoKSsnICAgICAgY29sTmV3PUJsZW5kKGJhc2UsIGJsZW5kLCBCbGVuZENvbG9yQnVybmYpOydcbiAgICAgICAgICAgIC5lbmRsKClcbiAgICAgICAgKyBcIiAgICAgIGNvbE5ldz12ZWMzKEJsZW5kQ29sb3JCdXJuZihiYXNlLnIsIGJsZW5kLnIpLEJsZW5kQ29sb3JCdXJuZihiYXNlLmcsIGJsZW5kLmcpLEJsZW5kQ29sb3JCdXJuZihiYXNlLmIsIGJsZW5kLmIpKTtcIi5lbmRsKClcbiAgICAgICAgKyBcIiAgICNlbmRpZlwiLmVuZGwoKVxuXG5cblxuXG5cblxuXG5cblxuXG4gICAgICAgICsgXCIgICByZXR1cm4gY29sTmV3O1wiLmVuZGwoKVxuICAgICAgICArIFwifVwiLmVuZGwoKTtcblxuICAgIGlmICghdmVyKVxuICAgICAgICBzcmMgKz0gXCJ2ZWM0IGNnbF9ibGVuZCh2ZWM0IG9sZENvbG9yLHZlYzQgbmV3Q29sb3IsZmxvYXQgYW1vdW50KVwiLmVuZGwoKVxuICAgICAgICAgICAgICAgICsgXCJ7XCIuZW5kbCgpXG4gICAgICAgICAgICAgICAgICAgICsgXCJ2ZWM0IGNvbD12ZWM0KCBfYmxlbmQob2xkQ29sb3IucmdiLG5ld0NvbG9yLnJnYikgLDEuMCk7XCIuZW5kbCgpXG4gICAgICAgICAgICAgICAgICAgICsgXCJjb2w9dmVjNCggbWl4KCBjb2wucmdiLCBvbGRDb2xvci5yZ2IgLDEuMC1vbGRDb2xvci5hKmFtb3VudCksMS4wKTtcIi5lbmRsKClcbiAgICAgICAgICAgICAgICAgICAgKyBcInJldHVybiBjb2w7XCIuZW5kbCgpXG4gICAgICAgICAgICAgICAgKyBcIn1cIi5lbmRsKCk7XG5cbiAgICBpZiAodmVyID49IDMpXG4gICAgICAgIHNyYyArPSBcInZlYzQgY2dsX2JsZW5kUGl4ZWwodmVjNCBiYXNlLHZlYzQgY29sLGZsb2F0IGFtb3VudClcIi5lbmRsKCkgK1xuICAgICAgICAgICAgICAgIFwie1wiLmVuZGwoKSArXG5cbiAgICAgICAgICAgICAgICBcIiNpZmRlZiBCTV9NQVRIX0FERFwiLmVuZGwoKSArXG4gICAgICAgICAgICAgICAgXCIgICByZXR1cm4gdmVjNChiYXNlLnJnYitjb2wucmdiKmFtb3VudCwxLjApO1wiLmVuZGwoKSArXG4gICAgICAgICAgICAgICAgXCIjZW5kaWZcIi5lbmRsKCkgK1xuXG4gICAgICAgICAgICAgICAgXCIjaWZkZWYgQk1fTUFUSF9TVUJcIi5lbmRsKCkgK1xuICAgICAgICAgICAgICAgIFwiICAgcmV0dXJuIHZlYzQoYmFzZS5yZ2ItY29sLnJnYiphbW91bnQsMS4wKTtcIi5lbmRsKCkgK1xuICAgICAgICAgICAgICAgIFwiI2VuZGlmXCIuZW5kbCgpICtcblxuICAgICAgICAgICAgICAgIFwiI2lmZGVmIEJNX01BVEhfTVVMXCIuZW5kbCgpICtcbiAgICAgICAgICAgICAgICBcIiAgIHJldHVybiB2ZWM0KGJhc2UucmdiKmNvbC5yZ2IqYW1vdW50LDEuMCk7XCIuZW5kbCgpICtcbiAgICAgICAgICAgICAgICBcIiNlbmRpZlwiLmVuZGwoKSArXG5cbiAgICAgICAgICAgICAgICBcIiNpZmRlZiBCTV9NQVRIX0RJVlwiLmVuZGwoKSArXG4gICAgICAgICAgICAgICAgXCIgICByZXR1cm4gdmVjNChiYXNlLnJnYi9jb2wucmdiKmFtb3VudCwxLjApO1wiLmVuZGwoKSArXG4gICAgICAgICAgICAgICAgXCIjZW5kaWZcIi5lbmRsKCkgK1xuXG5cbiAgICAgICAgICAgICAgICAgICAgXCIjaWZuZGVmIEJNX01BVEhcIi5lbmRsKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2ZWMzIGNvbE5ldz1fYmxlbmQoYmFzZS5yZ2IsY29sLnJnYik7XCIuZW5kbCgpICtcblxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmbG9hdCBuZXdBPWNsYW1wKGJhc2UuYSsoY29sLmEqYW1vdW50KSwwLiwxLik7XCIuZW5kbCgpICtcblxuICAgICAgICAgICAgICAgICAgICAgICAgXCIjaWZkZWYgQk1fQUxQSEFNQVNLRURcIi5lbmRsKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibmV3QT1iYXNlLmE7XCIuZW5kbCgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiI2VuZGlmXCIuZW5kbCgpICtcblxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyZXR1cm4gdmVjNChcIi5lbmRsKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWl4KGNvbE5ldyxiYXNlLnJnYiwxLjAtKGFtb3VudCpjb2wuYSkpLFwiLmVuZGwoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuZXdBKTtcIi5lbmRsKCkgK1xuXG4gICAgICAgICAgICAgICAgICAgIFwiI2VuZGlmXCIuZW5kbCgpICtcbiAgICBcIn1cIi5lbmRsKCk7XG5cbiAgICByZXR1cm4gc3JjO1xufTtcblxuVGV4dHVyZUVmZmVjdC5vbkNoYW5nZUJsZW5kU2VsZWN0ID0gZnVuY3Rpb24gKHNoYWRlciwgYmxlbmROYW1lLCBtYXNrQWxwaGEgPSBmYWxzZSlcbntcbiAgICBibGVuZE5hbWUgPSBTdHJpbmcoYmxlbmROYW1lKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fTk9STUFMXCIsIGJsZW5kTmFtZSA9PSBcIm5vcm1hbFwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fTVVMVElQTFlcIiwgYmxlbmROYW1lID09IFwibXVsdGlwbHlcIik7XG4gICAgc2hhZGVyLnRvZ2dsZURlZmluZShcIkJNX01VTFRJUExZX0lOVlwiLCBibGVuZE5hbWUgPT0gXCJtdWx0aXBseSBpbnZlcnRcIik7XG4gICAgc2hhZGVyLnRvZ2dsZURlZmluZShcIkJNX0FWRVJBR0VcIiwgYmxlbmROYW1lID09IFwiYXZlcmFnZVwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fQUREXCIsIGJsZW5kTmFtZSA9PSBcImFkZFwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fU1VCVFJBQ1RfT05FXCIsIGJsZW5kTmFtZSA9PSBcInN1YnRyYWN0IG9uZVwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fU1VCVFJBQ1RcIiwgYmxlbmROYW1lID09IFwic3VidHJhY3RcIik7XG4gICAgc2hhZGVyLnRvZ2dsZURlZmluZShcIkJNX0RJRkZFUkVOQ0VcIiwgYmxlbmROYW1lID09IFwiZGlmZmVyZW5jZVwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fTkVHQVRJT05cIiwgYmxlbmROYW1lID09IFwibmVnYXRpb25cIik7XG4gICAgc2hhZGVyLnRvZ2dsZURlZmluZShcIkJNX0VYQ0xVU0lPTlwiLCBibGVuZE5hbWUgPT0gXCJleGNsdXNpb25cIik7XG4gICAgc2hhZGVyLnRvZ2dsZURlZmluZShcIkJNX0xJR0hURU5cIiwgYmxlbmROYW1lID09IFwibGlnaHRlblwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fREFSS0VOXCIsIGJsZW5kTmFtZSA9PSBcImRhcmtlblwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fT1ZFUkxBWVwiLCBibGVuZE5hbWUgPT0gXCJvdmVybGF5XCIpO1xuICAgIHNoYWRlci50b2dnbGVEZWZpbmUoXCJCTV9TQ1JFRU5cIiwgYmxlbmROYW1lID09IFwic2NyZWVuXCIpO1xuICAgIHNoYWRlci50b2dnbGVEZWZpbmUoXCJCTV9TT0ZUTElHSFRcIiwgYmxlbmROYW1lID09IFwic29mdGxpZ2h0XCIpO1xuICAgIHNoYWRlci50b2dnbGVEZWZpbmUoXCJCTV9IQVJETElHSFRcIiwgYmxlbmROYW1lID09IFwiaGFyZGxpZ2h0XCIpO1xuICAgIHNoYWRlci50b2dnbGVEZWZpbmUoXCJCTV9DT0xPUkRPREdFXCIsIGJsZW5kTmFtZSA9PSBcImNvbG9yIGRvZGdlXCIpO1xuICAgIHNoYWRlci50b2dnbGVEZWZpbmUoXCJCTV9DT0xPUkJVUk5cIiwgYmxlbmROYW1lID09IFwiY29sb3IgYnVyblwiKTtcblxuICAgIHNoYWRlci50b2dnbGVEZWZpbmUoXCJCTV9NQVRIX0FERFwiLCBibGVuZE5hbWUgPT0gXCJNYXRoIEFkZFwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fTUFUSF9TVUJcIiwgYmxlbmROYW1lID09IFwiTWF0aCBTdWJ0cmFjdFwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fTUFUSF9NVUxcIiwgYmxlbmROYW1lID09IFwiTWF0aCBNdWx0aXBseVwiKTtcbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fTUFUSF9ESVZcIiwgYmxlbmROYW1lID09IFwiTWF0aCBEaXZpZGVcIik7XG5cbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fTUFUSFwiLCBibGVuZE5hbWUuaW5kZXhPZihcIk1hdGggXCIpID09IDApO1xuXG5cbiAgICBzaGFkZXIudG9nZ2xlRGVmaW5lKFwiQk1fQUxQSEFNQVNLRURcIiwgbWFza0FscGhhKTtcbn07XG5cblRleHR1cmVFZmZlY3QuQWRkQmxlbmRTZWxlY3QgPSBmdW5jdGlvbiAob3AsIG5hbWUsIGRlZmF1bHRNb2RlKVxue1xuICAgIGNvbnN0IHAgPSBvcC5pblZhbHVlU2VsZWN0KG5hbWUgfHwgXCJCbGVuZCBNb2RlXCIsIFtcbiAgICAgICAgXCJub3JtYWxcIiwgXCJsaWdodGVuXCIsIFwiZGFya2VuXCIsIFwibXVsdGlwbHlcIiwgXCJtdWx0aXBseSBpbnZlcnRcIiwgXCJhdmVyYWdlXCIsIFwiYWRkXCIsIFwic3VidHJhY3RcIiwgXCJkaWZmZXJlbmNlXCIsIFwibmVnYXRpb25cIiwgXCJleGNsdXNpb25cIiwgXCJvdmVybGF5XCIsIFwic2NyZWVuXCIsIFwiY29sb3IgZG9kZ2VcIiwgXCJjb2xvciBidXJuXCIsIFwic29mdGxpZ2h0XCIsIFwiaGFyZGxpZ2h0XCIsIFwic3VidHJhY3Qgb25lXCIsXG4gICAgICAgIFwiTWF0aCBBZGRcIixcbiAgICAgICAgXCJNYXRoIFN1YnRyYWN0XCIsXG4gICAgICAgIFwiTWF0aCBNdWx0aXBseVwiLFxuICAgICAgICBcIk1hdGggRGl2aWRlXCIsXG5cbiAgICBdLCBkZWZhdWx0TW9kZSB8fCBcIm5vcm1hbFwiKTtcbiAgICByZXR1cm4gcDtcbn07XG5cblRleHR1cmVFZmZlY3QuQWRkQmxlbmRBbHBoYU1hc2sgPSBmdW5jdGlvbiAob3AsIG5hbWUsIGRlZmF1bHRNb2RlKVxue1xuICAgIGNvbnN0IHAgPSBvcC5pblN3aXRjaChuYW1lIHx8IFwiQWxwaGEgTWFza1wiLCBbXCJPZmZcIiwgXCJPblwiXSwgZGVmYXVsdE1vZGUgfHwgXCJPZmZcIik7XG4gICAgcmV0dXJuIHA7XG59O1xuXG5UZXh0dXJlRWZmZWN0LnNldHVwQmxlbmRpbmcgPSBmdW5jdGlvbiAob3AsIHNoYWRlciwgYmxlbmRQb3J0LCBhbW91bnRQb3J0LCBhbHBoYU1hc2tQb3J0KVxue1xuICAgIGNvbnN0IG9uQ2hhbmdlID0gKCkgPT5cbiAgICB7XG4gICAgICAgIGxldCBtYXNrQWxwaGEgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFscGhhTWFza1BvcnQpIG1hc2tBbHBoYSA9IGFscGhhTWFza1BvcnQuZ2V0KCkgPT0gXCJPblwiO1xuICAgICAgICBUZXh0dXJlRWZmZWN0Lm9uQ2hhbmdlQmxlbmRTZWxlY3Qoc2hhZGVyLCBibGVuZFBvcnQuZ2V0KCksIG1hc2tBbHBoYSk7XG5cbiAgICAgICAgbGV0IHN0ciA9IGJsZW5kUG9ydC5nZXQoKTtcbiAgICAgICAgaWYgKHN0ciA9PSBcIm5vcm1hbFwiKSBzdHIgPSBudWxsO1xuICAgICAgICBlbHNlIGlmIChzdHIgPT0gXCJtdWx0aXBseVwiKSBzdHIgPSBcIm11bFwiO1xuICAgICAgICBlbHNlIGlmIChzdHIgPT0gXCJtdWx0aXBseSBpbnZlcnRcIikgc3RyID0gXCJtdWxpbnZcIjtcbiAgICAgICAgZWxzZSBpZiAoc3RyID09IFwibGlnaHRlblwiKSBzdHIgPSBcImxpZ2h0XCI7XG4gICAgICAgIGVsc2UgaWYgKHN0ciA9PSBcImRhcmtlblwiKSBzdHIgPSBcImRhcmtlblwiO1xuICAgICAgICBlbHNlIGlmIChzdHIgPT0gXCJhdmVyYWdlXCIpIHN0ciA9IFwiYXZnXCI7XG4gICAgICAgIGVsc2UgaWYgKHN0ciA9PSBcInN1YnRyYWN0IG9uZVwiKSBzdHIgPSBcInN1YiBvbmVcIjtcbiAgICAgICAgZWxzZSBpZiAoc3RyID09IFwic3VidHJhY3RcIikgc3RyID0gXCJzdWJcIjtcbiAgICAgICAgZWxzZSBpZiAoc3RyID09IFwiZGlmZmVyZW5jZVwiKSBzdHIgPSBcImRpZmZcIjtcbiAgICAgICAgZWxzZSBpZiAoc3RyID09IFwibmVnYXRpb25cIikgc3RyID0gXCJuZWdcIjtcbiAgICAgICAgZWxzZSBpZiAoc3RyID09IFwiZXhjbHVzaW9uXCIpIHN0ciA9IFwiZXhjXCI7XG4gICAgICAgIGVsc2UgaWYgKHN0ciA9PSBcIm92ZXJsYXlcIikgc3RyID0gXCJvdmxcIjtcbiAgICAgICAgZWxzZSBpZiAoc3RyID09IFwiY29sb3IgZG9kZ2VcIikgc3RyID0gXCJkb2RnZVwiO1xuICAgICAgICBlbHNlIGlmIChzdHIgPT0gXCJjb2xvciBidXJuXCIpIHN0ciA9IFwiYnVyblwiO1xuICAgICAgICBlbHNlIGlmIChzdHIgPT0gXCJzb2Z0bGlnaHRcIikgc3RyID0gXCJzb2Z0XCI7XG4gICAgICAgIGVsc2UgaWYgKHN0ciA9PSBcImhhcmRsaWdodFwiKSBzdHIgPSBcImhhcmRcIjtcbiAgICAgICAgZWxzZSBpZiAoc3RyID09IFwiTWF0aCBBZGRcIikgc3RyID0gXCIrXCI7XG4gICAgICAgIGVsc2UgaWYgKHN0ciA9PSBcIk1hdGggU3VidHJhY3RcIikgc3RyID0gXCItXCI7XG4gICAgICAgIGVsc2UgaWYgKHN0ciA9PSBcIk1hdGggTXVsdGlwbHlcIikgc3RyID0gXCIqXCI7XG4gICAgICAgIGVsc2UgaWYgKHN0ciA9PSBcIk1hdGggRGl2aWRlXCIpIHN0ciA9IFwiL1wiO1xuXG4gICAgICAgIG9wLnNldFVpQXR0cmliKHsgXCJleHRlbmRUaXRsZVwiOiBzdHIgfSk7XG4gICAgfTtcbiAgICBvcC5zZXRQb3J0R3JvdXAoXCJCbGVuZGluZ1wiLCBbYmxlbmRQb3J0LCBhbW91bnRQb3J0LCBhbHBoYU1hc2tQb3J0XSk7XG5cbiAgICBsZXQgbWFza0FscGhhID0gZmFsc2U7XG5cbiAgICBibGVuZFBvcnQub25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgICBpZiAoYWxwaGFNYXNrUG9ydClcbiAgICB7XG4gICAgICAgIGFscGhhTWFza1BvcnQub25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgICAgICAgbWFza0FscGhhID0gYWxwaGFNYXNrUG9ydC5nZXQoKSA9PSBcIk9uXCI7XG4gICAgfVxuXG4gICAgVGV4dHVyZUVmZmVjdC5vbkNoYW5nZUJsZW5kU2VsZWN0KHNoYWRlciwgYmxlbmRQb3J0LmdldCgpLCBtYXNrQWxwaGEpO1xufTtcblxuZXhwb3J0IHsgVGV4dHVyZUVmZmVjdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_textureeffect.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_unicolorshader.js":
/*!********************************************!*\
  !*** ./src/core/cgl/cgl_unicolorshader.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UniColorShader\": () => (/* binding */ UniColorShader)\n/* harmony export */ });\n\n\nclass UniColorShader\n{\n    constructor(_cgl)\n    {\n        this.shader = new CGL.Shader(_cgl, \"markermaterial\");\n\n        const frag = \"\"\n            .endl() + \"void main()\"\n            .endl() + \"{\"\n            .endl() + \"    outColor = vec4(color.rgb,1.0);\"\n            .endl() + \"}\";\n\n\n        const vert = \"\"\n            .endl() + \"IN vec3 vPosition;\"\n            .endl() + \"UNI mat4 projMatrix;\"\n            .endl() + \"UNI mat4 mvMatrix;\"\n\n            .endl() + \"void main()\"\n            .endl() + \"{\"\n            .endl() + \"   gl_Position = projMatrix * mvMatrix * vec4(vPosition,1.0);\"\n            .endl() + \"}\";\n\n        this.shader.setSource(vert, frag);\n        this.coloruni = this.shader.addUniformFrag(\"4f\", \"color\", [1, 0.777, 1, 1]);\n    }\n\n    setColor(r, g, b, a)\n    {\n        this.coloruni.set(r, g, b, a);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3VuaWNvbG9yc2hhZGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dsL2NnbF91bmljb2xvcnNoYWRlci5qcz80NTUxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IFVuaUNvbG9yU2hhZGVyIH07XG5cbmNsYXNzIFVuaUNvbG9yU2hhZGVyXG57XG4gICAgY29uc3RydWN0b3IoX2NnbClcbiAgICB7XG4gICAgICAgIHRoaXMuc2hhZGVyID0gbmV3IENHTC5TaGFkZXIoX2NnbCwgXCJtYXJrZXJtYXRlcmlhbFwiKTtcblxuICAgICAgICBjb25zdCBmcmFnID0gXCJcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwidm9pZCBtYWluKClcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwie1wiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCIgICAgb3V0Q29sb3IgPSB2ZWM0KGNvbG9yLnJnYiwxLjApO1wiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCJ9XCI7XG5cblxuICAgICAgICBjb25zdCB2ZXJ0ID0gXCJcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiSU4gdmVjMyB2UG9zaXRpb247XCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIlVOSSBtYXQ0IHByb2pNYXRyaXg7XCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIlVOSSBtYXQ0IG12TWF0cml4O1wiXG5cbiAgICAgICAgICAgIC5lbmRsKCkgKyBcInZvaWQgbWFpbigpXCJcbiAgICAgICAgICAgIC5lbmRsKCkgKyBcIntcIlxuICAgICAgICAgICAgLmVuZGwoKSArIFwiICAgZ2xfUG9zaXRpb24gPSBwcm9qTWF0cml4ICogbXZNYXRyaXggKiB2ZWM0KHZQb3NpdGlvbiwxLjApO1wiXG4gICAgICAgICAgICAuZW5kbCgpICsgXCJ9XCI7XG5cbiAgICAgICAgdGhpcy5zaGFkZXIuc2V0U291cmNlKHZlcnQsIGZyYWcpO1xuICAgICAgICB0aGlzLmNvbG9ydW5pID0gdGhpcy5zaGFkZXIuYWRkVW5pZm9ybUZyYWcoXCI0ZlwiLCBcImNvbG9yXCIsIFsxLCAwLjc3NywgMSwgMV0pO1xuICAgIH1cblxuICAgIHNldENvbG9yKHIsIGcsIGIsIGEpXG4gICAge1xuICAgICAgICB0aGlzLmNvbG9ydW5pLnNldChyLCBnLCBiLCBhKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_unicolorshader.js\n");

/***/ }),

/***/ "./src/core/cgl/cgl_utils.js":
/*!***********************************!*\
  !*** ./src/core/cgl/cgl_utils.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DEG2RAD\": () => (/* binding */ DEG2RAD),\n/* harmony export */   \"escapeHTML\": () => (/* binding */ escapeHTML),\n/* harmony export */   \"getWheelDelta\": () => (/* binding */ getWheelDelta),\n/* harmony export */   \"getWheelSpeed\": () => (/* binding */ getWheelSpeed),\n/* harmony export */   \"isWindows\": () => (/* binding */ isWindows),\n/* harmony export */   \"onLoadingAssetsFinished\": () => (/* binding */ onLoadingAssetsFinished)\n/* harmony export */ });\n/* unused harmony export RAD2DEG */\n/** @namespace CGL */\n\n/**\n * multiply to get radians from degree, e.g. `360 * CGL.DEG2RAD`\n * @const {Number}\n * @memberof CGL\n * @static\n */\nconst DEG2RAD = Math.PI / 180.0;\n\n/**\n * to get degrees from radians, e.g. `3.14 * CGL.RAD2DEG`\n * @const {number}\n * @memberof CGL\n */\nconst RAD2DEG = 180.0 / Math.PI;\n\nconst onLoadingAssetsFinished = null; // deprecated / remove later\n\n/**\n * get normalized mouse wheel delta (including browser specific adjustment)\n * @function getWheelDelta\n * @static\n * @memberof CGL\n * @param {MouseEvent} event\n * @return {Number} normalized delta\n */\nconst isWindows = window.navigator.userAgent.contains(\"Windows\");\nconst getWheelDelta_ = function (event)\n{\n    let normalized;\n    if (event.wheelDelta)\n    {\n        // chrome\n        normalized = (event.wheelDelta % 120) - 0 == -0 ? event.wheelDelta / 120 : event.wheelDelta / 30;\n        normalized *= -1.5;\n        if (isWindows) normalized *= 2;\n    }\n    else\n    {\n        // firefox\n        let d = event.deltaY;\n        if (event.shiftKey) d = event.deltaX;\n        const rawAmmount = d || event.detail;\n        normalized = -(rawAmmount % 3 ? rawAmmount * 10 : rawAmmount / 3);\n        normalized *= -3;\n    }\n\n    if (normalized > 20) normalized = 20;\n    if (normalized < -20) normalized = -20;\n\n    return normalized;\n};\n\nconst getWheelSpeed = getWheelDelta_;\nconst getWheelDelta = getWheelDelta_;\n\n// from https://github.com/lodash/lodash/blob/master/escape.js\n\nconst htmlEscapes = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    \"\\\"\": \"&quot;\",\n    \"'\": \"&#39;\",\n};\n\n/** Used to match HTML entities and HTML characters. */\nconst reUnescapedHtml = /[&<>\"']/g;\nconst reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n/*  eslint-disable */\nconst escapeHTML = function(string)\n{\n    return string && reHasUnescapedHtml.test(string) ?\n        string.replace(reUnescapedHtml, function(chr) { return htmlEscapes[chr]; })\n        : string || \"\";\n}\n/* eslint-enable */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY2dsX3V0aWxzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dsL2NnbF91dGlscy5qcz9lYWM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbmFtZXNwYWNlIENHTCAqL1xuXG4vKipcbiAqIG11bHRpcGx5IHRvIGdldCByYWRpYW5zIGZyb20gZGVncmVlLCBlLmcuIGAzNjAgKiBDR0wuREVHMlJBRGBcbiAqIEBjb25zdCB7TnVtYmVyfVxuICogQG1lbWJlcm9mIENHTFxuICogQHN0YXRpY1xuICovXG5leHBvcnQgY29uc3QgREVHMlJBRCA9IE1hdGguUEkgLyAxODAuMDtcblxuLyoqXG4gKiB0byBnZXQgZGVncmVlcyBmcm9tIHJhZGlhbnMsIGUuZy4gYDMuMTQgKiBDR0wuUkFEMkRFR2BcbiAqIEBjb25zdCB7bnVtYmVyfVxuICogQG1lbWJlcm9mIENHTFxuICovXG5leHBvcnQgY29uc3QgUkFEMkRFRyA9IDE4MC4wIC8gTWF0aC5QSTtcblxuZXhwb3J0IGNvbnN0IG9uTG9hZGluZ0Fzc2V0c0ZpbmlzaGVkID0gbnVsbDsgLy8gZGVwcmVjYXRlZCAvIHJlbW92ZSBsYXRlclxuXG4vKipcbiAqIGdldCBub3JtYWxpemVkIG1vdXNlIHdoZWVsIGRlbHRhIChpbmNsdWRpbmcgYnJvd3NlciBzcGVjaWZpYyBhZGp1c3RtZW50KVxuICogQGZ1bmN0aW9uIGdldFdoZWVsRGVsdGFcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBDR0xcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge051bWJlcn0gbm9ybWFsaXplZCBkZWx0YVxuICovXG5leHBvcnQgY29uc3QgaXNXaW5kb3dzID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuY29udGFpbnMoXCJXaW5kb3dzXCIpO1xuY29uc3QgZ2V0V2hlZWxEZWx0YV8gPSBmdW5jdGlvbiAoZXZlbnQpXG57XG4gICAgbGV0IG5vcm1hbGl6ZWQ7XG4gICAgaWYgKGV2ZW50LndoZWVsRGVsdGEpXG4gICAge1xuICAgICAgICAvLyBjaHJvbWVcbiAgICAgICAgbm9ybWFsaXplZCA9IChldmVudC53aGVlbERlbHRhICUgMTIwKSAtIDAgPT0gLTAgPyBldmVudC53aGVlbERlbHRhIC8gMTIwIDogZXZlbnQud2hlZWxEZWx0YSAvIDMwO1xuICAgICAgICBub3JtYWxpemVkICo9IC0xLjU7XG4gICAgICAgIGlmIChpc1dpbmRvd3MpIG5vcm1hbGl6ZWQgKj0gMjtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgLy8gZmlyZWZveFxuICAgICAgICBsZXQgZCA9IGV2ZW50LmRlbHRhWTtcbiAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSBkID0gZXZlbnQuZGVsdGFYO1xuICAgICAgICBjb25zdCByYXdBbW1vdW50ID0gZCB8fCBldmVudC5kZXRhaWw7XG4gICAgICAgIG5vcm1hbGl6ZWQgPSAtKHJhd0FtbW91bnQgJSAzID8gcmF3QW1tb3VudCAqIDEwIDogcmF3QW1tb3VudCAvIDMpO1xuICAgICAgICBub3JtYWxpemVkICo9IC0zO1xuICAgIH1cblxuICAgIGlmIChub3JtYWxpemVkID4gMjApIG5vcm1hbGl6ZWQgPSAyMDtcbiAgICBpZiAobm9ybWFsaXplZCA8IC0yMCkgbm9ybWFsaXplZCA9IC0yMDtcblxuICAgIHJldHVybiBub3JtYWxpemVkO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFdoZWVsU3BlZWQgPSBnZXRXaGVlbERlbHRhXztcbmV4cG9ydCBjb25zdCBnZXRXaGVlbERlbHRhID0gZ2V0V2hlZWxEZWx0YV87XG5cbi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvZXNjYXBlLmpzXG5cbmNvbnN0IGh0bWxFc2NhcGVzID0ge1xuICAgIFwiJlwiOiBcIiZhbXA7XCIsXG4gICAgXCI8XCI6IFwiJmx0O1wiLFxuICAgIFwiPlwiOiBcIiZndDtcIixcbiAgICBcIlxcXCJcIjogXCImcXVvdDtcIixcbiAgICBcIidcIjogXCImIzM5O1wiLFxufTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xuY29uc3QgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2c7XG5jb25zdCByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbi8qICBlc2xpbnQtZGlzYWJsZSAqL1xuZXhwb3J0IGNvbnN0IGVzY2FwZUhUTUwgPSBmdW5jdGlvbihzdHJpbmcpXG57XG4gICAgcmV0dXJuIHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpID9cbiAgICAgICAgc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGh0bWxFc2NhcGVzW2Nocl07IH0pXG4gICAgICAgIDogc3RyaW5nIHx8IFwiXCI7XG59XG4vKiBlc2xpbnQtZW5hYmxlICovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgl/cgl_utils.js\n");

/***/ }),

/***/ "./src/core/cgl/constants.js":
/*!***********************************!*\
  !*** ./src/core/cgl/constants.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CONSTANTS\": () => (/* binding */ CONSTANTS)\n/* harmony export */ });\nconst SHADER = {\n    // default attributes\n    \"SHADERVAR_VERTEX_POSITION\": \"vPosition\",\n    \"SHADERVAR_VERTEX_NUMBER\": \"attrVertIndex\",\n    \"SHADERVAR_VERTEX_NORMAL\": \"attrVertNormal\",\n    \"SHADERVAR_VERTEX_TEXCOORD\": \"attrTexCoord\",\n    \"SHADERVAR_INSTANCE_MMATRIX\": \"instMat\",\n    \"SHADERVAR_VERTEX_COLOR\": \"attrVertColor\",\n\n    \"SHADERVAR_INSTANCE_INDEX\": \"instanceIndex\",\n\n    // default uniforms\n    \"SHADERVAR_UNI_PROJMAT\": \"projMatrix\",\n    \"SHADERVAR_UNI_VIEWMAT\": \"viewMatrix\",\n    \"SHADERVAR_UNI_MODELMAT\": \"modelMatrix\",\n    \"SHADERVAR_UNI_NORMALMAT\": \"normalMatrix\",\n    \"SHADERVAR_UNI_INVVIEWMAT\": \"inverseViewMatrix\",\n    \"SHADERVAR_UNI_INVPROJMAT\": \"invProjMatrix\",\n    \"SHADERVAR_UNI_MATERIALID\": \"materialId\",\n    \"SHADERVAR_UNI_OBJECTID\": \"objectId\",\n\n    \"SHADERVAR_UNI_VIEWPOS\": \"camPos\",\n};\n\n\nconst BLEND_MODES = {\n    \"BLEND_NONE\": 0,\n    \"BLEND_NORMAL\": 1,\n    \"BLEND_ADD\": 2,\n    \"BLEND_SUB\": 3,\n    \"BLEND_MUL\": 4,\n};\n\n\n\n\n\nconst RAD2DEG = 180.0 / Math.PI;\nconst DEG2RAD = Math.PI / 180.0;\n\nconst CONSTANTS = {\n    \"MATH\": {\n        \"DEG2RAD\": DEG2RAD,\n        \"RAD2DEG\": RAD2DEG,\n    },\n    \"SHADER\": SHADER,\n    \"BLEND_MODES\": BLEND_MODES,\n};\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvY29uc3RhbnRzLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NnbC9jb25zdGFudHMuanM/OGYyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTSEFERVIgPSB7XG4gICAgLy8gZGVmYXVsdCBhdHRyaWJ1dGVzXG4gICAgXCJTSEFERVJWQVJfVkVSVEVYX1BPU0lUSU9OXCI6IFwidlBvc2l0aW9uXCIsXG4gICAgXCJTSEFERVJWQVJfVkVSVEVYX05VTUJFUlwiOiBcImF0dHJWZXJ0SW5kZXhcIixcbiAgICBcIlNIQURFUlZBUl9WRVJURVhfTk9STUFMXCI6IFwiYXR0clZlcnROb3JtYWxcIixcbiAgICBcIlNIQURFUlZBUl9WRVJURVhfVEVYQ09PUkRcIjogXCJhdHRyVGV4Q29vcmRcIixcbiAgICBcIlNIQURFUlZBUl9JTlNUQU5DRV9NTUFUUklYXCI6IFwiaW5zdE1hdFwiLFxuICAgIFwiU0hBREVSVkFSX1ZFUlRFWF9DT0xPUlwiOiBcImF0dHJWZXJ0Q29sb3JcIixcblxuICAgIFwiU0hBREVSVkFSX0lOU1RBTkNFX0lOREVYXCI6IFwiaW5zdGFuY2VJbmRleFwiLFxuXG4gICAgLy8gZGVmYXVsdCB1bmlmb3Jtc1xuICAgIFwiU0hBREVSVkFSX1VOSV9QUk9KTUFUXCI6IFwicHJvak1hdHJpeFwiLFxuICAgIFwiU0hBREVSVkFSX1VOSV9WSUVXTUFUXCI6IFwidmlld01hdHJpeFwiLFxuICAgIFwiU0hBREVSVkFSX1VOSV9NT0RFTE1BVFwiOiBcIm1vZGVsTWF0cml4XCIsXG4gICAgXCJTSEFERVJWQVJfVU5JX05PUk1BTE1BVFwiOiBcIm5vcm1hbE1hdHJpeFwiLFxuICAgIFwiU0hBREVSVkFSX1VOSV9JTlZWSUVXTUFUXCI6IFwiaW52ZXJzZVZpZXdNYXRyaXhcIixcbiAgICBcIlNIQURFUlZBUl9VTklfSU5WUFJPSk1BVFwiOiBcImludlByb2pNYXRyaXhcIixcbiAgICBcIlNIQURFUlZBUl9VTklfTUFURVJJQUxJRFwiOiBcIm1hdGVyaWFsSWRcIixcbiAgICBcIlNIQURFUlZBUl9VTklfT0JKRUNUSURcIjogXCJvYmplY3RJZFwiLFxuXG4gICAgXCJTSEFERVJWQVJfVU5JX1ZJRVdQT1NcIjogXCJjYW1Qb3NcIixcbn07XG5cblxuY29uc3QgQkxFTkRfTU9ERVMgPSB7XG4gICAgXCJCTEVORF9OT05FXCI6IDAsXG4gICAgXCJCTEVORF9OT1JNQUxcIjogMSxcbiAgICBcIkJMRU5EX0FERFwiOiAyLFxuICAgIFwiQkxFTkRfU1VCXCI6IDMsXG4gICAgXCJCTEVORF9NVUxcIjogNCxcbn07XG5cblxuXG5cblxuY29uc3QgUkFEMkRFRyA9IDE4MC4wIC8gTWF0aC5QSTtcbmNvbnN0IERFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLjA7XG5cbmNvbnN0IENPTlNUQU5UUyA9IHtcbiAgICBcIk1BVEhcIjoge1xuICAgICAgICBcIkRFRzJSQURcIjogREVHMlJBRCxcbiAgICAgICAgXCJSQUQyREVHXCI6IFJBRDJERUcsXG4gICAgfSxcbiAgICBcIlNIQURFUlwiOiBTSEFERVIsXG4gICAgXCJCTEVORF9NT0RFU1wiOiBCTEVORF9NT0RFUyxcbn07XG5cblxuZXhwb3J0IHsgQ09OU1RBTlRTIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgl/constants.js\n");

/***/ }),

/***/ "./src/core/cgl/index.js":
/*!*******************************!*\
  !*** ./src/core/cgl/index.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CGL\": () => (/* binding */ CGL)\n/* harmony export */ });\n/* harmony import */ var _cgl_framebuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cgl_framebuffer.js */ \"./src/core/cgl/cgl_framebuffer.js\");\n/* harmony import */ var _cgl_framebuffer2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgl_framebuffer2.js */ \"./src/core/cgl/cgl_framebuffer2.js\");\n/* harmony import */ var _cgl_marker_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cgl_marker.js */ \"./src/core/cgl/cgl_marker.js\");\n/* harmony import */ var _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cgl_mesh.js */ \"./src/core/cgl/cgl_mesh.js\");\n/* harmony import */ var _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./cgl_shader_uniform.js */ \"./src/core/cgl/cgl_shader_uniform.js\");\n/* harmony import */ var _cgl_shader_lib_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cgl_shader_lib.js */ \"./src/core/cgl/cgl_shader_lib.js\");\n/* harmony import */ var _cgl_unicolorshader_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./cgl_unicolorshader.js */ \"./src/core/cgl/cgl_unicolorshader.js\");\n/* harmony import */ var _cgl_shader_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cgl_shader.js */ \"./src/core/cgl/cgl_shader.js\");\n/* harmony import */ var _cgl_simplerect_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./cgl_simplerect.js */ \"./src/core/cgl/cgl_simplerect.js\");\n/* harmony import */ var _cgl_state_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./cgl_state.js */ \"./src/core/cgl/cgl_state.js\");\n/* harmony import */ var _cgl_utils_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./cgl_utils.js */ \"./src/core/cgl/cgl_utils.js\");\n/* harmony import */ var _cgl_texture_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./cgl_texture.js */ \"./src/core/cgl/cgl_texture.js\");\n/* harmony import */ var _cgl_textureeffect_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./cgl_textureeffect.js */ \"./src/core/cgl/cgl_textureeffect.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./constants.js */ \"./src/core/cgl/constants.js\");\n/* harmony import */ var _cgl_profiledata_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./cgl_profiledata.js */ \"./src/core/cgl/cgl_profiledata.js\");\n/* harmony import */ var _cg_cg_matrixstack_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cg/cg_matrixstack.js */ \"./src/core/cg/cg_matrixstack.js\");\n/* harmony import */ var _cg_cg_geom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cg/cg_geom.js */ \"./src/core/cg/cg_geom.js\");\n/* harmony import */ var _cg_cg_boundingbox_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cg/cg_boundingbox.js */ \"./src/core/cg/cg_boundingbox.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst CGL = {\n    \"Framebuffer\": _cgl_framebuffer_js__WEBPACK_IMPORTED_MODULE_0__.Framebuffer,\n    \"Framebuffer2\": _cgl_framebuffer2_js__WEBPACK_IMPORTED_MODULE_1__.Framebuffer2,\n    \"Geometry\": _cg_cg_geom_js__WEBPACK_IMPORTED_MODULE_2__.Geometry,\n    \"BoundingBox\": _cg_cg_boundingbox_js__WEBPACK_IMPORTED_MODULE_3__.BoundingBox,\n    \"Marker\": _cgl_marker_js__WEBPACK_IMPORTED_MODULE_4__.Marker,\n    \"WirePoint\": _cgl_marker_js__WEBPACK_IMPORTED_MODULE_4__.WirePoint,\n    \"WireCube\": _cgl_marker_js__WEBPACK_IMPORTED_MODULE_4__.WireCube,\n    \"MatrixStack\": _cg_cg_matrixstack_js__WEBPACK_IMPORTED_MODULE_5__.MatrixStack,\n    \"Mesh\": _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_6__.Mesh,\n    \"MESH\": _cgl_mesh_js__WEBPACK_IMPORTED_MODULE_6__.MESH,\n    \"ShaderLibMods\": _cgl_shader_lib_js__WEBPACK_IMPORTED_MODULE_7__.ShaderLibMods,\n    \"Shader\": _cgl_shader_js__WEBPACK_IMPORTED_MODULE_8__.Shader,\n    \"Uniform\": _cgl_shader_uniform_js__WEBPACK_IMPORTED_MODULE_9__.Uniform,\n    \"MESHES\": _cgl_simplerect_js__WEBPACK_IMPORTED_MODULE_10__.MESHES,\n    \"Context\": _cgl_state_js__WEBPACK_IMPORTED_MODULE_11__.Context,\n    \"Texture\": _cgl_texture_js__WEBPACK_IMPORTED_MODULE_12__.Texture,\n    \"TextureEffect\": _cgl_textureeffect_js__WEBPACK_IMPORTED_MODULE_13__.TextureEffect,\n    \"isWindows\": _cgl_utils_js__WEBPACK_IMPORTED_MODULE_14__.isWindows,\n    \"getWheelSpeed\": _cgl_utils_js__WEBPACK_IMPORTED_MODULE_14__.getWheelSpeed,\n    \"getWheelDelta\": _cgl_utils_js__WEBPACK_IMPORTED_MODULE_14__.getWheelDelta,\n    \"onLoadingAssetsFinished\": _cgl_utils_js__WEBPACK_IMPORTED_MODULE_14__.onLoadingAssetsFinished,\n    \"ProfileData\": _cgl_profiledata_js__WEBPACK_IMPORTED_MODULE_15__.ProfileData,\n    \"UniColorShader\": _cgl_unicolorshader_js__WEBPACK_IMPORTED_MODULE_16__.UniColorShader,\n    ..._constants_js__WEBPACK_IMPORTED_MODULE_17__.CONSTANTS.BLEND_MODES,\n    ..._constants_js__WEBPACK_IMPORTED_MODULE_17__.CONSTANTS.SHADER,\n    ..._constants_js__WEBPACK_IMPORTED_MODULE_17__.CONSTANTS.MATH,\n    ..._constants_js__WEBPACK_IMPORTED_MODULE_17__.CONSTANTS.BLEND_MODES,\n};\n\nwindow.CGL = CGL;\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ2wvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dsL2luZGV4LmpzPzViZmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRnJhbWVidWZmZXIgfSBmcm9tIFwiLi9jZ2xfZnJhbWVidWZmZXIuanNcIjtcbmltcG9ydCB7IEZyYW1lYnVmZmVyMiB9IGZyb20gXCIuL2NnbF9mcmFtZWJ1ZmZlcjIuanNcIjtcbmltcG9ydCB7IE1hcmtlciwgV2lyZUN1YmUsIFdpcmVQb2ludCB9IGZyb20gXCIuL2NnbF9tYXJrZXIuanNcIjtcbmltcG9ydCB7IE1lc2gsIE1FU0ggfSBmcm9tIFwiLi9jZ2xfbWVzaC5qc1wiO1xuaW1wb3J0IHsgVW5pZm9ybSB9IGZyb20gXCIuL2NnbF9zaGFkZXJfdW5pZm9ybS5qc1wiO1xuaW1wb3J0IHsgU2hhZGVyTGliTW9kcyB9IGZyb20gXCIuL2NnbF9zaGFkZXJfbGliLmpzXCI7XG5pbXBvcnQgeyBVbmlDb2xvclNoYWRlciB9IGZyb20gXCIuL2NnbF91bmljb2xvcnNoYWRlci5qc1wiO1xuXG5cbmltcG9ydCB7IFNoYWRlciB9IGZyb20gXCIuL2NnbF9zaGFkZXIuanNcIjtcbmltcG9ydCB7IE1FU0hFUyB9IGZyb20gXCIuL2NnbF9zaW1wbGVyZWN0LmpzXCI7XG5pbXBvcnQgeyBDb250ZXh0IH0gZnJvbSBcIi4vY2dsX3N0YXRlLmpzXCI7XG5pbXBvcnQge1xuICAgIGlzV2luZG93cywgZ2V0V2hlZWxTcGVlZCwgZ2V0V2hlZWxEZWx0YSwgb25Mb2FkaW5nQXNzZXRzRmluaXNoZWQsXG59IGZyb20gXCIuL2NnbF91dGlscy5qc1wiO1xuaW1wb3J0IHtcbiAgICBUZXh0dXJlLFxufSBmcm9tIFwiLi9jZ2xfdGV4dHVyZS5qc1wiO1xuXG5pbXBvcnQgeyBUZXh0dXJlRWZmZWN0IH0gZnJvbSBcIi4vY2dsX3RleHR1cmVlZmZlY3QuanNcIjtcbmltcG9ydCB7IENPTlNUQU5UUyB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgUHJvZmlsZURhdGEgfSBmcm9tIFwiLi9jZ2xfcHJvZmlsZWRhdGEuanNcIjtcbmltcG9ydCB7IE1hdHJpeFN0YWNrIH0gZnJvbSBcIi4uL2NnL2NnX21hdHJpeHN0YWNrLmpzXCI7XG5pbXBvcnQgeyBHZW9tZXRyeSB9IGZyb20gXCIuLi9jZy9jZ19nZW9tLmpzXCI7XG5pbXBvcnQgeyBCb3VuZGluZ0JveCB9IGZyb20gXCIuLi9jZy9jZ19ib3VuZGluZ2JveC5qc1wiO1xuXG5jb25zdCBDR0wgPSB7XG4gICAgXCJGcmFtZWJ1ZmZlclwiOiBGcmFtZWJ1ZmZlcixcbiAgICBcIkZyYW1lYnVmZmVyMlwiOiBGcmFtZWJ1ZmZlcjIsXG4gICAgXCJHZW9tZXRyeVwiOiBHZW9tZXRyeSxcbiAgICBcIkJvdW5kaW5nQm94XCI6IEJvdW5kaW5nQm94LFxuICAgIFwiTWFya2VyXCI6IE1hcmtlcixcbiAgICBcIldpcmVQb2ludFwiOiBXaXJlUG9pbnQsXG4gICAgXCJXaXJlQ3ViZVwiOiBXaXJlQ3ViZSxcbiAgICBcIk1hdHJpeFN0YWNrXCI6IE1hdHJpeFN0YWNrLFxuICAgIFwiTWVzaFwiOiBNZXNoLFxuICAgIFwiTUVTSFwiOiBNRVNILFxuICAgIFwiU2hhZGVyTGliTW9kc1wiOiBTaGFkZXJMaWJNb2RzLFxuICAgIFwiU2hhZGVyXCI6IFNoYWRlcixcbiAgICBcIlVuaWZvcm1cIjogVW5pZm9ybSxcbiAgICBcIk1FU0hFU1wiOiBNRVNIRVMsXG4gICAgXCJDb250ZXh0XCI6IENvbnRleHQsXG4gICAgXCJUZXh0dXJlXCI6IFRleHR1cmUsXG4gICAgXCJUZXh0dXJlRWZmZWN0XCI6IFRleHR1cmVFZmZlY3QsXG4gICAgXCJpc1dpbmRvd3NcIjogaXNXaW5kb3dzLFxuICAgIFwiZ2V0V2hlZWxTcGVlZFwiOiBnZXRXaGVlbFNwZWVkLFxuICAgIFwiZ2V0V2hlZWxEZWx0YVwiOiBnZXRXaGVlbERlbHRhLFxuICAgIFwib25Mb2FkaW5nQXNzZXRzRmluaXNoZWRcIjogb25Mb2FkaW5nQXNzZXRzRmluaXNoZWQsXG4gICAgXCJQcm9maWxlRGF0YVwiOiBQcm9maWxlRGF0YSxcbiAgICBcIlVuaUNvbG9yU2hhZGVyXCI6IFVuaUNvbG9yU2hhZGVyLFxuICAgIC4uLkNPTlNUQU5UUy5CTEVORF9NT0RFUyxcbiAgICAuLi5DT05TVEFOVFMuU0hBREVSLFxuICAgIC4uLkNPTlNUQU5UUy5NQVRILFxuICAgIC4uLkNPTlNUQU5UUy5CTEVORF9NT0RFUyxcbn07XG5cbndpbmRvdy5DR0wgPSBDR0w7XG5cbmV4cG9ydCB7IENHTCB9O1xuXG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cgl/index.js\n");

/***/ }),

/***/ "./src/core/cgp/cgp_mesh.js":
/*!**********************************!*\
  !*** ./src/core/cgp/cgp_mesh.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Mesh)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n/* harmony import */ var _cgp_pipeline_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgp_pipeline.js */ \"./src/core/cgp/cgp_pipeline.js\");\n\n\n\nclass Mesh\n{\n    constructor(_cgp, __geom)\n    {\n        this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"cgl_mesh\");\n        this._cgp = _cgp;\n        this._geom = null;\n        this.numIndex = 0;\n\n        this._pipe = new _cgp_pipeline_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this._cgp);\n\n        this._numNonIndexed = 0;\n        this._positionBuffer = null;\n        this._bufVerticesIndizes = null;\n        this._attributes = [];\n\n        this._needsPipelineUpdate = false;\n\n        if (__geom) this.setGeom(__geom);\n    }\n\n    _createBuffer(device, data, usage)\n    {\n        const buffer = device.createBuffer({\n            \"size\": data.byteLength,\n            \"usage\": usage,\n            \"mappedAtCreation\": true,\n        });\n        const dst = new data.constructor(buffer.getMappedRange());\n        dst.set(data);\n        buffer.unmap();\n        return buffer;\n    }\n\n    /**\n     * @function setGeom\n     * @memberof Mesh\n     * @instance\n     * @description set geometry for mesh\n     * @param {Geometry} geometry\n     */\n    setGeom(geom, removeRef)\n    {\n        this._needsPipelineUpdate = true;\n        this._geom = geom;\n        this._disposeAttributes();\n\n        this._positionBuffer = this._createBuffer(this._cgp.device, new Float32Array(geom.vertices), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);\n\n        let vi = geom.verticesIndices;\n        if (!geom.isIndexed()) vi = Array.from(Array(geom.vertices.length / 3).keys());\n        this._numIndices = vi.length;\n        this._indicesBuffer = this._createBuffer(this._cgp.device, new Uint32Array(vi), GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST);\n\n        if (geom.texCoords && geom.texCoords.length) this.setAttribute(\"texCoords\", geom.texCoords, 2);\n        if (geom.vertexNormals && geom.vertexNormals.length) this.setAttribute(\"normals\", geom.vertexNormals, 3);\n    }\n\n\n    _disposeAttributes()\n    {\n        this._needsPipelineUpdate = true;\n        for (let i = 0; i < this._attributes.length; i++)\n        {\n            this._attributes[i].buffer.destroy();\n        }\n        this._attributes.length = 0;\n    }\n\n    dispose()\n    {\n        this._disposeAttributes();\n    }\n\n    /**\n     * @function setAttribute\n     * @description update attribute\n     * @memberof Mesh\n     * @instance\n     * @param {String} attribute name\n     * @param {Array} data\n     * @param {Number} itemSize\n     * @param {Object} options\n     */\n    setAttribute(name, array, itemSize, options)\n    {\n        if (!array)\n        {\n            this._log.error(\"mesh addAttribute - no array given! \" + name);\n            throw new Error();\n        }\n\n        for (let i = 0; i < this._attributes.length; i++)\n        {\n            const attr = this._attributes[i];\n            if (attr.name == name)\n            {\n                // if (attr.numItems === numItems)\n                // {\n                // }\n                // else\n                // {\n                //     // this._log.log(\"wrong buffer size\", this._geom.name, attr.name, attr.numItems, numItems);\n                //     this._resizeAttr(array, attr);\n                // }\n                // normalBuffer = this._createBuffer(this._cgp.device, new Float32Array(geom.vertexNormals), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);\n\n                // this._cgl.gl.bindBuffer(this._cgl.gl.ARRAY_BUFFER, attr.buffer);\n                // this._bufferArray(array, attr);\n\n                return attr;\n            }\n        }\n\n        const buffer = this._createBuffer(this._cgp.device, new Float32Array(array), GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST);\n\n        const attr = {\n            \"buffer\": buffer,\n            \"name\": name,\n            // \"cb\": cb,\n            // \"itemSize\": itemSize,\n            // \"numItems\": numItems,\n            // \"startItem\": 0,\n            // \"instanced\": instanced,\n            // \"type\": type\n        };\n        this._attributes.push(attr);\n\n        return attr;\n    }\n\n    // setPipeline()\n    // {\n\n    //     this._cgp.passEncoder.setPipeline(this._pipe.getPiplelineObject(this._cgp.getShader(),this));\n\n\n    // }\n\n    render()\n    {\n        if (!this._positionBuffer) return;\n\n        // this.setPipeline();\n\n        const shader = this._cgp.getShader();\n        if (shader)shader.bind();\n\n        if (!this._cgp.getShader() || !this._cgp.getShader().isValid)\n        {\n            // console.log(\"invalid\");\n            return;\n        }\n\n        this._pipe.setPipeline(this._cgp.getShader(), this);\n\n        if (!this._pipe.isValid)\n        {\n            // console.log(\"invalid\");\n            return;\n        }\n\n\n        this._cgp.passEncoder.setVertexBuffer(0, this._positionBuffer);\n        for (let i = 0; i < this._attributes.length; i++)\n        {\n            this._cgp.passEncoder.setVertexBuffer(i + 1, this._attributes[i].buffer);\n        }\n\n        this._cgp.passEncoder.setIndexBuffer(this._indicesBuffer, \"uint32\");\n\n        if (this._numNonIndexed)\n            this._cgp.passEncoder.draw(this._numIndices);\n        else\n            this._cgp.passEncoder.drawIndexed(this._numIndices);\n\n        // if (shader)shader.unbind();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvY2dwX21lc2guanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dwL2NncF9tZXNoLmpzPzQyNDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcImNhYmxlcy1zaGFyZWQtY2xpZW50XCI7XG5pbXBvcnQgUGlwZWxpbmUgZnJvbSBcIi4vY2dwX3BpcGVsaW5lLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lc2hcbntcbiAgICBjb25zdHJ1Y3RvcihfY2dwLCBfX2dlb20pXG4gICAge1xuICAgICAgICB0aGlzLl9sb2cgPSBuZXcgTG9nZ2VyKFwiY2dsX21lc2hcIik7XG4gICAgICAgIHRoaXMuX2NncCA9IF9jZ3A7XG4gICAgICAgIHRoaXMuX2dlb20gPSBudWxsO1xuICAgICAgICB0aGlzLm51bUluZGV4ID0gMDtcblxuICAgICAgICB0aGlzLl9waXBlID0gbmV3IFBpcGVsaW5lKHRoaXMuX2NncCk7XG5cbiAgICAgICAgdGhpcy5fbnVtTm9uSW5kZXhlZCA9IDA7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYnVmVmVydGljZXNJbmRpemVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlcyA9IFtdO1xuXG4gICAgICAgIHRoaXMuX25lZWRzUGlwZWxpbmVVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoX19nZW9tKSB0aGlzLnNldEdlb20oX19nZW9tKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQnVmZmVyKGRldmljZSwgZGF0YSwgdXNhZ2UpXG4gICAge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBkZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgICAgIFwic2l6ZVwiOiBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICBcInVzYWdlXCI6IHVzYWdlLFxuICAgICAgICAgICAgXCJtYXBwZWRBdENyZWF0aW9uXCI6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkc3QgPSBuZXcgZGF0YS5jb25zdHJ1Y3RvcihidWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKSk7XG4gICAgICAgIGRzdC5zZXQoZGF0YSk7XG4gICAgICAgIGJ1ZmZlci51bm1hcCgpO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBzZXRHZW9tXG4gICAgICogQG1lbWJlcm9mIE1lc2hcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAZGVzY3JpcHRpb24gc2V0IGdlb21ldHJ5IGZvciBtZXNoXG4gICAgICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnlcbiAgICAgKi9cbiAgICBzZXRHZW9tKGdlb20sIHJlbW92ZVJlZilcbiAgICB7XG4gICAgICAgIHRoaXMuX25lZWRzUGlwZWxpbmVVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9nZW9tID0gZ2VvbTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZUF0dHJpYnV0ZXMoKTtcblxuICAgICAgICB0aGlzLl9wb3NpdGlvbkJ1ZmZlciA9IHRoaXMuX2NyZWF0ZUJ1ZmZlcih0aGlzLl9jZ3AuZGV2aWNlLCBuZXcgRmxvYXQzMkFycmF5KGdlb20udmVydGljZXMpLCBHUFVCdWZmZXJVc2FnZS5WRVJURVggfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCk7XG5cbiAgICAgICAgbGV0IHZpID0gZ2VvbS52ZXJ0aWNlc0luZGljZXM7XG4gICAgICAgIGlmICghZ2VvbS5pc0luZGV4ZWQoKSkgdmkgPSBBcnJheS5mcm9tKEFycmF5KGdlb20udmVydGljZXMubGVuZ3RoIC8gMykua2V5cygpKTtcbiAgICAgICAgdGhpcy5fbnVtSW5kaWNlcyA9IHZpLmxlbmd0aDtcbiAgICAgICAgdGhpcy5faW5kaWNlc0J1ZmZlciA9IHRoaXMuX2NyZWF0ZUJ1ZmZlcih0aGlzLl9jZ3AuZGV2aWNlLCBuZXcgVWludDMyQXJyYXkodmkpLCBHUFVCdWZmZXJVc2FnZS5JTkRFWCB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUKTtcblxuICAgICAgICBpZiAoZ2VvbS50ZXhDb29yZHMgJiYgZ2VvbS50ZXhDb29yZHMubGVuZ3RoKSB0aGlzLnNldEF0dHJpYnV0ZShcInRleENvb3Jkc1wiLCBnZW9tLnRleENvb3JkcywgMik7XG4gICAgICAgIGlmIChnZW9tLnZlcnRleE5vcm1hbHMgJiYgZ2VvbS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCkgdGhpcy5zZXRBdHRyaWJ1dGUoXCJub3JtYWxzXCIsIGdlb20udmVydGV4Tm9ybWFscywgMyk7XG4gICAgfVxuXG5cbiAgICBfZGlzcG9zZUF0dHJpYnV0ZXMoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbmVlZHNQaXBlbGluZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlc1tpXS5idWZmZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZXMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBkaXNwb3NlKClcbiAgICB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VBdHRyaWJ1dGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHNldEF0dHJpYnV0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiB1cGRhdGUgYXR0cmlidXRlXG4gICAgICogQG1lbWJlcm9mIE1lc2hcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZW1TaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBzZXRBdHRyaWJ1dGUobmFtZSwgYXJyYXksIGl0ZW1TaXplLCBvcHRpb25zKVxuICAgIHtcbiAgICAgICAgaWYgKCFhcnJheSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwibWVzaCBhZGRBdHRyaWJ1dGUgLSBubyBhcnJheSBnaXZlbiEgXCIgKyBuYW1lKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBhdHRyID0gdGhpcy5fYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAoYXR0ci5udW1JdGVtcyA9PT0gbnVtSXRlbXMpXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAvLyBlbHNlXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgICAvLyB0aGlzLl9sb2cubG9nKFwid3JvbmcgYnVmZmVyIHNpemVcIiwgdGhpcy5fZ2VvbS5uYW1lLCBhdHRyLm5hbWUsIGF0dHIubnVtSXRlbXMsIG51bUl0ZW1zKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5fcmVzaXplQXR0cihhcnJheSwgYXR0cik7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbEJ1ZmZlciA9IHRoaXMuX2NyZWF0ZUJ1ZmZlcih0aGlzLl9jZ3AuZGV2aWNlLCBuZXcgRmxvYXQzMkFycmF5KGdlb20udmVydGV4Tm9ybWFscyksIEdQVUJ1ZmZlclVzYWdlLlZFUlRFWCB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUKTtcblxuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2NnbC5nbC5iaW5kQnVmZmVyKHRoaXMuX2NnbC5nbC5BUlJBWV9CVUZGRVIsIGF0dHIuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9idWZmZXJBcnJheShhcnJheSwgYXR0cik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2NyZWF0ZUJ1ZmZlcih0aGlzLl9jZ3AuZGV2aWNlLCBuZXcgRmxvYXQzMkFycmF5KGFycmF5KSwgR1BVQnVmZmVyVXNhZ2UuVkVSVEVYIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QpO1xuXG4gICAgICAgIGNvbnN0IGF0dHIgPSB7XG4gICAgICAgICAgICBcImJ1ZmZlclwiOiBidWZmZXIsXG4gICAgICAgICAgICBcIm5hbWVcIjogbmFtZSxcbiAgICAgICAgICAgIC8vIFwiY2JcIjogY2IsXG4gICAgICAgICAgICAvLyBcIml0ZW1TaXplXCI6IGl0ZW1TaXplLFxuICAgICAgICAgICAgLy8gXCJudW1JdGVtc1wiOiBudW1JdGVtcyxcbiAgICAgICAgICAgIC8vIFwic3RhcnRJdGVtXCI6IDAsXG4gICAgICAgICAgICAvLyBcImluc3RhbmNlZFwiOiBpbnN0YW5jZWQsXG4gICAgICAgICAgICAvLyBcInR5cGVcIjogdHlwZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG5cbiAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfVxuXG4gICAgLy8gc2V0UGlwZWxpbmUoKVxuICAgIC8vIHtcblxuICAgIC8vICAgICB0aGlzLl9jZ3AucGFzc0VuY29kZXIuc2V0UGlwZWxpbmUodGhpcy5fcGlwZS5nZXRQaXBsZWxpbmVPYmplY3QodGhpcy5fY2dwLmdldFNoYWRlcigpLHRoaXMpKTtcblxuXG4gICAgLy8gfVxuXG4gICAgcmVuZGVyKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5fcG9zaXRpb25CdWZmZXIpIHJldHVybjtcblxuICAgICAgICAvLyB0aGlzLnNldFBpcGVsaW5lKCk7XG5cbiAgICAgICAgY29uc3Qgc2hhZGVyID0gdGhpcy5fY2dwLmdldFNoYWRlcigpO1xuICAgICAgICBpZiAoc2hhZGVyKXNoYWRlci5iaW5kKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jZ3AuZ2V0U2hhZGVyKCkgfHwgIXRoaXMuX2NncC5nZXRTaGFkZXIoKS5pc1ZhbGlkKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImludmFsaWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9waXBlLnNldFBpcGVsaW5lKHRoaXMuX2NncC5nZXRTaGFkZXIoKSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9waXBlLmlzVmFsaWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiaW52YWxpZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGhpcy5fY2dwLnBhc3NFbmNvZGVyLnNldFZlcnRleEJ1ZmZlcigwLCB0aGlzLl9wb3NpdGlvbkJ1ZmZlcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXR0cmlidXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2dwLnBhc3NFbmNvZGVyLnNldFZlcnRleEJ1ZmZlcihpICsgMSwgdGhpcy5fYXR0cmlidXRlc1tpXS5idWZmZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2dwLnBhc3NFbmNvZGVyLnNldEluZGV4QnVmZmVyKHRoaXMuX2luZGljZXNCdWZmZXIsIFwidWludDMyXCIpO1xuXG4gICAgICAgIGlmICh0aGlzLl9udW1Ob25JbmRleGVkKVxuICAgICAgICAgICAgdGhpcy5fY2dwLnBhc3NFbmNvZGVyLmRyYXcodGhpcy5fbnVtSW5kaWNlcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuX2NncC5wYXNzRW5jb2Rlci5kcmF3SW5kZXhlZCh0aGlzLl9udW1JbmRpY2VzKTtcblxuICAgICAgICAvLyBpZiAoc2hhZGVyKXNoYWRlci51bmJpbmQoKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgp/cgp_mesh.js\n");

/***/ }),

/***/ "./src/core/cgp/cgp_pipeline.js":
/*!**************************************!*\
  !*** ./src/core/cgp/cgp_pipeline.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Pipeline)\n/* harmony export */ });\n/* harmony import */ var _cgp_uniformbuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cgp_uniformbuffer.js */ \"./src/core/cgp/cgp_uniformbuffer.js\");\n\n\n\nclass Pipeline\n{\n    constructor(_cgp, _name)\n    {\n        if (!_cgp) throw new Error(\"Pipeline constructed without cgp \" + _name);\n        this._cgp = _cgp;\n        this._isValid = true;\n\n        this._pipeCfg = null;\n        this._renderPipeline = null;\n\n        this._fsUniformBuffer = null;\n        this._vsUniformBuffer = null;\n\n        this._old = {};\n\n\n        this.DEPTH_COMPARE_FUNCS_STRINGS = [\n            \"never\",\n            \"less\",\n            \"equal\",\n            \"lessequal\",\n            \"greater\",\n            \"notequal\",\n            \"greaterequal\",\n            \"always\"];\n    }\n\n    get isValid() { return this._isValid; }\n\n    setPipeline(shader, mesh)\n    {\n        if (!mesh || !shader)\n        {\n            console.log(\"pipeline unknown shader/mesh\");\n            return;\n        }\n\n        let needsRebuild =\n            !this._renderPipeline ||\n            !this._pipeCfg ||\n            this._old.mesh != mesh ||\n            this._old.shader != shader ||\n            mesh.needsPipelineUpdate ||\n            shader.needsPipelineUpdate;\n\n        if (this._pipeCfg)\n        {\n            if (this._pipeCfg.depthStencil.depthWriteEnabled != this._cgp.stateDepthWrite())\n            {\n                needsRebuild = true;\n                this._pipeCfg.depthStencil.depthWriteEnabled = this._cgp.stateDepthWrite();\n            }\n\n            if (this._cgp.stateDepthTest() === false)\n            {\n                if (this._pipeCfg.depthStencil.depthCompare != \"never\")\n                {\n                    this._pipeCfg.depthStencil.depthCompare = \"never\";\n                    needsRebuild = true;\n                }\n            }\n            else\n            if (this._pipeCfg.depthStencil.depthCompare != this._cgp.stateDepthFunc())\n            {\n                needsRebuild = true;\n                this._pipeCfg.depthStencil.depthCompare = this._cgp.stateDepthFunc();\n            }\n\n\n            if (this._cgp.stateCullFace() === false)\n            {\n                if (this._pipeCfg.primitive.cullMode != \"none\")\n                {\n                    needsRebuild = true;\n                    this._pipeCfg.primitive.cullMode = \"none\";\n                }\n            }\n            else\n            {\n                needsRebuild = true;\n                this._pipeCfg.primitive.cullMode = this._cgp.stateCullFaceFacing();\n            }\n        }\n\n        if (needsRebuild)\n        {\n            if (!this._pipeCfg || this._old.shader != shader) this._pipeCfg = this.getPiplelineObject(shader, mesh);\n\n            this._old.shader = shader;\n            this._old.mesh = mesh;\n\n\n            // try\n            // {\n            this._renderPipeline = this._cgp.device.createRenderPipeline(this._pipeCfg);\n            // }\n            // catch (e)\n            // {\n            //     console.error(e.message);\n            // }\n\n            this._bindUniforms(shader);\n        }\n\n        if (this._renderPipeline && this._isValid)\n        {\n            mat4.copy(this._matModel, this._cgp.mMatrix);\n            mat4.copy(this._matView, this._cgp.vMatrix);\n            mat4.copy(this._matProj, this._cgp.pMatrix);\n\n            this._cgp.device.queue.writeBuffer(\n                this._vsUniformBuffer,\n                0,\n                this._vsUniformValues.buffer,\n                this._vsUniformValues.byteOffset,\n                this._vsUniformValues.byteLength\n            );\n\n            this._uniBufFrag.updateUniformValues();\n\n            this._cgp.passEncoder.setPipeline(this._renderPipeline);\n            this._cgp.passEncoder.setBindGroup(0, this._bindGroup);\n            // this._pipeline = this._cgp.device.createRenderPipeline(this._pipeCfg);\n        }\n    }\n\n    getPiplelineObject(shader, mesh)\n    {\n        const pipeCfg = {\n            \"layout\": \"auto\",\n            \"vertex\": {\n                \"module\": shader.shaderModule,\n                \"entryPoint\": \"myVSMain\",\n                \"buffers\": [\n                    // position\n                    {\n                        \"arrayStride\": 3 * 4, // 3 floats, 4 bytes each\n                        \"attributes\": [\n                            { \"shaderLocation\": 0, \"offset\": 0, \"format\": \"float32x3\" },\n                        ],\n                    },\n                    // normals\n                    {\n                        \"arrayStride\": 3 * 4, // 3 floats, 4 bytes each\n                        \"attributes\": [\n                            { \"shaderLocation\": 1, \"offset\": 0, \"format\": \"float32x3\" },\n                        ],\n                    },\n                    // texcoords\n                    {\n                        \"arrayStride\": 2 * 4, // 2 floats, 4 bytes each\n                        \"attributes\": [\n                            { \"shaderLocation\": 2, \"offset\": 0, \"format\": \"float32x2\", },\n                        ],\n                    },\n                ],\n            },\n            \"fragment\": {\n                \"module\": shader.shaderModule,\n                \"entryPoint\": \"myFSMain\",\n                \"targets\": [\n                    { \"format\": this._cgp.presentationFormat },\n                ],\n            },\n            \"primitive\": {\n                \"topology\": \"triangle-list\",\n                \"cullMode\": \"back\", // back/none/front\n\n                // \"point-list\",\n                // \"line-list\",\n                // \"line-strip\",\n                // \"triangle-list\",\n                // \"triangle-strip\"\n            },\n            \"depthStencil\": {\n                \"depthWriteEnabled\": true,\n                \"depthCompare\": \"less\",\n                \"format\": \"depth24plus\",\n            },\n\n        };\n\n        return pipeCfg;\n    }\n\n\n    _bindUniforms(shader)\n    {\n        this._cgp.pushErrorScope();\n\n\n        const counts = { };\n\n        this._uniBufFrag = new _cgp_uniformbuffer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](shader, \"frag\");\n\n        // for (let i = 0; i < shader.uniforms.length; i++)\n        // {\n        //     const uni = shader.uniforms[i];\n        //     const type = uni.shaderType;\n        //     counts[type] = counts[type] || 0;\n\n\n        //     counts[type] += uni.getSizeBytes();\n        // }\n        // console.log(counts, counts.frag);\n\n\n        const vUniformBufferSize = 3 * 16 * 4; // 2 mat4s * 16 floats per mat * 4 bytes per float\n        // const fUniformBufferSize = counts.frag;// 2 * 3 * 4; // 1 vec3 * 3 floats per vec3 * 4 bytes per float\n\n        this._vsUniformBuffer = this._cgp.device.createBuffer({\n            \"size\": vUniformBufferSize,\n            \"usage\": GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        });\n\n        // this._fsUniformBuffer = this._cgp.device.createBuffer({\n        //     \"size\": fUniformBufferSize,\n        //     \"usage\": GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        // });\n\n        // this._fsUniformValues = new Float32Array(counts.frag / 4);\n\n        this._vsUniformValues = new Float32Array(vUniformBufferSize / 4);\n\n        this._matModel = this._vsUniformValues.subarray(0, 16);\n        this._matView = this._vsUniformValues.subarray(16, 32);\n        this._matProj = this._vsUniformValues.subarray(32, 48);\n\n\n        // this._fsUniformValues[1] = 1.0;\n        // this._fsUniformValues[0] = 1.0;\n        // const lightDirection = this._fsUniformValues.subarray(0, 3);\n\n        // console.log(\"pipeline bindgrouplayout \", pipeline.getBindGroupLayout(0));\n\n        this._bindGroup = this._cgp.device.createBindGroup(\n            {\n                \"layout\": this._renderPipeline.getBindGroupLayout(0),\n                \"entries\": [\n                    { \"binding\": 0, \"resource\": { \"buffer\": this._vsUniformBuffer } },\n                    { \"binding\": 1, \"resource\": { \"buffer\": this._uniBufFrag._gpuBuffer } }\n                    //   { binding: 2, resource: sampler },\n                    //   { binding: 3, resource: tex.createView() },\n                ],\n            });\n\n        this._cgp.device.queue.writeBuffer(\n            this._vsUniformBuffer,\n            0,\n            this._vsUniformValues.buffer,\n            this._vsUniformValues.byteOffset,\n            this._vsUniformValues.byteLength\n        );\n\n        this._uniBufFrag.updateUniformValues();\n        this._cgp.popErrorScope(\"cgp_pipeline end\", (e) =>\n        {\n            this._isValid = false;\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvY2dwX3BpcGVsaW5lLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NncC9jZ3BfcGlwZWxpbmUuanM/YTVlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBVbmlmb3JtIH0gZnJvbSBcIi4uL2NnbC9jZ2xfc2hhZGVyX3VuaWZvcm0uanNcIjtcbmltcG9ydCBVbmlmb3JtQnVmZmVyIGZyb20gXCIuL2NncF91bmlmb3JtYnVmZmVyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBpcGVsaW5lXG57XG4gICAgY29uc3RydWN0b3IoX2NncCwgX25hbWUpXG4gICAge1xuICAgICAgICBpZiAoIV9jZ3ApIHRocm93IG5ldyBFcnJvcihcIlBpcGVsaW5lIGNvbnN0cnVjdGVkIHdpdGhvdXQgY2dwIFwiICsgX25hbWUpO1xuICAgICAgICB0aGlzLl9jZ3AgPSBfY2dwO1xuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9waXBlQ2ZnID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVuZGVyUGlwZWxpbmUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2ZzVW5pZm9ybUJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ZzVW5pZm9ybUJ1ZmZlciA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fb2xkID0ge307XG5cblxuICAgICAgICB0aGlzLkRFUFRIX0NPTVBBUkVfRlVOQ1NfU1RSSU5HUyA9IFtcbiAgICAgICAgICAgIFwibmV2ZXJcIixcbiAgICAgICAgICAgIFwibGVzc1wiLFxuICAgICAgICAgICAgXCJlcXVhbFwiLFxuICAgICAgICAgICAgXCJsZXNzZXF1YWxcIixcbiAgICAgICAgICAgIFwiZ3JlYXRlclwiLFxuICAgICAgICAgICAgXCJub3RlcXVhbFwiLFxuICAgICAgICAgICAgXCJncmVhdGVyZXF1YWxcIixcbiAgICAgICAgICAgIFwiYWx3YXlzXCJdO1xuICAgIH1cblxuICAgIGdldCBpc1ZhbGlkKCkgeyByZXR1cm4gdGhpcy5faXNWYWxpZDsgfVxuXG4gICAgc2V0UGlwZWxpbmUoc2hhZGVyLCBtZXNoKVxuICAgIHtcbiAgICAgICAgaWYgKCFtZXNoIHx8ICFzaGFkZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicGlwZWxpbmUgdW5rbm93biBzaGFkZXIvbWVzaFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuZWVkc1JlYnVpbGQgPVxuICAgICAgICAgICAgIXRoaXMuX3JlbmRlclBpcGVsaW5lIHx8XG4gICAgICAgICAgICAhdGhpcy5fcGlwZUNmZyB8fFxuICAgICAgICAgICAgdGhpcy5fb2xkLm1lc2ggIT0gbWVzaCB8fFxuICAgICAgICAgICAgdGhpcy5fb2xkLnNoYWRlciAhPSBzaGFkZXIgfHxcbiAgICAgICAgICAgIG1lc2gubmVlZHNQaXBlbGluZVVwZGF0ZSB8fFxuICAgICAgICAgICAgc2hhZGVyLm5lZWRzUGlwZWxpbmVVcGRhdGU7XG5cbiAgICAgICAgaWYgKHRoaXMuX3BpcGVDZmcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9waXBlQ2ZnLmRlcHRoU3RlbmNpbC5kZXB0aFdyaXRlRW5hYmxlZCAhPSB0aGlzLl9jZ3Auc3RhdGVEZXB0aFdyaXRlKCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmVlZHNSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9waXBlQ2ZnLmRlcHRoU3RlbmNpbC5kZXB0aFdyaXRlRW5hYmxlZCA9IHRoaXMuX2NncC5zdGF0ZURlcHRoV3JpdGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2NncC5zdGF0ZURlcHRoVGVzdCgpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGlwZUNmZy5kZXB0aFN0ZW5jaWwuZGVwdGhDb21wYXJlICE9IFwibmV2ZXJcIilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BpcGVDZmcuZGVwdGhTdGVuY2lsLmRlcHRoQ29tcGFyZSA9IFwibmV2ZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiAodGhpcy5fcGlwZUNmZy5kZXB0aFN0ZW5jaWwuZGVwdGhDb21wYXJlICE9IHRoaXMuX2NncC5zdGF0ZURlcHRoRnVuYygpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5lZWRzUmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGlwZUNmZy5kZXB0aFN0ZW5jaWwuZGVwdGhDb21wYXJlID0gdGhpcy5fY2dwLnN0YXRlRGVwdGhGdW5jKCk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2NncC5zdGF0ZUN1bGxGYWNlKCkgPT09IGZhbHNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9waXBlQ2ZnLnByaW1pdGl2ZS5jdWxsTW9kZSAhPSBcIm5vbmVcIilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5lZWRzUmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BpcGVDZmcucHJpbWl0aXZlLmN1bGxNb2RlID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5lZWRzUmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGlwZUNmZy5wcmltaXRpdmUuY3VsbE1vZGUgPSB0aGlzLl9jZ3Auc3RhdGVDdWxsRmFjZUZhY2luZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5lZWRzUmVidWlsZClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9waXBlQ2ZnIHx8IHRoaXMuX29sZC5zaGFkZXIgIT0gc2hhZGVyKSB0aGlzLl9waXBlQ2ZnID0gdGhpcy5nZXRQaXBsZWxpbmVPYmplY3Qoc2hhZGVyLCBtZXNoKTtcblxuICAgICAgICAgICAgdGhpcy5fb2xkLnNoYWRlciA9IHNoYWRlcjtcbiAgICAgICAgICAgIHRoaXMuX29sZC5tZXNoID0gbWVzaDtcblxuXG4gICAgICAgICAgICAvLyB0cnlcbiAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclBpcGVsaW5lID0gdGhpcy5fY2dwLmRldmljZS5jcmVhdGVSZW5kZXJQaXBlbGluZSh0aGlzLl9waXBlQ2ZnKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIGNhdGNoIChlKVxuICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgdGhpcy5fYmluZFVuaWZvcm1zKHNoYWRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyUGlwZWxpbmUgJiYgdGhpcy5faXNWYWxpZClcbiAgICAgICAge1xuICAgICAgICAgICAgbWF0NC5jb3B5KHRoaXMuX21hdE1vZGVsLCB0aGlzLl9jZ3AubU1hdHJpeCk7XG4gICAgICAgICAgICBtYXQ0LmNvcHkodGhpcy5fbWF0VmlldywgdGhpcy5fY2dwLnZNYXRyaXgpO1xuICAgICAgICAgICAgbWF0NC5jb3B5KHRoaXMuX21hdFByb2osIHRoaXMuX2NncC5wTWF0cml4KTtcblxuICAgICAgICAgICAgdGhpcy5fY2dwLmRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihcbiAgICAgICAgICAgICAgICB0aGlzLl92c1VuaWZvcm1CdWZmZXIsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICB0aGlzLl92c1VuaWZvcm1WYWx1ZXMuYnVmZmVyLFxuICAgICAgICAgICAgICAgIHRoaXMuX3ZzVW5pZm9ybVZhbHVlcy5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHRoaXMuX3ZzVW5pZm9ybVZhbHVlcy5ieXRlTGVuZ3RoXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLl91bmlCdWZGcmFnLnVwZGF0ZVVuaWZvcm1WYWx1ZXMoKTtcblxuICAgICAgICAgICAgdGhpcy5fY2dwLnBhc3NFbmNvZGVyLnNldFBpcGVsaW5lKHRoaXMuX3JlbmRlclBpcGVsaW5lKTtcbiAgICAgICAgICAgIHRoaXMuX2NncC5wYXNzRW5jb2Rlci5zZXRCaW5kR3JvdXAoMCwgdGhpcy5fYmluZEdyb3VwKTtcbiAgICAgICAgICAgIC8vIHRoaXMuX3BpcGVsaW5lID0gdGhpcy5fY2dwLmRldmljZS5jcmVhdGVSZW5kZXJQaXBlbGluZSh0aGlzLl9waXBlQ2ZnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFBpcGxlbGluZU9iamVjdChzaGFkZXIsIG1lc2gpXG4gICAge1xuICAgICAgICBjb25zdCBwaXBlQ2ZnID0ge1xuICAgICAgICAgICAgXCJsYXlvdXRcIjogXCJhdXRvXCIsXG4gICAgICAgICAgICBcInZlcnRleFwiOiB7XG4gICAgICAgICAgICAgICAgXCJtb2R1bGVcIjogc2hhZGVyLnNoYWRlck1vZHVsZSxcbiAgICAgICAgICAgICAgICBcImVudHJ5UG9pbnRcIjogXCJteVZTTWFpblwiLFxuICAgICAgICAgICAgICAgIFwiYnVmZmVyc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJyYXlTdHJpZGVcIjogMyAqIDQsIC8vIDMgZmxvYXRzLCA0IGJ5dGVzIGVhY2hcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXR0cmlidXRlc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcInNoYWRlckxvY2F0aW9uXCI6IDAsIFwib2Zmc2V0XCI6IDAsIFwiZm9ybWF0XCI6IFwiZmxvYXQzMngzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vcm1hbHNcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhcnJheVN0cmlkZVwiOiAzICogNCwgLy8gMyBmbG9hdHMsIDQgYnl0ZXMgZWFjaFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IFwic2hhZGVyTG9jYXRpb25cIjogMSwgXCJvZmZzZXRcIjogMCwgXCJmb3JtYXRcIjogXCJmbG9hdDMyeDNcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGV4Y29vcmRzXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJyYXlTdHJpZGVcIjogMiAqIDQsIC8vIDIgZmxvYXRzLCA0IGJ5dGVzIGVhY2hcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXR0cmlidXRlc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBcInNoYWRlckxvY2F0aW9uXCI6IDIsIFwib2Zmc2V0XCI6IDAsIFwiZm9ybWF0XCI6IFwiZmxvYXQzMngyXCIsIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmcmFnbWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJtb2R1bGVcIjogc2hhZGVyLnNoYWRlck1vZHVsZSxcbiAgICAgICAgICAgICAgICBcImVudHJ5UG9pbnRcIjogXCJteUZTTWFpblwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0c1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgXCJmb3JtYXRcIjogdGhpcy5fY2dwLnByZXNlbnRhdGlvbkZvcm1hdCB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJwcmltaXRpdmVcIjoge1xuICAgICAgICAgICAgICAgIFwidG9wb2xvZ3lcIjogXCJ0cmlhbmdsZS1saXN0XCIsXG4gICAgICAgICAgICAgICAgXCJjdWxsTW9kZVwiOiBcImJhY2tcIiwgLy8gYmFjay9ub25lL2Zyb250XG5cbiAgICAgICAgICAgICAgICAvLyBcInBvaW50LWxpc3RcIixcbiAgICAgICAgICAgICAgICAvLyBcImxpbmUtbGlzdFwiLFxuICAgICAgICAgICAgICAgIC8vIFwibGluZS1zdHJpcFwiLFxuICAgICAgICAgICAgICAgIC8vIFwidHJpYW5nbGUtbGlzdFwiLFxuICAgICAgICAgICAgICAgIC8vIFwidHJpYW5nbGUtc3RyaXBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZGVwdGhTdGVuY2lsXCI6IHtcbiAgICAgICAgICAgICAgICBcImRlcHRoV3JpdGVFbmFibGVkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJkZXB0aENvbXBhcmVcIjogXCJsZXNzXCIsXG4gICAgICAgICAgICAgICAgXCJmb3JtYXRcIjogXCJkZXB0aDI0cGx1c1wiLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBwaXBlQ2ZnO1xuICAgIH1cblxuXG4gICAgX2JpbmRVbmlmb3JtcyhzaGFkZXIpXG4gICAge1xuICAgICAgICB0aGlzLl9jZ3AucHVzaEVycm9yU2NvcGUoKTtcblxuXG4gICAgICAgIGNvbnN0IGNvdW50cyA9IHsgfTtcblxuICAgICAgICB0aGlzLl91bmlCdWZGcmFnID0gbmV3IFVuaWZvcm1CdWZmZXIoc2hhZGVyLCBcImZyYWdcIik7XG5cbiAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFkZXIudW5pZm9ybXMubGVuZ3RoOyBpKyspXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICAgIGNvbnN0IHVuaSA9IHNoYWRlci51bmlmb3Jtc1tpXTtcbiAgICAgICAgLy8gICAgIGNvbnN0IHR5cGUgPSB1bmkuc2hhZGVyVHlwZTtcbiAgICAgICAgLy8gICAgIGNvdW50c1t0eXBlXSA9IGNvdW50c1t0eXBlXSB8fCAwO1xuXG5cbiAgICAgICAgLy8gICAgIGNvdW50c1t0eXBlXSArPSB1bmkuZ2V0U2l6ZUJ5dGVzKCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coY291bnRzLCBjb3VudHMuZnJhZyk7XG5cblxuICAgICAgICBjb25zdCB2VW5pZm9ybUJ1ZmZlclNpemUgPSAzICogMTYgKiA0OyAvLyAyIG1hdDRzICogMTYgZmxvYXRzIHBlciBtYXQgKiA0IGJ5dGVzIHBlciBmbG9hdFxuICAgICAgICAvLyBjb25zdCBmVW5pZm9ybUJ1ZmZlclNpemUgPSBjb3VudHMuZnJhZzsvLyAyICogMyAqIDQ7IC8vIDEgdmVjMyAqIDMgZmxvYXRzIHBlciB2ZWMzICogNCBieXRlcyBwZXIgZmxvYXRcblxuICAgICAgICB0aGlzLl92c1VuaWZvcm1CdWZmZXIgPSB0aGlzLl9jZ3AuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7XG4gICAgICAgICAgICBcInNpemVcIjogdlVuaWZvcm1CdWZmZXJTaXplLFxuICAgICAgICAgICAgXCJ1c2FnZVwiOiBHUFVCdWZmZXJVc2FnZS5VTklGT1JNIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRoaXMuX2ZzVW5pZm9ybUJ1ZmZlciA9IHRoaXMuX2NncC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtcbiAgICAgICAgLy8gICAgIFwic2l6ZVwiOiBmVW5pZm9ybUJ1ZmZlclNpemUsXG4gICAgICAgIC8vICAgICBcInVzYWdlXCI6IEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0gfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCxcbiAgICAgICAgLy8gfSk7XG5cbiAgICAgICAgLy8gdGhpcy5fZnNVbmlmb3JtVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShjb3VudHMuZnJhZyAvIDQpO1xuXG4gICAgICAgIHRoaXMuX3ZzVW5pZm9ybVZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodlVuaWZvcm1CdWZmZXJTaXplIC8gNCk7XG5cbiAgICAgICAgdGhpcy5fbWF0TW9kZWwgPSB0aGlzLl92c1VuaWZvcm1WYWx1ZXMuc3ViYXJyYXkoMCwgMTYpO1xuICAgICAgICB0aGlzLl9tYXRWaWV3ID0gdGhpcy5fdnNVbmlmb3JtVmFsdWVzLnN1YmFycmF5KDE2LCAzMik7XG4gICAgICAgIHRoaXMuX21hdFByb2ogPSB0aGlzLl92c1VuaWZvcm1WYWx1ZXMuc3ViYXJyYXkoMzIsIDQ4KTtcblxuXG4gICAgICAgIC8vIHRoaXMuX2ZzVW5pZm9ybVZhbHVlc1sxXSA9IDEuMDtcbiAgICAgICAgLy8gdGhpcy5fZnNVbmlmb3JtVmFsdWVzWzBdID0gMS4wO1xuICAgICAgICAvLyBjb25zdCBsaWdodERpcmVjdGlvbiA9IHRoaXMuX2ZzVW5pZm9ybVZhbHVlcy5zdWJhcnJheSgwLCAzKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcInBpcGVsaW5lIGJpbmRncm91cGxheW91dCBcIiwgcGlwZWxpbmUuZ2V0QmluZEdyb3VwTGF5b3V0KDApKTtcblxuICAgICAgICB0aGlzLl9iaW5kR3JvdXAgPSB0aGlzLl9jZ3AuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImxheW91dFwiOiB0aGlzLl9yZW5kZXJQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksXG4gICAgICAgICAgICAgICAgXCJlbnRyaWVzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBcImJpbmRpbmdcIjogMCwgXCJyZXNvdXJjZVwiOiB7IFwiYnVmZmVyXCI6IHRoaXMuX3ZzVW5pZm9ybUJ1ZmZlciB9IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgXCJiaW5kaW5nXCI6IDEsIFwicmVzb3VyY2VcIjogeyBcImJ1ZmZlclwiOiB0aGlzLl91bmlCdWZGcmFnLl9ncHVCdWZmZXIgfSB9XG4gICAgICAgICAgICAgICAgICAgIC8vICAgeyBiaW5kaW5nOiAyLCByZXNvdXJjZTogc2FtcGxlciB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHsgYmluZGluZzogMywgcmVzb3VyY2U6IHRleC5jcmVhdGVWaWV3KCkgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fY2dwLmRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihcbiAgICAgICAgICAgIHRoaXMuX3ZzVW5pZm9ybUJ1ZmZlcixcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0aGlzLl92c1VuaWZvcm1WYWx1ZXMuYnVmZmVyLFxuICAgICAgICAgICAgdGhpcy5fdnNVbmlmb3JtVmFsdWVzLmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICB0aGlzLl92c1VuaWZvcm1WYWx1ZXMuYnl0ZUxlbmd0aFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX3VuaUJ1ZkZyYWcudXBkYXRlVW5pZm9ybVZhbHVlcygpO1xuICAgICAgICB0aGlzLl9jZ3AucG9wRXJyb3JTY29wZShcImNncF9waXBlbGluZSBlbmRcIiwgKGUpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgp/cgp_pipeline.js\n");

/***/ }),

/***/ "./src/core/cgp/cgp_shader.js":
/*!************************************!*\
  !*** ./src/core/cgp/cgp_shader.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Shader)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"./src/core/utils.js\");\n/* harmony import */ var _cgp_uniform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgp_uniform.js */ \"./src/core/cgp/cgp_uniform.js\");\n\n\n\n\nclass Shader\n{\n    constructor(_cgp, _name)\n    {\n        if (!_cgp) throw new Error(\"shader constructed without cgp \" + _name);\n        this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"cgp_shader\");\n        this._cgp = _cgp;\n        this._name = _name;\n        this._uniforms = [];\n\n        if (!_name) this._log.stack(\"no shader name given\");\n        this._name = _name || \"unknown\";\n        this.id = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.simpleId)();\n        this._isValid = true;\n        this._compileReason = \"\";\n        this.shaderModule = null;\n        this._needsRecompile = true;\n\n        this._src = \"\";\n    }\n\n    get isValid()\n    {\n        return this._isValid;\n    }\n\n    get uniforms()\n    {\n        return this._uniforms;\n    }\n\n    getName()\n    {\n        return this._name;\n    }\n\n    setWhyCompile(why)\n    {\n        this._compileReason = why;\n    }\n\n    setSource(src)\n    {\n        this._src = src;\n        this.setWhyCompile(\"Source changed\");\n        this._needsRecompile = true;\n    }\n\n    compile()\n    {\n        this._isValid = true;\n        console.log(\"compiling shader...\", this._compileReason);\n        this._cgp.pushErrorScope();\n        this.shaderModule = this._cgp.device.createShaderModule({ \"code\": this._src });\n        this._cgp.popErrorScope(\"cgp_shader \" + this._name, this.error.bind(this));\n        this._needsRecompile = false;\n    }\n\n    error(e)\n    {\n        this._isValid = false;\n    }\n\n\n    bind()\n    {\n        let sizes = {};\n        for (let i = 0; i < this._uniforms.length; i++)\n        {\n            // console.log(this._uniforms[i]);\n        }\n\n        if (this._needsRecompile) this.compile();\n    }\n\n    /**\n     * add a uniform to the fragment shader\n     * @param {String} type ['f','t', etc]\n     * @param {String} name\n     * @param {any} value or port\n     * @memberof Shader\n     * @instance\n     * @function addUniformFrag\n     * @returns {Uniform}\n     */\n    addUniformFrag(type, name, valueOrPort, p2, p3, p4)\n    {\n        const uni = new _cgp_uniform_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this, type, name, valueOrPort, p2, p3, p4);\n        uni.shaderType = \"frag\";\n        return uni;\n    }\n\n    /**\n     * add a uniform to the vertex shader\n     * @param {String} type ['f','t', etc]\n     * @param {String} name\n     * @param {any} value or port\n     * @memberof Shader\n     * @instance\n     * @function addUniformVert\n     * @returns {Uniform}\n     */\n    addUniformVert(type, name, valueOrPort, p2, p3, p4)\n    {\n        const uni = new _cgp_uniform_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this, type, name, valueOrPort, p2, p3, p4);\n        uni.shaderType = \"vert\";\n        return uni;\n    }\n\n    /**\n     * add a uniform to all shader programs\n     * @param {String} type ['f','t', etc]\n     * @param {String} name\n     * @param {any} value or port\n     * @memberof Shader\n     * @instance\n     * @function addUniform\n     * @returns {Uniform}\n     */\n    addUniform(type, name, valueOrPort, p2, p3, p4)\n    {\n        const uni = new _cgp_uniform_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this, type, name, valueOrPort, p2, p3, p4);\n        uni.shaderType = \"both\";\n        return uni;\n    }\n\n\n    _addUniform(uni)\n    {\n        this._uniforms.push(uni);\n        this.setWhyCompile(\"add uniform \" + name);\n        this._needsRecompile = true;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvY2dwX3NoYWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZ3AvY2dwX3NoYWRlci5qcz82MGE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJjYWJsZXMtc2hhcmVkLWNsaWVudFwiO1xuaW1wb3J0IHsgc2ltcGxlSWQgfSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCBVbmlmb3JtIGZyb20gXCIuL2NncF91bmlmb3JtLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlclxue1xuICAgIGNvbnN0cnVjdG9yKF9jZ3AsIF9uYW1lKVxuICAgIHtcbiAgICAgICAgaWYgKCFfY2dwKSB0aHJvdyBuZXcgRXJyb3IoXCJzaGFkZXIgY29uc3RydWN0ZWQgd2l0aG91dCBjZ3AgXCIgKyBfbmFtZSk7XG4gICAgICAgIHRoaXMuX2xvZyA9IG5ldyBMb2dnZXIoXCJjZ3Bfc2hhZGVyXCIpO1xuICAgICAgICB0aGlzLl9jZ3AgPSBfY2dwO1xuICAgICAgICB0aGlzLl9uYW1lID0gX25hbWU7XG4gICAgICAgIHRoaXMuX3VuaWZvcm1zID0gW107XG5cbiAgICAgICAgaWYgKCFfbmFtZSkgdGhpcy5fbG9nLnN0YWNrKFwibm8gc2hhZGVyIG5hbWUgZ2l2ZW5cIik7XG4gICAgICAgIHRoaXMuX25hbWUgPSBfbmFtZSB8fCBcInVua25vd25cIjtcbiAgICAgICAgdGhpcy5pZCA9IHNpbXBsZUlkKCk7XG4gICAgICAgIHRoaXMuX2lzVmFsaWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jb21waWxlUmVhc29uID0gXCJcIjtcbiAgICAgICAgdGhpcy5zaGFkZXJNb2R1bGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9uZWVkc1JlY29tcGlsZSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fc3JjID0gXCJcIjtcbiAgICB9XG5cbiAgICBnZXQgaXNWYWxpZCgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBnZXQgdW5pZm9ybXMoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VuaWZvcm1zO1xuICAgIH1cblxuICAgIGdldE5hbWUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuXG4gICAgc2V0V2h5Q29tcGlsZSh3aHkpXG4gICAge1xuICAgICAgICB0aGlzLl9jb21waWxlUmVhc29uID0gd2h5O1xuICAgIH1cblxuICAgIHNldFNvdXJjZShzcmMpXG4gICAge1xuICAgICAgICB0aGlzLl9zcmMgPSBzcmM7XG4gICAgICAgIHRoaXMuc2V0V2h5Q29tcGlsZShcIlNvdXJjZSBjaGFuZ2VkXCIpO1xuICAgICAgICB0aGlzLl9uZWVkc1JlY29tcGlsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgY29tcGlsZSgpXG4gICAge1xuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5sb2coXCJjb21waWxpbmcgc2hhZGVyLi4uXCIsIHRoaXMuX2NvbXBpbGVSZWFzb24pO1xuICAgICAgICB0aGlzLl9jZ3AucHVzaEVycm9yU2NvcGUoKTtcbiAgICAgICAgdGhpcy5zaGFkZXJNb2R1bGUgPSB0aGlzLl9jZ3AuZGV2aWNlLmNyZWF0ZVNoYWRlck1vZHVsZSh7IFwiY29kZVwiOiB0aGlzLl9zcmMgfSk7XG4gICAgICAgIHRoaXMuX2NncC5wb3BFcnJvclNjb3BlKFwiY2dwX3NoYWRlciBcIiArIHRoaXMuX25hbWUsIHRoaXMuZXJyb3IuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX25lZWRzUmVjb21waWxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZXJyb3IoZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG5cblxuICAgIGJpbmQoKVxuICAgIHtcbiAgICAgICAgbGV0IHNpemVzID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdW5pZm9ybXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuX3VuaWZvcm1zW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9uZWVkc1JlY29tcGlsZSkgdGhpcy5jb21waWxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgdW5pZm9ybSB0byB0aGUgZnJhZ21lbnQgc2hhZGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgWydmJywndCcsIGV0Y11cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBvciBwb3J0XG4gICAgICogQG1lbWJlcm9mIFNoYWRlclxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBmdW5jdGlvbiBhZGRVbmlmb3JtRnJhZ1xuICAgICAqIEByZXR1cm5zIHtVbmlmb3JtfVxuICAgICAqL1xuICAgIGFkZFVuaWZvcm1GcmFnKHR5cGUsIG5hbWUsIHZhbHVlT3JQb3J0LCBwMiwgcDMsIHA0KVxuICAgIHtcbiAgICAgICAgY29uc3QgdW5pID0gbmV3IFVuaWZvcm0odGhpcywgdHlwZSwgbmFtZSwgdmFsdWVPclBvcnQsIHAyLCBwMywgcDQpO1xuICAgICAgICB1bmkuc2hhZGVyVHlwZSA9IFwiZnJhZ1wiO1xuICAgICAgICByZXR1cm4gdW5pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhIHVuaWZvcm0gdG8gdGhlIHZlcnRleCBzaGFkZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBbJ2YnLCd0JywgZXRjXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHthbnl9IHZhbHVlIG9yIHBvcnRcbiAgICAgKiBAbWVtYmVyb2YgU2hhZGVyXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQGZ1bmN0aW9uIGFkZFVuaWZvcm1WZXJ0XG4gICAgICogQHJldHVybnMge1VuaWZvcm19XG4gICAgICovXG4gICAgYWRkVW5pZm9ybVZlcnQodHlwZSwgbmFtZSwgdmFsdWVPclBvcnQsIHAyLCBwMywgcDQpXG4gICAge1xuICAgICAgICBjb25zdCB1bmkgPSBuZXcgVW5pZm9ybSh0aGlzLCB0eXBlLCBuYW1lLCB2YWx1ZU9yUG9ydCwgcDIsIHAzLCBwNCk7XG4gICAgICAgIHVuaS5zaGFkZXJUeXBlID0gXCJ2ZXJ0XCI7XG4gICAgICAgIHJldHVybiB1bmk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgdW5pZm9ybSB0byBhbGwgc2hhZGVyIHByb2dyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgWydmJywndCcsIGV0Y11cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBvciBwb3J0XG4gICAgICogQG1lbWJlcm9mIFNoYWRlclxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBmdW5jdGlvbiBhZGRVbmlmb3JtXG4gICAgICogQHJldHVybnMge1VuaWZvcm19XG4gICAgICovXG4gICAgYWRkVW5pZm9ybSh0eXBlLCBuYW1lLCB2YWx1ZU9yUG9ydCwgcDIsIHAzLCBwNClcbiAgICB7XG4gICAgICAgIGNvbnN0IHVuaSA9IG5ldyBVbmlmb3JtKHRoaXMsIHR5cGUsIG5hbWUsIHZhbHVlT3JQb3J0LCBwMiwgcDMsIHA0KTtcbiAgICAgICAgdW5pLnNoYWRlclR5cGUgPSBcImJvdGhcIjtcbiAgICAgICAgcmV0dXJuIHVuaTtcbiAgICB9XG5cblxuICAgIF9hZGRVbmlmb3JtKHVuaSlcbiAgICB7XG4gICAgICAgIHRoaXMuX3VuaWZvcm1zLnB1c2godW5pKTtcbiAgICAgICAgdGhpcy5zZXRXaHlDb21waWxlKFwiYWRkIHVuaWZvcm0gXCIgKyBuYW1lKTtcbiAgICAgICAgdGhpcy5fbmVlZHNSZWNvbXBpbGUgPSB0cnVlO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/cgp/cgp_shader.js\n");

/***/ }),

/***/ "./src/core/cgp/cgp_state.js":
/*!***********************************!*\
  !*** ./src/core/cgp/cgp_state.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebGpuContext\": () => (/* binding */ WebGpuContext)\n/* harmony export */ });\n/* harmony import */ var _cg_cg_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cg/cg_constants.js */ \"./src/core/cg/cg_constants.js\");\n/* harmony import */ var _cg_cg_state_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cg/cg_state.js */ \"./src/core/cg/cg_state.js\");\n/* harmony import */ var _cgp_shader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgp_shader.js */ \"./src/core/cgp/cgp_shader.js\");\n/* harmony import */ var _cgl_shader_default_wgsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cgl_shader_default.wgsl */ \"./src/core/cgp/cgl_shader_default.wgsl\");\n\n\n\n\n\n/**\n * cables webgpu context/state manager\n * @external CGP\n * @namespace Context\n * @class\n * @hideconstructor\n */\n// const Context = function (_patch)\nclass WebGpuContext extends _cg_cg_state_js__WEBPACK_IMPORTED_MODULE_0__.CGState\n{\n    constructor(_patch)\n    {\n        super();\n\n        this.patch = _patch;\n\n        this.gApi = _cg_cg_constants_js__WEBPACK_IMPORTED_MODULE_1__.CG.GAPI_WEBGPU;\n        this._viewport = [0, 0, 256, 256];\n        this._shaderStack = [];\n        this._simpleShader = null;\n\n        this._stackCullFaceFacing = [];\n        this._stackDepthTest = [];\n        this._stackCullFace = [];\n        this._stackDepthFunc = [];\n        this._stackDepthWrite = [];\n\n        this.DEPTH_FUNCS = [\n            \"never\",\n            \"always\",\n            \"less\",\n            \"less-equal\",\n            \"greater\",\n            \"greater-equal\",\n            \"equal\",\n            \"not-equal\"\n        ];\n\n        this.CULL_MODES = [\n            \"none\",\n            \"back\",\n            \"front\",\n            \"none\" // both does not exist in webgpu\n        ];\n    }\n\n\n    /// ////////////////////\n\n    getViewPort()\n    {\n        return [0, 0, this.canvasWidth, this.canvasHeight];\n    }\n\n    renderStart(cgp, identTranslate, identTranslateView)\n    {\n        if (!this._simpleShader)\n        {\n            this._simpleShader = new _cgp_shader_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this, \"simple default shader\");\n            this._simpleShader.setSource(_cgl_shader_default_wgsl__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n            this._simpleShader.addUniformFrag(\"4f\", \"color\", 1, 1, 0, 1);\n        }\n\n        this.fpsCounter.startFrame();\n\n        this._startMatrixStacks(identTranslate, identTranslateView);\n        this.setViewPort(0, 0, this.canvasWidth, this.canvasHeight);\n\n        this.pushShader(this._simpleShader);\n        this.pushDepthTest(true);\n        this.pushDepthWrite(true);\n        this.pushDepthFunc(\"less-equal\");\n\n        this.emitEvent(\"beginFrame\");\n    }\n\n    renderEnd()\n    {\n        this._endMatrixStacks();\n\n        this.popShader();\n        this.popDepthFunc();\n        this.popDepthWrite();\n        this.popDepthTest();\n\n        this.emitEvent(\"endFrame\");\n        this.fpsCounter.endFrame();\n    }\n\n\n    setViewPort(x, y, w, h)\n    {\n        this._viewport = [x, y, w, h];\n    }\n\n    /**\n     * @function getViewPort\n     * @memberof Context\n     * @instance\n     * @description get current gl viewport\n     * @returns {Array} array [x,y,w,h]\n     */\n    getViewPort()\n    {\n        return this._viewPort;\n    }\n\n\n    createMesh(geom, glPrimitive)\n    {\n        return new CGP.Mesh(this, geom, glPrimitive);\n    }\n\n    getShader()\n    {\n        return {};\n    }\n\n    /**\n     * push a shader to the shader stack\n     * @function pushShader\n     * @memberof Context\n     * @instance\n     * @param {Object} shader\n     * @function\n    */\n    pushShader(shader)\n    {\n        this._shaderStack.push(shader);\n        // currentShader = shader;\n    }\n\n    /**\n     * pop current used shader from shader stack\n     * @function popShader\n     * @memberof Context\n     * @instance\n     * @function\n     */\n    popShader()\n    {\n        if (this._shaderStack.length === 0) throw new Error(\"Invalid shader stack pop!\");\n        this._shaderStack.pop();\n        // currentShader = this._shaderStack[this._shaderStack.length - 1];\n    }\n\n    getShader()\n    {\n        return this._shaderStack[this._shaderStack.length - 1];\n        // if (currentShader) if (!this.frameStore || ((this.frameStore.renderOffscreen === true) == currentShader.offScreenPass) === true) return currentShader;\n        // for (let i = this._shaderStack.length - 1; i >= 0; i--) if (this._shaderStack[i]) if (this.frameStore.renderOffscreen == this._shaderStack[i].offScreenPass) return this._shaderStack[i];\n    }\n\n    pushErrorScope()\n    {\n        this.device.pushErrorScope(\"validation\");\n    }\n\n    popErrorScope(name, cb)\n    {\n        this.device.popErrorScope().then((error) =>\n        {\n            if (error)\n            {\n                this.patch.emitEvent(\"criticalError\", { \"title\": \"WebGPU error \\\"\" + name + \"\\\"\", \"codeText\": error.message });\n                // if (this.patch.isEditorMode())console.log(\"WebGPU error \" + this._name, error.message);\n\n                console.warn(\"[cgp]\", name, error.message, error, cb);\n                if (cb)cb(error);\n            }\n        });\n    }\n\n    /**\n     * push depth testing enabled state\n     * @function pushDepthTest\n     * @param {Boolean} enabled\n     * @memberof Context\n     * @instance\n     */\n\n    pushDepthTest(b)\n    {\n        this._stackDepthTest.push(b);\n    }\n\n    /**\n     * current state of depth testing\n     * @function stateDepthTest\n     * @returns {Boolean} enabled\n     * @memberof Context\n     * @instance\n     */\n    stateDepthTest()\n    {\n        return this._stackDepthTest[this._stackDepthTest.length - 1];\n    }\n\n    /**\n     * pop depth testing state\n     * @function popDepthTest\n     * @memberof Context\n     * @instance\n     */\n    popDepthTest()\n    {\n        this._stackDepthTest.pop();\n    }\n\n    // --------------------------------------\n    // state depthwrite\n\n    /**\n     * push depth write enabled state\n     * @function pushDepthTest\n     * @param {Boolean} enabled\n     * @memberof Context\n     * @instance\n     */\n\n    pushDepthWrite(b)\n    {\n        b = b || false;\n        this._stackDepthWrite.push(b);\n    }\n\n    /**\n     * current state of depth writing\n     * @function stateCullFace\n     * @returns {Boolean} enabled\n     * @memberof Context\n     * @instance\n     */\n    stateDepthWrite()\n    {\n        return this._stackDepthWrite[this._stackDepthWrite.length - 1];\n    }\n\n    /**\n     * pop depth writing state\n     * @function popCullFace\n     * @memberof Context\n     * @instance\n     */\n    popDepthWrite()\n    {\n        this._stackDepthWrite.pop();\n    }\n\n\n    // --------------------------------------\n    // state depthfunc\n\n\n    /**\n     * @function pushDepthFunc\n     * @memberof Context\n     * @instance\n     * @param {string} depth compare func\n     */\n    pushDepthFunc(f)\n    {\n        this._stackDepthFunc.push(f);\n    }\n\n    /**\n     * @function stateDepthFunc\n     * @memberof Context\n     * @instance\n     * @returns {string}\n     */\n    stateDepthFunc()\n    {\n        if (this._stackDepthFunc.length > 0) return this._stackDepthFunc[this._stackDepthFunc.length - 1];\n        return false;\n    }\n\n    /**\n     * pop depth compare func\n     * @function popDepthFunc\n     * @memberof Context\n     * @instance\n     */\n    popDepthFunc()\n    {\n        this._stackDepthFunc.pop();\n    }\n\n\n\n    // --------------------------------------\n    // state CullFace\n\n    /**\n     * push face culling face enabled state\n     * @function pushCullFaceFacing\n     * @param {Boolean} enabled\n     * @memberof Context\n     * @instance\n     */\n    pushCullFace(b)\n    {\n        this._stackCullFace.push(b);\n    }\n\n    /**\n * current state of face culling\n * @function stateCullFace\n * @returns {Boolean} enabled\n * @memberof Context\n * @instance\n */\n    stateCullFace()\n    {\n        return this._stackCullFace[this._stackCullFace.length - 1];\n    }\n\n    /**\n * pop face culling enabled state\n * @function popCullFace\n * @memberof Context\n * @instance\n */\n    popCullFace()\n    {\n        this._stackCullFace.pop();\n    }\n\n\n    // --------------------------------------\n    // state CullFace Facing\n\n\n    /**\n     * push face culling face side\n     * @function pushCullFaceFacing\n     * @memberof Context\n     * @instance\n     */\n\n    pushCullFaceFacing(b)\n    {\n        this._stackCullFaceFacing.push(b);\n    }\n\n    /**\n     * current state of face culling side\n     * @function stateCullFaceFacing\n     * @returns {Boolean} enabled\n     * @memberof Context\n     * @instance\n     */\n    stateCullFaceFacing()\n    {\n        return this._stackCullFaceFacing[this._stackCullFaceFacing.length - 1];\n    }\n\n    /**\n     * pop face culling face side\n     * @function popCullFaceFacing\n     * @memberof Context\n     * @instance\n     */\n    popCullFaceFacing()\n    {\n        this._stackCullFaceFacing.pop();\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvY2dwX3N0YXRlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dwL2NncF9zdGF0ZS5qcz85ZGMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENHIH0gZnJvbSBcIi4uL2NnL2NnX2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgQ0dTdGF0ZSB9IGZyb20gXCIuLi9jZy9jZ19zdGF0ZS5qc1wiO1xuaW1wb3J0IFNoYWRlciBmcm9tIFwiLi9jZ3Bfc2hhZGVyLmpzXCI7XG5pbXBvcnQgZGVmYXVsdFNoYWRlclNyY1ZlcnQgZnJvbSBcIi4vY2dsX3NoYWRlcl9kZWZhdWx0Lndnc2xcIjtcblxuLyoqXG4gKiBjYWJsZXMgd2ViZ3B1IGNvbnRleHQvc3RhdGUgbWFuYWdlclxuICogQGV4dGVybmFsIENHUFxuICogQG5hbWVzcGFjZSBDb250ZXh0XG4gKiBAY2xhc3NcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqL1xuLy8gY29uc3QgQ29udGV4dCA9IGZ1bmN0aW9uIChfcGF0Y2gpXG5jbGFzcyBXZWJHcHVDb250ZXh0IGV4dGVuZHMgQ0dTdGF0ZVxue1xuICAgIGNvbnN0cnVjdG9yKF9wYXRjaClcbiAgICB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5wYXRjaCA9IF9wYXRjaDtcblxuICAgICAgICB0aGlzLmdBcGkgPSBDRy5HQVBJX1dFQkdQVTtcbiAgICAgICAgdGhpcy5fdmlld3BvcnQgPSBbMCwgMCwgMjU2LCAyNTZdO1xuICAgICAgICB0aGlzLl9zaGFkZXJTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9zaW1wbGVTaGFkZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3N0YWNrQ3VsbEZhY2VGYWNpbmcgPSBbXTtcbiAgICAgICAgdGhpcy5fc3RhY2tEZXB0aFRlc3QgPSBbXTtcbiAgICAgICAgdGhpcy5fc3RhY2tDdWxsRmFjZSA9IFtdO1xuICAgICAgICB0aGlzLl9zdGFja0RlcHRoRnVuYyA9IFtdO1xuICAgICAgICB0aGlzLl9zdGFja0RlcHRoV3JpdGUgPSBbXTtcblxuICAgICAgICB0aGlzLkRFUFRIX0ZVTkNTID0gW1xuICAgICAgICAgICAgXCJuZXZlclwiLFxuICAgICAgICAgICAgXCJhbHdheXNcIixcbiAgICAgICAgICAgIFwibGVzc1wiLFxuICAgICAgICAgICAgXCJsZXNzLWVxdWFsXCIsXG4gICAgICAgICAgICBcImdyZWF0ZXJcIixcbiAgICAgICAgICAgIFwiZ3JlYXRlci1lcXVhbFwiLFxuICAgICAgICAgICAgXCJlcXVhbFwiLFxuICAgICAgICAgICAgXCJub3QtZXF1YWxcIlxuICAgICAgICBdO1xuXG4gICAgICAgIHRoaXMuQ1VMTF9NT0RFUyA9IFtcbiAgICAgICAgICAgIFwibm9uZVwiLFxuICAgICAgICAgICAgXCJiYWNrXCIsXG4gICAgICAgICAgICBcImZyb250XCIsXG4gICAgICAgICAgICBcIm5vbmVcIiAvLyBib3RoIGRvZXMgbm90IGV4aXN0IGluIHdlYmdwdVxuICAgICAgICBdO1xuICAgIH1cblxuXG4gICAgLy8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICBnZXRWaWV3UG9ydCgpXG4gICAge1xuICAgICAgICByZXR1cm4gWzAsIDAsIHRoaXMuY2FudmFzV2lkdGgsIHRoaXMuY2FudmFzSGVpZ2h0XTtcbiAgICB9XG5cbiAgICByZW5kZXJTdGFydChjZ3AsIGlkZW50VHJhbnNsYXRlLCBpZGVudFRyYW5zbGF0ZVZpZXcpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX3NpbXBsZVNoYWRlcilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fc2ltcGxlU2hhZGVyID0gbmV3IFNoYWRlcih0aGlzLCBcInNpbXBsZSBkZWZhdWx0IHNoYWRlclwiKTtcbiAgICAgICAgICAgIHRoaXMuX3NpbXBsZVNoYWRlci5zZXRTb3VyY2UoZGVmYXVsdFNoYWRlclNyY1ZlcnQpO1xuICAgICAgICAgICAgdGhpcy5fc2ltcGxlU2hhZGVyLmFkZFVuaWZvcm1GcmFnKFwiNGZcIiwgXCJjb2xvclwiLCAxLCAxLCAwLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZnBzQ291bnRlci5zdGFydEZyYW1lKCk7XG5cbiAgICAgICAgdGhpcy5fc3RhcnRNYXRyaXhTdGFja3MoaWRlbnRUcmFuc2xhdGUsIGlkZW50VHJhbnNsYXRlVmlldyk7XG4gICAgICAgIHRoaXMuc2V0Vmlld1BvcnQoMCwgMCwgdGhpcy5jYW52YXNXaWR0aCwgdGhpcy5jYW52YXNIZWlnaHQpO1xuXG4gICAgICAgIHRoaXMucHVzaFNoYWRlcih0aGlzLl9zaW1wbGVTaGFkZXIpO1xuICAgICAgICB0aGlzLnB1c2hEZXB0aFRlc3QodHJ1ZSk7XG4gICAgICAgIHRoaXMucHVzaERlcHRoV3JpdGUodHJ1ZSk7XG4gICAgICAgIHRoaXMucHVzaERlcHRoRnVuYyhcImxlc3MtZXF1YWxcIik7XG5cbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJiZWdpbkZyYW1lXCIpO1xuICAgIH1cblxuICAgIHJlbmRlckVuZCgpXG4gICAge1xuICAgICAgICB0aGlzLl9lbmRNYXRyaXhTdGFja3MoKTtcblxuICAgICAgICB0aGlzLnBvcFNoYWRlcigpO1xuICAgICAgICB0aGlzLnBvcERlcHRoRnVuYygpO1xuICAgICAgICB0aGlzLnBvcERlcHRoV3JpdGUoKTtcbiAgICAgICAgdGhpcy5wb3BEZXB0aFRlc3QoKTtcblxuICAgICAgICB0aGlzLmVtaXRFdmVudChcImVuZEZyYW1lXCIpO1xuICAgICAgICB0aGlzLmZwc0NvdW50ZXIuZW5kRnJhbWUoKTtcbiAgICB9XG5cblxuICAgIHNldFZpZXdQb3J0KHgsIHksIHcsIGgpXG4gICAge1xuICAgICAgICB0aGlzLl92aWV3cG9ydCA9IFt4LCB5LCB3LCBoXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gZ2V0Vmlld1BvcnRcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBkZXNjcmlwdGlvbiBnZXQgY3VycmVudCBnbCB2aWV3cG9ydFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXkgW3gseSx3LGhdXG4gICAgICovXG4gICAgZ2V0Vmlld1BvcnQoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdQb3J0O1xuICAgIH1cblxuXG4gICAgY3JlYXRlTWVzaChnZW9tLCBnbFByaW1pdGl2ZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgQ0dQLk1lc2godGhpcywgZ2VvbSwgZ2xQcmltaXRpdmUpO1xuICAgIH1cblxuICAgIGdldFNoYWRlcigpXG4gICAge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHVzaCBhIHNoYWRlciB0byB0aGUgc2hhZGVyIHN0YWNrXG4gICAgICogQGZ1bmN0aW9uIHB1c2hTaGFkZXJcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzaGFkZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAqL1xuICAgIHB1c2hTaGFkZXIoc2hhZGVyKVxuICAgIHtcbiAgICAgICAgdGhpcy5fc2hhZGVyU3RhY2sucHVzaChzaGFkZXIpO1xuICAgICAgICAvLyBjdXJyZW50U2hhZGVyID0gc2hhZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHBvcCBjdXJyZW50IHVzZWQgc2hhZGVyIGZyb20gc2hhZGVyIHN0YWNrXG4gICAgICogQGZ1bmN0aW9uIHBvcFNoYWRlclxuICAgICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgcG9wU2hhZGVyKClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9zaGFkZXJTdGFjay5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2hhZGVyIHN0YWNrIHBvcCFcIik7XG4gICAgICAgIHRoaXMuX3NoYWRlclN0YWNrLnBvcCgpO1xuICAgICAgICAvLyBjdXJyZW50U2hhZGVyID0gdGhpcy5fc2hhZGVyU3RhY2tbdGhpcy5fc2hhZGVyU3RhY2subGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgZ2V0U2hhZGVyKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaGFkZXJTdGFja1t0aGlzLl9zaGFkZXJTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgLy8gaWYgKGN1cnJlbnRTaGFkZXIpIGlmICghdGhpcy5mcmFtZVN0b3JlIHx8ICgodGhpcy5mcmFtZVN0b3JlLnJlbmRlck9mZnNjcmVlbiA9PT0gdHJ1ZSkgPT0gY3VycmVudFNoYWRlci5vZmZTY3JlZW5QYXNzKSA9PT0gdHJ1ZSkgcmV0dXJuIGN1cnJlbnRTaGFkZXI7XG4gICAgICAgIC8vIGZvciAobGV0IGkgPSB0aGlzLl9zaGFkZXJTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKHRoaXMuX3NoYWRlclN0YWNrW2ldKSBpZiAodGhpcy5mcmFtZVN0b3JlLnJlbmRlck9mZnNjcmVlbiA9PSB0aGlzLl9zaGFkZXJTdGFja1tpXS5vZmZTY3JlZW5QYXNzKSByZXR1cm4gdGhpcy5fc2hhZGVyU3RhY2tbaV07XG4gICAgfVxuXG4gICAgcHVzaEVycm9yU2NvcGUoKVxuICAgIHtcbiAgICAgICAgdGhpcy5kZXZpY2UucHVzaEVycm9yU2NvcGUoXCJ2YWxpZGF0aW9uXCIpO1xuICAgIH1cblxuICAgIHBvcEVycm9yU2NvcGUobmFtZSwgY2IpXG4gICAge1xuICAgICAgICB0aGlzLmRldmljZS5wb3BFcnJvclNjb3BlKCkudGhlbigoZXJyb3IpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGNoLmVtaXRFdmVudChcImNyaXRpY2FsRXJyb3JcIiwgeyBcInRpdGxlXCI6IFwiV2ViR1BVIGVycm9yIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIiwgXCJjb2RlVGV4dFwiOiBlcnJvci5tZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgIC8vIGlmICh0aGlzLnBhdGNoLmlzRWRpdG9yTW9kZSgpKWNvbnNvbGUubG9nKFwiV2ViR1BVIGVycm9yIFwiICsgdGhpcy5fbmFtZSwgZXJyb3IubWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbY2dwXVwiLCBuYW1lLCBlcnJvci5tZXNzYWdlLCBlcnJvciwgY2IpO1xuICAgICAgICAgICAgICAgIGlmIChjYiljYihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHB1c2ggZGVwdGggdGVzdGluZyBlbmFibGVkIHN0YXRlXG4gICAgICogQGZ1bmN0aW9uIHB1c2hEZXB0aFRlc3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuXG4gICAgcHVzaERlcHRoVGVzdChiKVxuICAgIHtcbiAgICAgICAgdGhpcy5fc3RhY2tEZXB0aFRlc3QucHVzaChiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjdXJyZW50IHN0YXRlIG9mIGRlcHRoIHRlc3RpbmdcbiAgICAgKiBAZnVuY3Rpb24gc3RhdGVEZXB0aFRlc3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgc3RhdGVEZXB0aFRlc3QoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrRGVwdGhUZXN0W3RoaXMuX3N0YWNrRGVwdGhUZXN0Lmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHBvcCBkZXB0aCB0ZXN0aW5nIHN0YXRlXG4gICAgICogQGZ1bmN0aW9uIHBvcERlcHRoVGVzdFxuICAgICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcG9wRGVwdGhUZXN0KClcbiAgICB7XG4gICAgICAgIHRoaXMuX3N0YWNrRGVwdGhUZXN0LnBvcCgpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gc3RhdGUgZGVwdGh3cml0ZVxuXG4gICAgLyoqXG4gICAgICogcHVzaCBkZXB0aCB3cml0ZSBlbmFibGVkIHN0YXRlXG4gICAgICogQGZ1bmN0aW9uIHB1c2hEZXB0aFRlc3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuXG4gICAgcHVzaERlcHRoV3JpdGUoYilcbiAgICB7XG4gICAgICAgIGIgPSBiIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGFja0RlcHRoV3JpdGUucHVzaChiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjdXJyZW50IHN0YXRlIG9mIGRlcHRoIHdyaXRpbmdcbiAgICAgKiBAZnVuY3Rpb24gc3RhdGVDdWxsRmFjZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBlbmFibGVkXG4gICAgICogQG1lbWJlcm9mIENvbnRleHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzdGF0ZURlcHRoV3JpdGUoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrRGVwdGhXcml0ZVt0aGlzLl9zdGFja0RlcHRoV3JpdGUubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcG9wIGRlcHRoIHdyaXRpbmcgc3RhdGVcbiAgICAgKiBAZnVuY3Rpb24gcG9wQ3VsbEZhY2VcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHBvcERlcHRoV3JpdGUoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fc3RhY2tEZXB0aFdyaXRlLnBvcCgpO1xuICAgIH1cblxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzdGF0ZSBkZXB0aGZ1bmNcblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHB1c2hEZXB0aEZ1bmNcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZXB0aCBjb21wYXJlIGZ1bmNcbiAgICAgKi9cbiAgICBwdXNoRGVwdGhGdW5jKGYpXG4gICAge1xuICAgICAgICB0aGlzLl9zdGFja0RlcHRoRnVuYy5wdXNoKGYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBzdGF0ZURlcHRoRnVuY1xuICAgICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0ZURlcHRoRnVuYygpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fc3RhY2tEZXB0aEZ1bmMubGVuZ3RoID4gMCkgcmV0dXJuIHRoaXMuX3N0YWNrRGVwdGhGdW5jW3RoaXMuX3N0YWNrRGVwdGhGdW5jLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcG9wIGRlcHRoIGNvbXBhcmUgZnVuY1xuICAgICAqIEBmdW5jdGlvbiBwb3BEZXB0aEZ1bmNcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHBvcERlcHRoRnVuYygpXG4gICAge1xuICAgICAgICB0aGlzLl9zdGFja0RlcHRoRnVuYy5wb3AoKTtcbiAgICB9XG5cblxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzdGF0ZSBDdWxsRmFjZVxuXG4gICAgLyoqXG4gICAgICogcHVzaCBmYWNlIGN1bGxpbmcgZmFjZSBlbmFibGVkIHN0YXRlXG4gICAgICogQGZ1bmN0aW9uIHB1c2hDdWxsRmFjZUZhY2luZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcHVzaEN1bGxGYWNlKGIpXG4gICAge1xuICAgICAgICB0aGlzLl9zdGFja0N1bGxGYWNlLnB1c2goYik7XG4gICAgfVxuXG4gICAgLyoqXG4gKiBjdXJyZW50IHN0YXRlIG9mIGZhY2UgY3VsbGluZ1xuICogQGZ1bmN0aW9uIHN0YXRlQ3VsbEZhY2VcbiAqIEByZXR1cm5zIHtCb29sZWFufSBlbmFibGVkXG4gKiBAbWVtYmVyb2YgQ29udGV4dFxuICogQGluc3RhbmNlXG4gKi9cbiAgICBzdGF0ZUN1bGxGYWNlKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFja0N1bGxGYWNlW3RoaXMuX3N0YWNrQ3VsbEZhY2UubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgLyoqXG4gKiBwb3AgZmFjZSBjdWxsaW5nIGVuYWJsZWQgc3RhdGVcbiAqIEBmdW5jdGlvbiBwb3BDdWxsRmFjZVxuICogQG1lbWJlcm9mIENvbnRleHRcbiAqIEBpbnN0YW5jZVxuICovXG4gICAgcG9wQ3VsbEZhY2UoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fc3RhY2tDdWxsRmFjZS5wb3AoKTtcbiAgICB9XG5cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gc3RhdGUgQ3VsbEZhY2UgRmFjaW5nXG5cblxuICAgIC8qKlxuICAgICAqIHB1c2ggZmFjZSBjdWxsaW5nIGZhY2Ugc2lkZVxuICAgICAqIEBmdW5jdGlvbiBwdXNoQ3VsbEZhY2VGYWNpbmdcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuXG4gICAgcHVzaEN1bGxGYWNlRmFjaW5nKGIpXG4gICAge1xuICAgICAgICB0aGlzLl9zdGFja0N1bGxGYWNlRmFjaW5nLnB1c2goYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3VycmVudCBzdGF0ZSBvZiBmYWNlIGN1bGxpbmcgc2lkZVxuICAgICAqIEBmdW5jdGlvbiBzdGF0ZUN1bGxGYWNlRmFjaW5nXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAbWVtYmVyb2YgQ29udGV4dFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHN0YXRlQ3VsbEZhY2VGYWNpbmcoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrQ3VsbEZhY2VGYWNpbmdbdGhpcy5fc3RhY2tDdWxsRmFjZUZhY2luZy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwb3AgZmFjZSBjdWxsaW5nIGZhY2Ugc2lkZVxuICAgICAqIEBmdW5jdGlvbiBwb3BDdWxsRmFjZUZhY2luZ1xuICAgICAqIEBtZW1iZXJvZiBDb250ZXh0XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcG9wQ3VsbEZhY2VGYWNpbmcoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fc3RhY2tDdWxsRmFjZUZhY2luZy5wb3AoKTtcbiAgICB9XG59XG5leHBvcnQgeyBXZWJHcHVDb250ZXh0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgp/cgp_state.js\n");

/***/ }),

/***/ "./src/core/cgp/cgp_texture.js":
/*!*************************************!*\
  !*** ./src/core/cgp/cgp_texture.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Texture)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n\n\nclass Texture\n{\n    constructor(_cgp, options)\n    {\n        if (!_cgp) throw new Error(\"no cgp\");\n        this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"cgp_texture\");\n        this._cgp = _cgp;\n        this.id = CABLES.uuid();\n\n        options = options || {};\n\n        this.name = options.name || \"unknown\";\n    }\n\n    /**\n     * set texture data from an image/canvas object\n     * @function initTexture\n     * @memberof Texture\n     * @instance\n     * @param {Object} image\n     * @param {Number} filter\n     */\n    initTexture(img, filter)\n    {\n        this.width = img.width;\n        this.height = img.height;\n\n        this.textureType = \"rgba8unorm\";\n\n        const textureDescriptor = {\n            // Unlike in WebGL, the size of our texture must be set at texture creation time.\n            // This means we have to wait until the image is loaded to create the texture, since we won't\n            // know the size until then.\n            \"size\": { \"width\": img.width, \"height\": img.height },\n            \"format\": this.textureType,\n            \"usage\": GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST\n        };\n        const texture = this._cgp.device.createTexture(textureDescriptor);\n\n        this._cgp.device.queue.copyExternalImageToTexture({ \"source\": img }, { \"texture\": texture }, textureDescriptor.size);\n\n        return texture;\n    }\n\n    getInfo()\n    {\n        const tex = this;\n        const obj = {};\n\n        obj.name = tex.name;\n        obj.size = tex.width + \" x \" + tex.height;\n\n        obj.textureType = tex.textureType;\n\n        return obj;\n    }\n}\n\n\n/**\n * @function load\n * @static\n * @memberof Texture\n * @description load an image from an url\n * @param {Context} cgl\n * @param {String} url\n * @param {Function} onFinished\n * @param {Object} options\n * @return {Texture}\n */\nTexture.load = function (cgp, url, onFinished, settings)\n{\n    fetch(url).then((response) =>\n    {\n        response.blob().then((blob) =>\n        {\n            createImageBitmap(blob).then((imgBitmap) =>\n            {\n                const texture = new Texture(cgp, { \"name\": url });\n                texture.initTexture(imgBitmap);\n                if (onFinished)onFinished(texture);\n                else console.log(\"Texture.load no onFinished callback\");\n            });\n        });\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvY2dwX3RleHR1cmUuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dwL2NncF90ZXh0dXJlLmpzPzkyYmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcImNhYmxlcy1zaGFyZWQtY2xpZW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmVcbntcbiAgICBjb25zdHJ1Y3RvcihfY2dwLCBvcHRpb25zKVxuICAgIHtcbiAgICAgICAgaWYgKCFfY2dwKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBjZ3BcIik7XG4gICAgICAgIHRoaXMuX2xvZyA9IG5ldyBMb2dnZXIoXCJjZ3BfdGV4dHVyZVwiKTtcbiAgICAgICAgdGhpcy5fY2dwID0gX2NncDtcbiAgICAgICAgdGhpcy5pZCA9IENBQkxFUy51dWlkKCk7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IFwidW5rbm93blwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCB0ZXh0dXJlIGRhdGEgZnJvbSBhbiBpbWFnZS9jYW52YXMgb2JqZWN0XG4gICAgICogQGZ1bmN0aW9uIGluaXRUZXh0dXJlXG4gICAgICogQG1lbWJlcm9mIFRleHR1cmVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZmlsdGVyXG4gICAgICovXG4gICAgaW5pdFRleHR1cmUoaW1nLCBmaWx0ZXIpXG4gICAge1xuICAgICAgICB0aGlzLndpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGltZy5oZWlnaHQ7XG5cbiAgICAgICAgdGhpcy50ZXh0dXJlVHlwZSA9IFwicmdiYTh1bm9ybVwiO1xuXG4gICAgICAgIGNvbnN0IHRleHR1cmVEZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgLy8gVW5saWtlIGluIFdlYkdMLCB0aGUgc2l6ZSBvZiBvdXIgdGV4dHVyZSBtdXN0IGJlIHNldCBhdCB0ZXh0dXJlIGNyZWF0aW9uIHRpbWUuXG4gICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHdlIGhhdmUgdG8gd2FpdCB1bnRpbCB0aGUgaW1hZ2UgaXMgbG9hZGVkIHRvIGNyZWF0ZSB0aGUgdGV4dHVyZSwgc2luY2Ugd2Ugd29uJ3RcbiAgICAgICAgICAgIC8vIGtub3cgdGhlIHNpemUgdW50aWwgdGhlbi5cbiAgICAgICAgICAgIFwic2l6ZVwiOiB7IFwid2lkdGhcIjogaW1nLndpZHRoLCBcImhlaWdodFwiOiBpbWcuaGVpZ2h0IH0sXG4gICAgICAgICAgICBcImZvcm1hdFwiOiB0aGlzLnRleHR1cmVUeXBlLFxuICAgICAgICAgICAgXCJ1c2FnZVwiOiBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HIHwgR1BVVGV4dHVyZVVzYWdlLkNPUFlfRFNUXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl9jZ3AuZGV2aWNlLmNyZWF0ZVRleHR1cmUodGV4dHVyZURlc2NyaXB0b3IpO1xuXG4gICAgICAgIHRoaXMuX2NncC5kZXZpY2UucXVldWUuY29weUV4dGVybmFsSW1hZ2VUb1RleHR1cmUoeyBcInNvdXJjZVwiOiBpbWcgfSwgeyBcInRleHR1cmVcIjogdGV4dHVyZSB9LCB0ZXh0dXJlRGVzY3JpcHRvci5zaXplKTtcblxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG5cbiAgICBnZXRJbmZvKClcbiAgICB7XG4gICAgICAgIGNvbnN0IHRleCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuXG4gICAgICAgIG9iai5uYW1lID0gdGV4Lm5hbWU7XG4gICAgICAgIG9iai5zaXplID0gdGV4LndpZHRoICsgXCIgeCBcIiArIHRleC5oZWlnaHQ7XG5cbiAgICAgICAgb2JqLnRleHR1cmVUeXBlID0gdGV4LnRleHR1cmVUeXBlO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQGZ1bmN0aW9uIGxvYWRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBUZXh0dXJlXG4gKiBAZGVzY3JpcHRpb24gbG9hZCBhbiBpbWFnZSBmcm9tIGFuIHVybFxuICogQHBhcmFtIHtDb250ZXh0fSBjZ2xcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRmluaXNoZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtUZXh0dXJlfVxuICovXG5UZXh0dXJlLmxvYWQgPSBmdW5jdGlvbiAoY2dwLCB1cmwsIG9uRmluaXNoZWQsIHNldHRpbmdzKVxue1xuICAgIGZldGNoKHVybCkudGhlbigocmVzcG9uc2UpID0+XG4gICAge1xuICAgICAgICByZXNwb25zZS5ibG9iKCkudGhlbigoYmxvYikgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYikudGhlbigoaW1nQml0bWFwKSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZShjZ3AsIHsgXCJuYW1lXCI6IHVybCB9KTtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmluaXRUZXh0dXJlKGltZ0JpdG1hcCk7XG4gICAgICAgICAgICAgICAgaWYgKG9uRmluaXNoZWQpb25GaW5pc2hlZCh0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGNvbnNvbGUubG9nKFwiVGV4dHVyZS5sb2FkIG5vIG9uRmluaXNoZWQgY2FsbGJhY2tcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgp/cgp_texture.js\n");

/***/ }),

/***/ "./src/core/cgp/cgp_uniform.js":
/*!*************************************!*\
  !*** ./src/core/cgp/cgp_uniform.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Uniform)\n/* harmony export */ });\n/* harmony import */ var _cg_cg_uniform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cg/cg_uniform.js */ \"./src/core/cg/cg_uniform.js\");\n\n\nclass Uniform extends _cg_cg_uniform_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n{\n    constructor(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName)\n    {\n        super(__shader, __type, __name, _value, _port2, _port3, _port4, _structUniformName, _structName, _propertyName);\n        this._loc = -1;\n        this._cgl = __shader._cgl;\n    }\n\n\n    updateValueF() { }\n\n    setValueF(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n    updateValue2F() { }\n\n    setValue2F(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n    updateValue3F() { }\n\n    setValue3F(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n    updateValue4F() { }\n\n    setValue4F(v)\n    {\n        this.needsUpdate = true;\n        this._value = v;\n    }\n\n    getSizeBytes()\n    {\n        if (this._type == \"f\") return 1 * 4;\n        if (this._type == \"i\") return 1 * 4;\n        if (this._type == \"2i\") return 2 * 4;\n        if (this._type == \"2f\") return 2 * 4;\n        if (this._type == \"3f\") return 3 * 4;\n        if (this._type == \"4f\") return 4 * 4;\n        if (this._type == \"m4\") return 4 * 4 * 4;\n\n        this._log.warn(\"unknown type getSizeBytes\");\n        // if (this._type == \"t\") return \"sampler2D\";\n        // if (this._type == \"tc\") return \"samplerCube\";\n        // if (this._type == \"b\") return \"bool\";\n\n        // if (t == \"3f[]\") return null; // ignore this for now...\n        // if (t == \"m4[]\") return null; // ignore this for now...\n        // if (t == \"f[]\") return null; // ignore this for now...\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvY2dwX3VuaWZvcm0uanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dwL2NncF91bmlmb3JtLmpzP2U4NTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENnVW5pZm9ybSBmcm9tIFwiLi4vY2cvY2dfdW5pZm9ybS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVbmlmb3JtIGV4dGVuZHMgQ2dVbmlmb3JtXG57XG4gICAgY29uc3RydWN0b3IoX19zaGFkZXIsIF9fdHlwZSwgX19uYW1lLCBfdmFsdWUsIF9wb3J0MiwgX3BvcnQzLCBfcG9ydDQsIF9zdHJ1Y3RVbmlmb3JtTmFtZSwgX3N0cnVjdE5hbWUsIF9wcm9wZXJ0eU5hbWUpXG4gICAge1xuICAgICAgICBzdXBlcihfX3NoYWRlciwgX190eXBlLCBfX25hbWUsIF92YWx1ZSwgX3BvcnQyLCBfcG9ydDMsIF9wb3J0NCwgX3N0cnVjdFVuaWZvcm1OYW1lLCBfc3RydWN0TmFtZSwgX3Byb3BlcnR5TmFtZSk7XG4gICAgICAgIHRoaXMuX2xvYyA9IC0xO1xuICAgICAgICB0aGlzLl9jZ2wgPSBfX3NoYWRlci5fY2dsO1xuICAgIH1cblxuXG4gICAgdXBkYXRlVmFsdWVGKCkgeyB9XG5cbiAgICBzZXRWYWx1ZUYodilcbiAgICB7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWUyRigpIHsgfVxuXG4gICAgc2V0VmFsdWUyRih2KVxuICAgIHtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcbiAgICB9XG5cbiAgICB1cGRhdGVWYWx1ZTNGKCkgeyB9XG5cbiAgICBzZXRWYWx1ZTNGKHYpXG4gICAge1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgIH1cblxuICAgIHVwZGF0ZVZhbHVlNEYoKSB7IH1cblxuICAgIHNldFZhbHVlNEYodilcbiAgICB7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0U2l6ZUJ5dGVzKClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl90eXBlID09IFwiZlwiKSByZXR1cm4gMSAqIDQ7XG4gICAgICAgIGlmICh0aGlzLl90eXBlID09IFwiaVwiKSByZXR1cm4gMSAqIDQ7XG4gICAgICAgIGlmICh0aGlzLl90eXBlID09IFwiMmlcIikgcmV0dXJuIDIgKiA0O1xuICAgICAgICBpZiAodGhpcy5fdHlwZSA9PSBcIjJmXCIpIHJldHVybiAyICogNDtcbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT0gXCIzZlwiKSByZXR1cm4gMyAqIDQ7XG4gICAgICAgIGlmICh0aGlzLl90eXBlID09IFwiNGZcIikgcmV0dXJuIDQgKiA0O1xuICAgICAgICBpZiAodGhpcy5fdHlwZSA9PSBcIm00XCIpIHJldHVybiA0ICogNCAqIDQ7XG5cbiAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJ1bmtub3duIHR5cGUgZ2V0U2l6ZUJ5dGVzXCIpO1xuICAgICAgICAvLyBpZiAodGhpcy5fdHlwZSA9PSBcInRcIikgcmV0dXJuIFwic2FtcGxlcjJEXCI7XG4gICAgICAgIC8vIGlmICh0aGlzLl90eXBlID09IFwidGNcIikgcmV0dXJuIFwic2FtcGxlckN1YmVcIjtcbiAgICAgICAgLy8gaWYgKHRoaXMuX3R5cGUgPT0gXCJiXCIpIHJldHVybiBcImJvb2xcIjtcblxuICAgICAgICAvLyBpZiAodCA9PSBcIjNmW11cIikgcmV0dXJuIG51bGw7IC8vIGlnbm9yZSB0aGlzIGZvciBub3cuLi5cbiAgICAgICAgLy8gaWYgKHQgPT0gXCJtNFtdXCIpIHJldHVybiBudWxsOyAvLyBpZ25vcmUgdGhpcyBmb3Igbm93Li4uXG4gICAgICAgIC8vIGlmICh0ID09IFwiZltdXCIpIHJldHVybiBudWxsOyAvLyBpZ25vcmUgdGhpcyBmb3Igbm93Li4uXG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgp/cgp_uniform.js\n");

/***/ }),

/***/ "./src/core/cgp/cgp_uniformbuffer.js":
/*!*******************************************!*\
  !*** ./src/core/cgp/cgp_uniformbuffer.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ UniformBuffer)\n/* harmony export */ });\nclass UniformBuffer\n{\n    constructor(shader, shaderType)\n    {\n        this._shaderType = shaderType; // frag, vert...\n        this._shader = shader;\n        this._cgp = shader._cgp;\n\n        this._gpuBuffer = null;\n        this._values = null;\n\n        this._sizeBytes = 0;\n        this.update();\n    }\n\n    update()\n    {\n        this._sizeBytes = 0;\n\n        for (let i = 0; i < this._shader.uniforms.length; i++)\n        {\n            const uni = this._shader.uniforms[i];\n\n            if (this._shaderType == uni.shaderType)\n                this._sizeBytes += uni.getSizeBytes();\n        }\n\n        this._gpuBuffer = this._cgp.device.createBuffer(\n            {\n                \"size\": this._sizeBytes,\n                \"usage\": GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n            });\n\n\n        this._values = new Float32Array(this._sizeBytes / 4);\n        this.updateUniformValues();\n    }\n\n    updateUniformValues()\n    {\n        let count = 0;\n        for (let i = 0; i < this._shader.uniforms.length; i++)\n        {\n            const uni = this._shader.uniforms[i];\n            if (uni.shaderType == this._shaderType)\n            {\n                if (uni.getSizeBytes() / 4 > 1)\n                {\n                    for (let j = 0; j < uni.getValue().length; j++)\n                    {\n                        this._values[count] = uni.getValue()[j];\n                        count++;\n                    }\n                }\n                else\n                {\n                    this._values[count] = uni.getValue();\n                    count++;\n                }\n            }\n        }\n\n\n        this._cgp.device.queue.writeBuffer(\n            this._gpuBuffer,\n            0,\n            this._values.buffer,\n            this._values.byteOffset,\n            this._values.byteLength\n        );\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvY2dwX3VuaWZvcm1idWZmZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY2dwL2NncF91bmlmb3JtYnVmZmVyLmpzPzA5ZWMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgVW5pZm9ybUJ1ZmZlclxue1xuICAgIGNvbnN0cnVjdG9yKHNoYWRlciwgc2hhZGVyVHlwZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX3NoYWRlclR5cGUgPSBzaGFkZXJUeXBlOyAvLyBmcmFnLCB2ZXJ0Li4uXG4gICAgICAgIHRoaXMuX3NoYWRlciA9IHNoYWRlcjtcbiAgICAgICAgdGhpcy5fY2dwID0gc2hhZGVyLl9jZ3A7XG5cbiAgICAgICAgdGhpcy5fZ3B1QnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9zaXplQnl0ZXMgPSAwO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpXG4gICAge1xuICAgICAgICB0aGlzLl9zaXplQnl0ZXMgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2hhZGVyLnVuaWZvcm1zLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCB1bmkgPSB0aGlzLl9zaGFkZXIudW5pZm9ybXNbaV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zaGFkZXJUeXBlID09IHVuaS5zaGFkZXJUeXBlKVxuICAgICAgICAgICAgICAgIHRoaXMuX3NpemVCeXRlcyArPSB1bmkuZ2V0U2l6ZUJ5dGVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ncHVCdWZmZXIgPSB0aGlzLl9jZ3AuZGV2aWNlLmNyZWF0ZUJ1ZmZlcihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcInNpemVcIjogdGhpcy5fc2l6ZUJ5dGVzLFxuICAgICAgICAgICAgICAgIFwidXNhZ2VcIjogR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNULFxuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICB0aGlzLl92YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX3NpemVCeXRlcyAvIDQpO1xuICAgICAgICB0aGlzLnVwZGF0ZVVuaWZvcm1WYWx1ZXMoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVVbmlmb3JtVmFsdWVzKClcbiAgICB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2hhZGVyLnVuaWZvcm1zLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCB1bmkgPSB0aGlzLl9zaGFkZXIudW5pZm9ybXNbaV07XG4gICAgICAgICAgICBpZiAodW5pLnNoYWRlclR5cGUgPT0gdGhpcy5fc2hhZGVyVHlwZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pLmdldFNpemVCeXRlcygpIC8gNCA+IDEpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHVuaS5nZXRWYWx1ZSgpLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbY291bnRdID0gdW5pLmdldFZhbHVlKClbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tjb3VudF0gPSB1bmkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMuX2NncC5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIoXG4gICAgICAgICAgICB0aGlzLl9ncHVCdWZmZXIsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmJ1ZmZlcixcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmJ5dGVMZW5ndGhcbiAgICAgICAgKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/cgp/cgp_uniformbuffer.js\n");

/***/ }),

/***/ "./src/core/cgp/index.js":
/*!*******************************!*\
  !*** ./src/core/cgp/index.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CGP\": () => (/* binding */ CGP)\n/* harmony export */ });\n/* harmony import */ var _cgp_state_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cgp_state.js */ \"./src/core/cgp/cgp_state.js\");\n/* harmony import */ var _cgp_shader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cgp_shader.js */ \"./src/core/cgp/cgp_shader.js\");\n/* harmony import */ var _cgp_mesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgp_mesh.js */ \"./src/core/cgp/cgp_mesh.js\");\n/* harmony import */ var _cgp_pipeline_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cgp_pipeline.js */ \"./src/core/cgp/cgp_pipeline.js\");\n/* harmony import */ var _cgp_texture_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cgp_texture.js */ \"./src/core/cgp/cgp_texture.js\");\n\n\n\n\n\n\nconst CGP = {\n    \"Context\": _cgp_state_js__WEBPACK_IMPORTED_MODULE_0__.WebGpuContext,\n    \"Shader\": _cgp_shader_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n    \"Mesh\": _cgp_mesh_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n    \"Pipeline\": _cgp_pipeline_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    \"Texture\": _cgp_texture_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n};\n\nwindow.CGP = CGP;\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jZ3AvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jZ3AvaW5kZXguanM/MGIzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXZWJHcHVDb250ZXh0IH0gZnJvbSBcIi4vY2dwX3N0YXRlLmpzXCI7XG5pbXBvcnQgU2hhZGVyIGZyb20gXCIuL2NncF9zaGFkZXIuanNcIjtcbmltcG9ydCBNZXNoIGZyb20gXCIuL2NncF9tZXNoLmpzXCI7XG5pbXBvcnQgUGlwZWxpbmUgZnJvbSBcIi4vY2dwX3BpcGVsaW5lLmpzXCI7XG5pbXBvcnQgVGV4dHVyZSBmcm9tIFwiLi9jZ3BfdGV4dHVyZS5qc1wiO1xuXG5jb25zdCBDR1AgPSB7XG4gICAgXCJDb250ZXh0XCI6IFdlYkdwdUNvbnRleHQsXG4gICAgXCJTaGFkZXJcIjogU2hhZGVyLFxuICAgIFwiTWVzaFwiOiBNZXNoLFxuICAgIFwiUGlwZWxpbmVcIjogUGlwZWxpbmUsXG4gICAgXCJUZXh0dXJlXCI6IFRleHR1cmUsXG59O1xuXG53aW5kb3cuQ0dQID0gQ0dQO1xuXG5cbmV4cG9ydCB7IENHUCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/cgp/index.js\n");

/***/ }),

/***/ "./src/core/constants.js":
/*!*******************************!*\
  !*** ./src/core/constants.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CONSTANTS\": () => (/* binding */ CONSTANTS)\n/* harmony export */ });\nconst CONSTANTS = {\n    \"ANIM\": {\n        \"EASINGS\": [\n            \"linear\",\n            \"absolute\",\n            \"smoothstep\",\n            \"smootherstep\",\n            \"Cubic In\",\n            \"Cubic Out\",\n            \"Cubic In Out\",\n            \"Expo In\",\n            \"Expo Out\",\n            \"Expo In Out\",\n            \"Sin In\",\n            \"Sin Out\",\n            \"Sin In Out\",\n            \"Quart In\",\n            \"Quart Out\",\n            \"Quart In Out\",\n            \"Quint In\",\n            \"Quint Out\",\n            \"Quint In Out\",\n            \"Back In\",\n            \"Back Out\",\n            \"Back In Out\",\n            \"Elastic In\",\n            \"Elastic Out\",\n            \"Bounce In\",\n            \"Bounce Out\",\n        ],\n        \"EASING_LINEAR\": 0,\n        \"EASING_ABSOLUTE\": 1,\n        \"EASING_SMOOTHSTEP\": 2,\n        \"EASING_SMOOTHERSTEP\": 3,\n        \"EASING_CUBICSPLINE\": 4,\n\n        \"EASING_CUBIC_IN\": 5,\n        \"EASING_CUBIC_OUT\": 6,\n        \"EASING_CUBIC_INOUT\": 7,\n\n        \"EASING_EXPO_IN\": 8,\n        \"EASING_EXPO_OUT\": 9,\n        \"EASING_EXPO_INOUT\": 10,\n\n        \"EASING_SIN_IN\": 11,\n        \"EASING_SIN_OUT\": 12,\n        \"EASING_SIN_INOUT\": 13,\n\n        \"EASING_BACK_IN\": 14,\n        \"EASING_BACK_OUT\": 15,\n        \"EASING_BACK_INOUT\": 16,\n\n        \"EASING_ELASTIC_IN\": 17,\n        \"EASING_ELASTIC_OUT\": 18,\n\n        \"EASING_BOUNCE_IN\": 19,\n        \"EASING_BOUNCE_OUT\": 21,\n\n        \"EASING_QUART_IN\": 22,\n        \"EASING_QUART_OUT\": 23,\n        \"EASING_QUART_INOUT\": 24,\n\n        \"EASING_QUINT_IN\": 25,\n        \"EASING_QUINT_OUT\": 26,\n        \"EASING_QUINT_INOUT\": 27,\n    },\n\n    \"OP\": {\n        \"OP_PORT_TYPE_VALUE\": 0,\n        \"OP_PORT_TYPE_FUNCTION\": 1,\n        \"OP_PORT_TYPE_TRIGGER\": 1,\n        \"OP_PORT_TYPE_OBJECT\": 2,\n        \"OP_PORT_TYPE_TEXTURE\": 2,\n        \"OP_PORT_TYPE_ARRAY\": 3,\n        \"OP_PORT_TYPE_DYNAMIC\": 4,\n        \"OP_PORT_TYPE_STRING\": 5,\n\n        \"OP_VERSION_PREFIX\": \"_v\",\n    },\n\n    \"PORT\": {\n        \"PORT_DIR_IN\": 0,\n        \"PORT_DIR_OUT\": 1,\n    },\n\n    \"PACO\": {\n        \"PACO_CLEAR\": 0,\n        \"PACO_VALUECHANGE\": 1,\n        \"PACO_OP_DELETE\": 2,\n        \"PACO_UNLINK\": 3,\n        \"PACO_LINK\": 4,\n        \"PACO_LOAD\": 5,\n        \"PACO_OP_CREATE\": 6,\n        \"PACO_OP_ENABLE\": 7,\n        \"PACO_OP_DISABLE\": 8,\n        \"PACO_UIATTRIBS\": 9,\n        \"PACO_VARIABLES\": 10,\n        \"PACO_TRIGGERS\": 11,\n        \"PACO_PORT_SETVARIABLE\": 12,\n        \"PACO_PORT_SETANIMATED\": 13,\n        \"PACO_PORT_ANIM_UPDATED\": 14,\n        \"PACO_DESERIALIZE\": 15\n\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb25zdGFudHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY29uc3RhbnRzLmpzPzUzNmIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IENPTlNUQU5UUyA9IHtcbiAgICBcIkFOSU1cIjoge1xuICAgICAgICBcIkVBU0lOR1NcIjogW1xuICAgICAgICAgICAgXCJsaW5lYXJcIixcbiAgICAgICAgICAgIFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIFwic21vb3Roc3RlcFwiLFxuICAgICAgICAgICAgXCJzbW9vdGhlcnN0ZXBcIixcbiAgICAgICAgICAgIFwiQ3ViaWMgSW5cIixcbiAgICAgICAgICAgIFwiQ3ViaWMgT3V0XCIsXG4gICAgICAgICAgICBcIkN1YmljIEluIE91dFwiLFxuICAgICAgICAgICAgXCJFeHBvIEluXCIsXG4gICAgICAgICAgICBcIkV4cG8gT3V0XCIsXG4gICAgICAgICAgICBcIkV4cG8gSW4gT3V0XCIsXG4gICAgICAgICAgICBcIlNpbiBJblwiLFxuICAgICAgICAgICAgXCJTaW4gT3V0XCIsXG4gICAgICAgICAgICBcIlNpbiBJbiBPdXRcIixcbiAgICAgICAgICAgIFwiUXVhcnQgSW5cIixcbiAgICAgICAgICAgIFwiUXVhcnQgT3V0XCIsXG4gICAgICAgICAgICBcIlF1YXJ0IEluIE91dFwiLFxuICAgICAgICAgICAgXCJRdWludCBJblwiLFxuICAgICAgICAgICAgXCJRdWludCBPdXRcIixcbiAgICAgICAgICAgIFwiUXVpbnQgSW4gT3V0XCIsXG4gICAgICAgICAgICBcIkJhY2sgSW5cIixcbiAgICAgICAgICAgIFwiQmFjayBPdXRcIixcbiAgICAgICAgICAgIFwiQmFjayBJbiBPdXRcIixcbiAgICAgICAgICAgIFwiRWxhc3RpYyBJblwiLFxuICAgICAgICAgICAgXCJFbGFzdGljIE91dFwiLFxuICAgICAgICAgICAgXCJCb3VuY2UgSW5cIixcbiAgICAgICAgICAgIFwiQm91bmNlIE91dFwiLFxuICAgICAgICBdLFxuICAgICAgICBcIkVBU0lOR19MSU5FQVJcIjogMCxcbiAgICAgICAgXCJFQVNJTkdfQUJTT0xVVEVcIjogMSxcbiAgICAgICAgXCJFQVNJTkdfU01PT1RIU1RFUFwiOiAyLFxuICAgICAgICBcIkVBU0lOR19TTU9PVEhFUlNURVBcIjogMyxcbiAgICAgICAgXCJFQVNJTkdfQ1VCSUNTUExJTkVcIjogNCxcblxuICAgICAgICBcIkVBU0lOR19DVUJJQ19JTlwiOiA1LFxuICAgICAgICBcIkVBU0lOR19DVUJJQ19PVVRcIjogNixcbiAgICAgICAgXCJFQVNJTkdfQ1VCSUNfSU5PVVRcIjogNyxcblxuICAgICAgICBcIkVBU0lOR19FWFBPX0lOXCI6IDgsXG4gICAgICAgIFwiRUFTSU5HX0VYUE9fT1VUXCI6IDksXG4gICAgICAgIFwiRUFTSU5HX0VYUE9fSU5PVVRcIjogMTAsXG5cbiAgICAgICAgXCJFQVNJTkdfU0lOX0lOXCI6IDExLFxuICAgICAgICBcIkVBU0lOR19TSU5fT1VUXCI6IDEyLFxuICAgICAgICBcIkVBU0lOR19TSU5fSU5PVVRcIjogMTMsXG5cbiAgICAgICAgXCJFQVNJTkdfQkFDS19JTlwiOiAxNCxcbiAgICAgICAgXCJFQVNJTkdfQkFDS19PVVRcIjogMTUsXG4gICAgICAgIFwiRUFTSU5HX0JBQ0tfSU5PVVRcIjogMTYsXG5cbiAgICAgICAgXCJFQVNJTkdfRUxBU1RJQ19JTlwiOiAxNyxcbiAgICAgICAgXCJFQVNJTkdfRUxBU1RJQ19PVVRcIjogMTgsXG5cbiAgICAgICAgXCJFQVNJTkdfQk9VTkNFX0lOXCI6IDE5LFxuICAgICAgICBcIkVBU0lOR19CT1VOQ0VfT1VUXCI6IDIxLFxuXG4gICAgICAgIFwiRUFTSU5HX1FVQVJUX0lOXCI6IDIyLFxuICAgICAgICBcIkVBU0lOR19RVUFSVF9PVVRcIjogMjMsXG4gICAgICAgIFwiRUFTSU5HX1FVQVJUX0lOT1VUXCI6IDI0LFxuXG4gICAgICAgIFwiRUFTSU5HX1FVSU5UX0lOXCI6IDI1LFxuICAgICAgICBcIkVBU0lOR19RVUlOVF9PVVRcIjogMjYsXG4gICAgICAgIFwiRUFTSU5HX1FVSU5UX0lOT1VUXCI6IDI3LFxuICAgIH0sXG5cbiAgICBcIk9QXCI6IHtcbiAgICAgICAgXCJPUF9QT1JUX1RZUEVfVkFMVUVcIjogMCxcbiAgICAgICAgXCJPUF9QT1JUX1RZUEVfRlVOQ1RJT05cIjogMSxcbiAgICAgICAgXCJPUF9QT1JUX1RZUEVfVFJJR0dFUlwiOiAxLFxuICAgICAgICBcIk9QX1BPUlRfVFlQRV9PQkpFQ1RcIjogMixcbiAgICAgICAgXCJPUF9QT1JUX1RZUEVfVEVYVFVSRVwiOiAyLFxuICAgICAgICBcIk9QX1BPUlRfVFlQRV9BUlJBWVwiOiAzLFxuICAgICAgICBcIk9QX1BPUlRfVFlQRV9EWU5BTUlDXCI6IDQsXG4gICAgICAgIFwiT1BfUE9SVF9UWVBFX1NUUklOR1wiOiA1LFxuXG4gICAgICAgIFwiT1BfVkVSU0lPTl9QUkVGSVhcIjogXCJfdlwiLFxuICAgIH0sXG5cbiAgICBcIlBPUlRcIjoge1xuICAgICAgICBcIlBPUlRfRElSX0lOXCI6IDAsXG4gICAgICAgIFwiUE9SVF9ESVJfT1VUXCI6IDEsXG4gICAgfSxcblxuICAgIFwiUEFDT1wiOiB7XG4gICAgICAgIFwiUEFDT19DTEVBUlwiOiAwLFxuICAgICAgICBcIlBBQ09fVkFMVUVDSEFOR0VcIjogMSxcbiAgICAgICAgXCJQQUNPX09QX0RFTEVURVwiOiAyLFxuICAgICAgICBcIlBBQ09fVU5MSU5LXCI6IDMsXG4gICAgICAgIFwiUEFDT19MSU5LXCI6IDQsXG4gICAgICAgIFwiUEFDT19MT0FEXCI6IDUsXG4gICAgICAgIFwiUEFDT19PUF9DUkVBVEVcIjogNixcbiAgICAgICAgXCJQQUNPX09QX0VOQUJMRVwiOiA3LFxuICAgICAgICBcIlBBQ09fT1BfRElTQUJMRVwiOiA4LFxuICAgICAgICBcIlBBQ09fVUlBVFRSSUJTXCI6IDksXG4gICAgICAgIFwiUEFDT19WQVJJQUJMRVNcIjogMTAsXG4gICAgICAgIFwiUEFDT19UUklHR0VSU1wiOiAxMSxcbiAgICAgICAgXCJQQUNPX1BPUlRfU0VUVkFSSUFCTEVcIjogMTIsXG4gICAgICAgIFwiUEFDT19QT1JUX1NFVEFOSU1BVEVEXCI6IDEzLFxuICAgICAgICBcIlBBQ09fUE9SVF9BTklNX1VQREFURURcIjogMTQsXG4gICAgICAgIFwiUEFDT19ERVNFUklBTElaRVwiOiAxNVxuXG4gICAgfSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/constants.js\n");

/***/ }),

/***/ "./src/core/core_link.js":
/*!*******************************!*\
  !*** ./src/core/core_link.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Link\": () => (/* binding */ Link)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./src/core/constants.js\");\n/* harmony import */ var _eventtarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eventtarget.js */ \"./src/core/eventtarget.js\");\n\n\n\n/**\n * @external CABLES\n * @namespace Link\n * @param {Object} patch The patch object\n * @description a link is a connection between two ops/ports -> one input and one output port\n * @hideconstructor\n * @class\n */\nconst Link = function (scene)\n{\n    _eventtarget_js__WEBPACK_IMPORTED_MODULE_0__.EventTarget.apply(this);\n\n    this.id = CABLES.simpleId();\n    this.portIn = null;\n    this.portOut = null;\n    this.scene = scene; // todo: make private and rename to patch\n    this.activityCounter = 0;\n    this.ignoreInSerialize = false;\n};\n\nLink.prototype.setValue = function (v)\n{\n    if (v === undefined) this._setValue();\n    else this.portIn.set(v);\n};\n\nLink.prototype.activity = function ()\n{\n    this.activityCounter++;\n    // if(Date.now()-this.lastTime>100)\n    // {\n    //     // this.lastTime=Date.now();\n    //     // this.changesPerSecond=this.changesCounter*10;\n    //     this.changesCounter=0;\n    // }\n};\n\nLink.prototype._setValue = function ()\n{\n    if (!this.portOut)\n    {\n        this.remove();\n        return;\n    }\n    const v = this.portOut.get();\n\n    if (v == v) // NaN is the only JavaScript value that is treated as unequal to itself\n    {\n        if (this.portIn.type != _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION) this.activity();\n\n        if (this.portIn.get() !== v)\n        {\n            this.portIn.set(v);\n        }\n        else\n        {\n            if (this.portIn.changeAlways) this.portIn.set(v);\n            if (this.portOut.forceRefChange) this.portIn.forceChange();\n        }\n    }\n};\n\n/**\n * @function getOtherPort\n * @memberof Link\n * @instance\n * @param {Port} port\n * @description returns the port of the link, which is not port\n */\nLink.prototype.getOtherPort = function (p)\n{\n    if (p == this.portIn) return this.portOut;\n    return this.portIn;\n};\n\n/**\n * @function remove\n * @memberof Link\n * @instance\n * @description unlink/remove this link from all ports\n */\nLink.prototype.remove = function ()\n{\n    if (this.portIn) this.portIn.removeLink(this);\n    if (this.portOut) this.portOut.removeLink(this);\n    if (this.scene)\n    {\n        this.scene.emitEvent(\"onUnLink\", this.portIn, this.portOut, this);\n    }\n\n    if (this.portIn && (this.portIn.type == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT || this.portIn.type == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.OP.OP_PORT_TYPE_ARRAY))\n    {\n        this.portIn.set(null);\n        if (this.portIn.links.length > 0) this.portIn.set(this.portIn.links[0].getOtherPort(this.portIn).get());\n    }\n\n    if (this.portIn) this.portIn.op._checkLinksNeededToWork();\n    if (this.portOut) this.portOut.op._checkLinksNeededToWork();\n\n    this.portIn = null;\n    this.portOut = null;\n    this.scene = null;\n};\n\n/**\n * @function link\n * @memberof Link\n * @instance\n * @description link those two ports\n * @param {Port} port1\n * @param {Port} port2\n */\nLink.prototype.link = function (p1, p2)\n{\n    if (!Link.canLink(p1, p2))\n    {\n        console.warn(\"[core_link] cannot link ports!\", p1, p2);\n        return false;\n    }\n\n    if (p1.direction == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.PORT.PORT_DIR_IN)\n    {\n        this.portIn = p1;\n        this.portOut = p2;\n    }\n    else\n    {\n        this.portIn = p2;\n        this.portOut = p1;\n    }\n\n    p1.addLink(this);\n    p2.addLink(this);\n\n    this.setValue();\n\n    if (p1.onLink) p1.onLink(this);\n    if (p2.onLink) p2.onLink(this);\n\n    p1.op._checkLinksNeededToWork();\n    p2.op._checkLinksNeededToWork();\n};\n\nLink.prototype.getSerialized = function ()\n{\n    const obj = {};\n\n    obj.portIn = this.portIn.getName();\n    obj.portOut = this.portOut.getName();\n    obj.objIn = this.portIn.op.id;\n    obj.objOut = this.portOut.op.id;\n\n    return obj;\n};\n\n// --------------------------------------------\n\n/**\n * @function canLinkText\n * @memberof Link\n * @instance\n * @description return a text message with human readable reason if ports can not be linked, or can be\n * @param {Port} port1\n * @param {Port} port2\n */\nLink.canLinkText = function (p1, p2)\n{\n    if (p1.direction == p2.direction)\n    {\n        let txt = \"(out)\";\n        if (p2.direction == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.PORT.PORT_DIR_IN) txt = \"(in)\";\n        return \"can not link: same direction \" + txt;\n    }\n    if (p1.op == p2.op) return \"can not link: same op\";\n    if (p1.type != _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC && p2.type != _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC)\n    {\n        if (p1.type != p2.type) return \"can not link: different type\";\n    }\n\n    if (CABLES.UI && p1.type == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT && p2.type == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT)\n    {\n        if (p1.uiAttribs.objType && p2.uiAttribs.objType)\n            if (p1.uiAttribs.objType != p2.uiAttribs.objType)\n                return \"incompatible objects\";\n    }\n\n\n    if (!p1) return \"can not link: port 1 invalid\";\n    if (!p2) return \"can not link: port 2 invalid\";\n\n    if (p1.direction == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.PORT.PORT_DIR_IN && p1.isAnimated()) return \"can not link: is animated\";\n    if (p2.direction == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.PORT.PORT_DIR_IN && p2.isAnimated()) return \"can not link: is animated\";\n\n    // if(p1.direction==CABLES.CONSTANTS.PORT.PORT_DIR_IN && p1.links.length>0)return 'input port already busy';\n    // if(p2.direction==CABLES.CONSTANTS.PORT.PORT_DIR_IN && p2.links.length>0)return 'input port already busy';\n    if (p1.isLinkedTo(p2)) return \"ports already linked\";\n\n    if ((p1.canLink && !p1.canLink(p2)) || (p2.canLink && !p2.canLink(p1))) return \"Incompatible\";\n\n    return \"can link\";\n};\n\n/**\n * @function canLink\n * @memberof Link\n * @instance\n * @description return true if ports can be linked\n * @param {Port} port1\n * @param {Port} port2\n * @returns {Boolean}\n */\nLink.canLink = function (p1, p2)\n{\n    if (!p1) return false;\n    if (!p2) return false;\n    if (p1.direction == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.PORT.PORT_DIR_IN && p1.isAnimated()) return false;\n    if (p2.direction == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.PORT.PORT_DIR_IN && p2.isAnimated()) return false;\n\n    if (p1.isHidden() || p2.isHidden()) return false;\n\n    if (p1.isLinkedTo(p2)) return false;\n\n    if (p1.direction == p2.direction) return false;\n\n    if (CABLES.UI && p1.type == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT && p2.type == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT)\n    {\n        if (p1.uiAttribs.objType && p2.uiAttribs.objType)\n        {\n            if (p1.uiAttribs.objType.indexOf(\"sg_\") == 0 && p2.uiAttribs.objType.indexOf(\"sg_\") == 0) return true;\n            if (p1.uiAttribs.objType != p2.uiAttribs.objType)\n                return false;\n        }\n    }\n\n    if (p1.type != p2.type && (p1.type != _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC && p2.type != _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC)) return false;\n    if (p1.type == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC || p2.type == _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return true;\n\n    if (p1.op == p2.op) return false;\n\n    if (p1.canLink && !p1.canLink(p2)) return false;\n    if (p2.canLink && !p2.canLink(p1)) return false;\n\n    return true;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX2xpbmsuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jb3JlX2xpbmsuanM/YTdlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IEV2ZW50VGFyZ2V0IH0gZnJvbSBcIi4vZXZlbnR0YXJnZXQuanNcIjtcblxuLyoqXG4gKiBAZXh0ZXJuYWwgQ0FCTEVTXG4gKiBAbmFtZXNwYWNlIExpbmtcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRjaCBUaGUgcGF0Y2ggb2JqZWN0XG4gKiBAZGVzY3JpcHRpb24gYSBsaW5rIGlzIGEgY29ubmVjdGlvbiBiZXR3ZWVuIHR3byBvcHMvcG9ydHMgLT4gb25lIGlucHV0IGFuZCBvbmUgb3V0cHV0IHBvcnRcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqIEBjbGFzc1xuICovXG5jb25zdCBMaW5rID0gZnVuY3Rpb24gKHNjZW5lKVxue1xuICAgIEV2ZW50VGFyZ2V0LmFwcGx5KHRoaXMpO1xuXG4gICAgdGhpcy5pZCA9IENBQkxFUy5zaW1wbGVJZCgpO1xuICAgIHRoaXMucG9ydEluID0gbnVsbDtcbiAgICB0aGlzLnBvcnRPdXQgPSBudWxsO1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTsgLy8gdG9kbzogbWFrZSBwcml2YXRlIGFuZCByZW5hbWUgdG8gcGF0Y2hcbiAgICB0aGlzLmFjdGl2aXR5Q291bnRlciA9IDA7XG4gICAgdGhpcy5pZ25vcmVJblNlcmlhbGl6ZSA9IGZhbHNlO1xufTtcblxuTGluay5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodilcbntcbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB0aGlzLl9zZXRWYWx1ZSgpO1xuICAgIGVsc2UgdGhpcy5wb3J0SW4uc2V0KHYpO1xufTtcblxuTGluay5wcm90b3R5cGUuYWN0aXZpdHkgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuYWN0aXZpdHlDb3VudGVyKys7XG4gICAgLy8gaWYoRGF0ZS5ub3coKS10aGlzLmxhc3RUaW1lPjEwMClcbiAgICAvLyB7XG4gICAgLy8gICAgIC8vIHRoaXMubGFzdFRpbWU9RGF0ZS5ub3coKTtcbiAgICAvLyAgICAgLy8gdGhpcy5jaGFuZ2VzUGVyU2Vjb25kPXRoaXMuY2hhbmdlc0NvdW50ZXIqMTA7XG4gICAgLy8gICAgIHRoaXMuY2hhbmdlc0NvdW50ZXI9MDtcbiAgICAvLyB9XG59O1xuXG5MaW5rLnByb3RvdHlwZS5fc2V0VmFsdWUgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICghdGhpcy5wb3J0T3V0KVxuICAgIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2ID0gdGhpcy5wb3J0T3V0LmdldCgpO1xuXG4gICAgaWYgKHYgPT0gdikgLy8gTmFOIGlzIHRoZSBvbmx5IEphdmFTY3JpcHQgdmFsdWUgdGhhdCBpcyB0cmVhdGVkIGFzIHVuZXF1YWwgdG8gaXRzZWxmXG4gICAge1xuICAgICAgICBpZiAodGhpcy5wb3J0SW4udHlwZSAhPSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0ZVTkNUSU9OKSB0aGlzLmFjdGl2aXR5KCk7XG5cbiAgICAgICAgaWYgKHRoaXMucG9ydEluLmdldCgpICE9PSB2KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnBvcnRJbi5zZXQodik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3J0SW4uY2hhbmdlQWx3YXlzKSB0aGlzLnBvcnRJbi5zZXQodik7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3J0T3V0LmZvcmNlUmVmQ2hhbmdlKSB0aGlzLnBvcnRJbi5mb3JjZUNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gZ2V0T3RoZXJQb3J0XG4gKiBAbWVtYmVyb2YgTGlua1xuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1BvcnR9IHBvcnRcbiAqIEBkZXNjcmlwdGlvbiByZXR1cm5zIHRoZSBwb3J0IG9mIHRoZSBsaW5rLCB3aGljaCBpcyBub3QgcG9ydFxuICovXG5MaW5rLnByb3RvdHlwZS5nZXRPdGhlclBvcnQgPSBmdW5jdGlvbiAocClcbntcbiAgICBpZiAocCA9PSB0aGlzLnBvcnRJbikgcmV0dXJuIHRoaXMucG9ydE91dDtcbiAgICByZXR1cm4gdGhpcy5wb3J0SW47XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiByZW1vdmVcbiAqIEBtZW1iZXJvZiBMaW5rXG4gKiBAaW5zdGFuY2VcbiAqIEBkZXNjcmlwdGlvbiB1bmxpbmsvcmVtb3ZlIHRoaXMgbGluayBmcm9tIGFsbCBwb3J0c1xuICovXG5MaW5rLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLnBvcnRJbikgdGhpcy5wb3J0SW4ucmVtb3ZlTGluayh0aGlzKTtcbiAgICBpZiAodGhpcy5wb3J0T3V0KSB0aGlzLnBvcnRPdXQucmVtb3ZlTGluayh0aGlzKTtcbiAgICBpZiAodGhpcy5zY2VuZSlcbiAgICB7XG4gICAgICAgIHRoaXMuc2NlbmUuZW1pdEV2ZW50KFwib25VbkxpbmtcIiwgdGhpcy5wb3J0SW4sIHRoaXMucG9ydE91dCwgdGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucG9ydEluICYmICh0aGlzLnBvcnRJbi50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfT0JKRUNUIHx8IHRoaXMucG9ydEluLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9BUlJBWSkpXG4gICAge1xuICAgICAgICB0aGlzLnBvcnRJbi5zZXQobnVsbCk7XG4gICAgICAgIGlmICh0aGlzLnBvcnRJbi5saW5rcy5sZW5ndGggPiAwKSB0aGlzLnBvcnRJbi5zZXQodGhpcy5wb3J0SW4ubGlua3NbMF0uZ2V0T3RoZXJQb3J0KHRoaXMucG9ydEluKS5nZXQoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucG9ydEluKSB0aGlzLnBvcnRJbi5vcC5fY2hlY2tMaW5rc05lZWRlZFRvV29yaygpO1xuICAgIGlmICh0aGlzLnBvcnRPdXQpIHRoaXMucG9ydE91dC5vcC5fY2hlY2tMaW5rc05lZWRlZFRvV29yaygpO1xuXG4gICAgdGhpcy5wb3J0SW4gPSBudWxsO1xuICAgIHRoaXMucG9ydE91dCA9IG51bGw7XG4gICAgdGhpcy5zY2VuZSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBsaW5rXG4gKiBAbWVtYmVyb2YgTGlua1xuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gbGluayB0aG9zZSB0d28gcG9ydHNcbiAqIEBwYXJhbSB7UG9ydH0gcG9ydDFcbiAqIEBwYXJhbSB7UG9ydH0gcG9ydDJcbiAqL1xuTGluay5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uIChwMSwgcDIpXG57XG4gICAgaWYgKCFMaW5rLmNhbkxpbmsocDEsIHAyKSlcbiAgICB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltjb3JlX2xpbmtdIGNhbm5vdCBsaW5rIHBvcnRzIVwiLCBwMSwgcDIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHAxLmRpcmVjdGlvbiA9PSBDT05TVEFOVFMuUE9SVC5QT1JUX0RJUl9JTilcbiAgICB7XG4gICAgICAgIHRoaXMucG9ydEluID0gcDE7XG4gICAgICAgIHRoaXMucG9ydE91dCA9IHAyO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLnBvcnRJbiA9IHAyO1xuICAgICAgICB0aGlzLnBvcnRPdXQgPSBwMTtcbiAgICB9XG5cbiAgICBwMS5hZGRMaW5rKHRoaXMpO1xuICAgIHAyLmFkZExpbmsodGhpcyk7XG5cbiAgICB0aGlzLnNldFZhbHVlKCk7XG5cbiAgICBpZiAocDEub25MaW5rKSBwMS5vbkxpbmsodGhpcyk7XG4gICAgaWYgKHAyLm9uTGluaykgcDIub25MaW5rKHRoaXMpO1xuXG4gICAgcDEub3AuX2NoZWNrTGlua3NOZWVkZWRUb1dvcmsoKTtcbiAgICBwMi5vcC5fY2hlY2tMaW5rc05lZWRlZFRvV29yaygpO1xufTtcblxuTGluay5wcm90b3R5cGUuZ2V0U2VyaWFsaXplZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgY29uc3Qgb2JqID0ge307XG5cbiAgICBvYmoucG9ydEluID0gdGhpcy5wb3J0SW4uZ2V0TmFtZSgpO1xuICAgIG9iai5wb3J0T3V0ID0gdGhpcy5wb3J0T3V0LmdldE5hbWUoKTtcbiAgICBvYmoub2JqSW4gPSB0aGlzLnBvcnRJbi5vcC5pZDtcbiAgICBvYmoub2JqT3V0ID0gdGhpcy5wb3J0T3V0Lm9wLmlkO1xuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQGZ1bmN0aW9uIGNhbkxpbmtUZXh0XG4gKiBAbWVtYmVyb2YgTGlua1xuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gcmV0dXJuIGEgdGV4dCBtZXNzYWdlIHdpdGggaHVtYW4gcmVhZGFibGUgcmVhc29uIGlmIHBvcnRzIGNhbiBub3QgYmUgbGlua2VkLCBvciBjYW4gYmVcbiAqIEBwYXJhbSB7UG9ydH0gcG9ydDFcbiAqIEBwYXJhbSB7UG9ydH0gcG9ydDJcbiAqL1xuTGluay5jYW5MaW5rVGV4dCA9IGZ1bmN0aW9uIChwMSwgcDIpXG57XG4gICAgaWYgKHAxLmRpcmVjdGlvbiA9PSBwMi5kaXJlY3Rpb24pXG4gICAge1xuICAgICAgICBsZXQgdHh0ID0gXCIob3V0KVwiO1xuICAgICAgICBpZiAocDIuZGlyZWN0aW9uID09IENPTlNUQU5UUy5QT1JULlBPUlRfRElSX0lOKSB0eHQgPSBcIihpbilcIjtcbiAgICAgICAgcmV0dXJuIFwiY2FuIG5vdCBsaW5rOiBzYW1lIGRpcmVjdGlvbiBcIiArIHR4dDtcbiAgICB9XG4gICAgaWYgKHAxLm9wID09IHAyLm9wKSByZXR1cm4gXCJjYW4gbm90IGxpbms6IHNhbWUgb3BcIjtcbiAgICBpZiAocDEudHlwZSAhPSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0RZTkFNSUMgJiYgcDIudHlwZSAhPSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0RZTkFNSUMpXG4gICAge1xuICAgICAgICBpZiAocDEudHlwZSAhPSBwMi50eXBlKSByZXR1cm4gXCJjYW4gbm90IGxpbms6IGRpZmZlcmVudCB0eXBlXCI7XG4gICAgfVxuXG4gICAgaWYgKENBQkxFUy5VSSAmJiBwMS50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfT0JKRUNUICYmIHAyLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9PQkpFQ1QpXG4gICAge1xuICAgICAgICBpZiAocDEudWlBdHRyaWJzLm9ialR5cGUgJiYgcDIudWlBdHRyaWJzLm9ialR5cGUpXG4gICAgICAgICAgICBpZiAocDEudWlBdHRyaWJzLm9ialR5cGUgIT0gcDIudWlBdHRyaWJzLm9ialR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5jb21wYXRpYmxlIG9iamVjdHNcIjtcbiAgICB9XG5cblxuICAgIGlmICghcDEpIHJldHVybiBcImNhbiBub3QgbGluazogcG9ydCAxIGludmFsaWRcIjtcbiAgICBpZiAoIXAyKSByZXR1cm4gXCJjYW4gbm90IGxpbms6IHBvcnQgMiBpbnZhbGlkXCI7XG5cbiAgICBpZiAocDEuZGlyZWN0aW9uID09IENPTlNUQU5UUy5QT1JULlBPUlRfRElSX0lOICYmIHAxLmlzQW5pbWF0ZWQoKSkgcmV0dXJuIFwiY2FuIG5vdCBsaW5rOiBpcyBhbmltYXRlZFwiO1xuICAgIGlmIChwMi5kaXJlY3Rpb24gPT0gQ09OU1RBTlRTLlBPUlQuUE9SVF9ESVJfSU4gJiYgcDIuaXNBbmltYXRlZCgpKSByZXR1cm4gXCJjYW4gbm90IGxpbms6IGlzIGFuaW1hdGVkXCI7XG5cbiAgICAvLyBpZihwMS5kaXJlY3Rpb249PUNBQkxFUy5DT05TVEFOVFMuUE9SVC5QT1JUX0RJUl9JTiAmJiBwMS5saW5rcy5sZW5ndGg+MClyZXR1cm4gJ2lucHV0IHBvcnQgYWxyZWFkeSBidXN5JztcbiAgICAvLyBpZihwMi5kaXJlY3Rpb249PUNBQkxFUy5DT05TVEFOVFMuUE9SVC5QT1JUX0RJUl9JTiAmJiBwMi5saW5rcy5sZW5ndGg+MClyZXR1cm4gJ2lucHV0IHBvcnQgYWxyZWFkeSBidXN5JztcbiAgICBpZiAocDEuaXNMaW5rZWRUbyhwMikpIHJldHVybiBcInBvcnRzIGFscmVhZHkgbGlua2VkXCI7XG5cbiAgICBpZiAoKHAxLmNhbkxpbmsgJiYgIXAxLmNhbkxpbmsocDIpKSB8fCAocDIuY2FuTGluayAmJiAhcDIuY2FuTGluayhwMSkpKSByZXR1cm4gXCJJbmNvbXBhdGlibGVcIjtcblxuICAgIHJldHVybiBcImNhbiBsaW5rXCI7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBjYW5MaW5rXG4gKiBAbWVtYmVyb2YgTGlua1xuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gcmV0dXJuIHRydWUgaWYgcG9ydHMgY2FuIGJlIGxpbmtlZFxuICogQHBhcmFtIHtQb3J0fSBwb3J0MVxuICogQHBhcmFtIHtQb3J0fSBwb3J0MlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbkxpbmsuY2FuTGluayA9IGZ1bmN0aW9uIChwMSwgcDIpXG57XG4gICAgaWYgKCFwMSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghcDIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAocDEuZGlyZWN0aW9uID09IENPTlNUQU5UUy5QT1JULlBPUlRfRElSX0lOICYmIHAxLmlzQW5pbWF0ZWQoKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwMi5kaXJlY3Rpb24gPT0gQ09OU1RBTlRTLlBPUlQuUE9SVF9ESVJfSU4gJiYgcDIuaXNBbmltYXRlZCgpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAocDEuaXNIaWRkZW4oKSB8fCBwMi5pc0hpZGRlbigpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAocDEuaXNMaW5rZWRUbyhwMikpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwMS5kaXJlY3Rpb24gPT0gcDIuZGlyZWN0aW9uKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoQ0FCTEVTLlVJICYmIHAxLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9PQkpFQ1QgJiYgcDIudHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX09CSkVDVClcbiAgICB7XG4gICAgICAgIGlmIChwMS51aUF0dHJpYnMub2JqVHlwZSAmJiBwMi51aUF0dHJpYnMub2JqVHlwZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHAxLnVpQXR0cmlicy5vYmpUeXBlLmluZGV4T2YoXCJzZ19cIikgPT0gMCAmJiBwMi51aUF0dHJpYnMub2JqVHlwZS5pbmRleE9mKFwic2dfXCIpID09IDApIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHAxLnVpQXR0cmlicy5vYmpUeXBlICE9IHAyLnVpQXR0cmlicy5vYmpUeXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwMS50eXBlICE9IHAyLnR5cGUgJiYgKHAxLnR5cGUgIT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9EWU5BTUlDICYmIHAyLnR5cGUgIT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9EWU5BTUlDKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwMS50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfRFlOQU1JQyB8fCBwMi50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfRFlOQU1JQykgcmV0dXJuIHRydWU7XG5cbiAgICBpZiAocDEub3AgPT0gcDIub3ApIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwMS5jYW5MaW5rICYmICFwMS5jYW5MaW5rKHAyKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwMi5jYW5MaW5rICYmICFwMi5jYW5MaW5rKHAxKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnQgeyBMaW5rIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/core_link.js\n");

/***/ }),

/***/ "./src/core/core_op.js":
/*!*****************************!*\
  !*** ./src/core/core_op.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Op\": () => (/* binding */ Op)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n/* harmony import */ var _eventtarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eventtarget.js */ \"./src/core/eventtarget.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./src/core/utils.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"./src/core/constants.js\");\n/* harmony import */ var _core_port_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core_port.js */ \"./src/core/core_port.js\");\n/* harmony import */ var _core_port_switch_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core_port_switch.js */ \"./src/core/core_port_switch.js\");\n/* harmony import */ var _core_port_select_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core_port_select.js */ \"./src/core/core_port_select.js\");\n\n\n\n\n\n\n\n\n/**\n * op the class of all operators\n * @external CABLES\n * @namespace Op\n * @hideconstructor\n */\n\n/**\n * @type {Object}\n * @name attachments\n * @instance\n * @memberof Op\n * @description access file attachments as String values\n * @example\n * // set shader source to attached files (files are called shader.vert / shader.frag)\n * shader.setSource(attachments.shader_vert,attachments.shader_frag);\n */\n\nconst Ops = {};\n\nconst Op = function ()\n{\n    _eventtarget_js__WEBPACK_IMPORTED_MODULE_0__.EventTarget.apply(this);\n\n    this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"core_op\");\n    this.data = {}; // UNUSED, DEPRECATED, only left in for backwards compatibility with userops\n    this.storage = {}; // op-specific data to be included in export\n    this._objName = \"\";\n    this.portsOut = [];\n    this.portsIn = [];\n    this.portsInData = []; // original loaded patch data\n    this.opId = \"\"; // unique op id\n    this.uiAttribs = {};\n    this.enabled = true;\n    this.patch = arguments[0];\n    this.name = arguments[1];\n\n    this._linkTimeRules = {\n        \"needsLinkedToWork\": [],\n        \"needsParentOp\": null\n    };\n\n    this.shouldWork = {};\n    this.hasUiErrors = false;\n    this._uiErrors = {};\n    this._hasAnimPort = false;\n\n    if (arguments[1])\n    {\n        this._shortOpName = CABLES.getShortOpName(arguments[1]);\n        this.getTitle();\n    }\n\n    this.id = arguments[2] || (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.shortId)(); // instance id\n    this.onAddPort = null;\n    this.onCreate = null;\n    this.onResize = null;\n    this.onLoaded = null;\n    this.onDelete = null;\n    this.onUiAttrChange = null;\n    this.onError = null;\n\n    this._instances = null;\n\n    /**\n     * overwrite this to prerender shader and meshes / will be called by op `loadingStatus`\n     * @function preRender\n     * @memberof Op\n     * @instance\n     */\n    this.preRender = null;\n\n    /**\n     * overwrite this to initialize your op\n     * @function init\n     * @memberof Op\n     * @instance\n     */\n    this.init = null;\n\n    Object.defineProperty(this, \"objName\", { get() { return this._objName; } });\n    Object.defineProperty(this, \"shortName\", { get() { return this._shortOpName; } });\n\n    if (this.initUi) this.initUi();\n};\n\n{\n    Op.prototype.clearUiAttrib = function (name)\n    {\n        const obj = {};\n        obj.name = null;\n        this.uiAttrib(obj);\n    };\n\n    Op.prototype.checkMainloopExists = function ()\n    {\n        if (!CABLES.UI) return;\n        if (!this.patch.cgl.mainloopOp) this.setUiError(\"nomainloop\", \"patch should have a mainloop to use this op\");\n        else this.setUiError(\"nomainloop\", null);\n    };\n\n    Op.prototype.getTitle = function ()\n    {\n        if (!this.uiAttribs) return \"nouiattribs\" + this.name;\n\n        if ((this.uiAttribs.title === undefined || this.uiAttribs.title === \"\") && this.objName.indexOf(\"Ops.Ui.\") == -1)\n            this.uiAttribs.title = this._shortOpName;\n\n        if (this.uiAttribs.title === undefined) this.uiAttribs.title = this._shortOpName;\n\n        return this.uiAttribs.title;\n    };\n\n    Op.prototype.setTitle = function (name)\n    {\n        const doEmitEvent = this.name != name;\n        this.name = name;\n\n        if (this.uiAttribs.title != name) this.uiAttr({ \"title\": name });\n        if (doEmitEvent) this.emitEvent(\"onTitleChange\", name);\n    };\n\n    Op.prototype.setStorage = function (newAttribs)\n    {\n        if (!newAttribs) return;\n        this.storage = this.storage || {};\n\n        let changed = false;\n        for (const p in newAttribs)\n        {\n            if (this.storage[p] != newAttribs[p]) changed = true;\n            this.storage[p] = newAttribs[p];\n        }\n\n        if (changed) this.emitEvent(\"onStorageChange\", newAttribs);\n    };\n\n    Op.prototype.isSubPatchOp = function ()\n    {\n        if (this.storage) return (this.storage.subPatchVer || 0);\n    };\n\n    const _setUiAttrib = function (newAttribs)\n    {\n        if (!newAttribs) return;\n\n        if (newAttribs.error || newAttribs.warning || newAttribs.hint)\n        {\n            this._log.warn(\"old ui error/warning attribute in \" + this.name + \", use op.setUiError !\", newAttribs);\n        }\n\n\n\n        if (typeof newAttribs != \"object\") this._log.error(\"op.uiAttrib attribs are not of type object\");\n        if (!this.uiAttribs) this.uiAttribs = {};\n\n\n        let emitMove = false;\n        if (\n            CABLES.UI &&\n            newAttribs.hasOwnProperty(\"translate\") &&\n            (\n                !this.uiAttribs.translate ||\n                this.uiAttribs.translate.x != newAttribs.translate.x ||\n                this.uiAttribs.translate.y != newAttribs.translate.y\n            )) emitMove = true;\n\n\n        if (newAttribs.hasOwnProperty(\"disabled\"))\n        {\n            this.setEnabled(!newAttribs.disabled);\n        }\n\n        let changed = false;\n        for (const p in newAttribs)\n        {\n            if (this.uiAttribs[p] != newAttribs[p]) changed = true;\n            this.uiAttribs[p] = newAttribs[p];\n        }\n\n        if (this.uiAttribs.hasOwnProperty(\"selected\") && this.uiAttribs.selected == false) delete this.uiAttribs.selected;\n        if (newAttribs.title && newAttribs.title != this.name) this.setTitle(newAttribs.title);\n\n        if (changed)\n        {\n            this.emitEvent(\"onUiAttribsChange\", newAttribs);\n            this.patch.emitEvent(\"onUiAttribsChange\", this, newAttribs);\n        }\n\n\n        if (emitMove) this.emitEvent(\"move\");\n    };\n    /**\n     * setUiAttrib\n     * possible values:\n     * <pre>\n     * warning - warning message - showing up in op parameter panel\n     * error - error message - showing up in op parameter panel\n     * extendTitle - op title extension, e.g. [ + ]\n     * </pre>\n     * @function setUiAttrib\n     * @param {Object} newAttribs, e.g. {\"attrib\":value}\n     * @memberof Op\n     * @instance\n     * @example\n     * op.setUiAttrib({\"extendTitle\":str});\n     */\n    Op.prototype.setUiAttribs = Op.prototype.setUiAttrib = Op.prototype.uiAttr = _setUiAttrib;\n\n    Op.prototype.getName = function ()\n    {\n        if (this.uiAttribs.name) return this.uiAttribs.name;\n        return this.name;\n    };\n\n    Op.prototype.addOutPort = function (p)\n    {\n        p.direction = _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.PORT.PORT_DIR_OUT;\n        p._op = this;\n        this.portsOut.push(p);\n        this.emitEvent(\"onPortAdd\", p);\n        return p;\n    };\n\n    Op.prototype.hasDynamicPort = function ()\n    {\n        let i = 0;\n        for (i = 0; i < this.portsIn.length; i++)\n        {\n            if (this.portsIn[i].type == _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return true;\n            if (this.portsIn[i].getName() == \"dyn\") return true;\n        }\n        for (i = 0; i < this.portsOut.length; i++)\n        {\n            if (this.portsOut[i].type == _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return true;\n            if (this.portsOut[i].getName() == \"dyn\") return true;\n        }\n\n        return false;\n    };\n\n    Op.prototype.addInPort = function (p)\n    {\n        if (!(p instanceof _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port))\n            throw new Error(\"parameter is not a port!\");\n\n        p.direction = _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.PORT.PORT_DIR_IN;\n        p._op = this;\n\n        this.portsIn.push(p);\n        this.emitEvent(\"onPortAdd\", p);\n\n        return p;\n    };\n\n    /**\n     * create a trigger input port\n     * @function inTrigger\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     *\n     */\n    Op.prototype.inFunction = Op.prototype.inTrigger = function (name, v)\n    {\n        const p = this.addInPort(new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION));\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n\n    /**\n     * create multiple UI trigger buttons\n     * @function inTriggerButton\n     * @memberof Op\n     * @instance\n     * @param {String} name\n     * @param {Array} names\n     * @return {Port} created port\n     */\n    Op.prototype.inFunctionButton = Op.prototype.inTriggerButton = function (name, v)\n    {\n        const p = this.addInPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION, {\n                \"display\": \"button\"\n            })\n        );\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n\n    Op.prototype.inFunctionButton = Op.prototype.inUiTriggerButtons = function (name, v)\n    {\n        const p = this.addInPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION, {\n                \"display\": \"buttons\"\n            })\n        );\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n\n    /**\n     * create a number value input port\n     * @function inFloat\n     * @memberof Op\n     * @instance\n     * @param {String} name\n     * @param {Number} value\n     * @return {Port} created port\n     */\n    Op.prototype.inValueFloat = Op.prototype.inValue = Op.prototype.inFloat = function (name, v)\n    {\n        const p = this.addInPort(new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE));\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    /**\n     * create a boolean input port, displayed as a checkbox\n     * @function inBool\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {Boolean} value\n     * @return {Port} created port\n     */\n    Op.prototype.inValueBool = Op.prototype.inBool = function (name, v)\n    {\n        // old\n        const p = this.addInPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"display\": \"bool\"\n            })\n        );\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = p.get();\n        }\n        return p;\n    };\n\n    /**\n     * create a String value input port\n     * @function inString\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {String} value default value\n     * @return {Port} created port\n     */\n    Op.prototype.inValueString = function (name, v)\n    {\n        const p = this.addInPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"type\": \"string\"\n            })\n        );\n        p.value = \"\";\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    // new string\n    Op.prototype.inString = function (name, v)\n    {\n        const p = this.addInPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_STRING, {\n                \"type\": \"string\"\n            })\n        );\n        v = v || \"\";\n        p.value = v;\n        p.set(v);\n        p.defaultValue = v;\n        return p;\n    };\n\n    /**\n     * create a String value input port displayed as TextArea\n     * @function inValueText\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {String} value default value\n     * @return {Port} created port\n     */\n    Op.prototype.inValueText = function (name, v)\n    {\n        const p = this.addInPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"type\": \"string\",\n                \"display\": \"text\"\n            })\n        );\n        p.value = \"\";\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    Op.prototype.inTextarea = function (name, v)\n    {\n        const p = this.addInPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_STRING, {\n                \"type\": \"string\",\n                \"display\": \"text\"\n            })\n        );\n        p.value = \"\";\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    /**\n     * create a String value input port displayed as editor\n     * @function inStringEditor\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {String} value default value\n     * @return {Port} created port\n     */\n    // new string\n    Op.prototype.inStringEditor = function (name, v, syntax, hideFormatButton = true)\n    {\n        const p = this.addInPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_STRING, {\n                \"type\": \"string\",\n                \"display\": \"editor\",\n                \"editShortcut\": true,\n                \"editorSyntax\": syntax,\n                \"hideFormatButton\": hideFormatButton\n            }));\n\n        p.value = \"\";\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    // old\n    Op.prototype.inValueEditor = function (name, v, syntax, hideFormatButton = true)\n    {\n        const p = this.addInPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"type\": \"string\",\n                \"display\": \"editor\",\n                \"editorSyntax\": syntax,\n                \"hideFormatButton\": hideFormatButton\n            })\n        );\n        p.value = \"\";\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    /**\n     * create a string select box\n     * @function inDropDown\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {Array} values\n     * @param {String} value default value\n     * @return {Port} created port\n     */\n    Op.prototype.inValueSelect = Op.prototype.inDropDown = function (name, values, v, noindex)\n    {\n        let p = null;\n        if (!noindex)\n        {\n            const indexPort = new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name + \" index\", _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"increment\": \"integer\",\n                \"hideParam\": true\n            });\n            const n = this.addInPort(indexPort);\n\n            if (values) for (let i = 0; i < values.length; i++) values[i] = String(values[i]);\n\n            const valuePort = new _core_port_select_js__WEBPACK_IMPORTED_MODULE_5__.ValueSelectPort(\n                this,\n                name,\n                _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE,\n                {\n                    \"display\": \"dropdown\",\n                    \"hidePort\": true,\n                    \"type\": \"string\",\n                    \"values\": values\n                },\n                n\n            );\n\n            valuePort.indexPort = indexPort;\n\n            indexPort.onLinkChanged = function ()\n            {\n                valuePort.setUiAttribs({ \"greyout\": indexPort.isLinked() });\n            };\n\n            p = this.addInPort(valuePort);\n\n            if (v !== undefined)\n            {\n                p.set(v);\n                const index = values.findIndex((item) => { return item == v; });\n                n.setValue(index);\n                p.defaultValue = v;\n                n.defaultValue = index;\n            }\n        }\n        else\n        {\n            const valuePort = new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"display\": \"dropdown\",\n                \"hidePort\": true,\n                \"type\": \"string\",\n                values\n            });\n\n            p = this.addInPort(valuePort);\n        }\n\n        return p;\n    };\n\n    /**\n     * create a string switch box\n     * @function inSwitch\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {Array} values\n     * @param {String} value default value\n     * @return {Port} created port\n     */\n    Op.prototype.inSwitch = function (name, values, v, noindex)\n    {\n        let p = null;\n        if (!noindex)\n        {\n            if (!v)v = values[0];\n            const indexPort = new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name + \" index\", _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"increment\": \"integer\",\n                \"values\": values,\n                \"hideParam\": true\n            });\n            const n = this.addInPort(indexPort);\n\n            if (values) for (let i = 0; i < values.length; i++) values[i] = String(values[i]);\n\n            const switchPort = new _core_port_switch_js__WEBPACK_IMPORTED_MODULE_6__.SwitchPort(\n                this,\n                name,\n                _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_STRING,\n                {\n                    \"display\": \"switch\",\n                    \"hidePort\": true,\n                    \"type\": \"string\",\n                    \"values\": values\n                },\n                n\n            );\n\n            indexPort.onLinkChanged = function ()\n            {\n                switchPort.setUiAttribs({ \"greyout\": indexPort.isLinked() });\n            };\n            p = this.addInPort(switchPort);\n\n            if (v !== undefined)\n            {\n                p.set(v);\n                const index = values.findIndex((item) => { return item == v; });\n                n.setValue(index);\n                p.defaultValue = v;\n                n.defaultValue = index;\n            }\n        }\n        else\n        {\n            const switchPort = new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_STRING, {\n                \"display\": \"switch\",\n                \"hidePort\": true,\n                \"type\": \"string\",\n                \"values\": values\n            });\n            p = this.addInPort(switchPort);\n        }\n\n        return p;\n    };\n\n    /**\n     * create a integer input port\n     * @function inInt\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {number} value default value\n     * @return {Port} created port\n     */\n    Op.prototype.inValueInt = Op.prototype.inInt = function (name, v)\n    {\n        // old\n        const p = this.addInPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"increment\": \"integer\"\n            })\n        );\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    /**\n     * create a file/URL input port\n     * @function inURL\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.inFile = function (name, filter, v)\n    {\n        const p = this.addInPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"display\": \"file\",\n                \"type\": \"string\",\n                \"filter\": filter\n            })\n        );\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    Op.prototype.inUrl = function (name, filter, v)\n    {\n        const p = this.addInPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_STRING, {\n                \"display\": \"file\",\n                \"type\": \"string\",\n                \"filter\": filter\n            })\n        );\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    /**\n     * create a texture input port\n     * @function inTexture\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.inTexture = function (name, v)\n    {\n        const p = this.addInPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT, {\n                \"display\": \"texture\",\n                \"objType\": \"texture\",\n                \"preview\": true\n            })\n        );\n        p.ignoreValueSerialize = true;\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n\n\n    /**\n     * create a object input port\n     * @function inObject\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.inObject = function (name, v, objType)\n    {\n        const p = this.addInPort(new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT, { \"objType\": objType }));\n        p.ignoreValueSerialize = true;\n\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n\n    Op.prototype.inGradient = function (name, v)\n    {\n        const p = this.addInPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"display\": \"gradient\"\n                // \"hidePort\": true\n            })\n        );\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n\n\n    Op.prototype.getPortVisibleIndex = function (p)\n    {\n        let ports = this.portsIn;\n        if (p.direction == _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.PORT_DIR_OUT)ports = this.portsOut;\n\n        let index = 0;\n        for (let i = 0; i < ports.length; i++)\n        {\n            if (ports[i].uiAttribs.hidePort) continue;\n            index++;\n            if (ports[i] == p) return index;\n        }\n    };\n\n    /**\n     * create a array input port\n     * @function inArray\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.inArray = function (name, v, stride)\n    {\n        if (!stride && CABLES.UTILS.isNumeric(v))stride = v;\n\n        const p = this.addInPort(new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_ARRAY, { \"stride\": stride }));\n\n        if (v !== undefined && (Array.isArray(v) || v == null)) p.set(v);\n\n        // if (v !== undefined) p.set(v);\n        return p;\n    };\n\n    /**\n     * create a value slider input port\n     * @function inFloatSlider\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {number} defaultvalue\n     * @param {number} min\n     * @param {number} max\n     * @return {Port} created port\n     */\n    Op.prototype.inValueSlider = Op.prototype.inFloatSlider = function (name, v, min, max)\n    {\n        const uiattribs = { \"display\": \"range\" };\n\n        if (min != undefined && max != undefined)\n        {\n            uiattribs.min = min;\n            uiattribs.max = max;\n        }\n\n        const p = this.addInPort(new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, uiattribs));\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    /**\n     * create output trigger port\n     * @function outTrigger\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.outFunction = Op.prototype.outTrigger = function (name, v)\n    {\n        // old\n        const p = this.addOutPort(new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION));\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n\n    /**\n     * create output value port\n     * @function outNumber\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {number} default value\n     * @return {Port} created port\n     */\n    Op.prototype.outValue = Op.prototype.outNumber = function (name, v)\n    {\n        // old\n        const p = this.addOutPort(new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE));\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n\n    /**\n     * create output boolean port\n     * @function outBool\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.outValueBool = Op.prototype.outBool = function (name, v)\n    {\n        // old\n        const p = this.addOutPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"display\": \"bool\"\n            })\n        );\n        if (v !== undefined) p.set(v);\n        else p.set(0);\n        return p;\n    };\n\n    /**\n     * create output boolean port,value will be converted to 0 or 1\n     * @function outBool\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.outBoolNum = function (name, v)\n    {\n        const p = this.addOutPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"display\": \"boolnum\"\n            })\n        );\n\n        p.set = function (b)\n        {\n            this.setValue(b ? 1 : 0);\n            // console.log(\"bool set\", b, this.get());\n        }.bind(p);\n\n        if (v !== undefined) p.set(v);\n        else p.set(0);\n        return p;\n    };\n\n    /**\n     * create output string port\n     * @function outString\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.outValueString = function (name, v)\n    {\n        const p = this.addOutPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, {\n                \"type\": \"string\"\n            })\n        );\n        if (v !== undefined) p.set(v);\n        return p;\n    };\n    Op.prototype.outString = function (name, v)\n    {\n        const p = this.addOutPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_STRING, {\n                \"type\": \"string\"\n            })\n        );\n        if (v !== undefined) p.set(v);\n        else p.set(\"\");\n        return p;\n    };\n\n    /**\n     * create output object port\n     * @function outObject\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.outObject = function (name, v, objType)\n    {\n        const p = this.addOutPort(new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT, { \"objType\": objType || null }));\n        p.set(v || null);\n        p.ignoreValueSerialize = true;\n        return p;\n    };\n\n    /**\n     * create output array port\n     * @function outArray\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.outArray = function (name, v, stride)\n    {\n        if (!stride && CABLES.UTILS.isNumeric(v))stride = v;\n        const p = this.addOutPort(new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_ARRAY, { \"stride\": stride }));\n        if (v !== undefined && (Array.isArray(v) || v == null)) p.set(v);\n\n        p.ignoreValueSerialize = true;\n        return p;\n    };\n\n    /**\n     * create output texture port\n     * @function outTexture\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @return {Port} created port\n     */\n    Op.prototype.outTexture = function (name, v)\n    {\n        const p = this.addOutPort(\n            new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT, {\n                \"preview\": true,\n                \"objType\": \"texture\"\n            })\n        );\n        if (v !== undefined) p.set(v || CGL.Texture.getEmptyTexture(this.patch.cgl));\n\n        p.ignoreValueSerialize = true;\n        return p;\n    };\n\n    Op.prototype.inDynamic = function (name, filter, options, v)\n    {\n        const p = new _core_port_js__WEBPACK_IMPORTED_MODULE_4__.Port(this, name, _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC, options);\n\n        p.shouldLink = function (p1, p2)\n        {\n            if (filter && _utils_js__WEBPACK_IMPORTED_MODULE_2__.UTILS.isArray(filter))\n            {\n                for (let i = 0; i < filter.length; i++)\n                {\n                    if (p1 == this && p2.type === filter[i]) return true;\n                    if (p2 == this && p1.type === filter[i]) return true;\n                }\n                return false; // types do not match\n            }\n            return true; // no filter set\n        };\n\n        this.addInPort(p);\n        if (v !== undefined)\n        {\n            p.set(v);\n            p.defaultValue = v;\n        }\n        return p;\n    };\n\n    Op.prototype.removeLinks = function ()\n    {\n        for (let i = 0; i < this.portsIn.length; i++) this.portsIn[i].removeLinks();\n        for (let ipo = 0; ipo < this.portsOut.length; ipo++) this.portsOut[ipo].removeLinks();\n    };\n\n    Op.prototype.getSerialized = function ()\n    {\n        const op = {};\n\n        if (this.opId) op.opId = this.opId;\n        if (this.patch.storeObjNames) op.objName = this.objName;\n\n\n        op.id = this.id;\n        op.uiAttribs = JSON.parse(JSON.stringify(this.uiAttribs)) || {};\n\n        if (this.storage && Object.keys(this.storage).length > 0) op.storage = JSON.parse(JSON.stringify(this.storage));\n        if (this.uiAttribs.hasOwnProperty(\"working\") && this.uiAttribs.working == true) delete this.uiAttribs.working;\n        if (op.uiAttribs.hasOwnProperty(\"uierrors\")) delete op.uiAttribs.uierrors;\n\n        if (op.uiAttribs.title == this._shortOpName) delete op.uiAttribs.title;\n\n        op.portsIn = [];\n        op.portsOut = [];\n\n        for (let i = 0; i < this.portsIn.length; i++)\n        {\n            const s = this.portsIn[i].getSerialized();\n            if (s)op.portsIn.push(s);\n        }\n        for (const ipo in this.portsOut)\n        {\n            const s = this.portsOut[ipo].getSerialized();\n            if (s)op.portsOut.push(s);\n        }\n\n        if (op.portsIn.length == 0) delete op.portsIn;\n        if (op.portsOut.length == 0) delete op.portsOut;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.cleanJson)(op);\n\n        return op;\n    };\n\n    Op.prototype.getFirstOutPortByType = function (type)\n    {\n        for (const ipo in this.portsOut) if (this.portsOut[ipo].type == type) return this.portsOut[ipo];\n    };\n\n    Op.prototype.getFirstInPortByType = function (type)\n    {\n        for (const ipo in this.portsIn) if (this.portsIn[ipo].type == type) return this.portsIn[ipo];\n    };\n\n    /**\n     * return port by the name portName\n     * @function getPort\n     * @instance\n     * @memberof Op\n     * @param {String} portName\n     * @return {Port}\n     */\n    Op.prototype.getPort = Op.prototype.getPortByName = function (name, lowerCase)\n    {\n        if (lowerCase)\n        {\n            for (let ipi = 0; ipi < this.portsIn.length; ipi++)\n                if (this.portsIn[ipi].getName().toLowerCase() == name || this.portsIn[ipi].id.toLowerCase() == name)\n                    return this.portsIn[ipi];\n\n            for (let ipo = 0; ipo < this.portsOut.length; ipo++)\n                if (this.portsOut[ipo].getName().toLowerCase() == name || this.portsOut[ipo].id.toLowerCase() == name)\n                    return this.portsOut[ipo];\n        }\n        else\n        {\n            for (let ipi = 0; ipi < this.portsIn.length; ipi++)\n                if (this.portsIn[ipi].getName() == name || this.portsIn[ipi].id == name)\n                    return this.portsIn[ipi];\n\n            for (let ipo = 0; ipo < this.portsOut.length; ipo++)\n                if (this.portsOut[ipo].getName() == name || this.portsOut[ipo].id == name)\n                    return this.portsOut[ipo];\n        }\n    };\n\n\n    /**\n     * return port by the name id\n     * @function getPortById\n     * @instance\n     * @memberof Op\n     * @param {String} id\n     * @return {Port}\n     */\n    Op.prototype.getPortById = function (id)\n    {\n        for (let ipi = 0; ipi < this.portsIn.length; ipi++) if (this.portsIn[ipi].id == id) return this.portsIn[ipi];\n        for (let ipo = 0; ipo < this.portsOut.length; ipo++) if (this.portsOut[ipo].id == id) return this.portsOut[ipo];\n    };\n\n    Op.prototype.updateAnims = function ()\n    {\n        if (this._hasAnimPort)\n            for (let i = 0; i < this.portsIn.length; i++) this.portsIn[i].updateAnim();\n    };\n\n    Op.prototype.log = function ()\n    {\n        const initiator = \"op \" + this.objName;\n        if (CABLES.UI && !CABLES.UI.logFilter.shouldPrint(initiator, ...arguments)) return;\n        if (!CABLES.UI && this.patch.silent) return;\n\n        const args = [\"[op \" + CABLES.getShortOpName(this.objName) + \"]\"];\n        args.push.apply(args, arguments);\n        Function.prototype.apply.apply(console.log, [console, args]);// eslint-disable-line\n    };\n\n    Op.prototype.error = Op.prototype.logError = function ()\n    {\n        if (!this)\n        {\n            console.log(\"no this...!!!\");\n            debugger;\n            return;\n        }\n\n        // if (this.patch.silent) return;\n        const args = [\"[op \" + CABLES.getShortOpName(this.objName) + \"]\"];\n        args.push.apply(args, arguments);\n        Function.prototype.apply.apply(console.error, [console, args]);// eslint-disable-line\n        if (window.gui) window.gui.emitEvent(\"opLogEvent\", this.objName, \"error\", arguments);\n    };\n\n    Op.prototype.warn = Op.prototype.logWarn = function ()\n    {\n        // if (this.patch.silent) return;\n        const args = [\"[op \" + CABLES.getShortOpName(this.objName) + \"]\"];\n        args.push.apply(args, arguments);\n        Function.prototype.apply.apply(console.warn, [console, args]);// eslint-disable-line\n    };\n\n    Op.prototype.verbose = Op.prototype.logVerbose = function ()\n    {\n        const initiator = \"op \" + CABLES.getShortOpName(this.objName);\n        if (CABLES.UI && !CABLES.UI.logFilter.shouldPrint(initiator, ...arguments)) return;\n\n        if (!CABLES.UI && this.patch.silent) return;\n\n        const args = [\"[\" + initiator + \"]\"];\n        args.push.apply(args, arguments);\n        Function.prototype.apply.apply(console.info, [console, args]);// eslint-disable-line\n    };\n\n\n    Op.prototype.profile = function (enable)\n    {\n        for (let ipi = 0; ipi < this.portsIn.length; ipi++)\n        {\n            this.portsIn[ipi]._onTriggered = this.portsIn[ipi]._onTriggeredProfiling;\n            this.portsIn[ipi].set = this.portsIn[ipi]._onSetProfiling;\n        }\n    };\n\n    Op.prototype.findParent = function (objName)\n    {\n        for (let ipi = 0; ipi < this.portsIn.length; ipi++)\n        {\n            if (this.portsIn[ipi].isLinked())\n            {\n                if (this.portsIn[ipi].links[0].portOut.parent.objName == objName)\n                    return this.portsIn[ipi].links[0].portOut.parent;\n\n                let found = null;\n                found = this.portsIn[ipi].links[0].portOut.parent.findParent(objName);\n                if (found) return found;\n            }\n        }\n        return null;\n    };\n\n\n    // todo: check instancing stuff?\n    Op.prototype.cleanUp = function ()\n    {\n        if (this._instances)\n        {\n            for (let i = 0; i < this._instances.length; i++)\n            {\n                if (this._instances[i].onDelete) this._instances[i].onDelete();\n            }\n\n\n            this._instances.length = 0;\n        }\n        for (let i = 0; i < this.portsIn.length; i++)\n        {\n            this.portsIn[i].setAnimated(false);\n        }\n\n        if (this.onAnimFrame) this.patch.removeOnAnimFrame(this);\n    };\n\n    // todo: check instancing stuff?\n    Op.prototype.instanced = function (triggerPort)\n    {\n        console.log(\"instanced\", this.patch.instancing.numCycles());\n        if (this.patch.instancing.numCycles() === 0) return false;\n\n\n        let i = 0;\n        let ipi = 0;\n        if (!this._instances || this._instances.length != this.patch.instancing.numCycles())\n        {\n            if (!this._instances) this._instances = [];\n            this._.log(\"creating instances of \", this.objName, this.patch.instancing.numCycles(), this._instances.length);\n            this._instances.length = this.patch.instancing.numCycles();\n\n            for (i = 0; i < this._instances.length; i++)\n            {\n                this._instances[i] = this.patch.createOp(this.objName, true);\n                this._instances[i].instanced = function ()\n                {\n                    return false;\n                };\n                this._instances[i].uiAttr(this.uiAttribs);\n\n                for (let ipo = 0; ipo < this.portsOut.length; ipo++)\n                {\n                    if (this.portsOut[ipo].type == _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)\n                    {\n                        this._instances[i].getPortByName(this.portsOut[ipo].name).trigger = this.portsOut[ipo].trigger.bind(this.portsOut[ipo]);\n                    }\n                }\n            }\n\n            for (ipi = 0; ipi < this.portsIn.length; ipi++)\n            {\n                this.portsIn[ipi].onChange = null;\n                this.portsIn[ipi].onValueChanged = null;\n            }\n        }\n\n        const theTriggerPort = null;\n        for (ipi = 0; ipi < this.portsIn.length; ipi++)\n        {\n            if (\n                this.portsIn[ipi].type == _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE ||\n                this.portsIn[ipi].type == _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_ARRAY\n            )\n            {\n                this._instances[this.patch.instancing.index()].portsIn[ipi].set(this.portsIn[ipi].get());\n            }\n            if (this.portsIn[ipi].type == _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)\n            {\n                // if(this._instances[ this.patch.instancing.index() ].portsIn[ipi].name==triggerPort.name)\n                // theTriggerPort=this._instances[ this.patch.instancing.index() ].portsIn[ipi];\n            }\n        }\n\n        if (theTriggerPort) theTriggerPort.onTriggered();\n\n        for (ipi = 0; ipi < this.portsOut.length; ipi++)\n        {\n            if (this.portsOut[ipi].type == _constants_js__WEBPACK_IMPORTED_MODULE_3__.CONSTANTS.OP.OP_PORT_TYPE_VALUE)\n            {\n                this.portsOut[ipi].set(this._instances[this.patch.instancing.index()].portsOut[ipi].get());\n            }\n        }\n\n        return true;\n    };\n\n    // todo: check instancing stuff?\n    Op.prototype.initInstancable = function ()\n    {\n        //         if(this.isInstanced)\n        //         {\n        //             console.log('cancel instancing');\n        //             return;\n        //         }\n        //         this._instances=[];\n        //         for(var ipi=0;ipi<this.portsIn.length;ipi++)\n        //         {\n        //             if(this.portsIn[ipi].type==CONSTANTS.OP.OP_PORT_TYPE_VALUE)\n        //             {\n        //\n        //             }\n        //             if(this.portsIn[ipi].type==CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)\n        //             {\n        //                 // var piIndex=ipi;\n        //                 this.portsIn[ipi].onTriggered=function(piIndex)\n        //                 {\n        //\n        //                     var i=0;\n        // // console.log('trigger',this._instances.length);\n        //\n        //                 }.bind(this,ipi );\n        //\n        //             }\n        // };\n        // this._instances=null;\n    };\n\n    Op.prototype.setValues = function (obj)\n    {\n        for (const i in obj)\n        {\n            const port = this.getPortByName(i);\n            if (port) port.set(obj[i]);\n            else this._log.warn(\"op.setValues: port not found:\", i);\n        }\n    };\n\n    /**\n     * return true if op has this error message id\n     * @function hasUiError\n     * @instance\n     * @memberof Op\n     * @param {id} error id\n     * @returns {Boolean} - has id\n     */\n    Op.prototype.hasUiError = function (id)\n    {\n        return this._uiErrors.hasOwnProperty(id) && this._uiErrors[id];\n    };\n\n    /**\n     * show op error message - set message to null to remove error message\n     * @function setUiError\n     * @instance\n     * @memberof Op\n     * @param {id} error id\n     * @param {txt} text message\n     * @param {level} level\n     */\n    Op.prototype.setUiError = function (id, txt, level)\n    {\n        if (!txt && !this.hasUiErrors) return;\n        if (!txt && !this._uiErrors.hasOwnProperty(id)) return;\n        if (this._uiErrors.hasOwnProperty(id) && this._uiErrors[id].txt == txt) return;\n\n        if (id.indexOf(\" \") > -1) this._log.warn(\"setuierror id cant have spaces! \", id);\n        id = id.replaceAll(\" \", \"_\");\n\n        if (!txt && this._uiErrors.hasOwnProperty(id)) delete this._uiErrors[id];\n        else\n        {\n            if (txt && (!this._uiErrors.hasOwnProperty(id) || this._uiErrors[id].txt != txt))\n            {\n                if (level == undefined) level = 2;\n                this._uiErrors[id] = { \"txt\": txt, \"level\": level, \"id\": id };\n            }\n        }\n\n        const errorArr = [];\n        for (const i in this._uiErrors) errorArr.push(this._uiErrors[i]);\n\n        this.uiAttr({ \"uierrors\": errorArr });\n        this.hasUiErrors = Object.keys(this._uiErrors).length;\n\n        this.emitEvent(\"uiErrorChange\");\n    };\n\n    // todo: remove\n    Op.prototype.setError = function (id, txt)\n    {\n        this._log.warn(\"old error message op.error() - use op.setUiError()\");\n    };\n\n\n    /**\n     * enable/disable op\n     * @function\n     * @instance\n     * @memberof Op\n     * @param {boolean}\n     */\n    Op.prototype.setEnabled = function (b)\n    {\n        this.enabled = b;\n        this.emitEvent(\"onEnabledChange\", b);\n        if (!this.enabled) this.setUiError(\"_disabled\", \"Op is disabled\", 0);\n        else this.setUiError(\"_disabled\", null);\n    };\n\n    /**\n     * organize ports into a group\n     * @function\n     * @instance\n     * @memberof Op\n     * @param {String} name\n     * @param {Array} ports\n     */\n    Op.prototype.setPortGroup = function (name, ports)\n    {\n        for (let i = 0; i < ports.length; i++)\n        {\n            if (ports[i])\n                if (ports[i].setUiAttribs) ports[i].setUiAttribs({ \"group\": name });\n                else\n                {\n                    this._log.error(\"setPortGroup: invalid port!\");\n                }\n        }\n    };\n\n    /**\n     * visually indicate ports that they are coordinate inputs\n     * @function\n     * @instance\n     * @memberof Op\n     * @param {Port} portX\n     * @param {Port} portY\n     * @param {Port} portZ\n     */\n    Op.prototype.setUiAxisPorts = function (px, py, pz)\n    {\n        if (px) px.setUiAttribs({ \"axis\": \"X\" });\n        if (py) py.setUiAttribs({ \"axis\": \"Y\" });\n        if (pz) pz.setUiAttribs({ \"axis\": \"Z\" });\n    };\n\n    /**\n     * remove port from op\n     * @function removePort\n     * @instance\n     * @memberof Op\n     * @param {Port} port to remove\n     */\n    Op.prototype.removePort = function (port)\n    {\n        for (let ipi = 0; ipi < this.portsIn.length; ipi++)\n        {\n            if (this.portsIn[ipi] == port)\n            {\n                this.portsIn.splice(ipi, 1);\n                this.emitEvent(\"onUiAttribsChange\", {});\n                this.emitEvent(\"onPortRemoved\", {});\n                return;\n            }\n        }\n    };\n\n    Op.prototype._checkLinksNeededToWork = function () {};\n\n    /**\n     * show a warning of this op is not a child of parentOpName\n     * @function\n     * @instance\n     * @memberof Op\n     * @param {String} parentOpName\n     */\n    Op.prototype.toWorkNeedsParent = function (parentOpName)\n    {\n        if (!this.patch.isEditorMode()) return;\n\n        this._linkTimeRules.needsParentOp = parentOpName;\n    };\n\n    // /**\n    //  * show a warning of this op is a child of parentOpName\n    //  * @function\n    //  * @instance\n    //  * @memberof Op\n    //  * @param {String} parentOpName\n    //  */\n    Op.prototype.toWorkShouldNotBeChild = function (parentOpName, type)\n    {\n        if (!this.patch.isEditorMode()) return;\n        this._linkTimeRules.forbiddenParent = parentOpName;\n        if (type != undefined) this._linkTimeRules.forbiddenParentType = type;\n    };\n\n\n    /**\n     * show a small X to indicate op is not working when given ports are not linked\n     * @function\n     * @instance\n     * @memberof Op\n     * @param {Port} port1\n     * @param {Port} port2\n     * @param {Port} port3\n     */\n    Op.prototype.toWorkPortsNeedToBeLinked = function ()\n    {\n        if (!this.patch.isEditorMode()) return;\n        for (let i = 0; i < arguments.length; i++)\n            if (this._linkTimeRules.needsLinkedToWork.indexOf(arguments[i]) == -1) this._linkTimeRules.needsLinkedToWork.push(arguments[i]);\n    };\n    Op.prototype.toWorkPortsNeedToBeLinkedReset = function ()\n    {\n        if (!this.patch.isEditorMode()) return;\n        this._linkTimeRules.needsLinkedToWork.length = 0;\n        if (this.checkLinkTimeWarnings) this.checkLinkTimeWarnings();\n    };\n\n    Op.prototype.initVarPorts = function ()\n    {\n        for (let i = 0; i < this.portsIn.length; i++)\n        {\n            if (this.portsIn[i].getVariableName()) this.portsIn[i].setVariable(this.portsIn[i].getVariableName());\n        }\n    };\n\n    /**\n     * refresh op parameters, if current op is selected\n     * @function\n     * @instance\n     * @memberof Op\n     */\n    Op.prototype.refreshParams = function ()\n    {\n        if (this.patch && this.patch.isEditorMode() && this.isCurrentUiOp())\n        {\n            gui.opParams.show(this);\n        }\n    };\n\n    /**\n     * Returns true if op is selected and parameter are shown in the editor, can only return true if in editor/ui\n     * @function isCurrentUiOp\n     * @instance\n     * @memberof Op\n     * @returns {Boolean} - is current ui op\n     */\n    Op.prototype.isCurrentUiOp = function ()\n    {\n        if (this.patch.isEditorMode()) return gui.patchView.isCurrentOp(this);\n    };\n\n    /**\n     * Implement to render 2d canvas based graphics from in an op\n     * @function renderVizLayer\n     * @instance\n     * @memberof Op\n     * @param {ctx} context of canvas 2d\n     * @param {Object} layer info\n     * @param {number} layer.x x position on canvas\n     * @param {number} layer.y y position on canvas\n     * @param {number} layer.width width of canvas\n     * @param {number} layer.height height of canvas\n     * @param {number} layer.scale current scaling of patchfield view\n     */\n    Op.prototype.renderVizLayer = null; // optionaly defined in op instance\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX29wLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY29yZV9vcC5qcz9kOGExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJjYWJsZXMtc2hhcmVkLWNsaWVudFwiO1xuaW1wb3J0IHsgRXZlbnRUYXJnZXQgfSBmcm9tIFwiLi9ldmVudHRhcmdldC5qc1wiO1xuaW1wb3J0IHsgVVRJTFMsIGNsZWFuSnNvbiwgc2hvcnRJZCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IFBvcnQgfSBmcm9tIFwiLi9jb3JlX3BvcnQuanNcIjtcbmltcG9ydCB7IFN3aXRjaFBvcnQgfSBmcm9tIFwiLi9jb3JlX3BvcnRfc3dpdGNoLmpzXCI7XG5pbXBvcnQgeyBWYWx1ZVNlbGVjdFBvcnQgfSBmcm9tIFwiLi9jb3JlX3BvcnRfc2VsZWN0LmpzXCI7XG5cbi8qKlxuICogb3AgdGhlIGNsYXNzIG9mIGFsbCBvcGVyYXRvcnNcbiAqIEBleHRlcm5hbCBDQUJMRVNcbiAqIEBuYW1lc3BhY2UgT3BcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAbmFtZSBhdHRhY2htZW50c1xuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgT3BcbiAqIEBkZXNjcmlwdGlvbiBhY2Nlc3MgZmlsZSBhdHRhY2htZW50cyBhcyBTdHJpbmcgdmFsdWVzXG4gKiBAZXhhbXBsZVxuICogLy8gc2V0IHNoYWRlciBzb3VyY2UgdG8gYXR0YWNoZWQgZmlsZXMgKGZpbGVzIGFyZSBjYWxsZWQgc2hhZGVyLnZlcnQgLyBzaGFkZXIuZnJhZylcbiAqIHNoYWRlci5zZXRTb3VyY2UoYXR0YWNobWVudHMuc2hhZGVyX3ZlcnQsYXR0YWNobWVudHMuc2hhZGVyX2ZyYWcpO1xuICovXG5cbmNvbnN0IE9wcyA9IHt9O1xuXG5jb25zdCBPcCA9IGZ1bmN0aW9uICgpXG57XG4gICAgRXZlbnRUYXJnZXQuYXBwbHkodGhpcyk7XG5cbiAgICB0aGlzLl9sb2cgPSBuZXcgTG9nZ2VyKFwiY29yZV9vcFwiKTtcbiAgICB0aGlzLmRhdGEgPSB7fTsgLy8gVU5VU0VELCBERVBSRUNBVEVELCBvbmx5IGxlZnQgaW4gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggdXNlcm9wc1xuICAgIHRoaXMuc3RvcmFnZSA9IHt9OyAvLyBvcC1zcGVjaWZpYyBkYXRhIHRvIGJlIGluY2x1ZGVkIGluIGV4cG9ydFxuICAgIHRoaXMuX29iak5hbWUgPSBcIlwiO1xuICAgIHRoaXMucG9ydHNPdXQgPSBbXTtcbiAgICB0aGlzLnBvcnRzSW4gPSBbXTtcbiAgICB0aGlzLnBvcnRzSW5EYXRhID0gW107IC8vIG9yaWdpbmFsIGxvYWRlZCBwYXRjaCBkYXRhXG4gICAgdGhpcy5vcElkID0gXCJcIjsgLy8gdW5pcXVlIG9wIGlkXG4gICAgdGhpcy51aUF0dHJpYnMgPSB7fTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMucGF0Y2ggPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5uYW1lID0gYXJndW1lbnRzWzFdO1xuXG4gICAgdGhpcy5fbGlua1RpbWVSdWxlcyA9IHtcbiAgICAgICAgXCJuZWVkc0xpbmtlZFRvV29ya1wiOiBbXSxcbiAgICAgICAgXCJuZWVkc1BhcmVudE9wXCI6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5zaG91bGRXb3JrID0ge307XG4gICAgdGhpcy5oYXNVaUVycm9ycyA9IGZhbHNlO1xuICAgIHRoaXMuX3VpRXJyb3JzID0ge307XG4gICAgdGhpcy5faGFzQW5pbVBvcnQgPSBmYWxzZTtcblxuICAgIGlmIChhcmd1bWVudHNbMV0pXG4gICAge1xuICAgICAgICB0aGlzLl9zaG9ydE9wTmFtZSA9IENBQkxFUy5nZXRTaG9ydE9wTmFtZShhcmd1bWVudHNbMV0pO1xuICAgICAgICB0aGlzLmdldFRpdGxlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5pZCA9IGFyZ3VtZW50c1syXSB8fCBzaG9ydElkKCk7IC8vIGluc3RhbmNlIGlkXG4gICAgdGhpcy5vbkFkZFBvcnQgPSBudWxsO1xuICAgIHRoaXMub25DcmVhdGUgPSBudWxsO1xuICAgIHRoaXMub25SZXNpemUgPSBudWxsO1xuICAgIHRoaXMub25Mb2FkZWQgPSBudWxsO1xuICAgIHRoaXMub25EZWxldGUgPSBudWxsO1xuICAgIHRoaXMub25VaUF0dHJDaGFuZ2UgPSBudWxsO1xuICAgIHRoaXMub25FcnJvciA9IG51bGw7XG5cbiAgICB0aGlzLl9pbnN0YW5jZXMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogb3ZlcndyaXRlIHRoaXMgdG8gcHJlcmVuZGVyIHNoYWRlciBhbmQgbWVzaGVzIC8gd2lsbCBiZSBjYWxsZWQgYnkgb3AgYGxvYWRpbmdTdGF0dXNgXG4gICAgICogQGZ1bmN0aW9uIHByZVJlbmRlclxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRoaXMucHJlUmVuZGVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIG92ZXJ3cml0ZSB0aGlzIHRvIGluaXRpYWxpemUgeW91ciBvcFxuICAgICAqIEBmdW5jdGlvbiBpbml0XG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5pbml0ID0gbnVsbDtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9iak5hbWVcIiwgeyBnZXQoKSB7IHJldHVybiB0aGlzLl9vYmpOYW1lOyB9IH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNob3J0TmFtZVwiLCB7IGdldCgpIHsgcmV0dXJuIHRoaXMuX3Nob3J0T3BOYW1lOyB9IH0pO1xuXG4gICAgaWYgKHRoaXMuaW5pdFVpKSB0aGlzLmluaXRVaSgpO1xufTtcblxue1xuICAgIE9wLnByb3RvdHlwZS5jbGVhclVpQXR0cmliID0gZnVuY3Rpb24gKG5hbWUpXG4gICAge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgb2JqLm5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnVpQXR0cmliKG9iaik7XG4gICAgfTtcblxuICAgIE9wLnByb3RvdHlwZS5jaGVja01haW5sb29wRXhpc3RzID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGlmICghQ0FCTEVTLlVJKSByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5wYXRjaC5jZ2wubWFpbmxvb3BPcCkgdGhpcy5zZXRVaUVycm9yKFwibm9tYWlubG9vcFwiLCBcInBhdGNoIHNob3VsZCBoYXZlIGEgbWFpbmxvb3AgdG8gdXNlIHRoaXMgb3BcIik7XG4gICAgICAgIGVsc2UgdGhpcy5zZXRVaUVycm9yKFwibm9tYWlubG9vcFwiLCBudWxsKTtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy51aUF0dHJpYnMpIHJldHVybiBcIm5vdWlhdHRyaWJzXCIgKyB0aGlzLm5hbWU7XG5cbiAgICAgICAgaWYgKCh0aGlzLnVpQXR0cmlicy50aXRsZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudWlBdHRyaWJzLnRpdGxlID09PSBcIlwiKSAmJiB0aGlzLm9iak5hbWUuaW5kZXhPZihcIk9wcy5VaS5cIikgPT0gLTEpXG4gICAgICAgICAgICB0aGlzLnVpQXR0cmlicy50aXRsZSA9IHRoaXMuX3Nob3J0T3BOYW1lO1xuXG4gICAgICAgIGlmICh0aGlzLnVpQXR0cmlicy50aXRsZSA9PT0gdW5kZWZpbmVkKSB0aGlzLnVpQXR0cmlicy50aXRsZSA9IHRoaXMuX3Nob3J0T3BOYW1lO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnVpQXR0cmlicy50aXRsZTtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLnNldFRpdGxlID0gZnVuY3Rpb24gKG5hbWUpXG4gICAge1xuICAgICAgICBjb25zdCBkb0VtaXRFdmVudCA9IHRoaXMubmFtZSAhPSBuYW1lO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmICh0aGlzLnVpQXR0cmlicy50aXRsZSAhPSBuYW1lKSB0aGlzLnVpQXR0cih7IFwidGl0bGVcIjogbmFtZSB9KTtcbiAgICAgICAgaWYgKGRvRW1pdEV2ZW50KSB0aGlzLmVtaXRFdmVudChcIm9uVGl0bGVDaGFuZ2VcIiwgbmFtZSk7XG4gICAgfTtcblxuICAgIE9wLnByb3RvdHlwZS5zZXRTdG9yYWdlID0gZnVuY3Rpb24gKG5ld0F0dHJpYnMpXG4gICAge1xuICAgICAgICBpZiAoIW5ld0F0dHJpYnMpIHJldHVybjtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gdGhpcy5zdG9yYWdlIHx8IHt9O1xuXG4gICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgcCBpbiBuZXdBdHRyaWJzKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9yYWdlW3BdICE9IG5ld0F0dHJpYnNbcF0pIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlW3BdID0gbmV3QXR0cmlic1twXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VkKSB0aGlzLmVtaXRFdmVudChcIm9uU3RvcmFnZUNoYW5nZVwiLCBuZXdBdHRyaWJzKTtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLmlzU3ViUGF0Y2hPcCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlKSByZXR1cm4gKHRoaXMuc3RvcmFnZS5zdWJQYXRjaFZlciB8fCAwKTtcbiAgICB9O1xuXG4gICAgY29uc3QgX3NldFVpQXR0cmliID0gZnVuY3Rpb24gKG5ld0F0dHJpYnMpXG4gICAge1xuICAgICAgICBpZiAoIW5ld0F0dHJpYnMpIHJldHVybjtcblxuICAgICAgICBpZiAobmV3QXR0cmlicy5lcnJvciB8fCBuZXdBdHRyaWJzLndhcm5pbmcgfHwgbmV3QXR0cmlicy5oaW50KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcIm9sZCB1aSBlcnJvci93YXJuaW5nIGF0dHJpYnV0ZSBpbiBcIiArIHRoaXMubmFtZSArIFwiLCB1c2Ugb3Auc2V0VWlFcnJvciAhXCIsIG5ld0F0dHJpYnMpO1xuICAgICAgICB9XG5cblxuXG4gICAgICAgIGlmICh0eXBlb2YgbmV3QXR0cmlicyAhPSBcIm9iamVjdFwiKSB0aGlzLl9sb2cuZXJyb3IoXCJvcC51aUF0dHJpYiBhdHRyaWJzIGFyZSBub3Qgb2YgdHlwZSBvYmplY3RcIik7XG4gICAgICAgIGlmICghdGhpcy51aUF0dHJpYnMpIHRoaXMudWlBdHRyaWJzID0ge307XG5cblxuICAgICAgICBsZXQgZW1pdE1vdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgQ0FCTEVTLlVJICYmXG4gICAgICAgICAgICBuZXdBdHRyaWJzLmhhc093blByb3BlcnR5KFwidHJhbnNsYXRlXCIpICYmXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgIXRoaXMudWlBdHRyaWJzLnRyYW5zbGF0ZSB8fFxuICAgICAgICAgICAgICAgIHRoaXMudWlBdHRyaWJzLnRyYW5zbGF0ZS54ICE9IG5ld0F0dHJpYnMudHJhbnNsYXRlLnggfHxcbiAgICAgICAgICAgICAgICB0aGlzLnVpQXR0cmlicy50cmFuc2xhdGUueSAhPSBuZXdBdHRyaWJzLnRyYW5zbGF0ZS55XG4gICAgICAgICAgICApKSBlbWl0TW92ZSA9IHRydWU7XG5cblxuICAgICAgICBpZiAobmV3QXR0cmlicy5oYXNPd25Qcm9wZXJ0eShcImRpc2FibGVkXCIpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNldEVuYWJsZWQoIW5ld0F0dHJpYnMuZGlzYWJsZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBwIGluIG5ld0F0dHJpYnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVpQXR0cmlic1twXSAhPSBuZXdBdHRyaWJzW3BdKSBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudWlBdHRyaWJzW3BdID0gbmV3QXR0cmlic1twXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnVpQXR0cmlicy5oYXNPd25Qcm9wZXJ0eShcInNlbGVjdGVkXCIpICYmIHRoaXMudWlBdHRyaWJzLnNlbGVjdGVkID09IGZhbHNlKSBkZWxldGUgdGhpcy51aUF0dHJpYnMuc2VsZWN0ZWQ7XG4gICAgICAgIGlmIChuZXdBdHRyaWJzLnRpdGxlICYmIG5ld0F0dHJpYnMudGl0bGUgIT0gdGhpcy5uYW1lKSB0aGlzLnNldFRpdGxlKG5ld0F0dHJpYnMudGl0bGUpO1xuXG4gICAgICAgIGlmIChjaGFuZ2VkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcIm9uVWlBdHRyaWJzQ2hhbmdlXCIsIG5ld0F0dHJpYnMpO1xuICAgICAgICAgICAgdGhpcy5wYXRjaC5lbWl0RXZlbnQoXCJvblVpQXR0cmlic0NoYW5nZVwiLCB0aGlzLCBuZXdBdHRyaWJzKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKGVtaXRNb3ZlKSB0aGlzLmVtaXRFdmVudChcIm1vdmVcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzZXRVaUF0dHJpYlxuICAgICAqIHBvc3NpYmxlIHZhbHVlczpcbiAgICAgKiA8cHJlPlxuICAgICAqIHdhcm5pbmcgLSB3YXJuaW5nIG1lc3NhZ2UgLSBzaG93aW5nIHVwIGluIG9wIHBhcmFtZXRlciBwYW5lbFxuICAgICAqIGVycm9yIC0gZXJyb3IgbWVzc2FnZSAtIHNob3dpbmcgdXAgaW4gb3AgcGFyYW1ldGVyIHBhbmVsXG4gICAgICogZXh0ZW5kVGl0bGUgLSBvcCB0aXRsZSBleHRlbnNpb24sIGUuZy4gWyArIF1cbiAgICAgKiA8L3ByZT5cbiAgICAgKiBAZnVuY3Rpb24gc2V0VWlBdHRyaWJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3QXR0cmlicywgZS5nLiB7XCJhdHRyaWJcIjp2YWx1ZX1cbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG9wLnNldFVpQXR0cmliKHtcImV4dGVuZFRpdGxlXCI6c3RyfSk7XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLnNldFVpQXR0cmlicyA9IE9wLnByb3RvdHlwZS5zZXRVaUF0dHJpYiA9IE9wLnByb3RvdHlwZS51aUF0dHIgPSBfc2V0VWlBdHRyaWI7XG5cbiAgICBPcC5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy51aUF0dHJpYnMubmFtZSkgcmV0dXJuIHRoaXMudWlBdHRyaWJzLm5hbWU7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfTtcblxuICAgIE9wLnByb3RvdHlwZS5hZGRPdXRQb3J0ID0gZnVuY3Rpb24gKHApXG4gICAge1xuICAgICAgICBwLmRpcmVjdGlvbiA9IENPTlNUQU5UUy5QT1JULlBPUlRfRElSX09VVDtcbiAgICAgICAgcC5fb3AgPSB0aGlzO1xuICAgICAgICB0aGlzLnBvcnRzT3V0LnB1c2gocCk7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwib25Qb3J0QWRkXCIsIHApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLmhhc0R5bmFtaWNQb3J0ID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucG9ydHNJbi5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9ydHNJbltpXS50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfRFlOQU1JQykgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3J0c0luW2ldLmdldE5hbWUoKSA9PSBcImR5blwiKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5wb3J0c091dC5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9ydHNPdXRbaV0udHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0RZTkFNSUMpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9ydHNPdXRbaV0uZ2V0TmFtZSgpID09IFwiZHluXCIpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBPcC5wcm90b3R5cGUuYWRkSW5Qb3J0ID0gZnVuY3Rpb24gKHApXG4gICAge1xuICAgICAgICBpZiAoIShwIGluc3RhbmNlb2YgUG9ydCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXJhbWV0ZXIgaXMgbm90IGEgcG9ydCFcIik7XG5cbiAgICAgICAgcC5kaXJlY3Rpb24gPSBDT05TVEFOVFMuUE9SVC5QT1JUX0RJUl9JTjtcbiAgICAgICAgcC5fb3AgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMucG9ydHNJbi5wdXNoKHApO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcIm9uUG9ydEFkZFwiLCBwKTtcblxuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgdHJpZ2dlciBpbnB1dCBwb3J0XG4gICAgICogQGZ1bmN0aW9uIGluVHJpZ2dlclxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICpcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUuaW5GdW5jdGlvbiA9IE9wLnByb3RvdHlwZS5pblRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZEluUG9ydChuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0ZVTkNUSU9OKSk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHAuc2V0KHYpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIG11bHRpcGxlIFVJIHRyaWdnZXIgYnV0dG9uc1xuICAgICAqIEBmdW5jdGlvbiBpblRyaWdnZXJCdXR0b25cbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG5hbWVzXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLmluRnVuY3Rpb25CdXR0b24gPSBPcC5wcm90b3R5cGUuaW5UcmlnZ2VyQnV0dG9uID0gZnVuY3Rpb24gKG5hbWUsIHYpXG4gICAge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRJblBvcnQoXG4gICAgICAgICAgICBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0ZVTkNUSU9OLCB7XG4gICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiYnV0dG9uXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHAuc2V0KHYpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLmluRnVuY3Rpb25CdXR0b24gPSBPcC5wcm90b3R5cGUuaW5VaVRyaWdnZXJCdXR0b25zID0gZnVuY3Rpb24gKG5hbWUsIHYpXG4gICAge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRJblBvcnQoXG4gICAgICAgICAgICBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0ZVTkNUSU9OLCB7XG4gICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiYnV0dG9uc1wiXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBwLnNldCh2KTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIG51bWJlciB2YWx1ZSBpbnB1dCBwb3J0XG4gICAgICogQGZ1bmN0aW9uIGluRmxvYXRcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1BvcnR9IGNyZWF0ZWQgcG9ydFxuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5pblZhbHVlRmxvYXQgPSBPcC5wcm90b3R5cGUuaW5WYWx1ZSA9IE9wLnByb3RvdHlwZS5pbkZsb2F0ID0gZnVuY3Rpb24gKG5hbWUsIHYpXG4gICAge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRJblBvcnQobmV3IFBvcnQodGhpcywgbmFtZSwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9WQUxVRSkpO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBwLnNldCh2KTtcbiAgICAgICAgICAgIHAuZGVmYXVsdFZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgYm9vbGVhbiBpbnB1dCBwb3J0LCBkaXNwbGF5ZWQgYXMgYSBjaGVja2JveFxuICAgICAqIEBmdW5jdGlvbiBpbkJvb2xcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUuaW5WYWx1ZUJvb2wgPSBPcC5wcm90b3R5cGUuaW5Cb29sID0gZnVuY3Rpb24gKG5hbWUsIHYpXG4gICAge1xuICAgICAgICAvLyBvbGRcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuYWRkSW5Qb3J0KFxuICAgICAgICAgICAgbmV3IFBvcnQodGhpcywgbmFtZSwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9WQUxVRSwge1xuICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImJvb2xcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgcC5zZXQodik7XG4gICAgICAgICAgICBwLmRlZmF1bHRWYWx1ZSA9IHAuZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIFN0cmluZyB2YWx1ZSBpbnB1dCBwb3J0XG4gICAgICogQGZ1bmN0aW9uIGluU3RyaW5nXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgZGVmYXVsdCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1BvcnR9IGNyZWF0ZWQgcG9ydFxuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5pblZhbHVlU3RyaW5nID0gZnVuY3Rpb24gKG5hbWUsIHYpXG4gICAge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRJblBvcnQoXG4gICAgICAgICAgICBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFLCB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHAudmFsdWUgPSBcIlwiO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBwLnNldCh2KTtcbiAgICAgICAgICAgIHAuZGVmYXVsdFZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgLy8gbmV3IHN0cmluZ1xuICAgIE9wLnByb3RvdHlwZS5pblN0cmluZyA9IGZ1bmN0aW9uIChuYW1lLCB2KVxuICAgIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuYWRkSW5Qb3J0KFxuICAgICAgICAgICAgbmV3IFBvcnQodGhpcywgbmFtZSwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9TVFJJTkcsIHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgdiA9IHYgfHwgXCJcIjtcbiAgICAgICAgcC52YWx1ZSA9IHY7XG4gICAgICAgIHAuc2V0KHYpO1xuICAgICAgICBwLmRlZmF1bHRWYWx1ZSA9IHY7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYSBTdHJpbmcgdmFsdWUgaW5wdXQgcG9ydCBkaXNwbGF5ZWQgYXMgVGV4dEFyZWFcbiAgICAgKiBAZnVuY3Rpb24gaW5WYWx1ZVRleHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBkZWZhdWx0IHZhbHVlXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLmluVmFsdWVUZXh0ID0gZnVuY3Rpb24gKG5hbWUsIHYpXG4gICAge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRJblBvcnQoXG4gICAgICAgICAgICBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFLCB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwidGV4dFwiXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBwLnZhbHVlID0gXCJcIjtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgcC5zZXQodik7XG4gICAgICAgICAgICBwLmRlZmF1bHRWYWx1ZSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIE9wLnByb3RvdHlwZS5pblRleHRhcmVhID0gZnVuY3Rpb24gKG5hbWUsIHYpXG4gICAge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRJblBvcnQoXG4gICAgICAgICAgICBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1NUUklORywge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcInRleHRcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcC52YWx1ZSA9IFwiXCI7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHAuc2V0KHYpO1xuICAgICAgICAgICAgcC5kZWZhdWx0VmFsdWUgPSB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgYSBTdHJpbmcgdmFsdWUgaW5wdXQgcG9ydCBkaXNwbGF5ZWQgYXMgZWRpdG9yXG4gICAgICogQGZ1bmN0aW9uIGluU3RyaW5nRWRpdG9yXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgZGVmYXVsdCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1BvcnR9IGNyZWF0ZWQgcG9ydFxuICAgICAqL1xuICAgIC8vIG5ldyBzdHJpbmdcbiAgICBPcC5wcm90b3R5cGUuaW5TdHJpbmdFZGl0b3IgPSBmdW5jdGlvbiAobmFtZSwgdiwgc3ludGF4LCBoaWRlRm9ybWF0QnV0dG9uID0gdHJ1ZSlcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZEluUG9ydChcbiAgICAgICAgICAgIG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfU1RSSU5HLCB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiZWRpdG9yXCIsXG4gICAgICAgICAgICAgICAgXCJlZGl0U2hvcnRjdXRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcImVkaXRvclN5bnRheFwiOiBzeW50YXgsXG4gICAgICAgICAgICAgICAgXCJoaWRlRm9ybWF0QnV0dG9uXCI6IGhpZGVGb3JtYXRCdXR0b25cbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICBwLnZhbHVlID0gXCJcIjtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgcC5zZXQodik7XG4gICAgICAgICAgICBwLmRlZmF1bHRWYWx1ZSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8vIG9sZFxuICAgIE9wLnByb3RvdHlwZS5pblZhbHVlRWRpdG9yID0gZnVuY3Rpb24gKG5hbWUsIHYsIHN5bnRheCwgaGlkZUZvcm1hdEJ1dHRvbiA9IHRydWUpXG4gICAge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRJblBvcnQoXG4gICAgICAgICAgICBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFLCB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiZWRpdG9yXCIsXG4gICAgICAgICAgICAgICAgXCJlZGl0b3JTeW50YXhcIjogc3ludGF4LFxuICAgICAgICAgICAgICAgIFwiaGlkZUZvcm1hdEJ1dHRvblwiOiBoaWRlRm9ybWF0QnV0dG9uXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBwLnZhbHVlID0gXCJcIjtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgcC5zZXQodik7XG4gICAgICAgICAgICBwLmRlZmF1bHRWYWx1ZSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIHN0cmluZyBzZWxlY3QgYm94XG4gICAgICogQGZ1bmN0aW9uIGluRHJvcERvd25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBkZWZhdWx0IHZhbHVlXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLmluVmFsdWVTZWxlY3QgPSBPcC5wcm90b3R5cGUuaW5Ecm9wRG93biA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZXMsIHYsIG5vaW5kZXgpXG4gICAge1xuICAgICAgICBsZXQgcCA9IG51bGw7XG4gICAgICAgIGlmICghbm9pbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhQb3J0ID0gbmV3IFBvcnQodGhpcywgbmFtZSArIFwiIGluZGV4XCIsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUsIHtcbiAgICAgICAgICAgICAgICBcImluY3JlbWVudFwiOiBcImludGVnZXJcIixcbiAgICAgICAgICAgICAgICBcImhpZGVQYXJhbVwiOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLmFkZEluUG9ydChpbmRleFBvcnQpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWVzKSBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykgdmFsdWVzW2ldID0gU3RyaW5nKHZhbHVlc1tpXSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlUG9ydCA9IG5ldyBWYWx1ZVNlbGVjdFBvcnQoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJkcm9wZG93blwiLFxuICAgICAgICAgICAgICAgICAgICBcImhpZGVQb3J0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlc1wiOiB2YWx1ZXNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhbHVlUG9ydC5pbmRleFBvcnQgPSBpbmRleFBvcnQ7XG5cbiAgICAgICAgICAgIGluZGV4UG9ydC5vbkxpbmtDaGFuZ2VkID0gZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVBvcnQuc2V0VWlBdHRyaWJzKHsgXCJncmV5b3V0XCI6IGluZGV4UG9ydC5pc0xpbmtlZCgpIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcCA9IHRoaXMuYWRkSW5Qb3J0KHZhbHVlUG9ydCk7XG5cbiAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcC5zZXQodik7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB2YWx1ZXMuZmluZEluZGV4KChpdGVtKSA9PiB7IHJldHVybiBpdGVtID09IHY7IH0pO1xuICAgICAgICAgICAgICAgIG4uc2V0VmFsdWUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHAuZGVmYXVsdFZhbHVlID0gdjtcbiAgICAgICAgICAgICAgICBuLmRlZmF1bHRWYWx1ZSA9IGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVQb3J0ID0gbmV3IFBvcnQodGhpcywgbmFtZSwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9WQUxVRSwge1xuICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImRyb3Bkb3duXCIsXG4gICAgICAgICAgICAgICAgXCJoaWRlUG9ydFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIHZhbHVlc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHAgPSB0aGlzLmFkZEluUG9ydCh2YWx1ZVBvcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIHN0cmluZyBzd2l0Y2ggYm94XG4gICAgICogQGZ1bmN0aW9uIGluU3dpdGNoXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgZGVmYXVsdCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1BvcnR9IGNyZWF0ZWQgcG9ydFxuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5pblN3aXRjaCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZXMsIHYsIG5vaW5kZXgpXG4gICAge1xuICAgICAgICBsZXQgcCA9IG51bGw7XG4gICAgICAgIGlmICghbm9pbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCF2KXYgPSB2YWx1ZXNbMF07XG4gICAgICAgICAgICBjb25zdCBpbmRleFBvcnQgPSBuZXcgUG9ydCh0aGlzLCBuYW1lICsgXCIgaW5kZXhcIiwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9WQUxVRSwge1xuICAgICAgICAgICAgICAgIFwiaW5jcmVtZW50XCI6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIFwidmFsdWVzXCI6IHZhbHVlcyxcbiAgICAgICAgICAgICAgICBcImhpZGVQYXJhbVwiOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLmFkZEluUG9ydChpbmRleFBvcnQpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWVzKSBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykgdmFsdWVzW2ldID0gU3RyaW5nKHZhbHVlc1tpXSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHN3aXRjaFBvcnQgPSBuZXcgU3dpdGNoUG9ydChcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9TVFJJTkcsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJzd2l0Y2hcIixcbiAgICAgICAgICAgICAgICAgICAgXCJoaWRlUG9ydFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZXNcIjogdmFsdWVzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpbmRleFBvcnQub25MaW5rQ2hhbmdlZCA9IGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3dpdGNoUG9ydC5zZXRVaUF0dHJpYnMoeyBcImdyZXlvdXRcIjogaW5kZXhQb3J0LmlzTGlua2VkKCkgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcCA9IHRoaXMuYWRkSW5Qb3J0KHN3aXRjaFBvcnQpO1xuXG4gICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHAuc2V0KHYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdmFsdWVzLmZpbmRJbmRleCgoaXRlbSkgPT4geyByZXR1cm4gaXRlbSA9PSB2OyB9KTtcbiAgICAgICAgICAgICAgICBuLnNldFZhbHVlKGluZGV4KTtcbiAgICAgICAgICAgICAgICBwLmRlZmF1bHRWYWx1ZSA9IHY7XG4gICAgICAgICAgICAgICAgbi5kZWZhdWx0VmFsdWUgPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHN3aXRjaFBvcnQgPSBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1NUUklORywge1xuICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcInN3aXRjaFwiLFxuICAgICAgICAgICAgICAgIFwiaGlkZVBvcnRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcInZhbHVlc1wiOiB2YWx1ZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcCA9IHRoaXMuYWRkSW5Qb3J0KHN3aXRjaFBvcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIGludGVnZXIgaW5wdXQgcG9ydFxuICAgICAqIEBmdW5jdGlvbiBpbkludFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIGRlZmF1bHQgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUuaW5WYWx1ZUludCA9IE9wLnByb3RvdHlwZS5pbkludCA9IGZ1bmN0aW9uIChuYW1lLCB2KVxuICAgIHtcbiAgICAgICAgLy8gb2xkXG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZEluUG9ydChcbiAgICAgICAgICAgIG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUsIHtcbiAgICAgICAgICAgICAgICBcImluY3JlbWVudFwiOiBcImludGVnZXJcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgcC5zZXQodik7XG4gICAgICAgICAgICBwLmRlZmF1bHRWYWx1ZSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIGZpbGUvVVJMIGlucHV0IHBvcnRcbiAgICAgKiBAZnVuY3Rpb24gaW5VUkxcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm4ge1BvcnR9IGNyZWF0ZWQgcG9ydFxuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5pbkZpbGUgPSBmdW5jdGlvbiAobmFtZSwgZmlsdGVyLCB2KVxuICAgIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuYWRkSW5Qb3J0KFxuICAgICAgICAgICAgbmV3IFBvcnQodGhpcywgbmFtZSwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9WQUxVRSwge1xuICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBcImZpbHRlclwiOiBmaWx0ZXJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHAuc2V0KHYpO1xuICAgICAgICAgICAgcC5kZWZhdWx0VmFsdWUgPSB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICBPcC5wcm90b3R5cGUuaW5VcmwgPSBmdW5jdGlvbiAobmFtZSwgZmlsdGVyLCB2KVxuICAgIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuYWRkSW5Qb3J0KFxuICAgICAgICAgICAgbmV3IFBvcnQodGhpcywgbmFtZSwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9TVFJJTkcsIHtcbiAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJmaWx0ZXJcIjogZmlsdGVyXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBwLnNldCh2KTtcbiAgICAgICAgICAgIHAuZGVmYXVsdFZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgdGV4dHVyZSBpbnB1dCBwb3J0XG4gICAgICogQGZ1bmN0aW9uIGluVGV4dHVyZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLmluVGV4dHVyZSA9IGZ1bmN0aW9uIChuYW1lLCB2KVxuICAgIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuYWRkSW5Qb3J0KFxuICAgICAgICAgICAgbmV3IFBvcnQodGhpcywgbmFtZSwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9PQkpFQ1QsIHtcbiAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJ0ZXh0dXJlXCIsXG4gICAgICAgICAgICAgICAgXCJvYmpUeXBlXCI6IFwidGV4dHVyZVwiLFxuICAgICAgICAgICAgICAgIFwicHJldmlld1wiOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBwLmlnbm9yZVZhbHVlU2VyaWFsaXplID0gdHJ1ZTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgcC5zZXQodik7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIG9iamVjdCBpbnB1dCBwb3J0XG4gICAgICogQGZ1bmN0aW9uIGluT2JqZWN0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUuaW5PYmplY3QgPSBmdW5jdGlvbiAobmFtZSwgdiwgb2JqVHlwZSlcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZEluUG9ydChuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX09CSkVDVCwgeyBcIm9ialR5cGVcIjogb2JqVHlwZSB9KSk7XG4gICAgICAgIHAuaWdub3JlVmFsdWVTZXJpYWxpemUgPSB0cnVlO1xuXG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHAuc2V0KHYpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLmluR3JhZGllbnQgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZEluUG9ydChcbiAgICAgICAgICAgIG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUsIHtcbiAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJncmFkaWVudFwiXG4gICAgICAgICAgICAgICAgLy8gXCJoaWRlUG9ydFwiOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBwLnNldCh2KTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuXG4gICAgT3AucHJvdG90eXBlLmdldFBvcnRWaXNpYmxlSW5kZXggPSBmdW5jdGlvbiAocClcbiAgICB7XG4gICAgICAgIGxldCBwb3J0cyA9IHRoaXMucG9ydHNJbjtcbiAgICAgICAgaWYgKHAuZGlyZWN0aW9uID09IENPTlNUQU5UUy5QT1JUX0RJUl9PVVQpcG9ydHMgPSB0aGlzLnBvcnRzT3V0O1xuXG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9ydHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChwb3J0c1tpXS51aUF0dHJpYnMuaGlkZVBvcnQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGlmIChwb3J0c1tpXSA9PSBwKSByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgYXJyYXkgaW5wdXQgcG9ydFxuICAgICAqIEBmdW5jdGlvbiBpbkFycmF5XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUuaW5BcnJheSA9IGZ1bmN0aW9uIChuYW1lLCB2LCBzdHJpZGUpXG4gICAge1xuICAgICAgICBpZiAoIXN0cmlkZSAmJiBDQUJMRVMuVVRJTFMuaXNOdW1lcmljKHYpKXN0cmlkZSA9IHY7XG5cbiAgICAgICAgY29uc3QgcCA9IHRoaXMuYWRkSW5Qb3J0KG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfQVJSQVksIHsgXCJzdHJpZGVcIjogc3RyaWRlIH0pKTtcblxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkICYmIChBcnJheS5pc0FycmF5KHYpIHx8IHYgPT0gbnVsbCkpIHAuc2V0KHYpO1xuXG4gICAgICAgIC8vIGlmICh2ICE9PSB1bmRlZmluZWQpIHAuc2V0KHYpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgdmFsdWUgc2xpZGVyIGlucHV0IHBvcnRcbiAgICAgKiBAZnVuY3Rpb24gaW5GbG9hdFNsaWRlclxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHR2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLmluVmFsdWVTbGlkZXIgPSBPcC5wcm90b3R5cGUuaW5GbG9hdFNsaWRlciA9IGZ1bmN0aW9uIChuYW1lLCB2LCBtaW4sIG1heClcbiAgICB7XG4gICAgICAgIGNvbnN0IHVpYXR0cmlicyA9IHsgXCJkaXNwbGF5XCI6IFwicmFuZ2VcIiB9O1xuXG4gICAgICAgIGlmIChtaW4gIT0gdW5kZWZpbmVkICYmIG1heCAhPSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHVpYXR0cmlicy5taW4gPSBtaW47XG4gICAgICAgICAgICB1aWF0dHJpYnMubWF4ID0gbWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcCA9IHRoaXMuYWRkSW5Qb3J0KG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUsIHVpYXR0cmlicykpO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBwLnNldCh2KTtcbiAgICAgICAgICAgIHAuZGVmYXVsdFZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIG91dHB1dCB0cmlnZ2VyIHBvcnRcbiAgICAgKiBAZnVuY3Rpb24gb3V0VHJpZ2dlclxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLm91dEZ1bmN0aW9uID0gT3AucHJvdG90eXBlLm91dFRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIC8vIG9sZFxuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRPdXRQb3J0KG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfRlVOQ1RJT04pKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgcC5zZXQodik7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgb3V0cHV0IHZhbHVlIHBvcnRcbiAgICAgKiBAZnVuY3Rpb24gb3V0TnVtYmVyXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1BvcnR9IGNyZWF0ZWQgcG9ydFxuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5vdXRWYWx1ZSA9IE9wLnByb3RvdHlwZS5vdXROdW1iZXIgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIC8vIG9sZFxuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRPdXRQb3J0KG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUpKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgcC5zZXQodik7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgb3V0cHV0IGJvb2xlYW4gcG9ydFxuICAgICAqIEBmdW5jdGlvbiBvdXRCb29sXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUub3V0VmFsdWVCb29sID0gT3AucHJvdG90eXBlLm91dEJvb2wgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIC8vIG9sZFxuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRPdXRQb3J0KFxuICAgICAgICAgICAgbmV3IFBvcnQodGhpcywgbmFtZSwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9WQUxVRSwge1xuICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImJvb2xcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgcC5zZXQodik7XG4gICAgICAgIGVsc2UgcC5zZXQoMCk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgb3V0cHV0IGJvb2xlYW4gcG9ydCx2YWx1ZSB3aWxsIGJlIGNvbnZlcnRlZCB0byAwIG9yIDFcbiAgICAgKiBAZnVuY3Rpb24gb3V0Qm9vbFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLm91dEJvb2xOdW0gPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZE91dFBvcnQoXG4gICAgICAgICAgICBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFLCB7XG4gICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiYm9vbG51bVwiXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIHAuc2V0ID0gZnVuY3Rpb24gKGIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoYiA/IDEgOiAwKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiYm9vbCBzZXRcIiwgYiwgdGhpcy5nZXQoKSk7XG4gICAgICAgIH0uYmluZChwKTtcblxuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBwLnNldCh2KTtcbiAgICAgICAgZWxzZSBwLnNldCgwKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBvdXRwdXQgc3RyaW5nIHBvcnRcbiAgICAgKiBAZnVuY3Rpb24gb3V0U3RyaW5nXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUub3V0VmFsdWVTdHJpbmcgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZE91dFBvcnQoXG4gICAgICAgICAgICBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFLCB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHAuc2V0KHYpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuICAgIE9wLnByb3RvdHlwZS5vdXRTdHJpbmcgPSBmdW5jdGlvbiAobmFtZSwgdilcbiAgICB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLmFkZE91dFBvcnQoXG4gICAgICAgICAgICBuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1NUUklORywge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBwLnNldCh2KTtcbiAgICAgICAgZWxzZSBwLnNldChcIlwiKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBvdXRwdXQgb2JqZWN0IHBvcnRcbiAgICAgKiBAZnVuY3Rpb24gb3V0T2JqZWN0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUub3V0T2JqZWN0ID0gZnVuY3Rpb24gKG5hbWUsIHYsIG9ialR5cGUpXG4gICAge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5hZGRPdXRQb3J0KG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfT0JKRUNULCB7IFwib2JqVHlwZVwiOiBvYmpUeXBlIHx8IG51bGwgfSkpO1xuICAgICAgICBwLnNldCh2IHx8IG51bGwpO1xuICAgICAgICBwLmlnbm9yZVZhbHVlU2VyaWFsaXplID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBvdXRwdXQgYXJyYXkgcG9ydFxuICAgICAqIEBmdW5jdGlvbiBvdXRBcnJheVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7UG9ydH0gY3JlYXRlZCBwb3J0XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLm91dEFycmF5ID0gZnVuY3Rpb24gKG5hbWUsIHYsIHN0cmlkZSlcbiAgICB7XG4gICAgICAgIGlmICghc3RyaWRlICYmIENBQkxFUy5VVElMUy5pc051bWVyaWModikpc3RyaWRlID0gdjtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuYWRkT3V0UG9ydChuZXcgUG9ydCh0aGlzLCBuYW1lLCBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0FSUkFZLCB7IFwic3RyaWRlXCI6IHN0cmlkZSB9KSk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgJiYgKEFycmF5LmlzQXJyYXkodikgfHwgdiA9PSBudWxsKSkgcC5zZXQodik7XG5cbiAgICAgICAgcC5pZ25vcmVWYWx1ZVNlcmlhbGl6ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgb3V0cHV0IHRleHR1cmUgcG9ydFxuICAgICAqIEBmdW5jdGlvbiBvdXRUZXh0dXJlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQb3J0fSBjcmVhdGVkIHBvcnRcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUub3V0VGV4dHVyZSA9IGZ1bmN0aW9uIChuYW1lLCB2KVxuICAgIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuYWRkT3V0UG9ydChcbiAgICAgICAgICAgIG5ldyBQb3J0KHRoaXMsIG5hbWUsIENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfT0JKRUNULCB7XG4gICAgICAgICAgICAgICAgXCJwcmV2aWV3XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJvYmpUeXBlXCI6IFwidGV4dHVyZVwiXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBwLnNldCh2IHx8IENHTC5UZXh0dXJlLmdldEVtcHR5VGV4dHVyZSh0aGlzLnBhdGNoLmNnbCkpO1xuXG4gICAgICAgIHAuaWdub3JlVmFsdWVTZXJpYWxpemUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLmluRHluYW1pYyA9IGZ1bmN0aW9uIChuYW1lLCBmaWx0ZXIsIG9wdGlvbnMsIHYpXG4gICAge1xuICAgICAgICBjb25zdCBwID0gbmV3IFBvcnQodGhpcywgbmFtZSwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9EWU5BTUlDLCBvcHRpb25zKTtcblxuICAgICAgICBwLnNob3VsZExpbmsgPSBmdW5jdGlvbiAocDEsIHAyKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyICYmIFVUSUxTLmlzQXJyYXkoZmlsdGVyKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlci5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwMSA9PSB0aGlzICYmIHAyLnR5cGUgPT09IGZpbHRlcltpXSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwMiA9PSB0aGlzICYmIHAxLnR5cGUgPT09IGZpbHRlcltpXSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gdHlwZXMgZG8gbm90IG1hdGNoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gbm8gZmlsdGVyIHNldFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYWRkSW5Qb3J0KHApO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBwLnNldCh2KTtcbiAgICAgICAgICAgIHAuZGVmYXVsdFZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLnJlbW92ZUxpbmtzID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wb3J0c0luLmxlbmd0aDsgaSsrKSB0aGlzLnBvcnRzSW5baV0ucmVtb3ZlTGlua3MoKTtcbiAgICAgICAgZm9yIChsZXQgaXBvID0gMDsgaXBvIDwgdGhpcy5wb3J0c091dC5sZW5ndGg7IGlwbysrKSB0aGlzLnBvcnRzT3V0W2lwb10ucmVtb3ZlTGlua3MoKTtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLmdldFNlcmlhbGl6ZWQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgY29uc3Qgb3AgPSB7fTtcblxuICAgICAgICBpZiAodGhpcy5vcElkKSBvcC5vcElkID0gdGhpcy5vcElkO1xuICAgICAgICBpZiAodGhpcy5wYXRjaC5zdG9yZU9iak5hbWVzKSBvcC5vYmpOYW1lID0gdGhpcy5vYmpOYW1lO1xuXG5cbiAgICAgICAgb3AuaWQgPSB0aGlzLmlkO1xuICAgICAgICBvcC51aUF0dHJpYnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMudWlBdHRyaWJzKSkgfHwge307XG5cbiAgICAgICAgaWYgKHRoaXMuc3RvcmFnZSAmJiBPYmplY3Qua2V5cyh0aGlzLnN0b3JhZ2UpLmxlbmd0aCA+IDApIG9wLnN0b3JhZ2UgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuc3RvcmFnZSkpO1xuICAgICAgICBpZiAodGhpcy51aUF0dHJpYnMuaGFzT3duUHJvcGVydHkoXCJ3b3JraW5nXCIpICYmIHRoaXMudWlBdHRyaWJzLndvcmtpbmcgPT0gdHJ1ZSkgZGVsZXRlIHRoaXMudWlBdHRyaWJzLndvcmtpbmc7XG4gICAgICAgIGlmIChvcC51aUF0dHJpYnMuaGFzT3duUHJvcGVydHkoXCJ1aWVycm9yc1wiKSkgZGVsZXRlIG9wLnVpQXR0cmlicy51aWVycm9ycztcblxuICAgICAgICBpZiAob3AudWlBdHRyaWJzLnRpdGxlID09IHRoaXMuX3Nob3J0T3BOYW1lKSBkZWxldGUgb3AudWlBdHRyaWJzLnRpdGxlO1xuXG4gICAgICAgIG9wLnBvcnRzSW4gPSBbXTtcbiAgICAgICAgb3AucG9ydHNPdXQgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucG9ydHNJbi5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMucG9ydHNJbltpXS5nZXRTZXJpYWxpemVkKCk7XG4gICAgICAgICAgICBpZiAocylvcC5wb3J0c0luLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpcG8gaW4gdGhpcy5wb3J0c091dClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMucG9ydHNPdXRbaXBvXS5nZXRTZXJpYWxpemVkKCk7XG4gICAgICAgICAgICBpZiAocylvcC5wb3J0c091dC5wdXNoKHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wLnBvcnRzSW4ubGVuZ3RoID09IDApIGRlbGV0ZSBvcC5wb3J0c0luO1xuICAgICAgICBpZiAob3AucG9ydHNPdXQubGVuZ3RoID09IDApIGRlbGV0ZSBvcC5wb3J0c091dDtcbiAgICAgICAgY2xlYW5Kc29uKG9wKTtcblxuICAgICAgICByZXR1cm4gb3A7XG4gICAgfTtcblxuICAgIE9wLnByb3RvdHlwZS5nZXRGaXJzdE91dFBvcnRCeVR5cGUgPSBmdW5jdGlvbiAodHlwZSlcbiAgICB7XG4gICAgICAgIGZvciAoY29uc3QgaXBvIGluIHRoaXMucG9ydHNPdXQpIGlmICh0aGlzLnBvcnRzT3V0W2lwb10udHlwZSA9PSB0eXBlKSByZXR1cm4gdGhpcy5wb3J0c091dFtpcG9dO1xuICAgIH07XG5cbiAgICBPcC5wcm90b3R5cGUuZ2V0Rmlyc3RJblBvcnRCeVR5cGUgPSBmdW5jdGlvbiAodHlwZSlcbiAgICB7XG4gICAgICAgIGZvciAoY29uc3QgaXBvIGluIHRoaXMucG9ydHNJbikgaWYgKHRoaXMucG9ydHNJbltpcG9dLnR5cGUgPT0gdHlwZSkgcmV0dXJuIHRoaXMucG9ydHNJbltpcG9dO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gcG9ydCBieSB0aGUgbmFtZSBwb3J0TmFtZVxuICAgICAqIEBmdW5jdGlvbiBnZXRQb3J0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBvcnROYW1lXG4gICAgICogQHJldHVybiB7UG9ydH1cbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUuZ2V0UG9ydCA9IE9wLnByb3RvdHlwZS5nZXRQb3J0QnlOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGxvd2VyQ2FzZSlcbiAgICB7XG4gICAgICAgIGlmIChsb3dlckNhc2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlwaSA9IDA7IGlwaSA8IHRoaXMucG9ydHNJbi5sZW5ndGg7IGlwaSsrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcnRzSW5baXBpXS5nZXROYW1lKCkudG9Mb3dlckNhc2UoKSA9PSBuYW1lIHx8IHRoaXMucG9ydHNJbltpcGldLmlkLnRvTG93ZXJDYXNlKCkgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9ydHNJbltpcGldO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpcG8gPSAwOyBpcG8gPCB0aGlzLnBvcnRzT3V0Lmxlbmd0aDsgaXBvKyspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9ydHNPdXRbaXBvXS5nZXROYW1lKCkudG9Mb3dlckNhc2UoKSA9PSBuYW1lIHx8IHRoaXMucG9ydHNPdXRbaXBvXS5pZC50b0xvd2VyQ2FzZSgpID09IG5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBvcnRzT3V0W2lwb107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKGxldCBpcGkgPSAwOyBpcGkgPCB0aGlzLnBvcnRzSW4ubGVuZ3RoOyBpcGkrKylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3J0c0luW2lwaV0uZ2V0TmFtZSgpID09IG5hbWUgfHwgdGhpcy5wb3J0c0luW2lwaV0uaWQgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9ydHNJbltpcGldO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpcG8gPSAwOyBpcG8gPCB0aGlzLnBvcnRzT3V0Lmxlbmd0aDsgaXBvKyspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9ydHNPdXRbaXBvXS5nZXROYW1lKCkgPT0gbmFtZSB8fCB0aGlzLnBvcnRzT3V0W2lwb10uaWQgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9ydHNPdXRbaXBvXTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIHJldHVybiBwb3J0IGJ5IHRoZSBuYW1lIGlkXG4gICAgICogQGZ1bmN0aW9uIGdldFBvcnRCeUlkXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICogQHJldHVybiB7UG9ydH1cbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUuZ2V0UG9ydEJ5SWQgPSBmdW5jdGlvbiAoaWQpXG4gICAge1xuICAgICAgICBmb3IgKGxldCBpcGkgPSAwOyBpcGkgPCB0aGlzLnBvcnRzSW4ubGVuZ3RoOyBpcGkrKykgaWYgKHRoaXMucG9ydHNJbltpcGldLmlkID09IGlkKSByZXR1cm4gdGhpcy5wb3J0c0luW2lwaV07XG4gICAgICAgIGZvciAobGV0IGlwbyA9IDA7IGlwbyA8IHRoaXMucG9ydHNPdXQubGVuZ3RoOyBpcG8rKykgaWYgKHRoaXMucG9ydHNPdXRbaXBvXS5pZCA9PSBpZCkgcmV0dXJuIHRoaXMucG9ydHNPdXRbaXBvXTtcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLnVwZGF0ZUFuaW1zID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNBbmltUG9ydClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wb3J0c0luLmxlbmd0aDsgaSsrKSB0aGlzLnBvcnRzSW5baV0udXBkYXRlQW5pbSgpO1xuICAgIH07XG5cbiAgICBPcC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGNvbnN0IGluaXRpYXRvciA9IFwib3AgXCIgKyB0aGlzLm9iak5hbWU7XG4gICAgICAgIGlmIChDQUJMRVMuVUkgJiYgIUNBQkxFUy5VSS5sb2dGaWx0ZXIuc2hvdWxkUHJpbnQoaW5pdGlhdG9yLCAuLi5hcmd1bWVudHMpKSByZXR1cm47XG4gICAgICAgIGlmICghQ0FCTEVTLlVJICYmIHRoaXMucGF0Y2guc2lsZW50KSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgYXJncyA9IFtcIltvcCBcIiArIENBQkxFUy5nZXRTaG9ydE9wTmFtZSh0aGlzLm9iak5hbWUpICsgXCJdXCJdO1xuICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KGNvbnNvbGUubG9nLCBbY29uc29sZSwgYXJnc10pOy8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLmVycm9yID0gT3AucHJvdG90eXBlLmxvZ0Vycm9yID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJubyB0aGlzLi4uISEhXCIpO1xuICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiAodGhpcy5wYXRjaC5zaWxlbnQpIHJldHVybjtcbiAgICAgICAgY29uc3QgYXJncyA9IFtcIltvcCBcIiArIENBQkxFUy5nZXRTaG9ydE9wTmFtZSh0aGlzLm9iak5hbWUpICsgXCJdXCJdO1xuICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KGNvbnNvbGUuZXJyb3IsIFtjb25zb2xlLCBhcmdzXSk7Ly8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBpZiAod2luZG93Lmd1aSkgd2luZG93Lmd1aS5lbWl0RXZlbnQoXCJvcExvZ0V2ZW50XCIsIHRoaXMub2JqTmFtZSwgXCJlcnJvclwiLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBPcC5wcm90b3R5cGUud2FybiA9IE9wLnByb3RvdHlwZS5sb2dXYXJuID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vIGlmICh0aGlzLnBhdGNoLnNpbGVudCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBhcmdzID0gW1wiW29wIFwiICsgQ0FCTEVTLmdldFNob3J0T3BOYW1lKHRoaXMub2JqTmFtZSkgKyBcIl1cIl07XG4gICAgICAgIGFyZ3MucHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS53YXJuLCBbY29uc29sZSwgYXJnc10pOy8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB9O1xuXG4gICAgT3AucHJvdG90eXBlLnZlcmJvc2UgPSBPcC5wcm90b3R5cGUubG9nVmVyYm9zZSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBjb25zdCBpbml0aWF0b3IgPSBcIm9wIFwiICsgQ0FCTEVTLmdldFNob3J0T3BOYW1lKHRoaXMub2JqTmFtZSk7XG4gICAgICAgIGlmIChDQUJMRVMuVUkgJiYgIUNBQkxFUy5VSS5sb2dGaWx0ZXIuc2hvdWxkUHJpbnQoaW5pdGlhdG9yLCAuLi5hcmd1bWVudHMpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCFDQUJMRVMuVUkgJiYgdGhpcy5wYXRjaC5zaWxlbnQpIHJldHVybjtcblxuICAgICAgICBjb25zdCBhcmdzID0gW1wiW1wiICsgaW5pdGlhdG9yICsgXCJdXCJdO1xuICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KGNvbnNvbGUuaW5mbywgW2NvbnNvbGUsIGFyZ3NdKTsvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfTtcblxuXG4gICAgT3AucHJvdG90eXBlLnByb2ZpbGUgPSBmdW5jdGlvbiAoZW5hYmxlKVxuICAgIHtcbiAgICAgICAgZm9yIChsZXQgaXBpID0gMDsgaXBpIDwgdGhpcy5wb3J0c0luLmxlbmd0aDsgaXBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucG9ydHNJbltpcGldLl9vblRyaWdnZXJlZCA9IHRoaXMucG9ydHNJbltpcGldLl9vblRyaWdnZXJlZFByb2ZpbGluZztcbiAgICAgICAgICAgIHRoaXMucG9ydHNJbltpcGldLnNldCA9IHRoaXMucG9ydHNJbltpcGldLl9vblNldFByb2ZpbGluZztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBPcC5wcm90b3R5cGUuZmluZFBhcmVudCA9IGZ1bmN0aW9uIChvYmpOYW1lKVxuICAgIHtcbiAgICAgICAgZm9yIChsZXQgaXBpID0gMDsgaXBpIDwgdGhpcy5wb3J0c0luLmxlbmd0aDsgaXBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcnRzSW5baXBpXS5pc0xpbmtlZCgpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcnRzSW5baXBpXS5saW5rc1swXS5wb3J0T3V0LnBhcmVudC5vYmpOYW1lID09IG9iak5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBvcnRzSW5baXBpXS5saW5rc1swXS5wb3J0T3V0LnBhcmVudDtcblxuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0aGlzLnBvcnRzSW5baXBpXS5saW5rc1swXS5wb3J0T3V0LnBhcmVudC5maW5kUGFyZW50KG9iak5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cblxuICAgIC8vIHRvZG86IGNoZWNrIGluc3RhbmNpbmcgc3R1ZmY/XG4gICAgT3AucHJvdG90eXBlLmNsZWFuVXAgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlcylcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbnN0YW5jZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlc1tpXS5vbkRlbGV0ZSkgdGhpcy5faW5zdGFuY2VzW2ldLm9uRGVsZXRlKCk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBvcnRzSW4ubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucG9ydHNJbltpXS5zZXRBbmltYXRlZChmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vbkFuaW1GcmFtZSkgdGhpcy5wYXRjaC5yZW1vdmVPbkFuaW1GcmFtZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgLy8gdG9kbzogY2hlY2sgaW5zdGFuY2luZyBzdHVmZj9cbiAgICBPcC5wcm90b3R5cGUuaW5zdGFuY2VkID0gZnVuY3Rpb24gKHRyaWdnZXJQb3J0KVxuICAgIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJpbnN0YW5jZWRcIiwgdGhpcy5wYXRjaC5pbnN0YW5jaW5nLm51bUN5Y2xlcygpKTtcbiAgICAgICAgaWYgKHRoaXMucGF0Y2guaW5zdGFuY2luZy5udW1DeWNsZXMoKSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG5cbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgaXBpID0gMDtcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZXMgfHwgdGhpcy5faW5zdGFuY2VzLmxlbmd0aCAhPSB0aGlzLnBhdGNoLmluc3RhbmNpbmcubnVtQ3ljbGVzKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5zdGFuY2VzKSB0aGlzLl9pbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuXy5sb2coXCJjcmVhdGluZyBpbnN0YW5jZXMgb2YgXCIsIHRoaXMub2JqTmFtZSwgdGhpcy5wYXRjaC5pbnN0YW5jaW5nLm51bUN5Y2xlcygpLCB0aGlzLl9pbnN0YW5jZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlcy5sZW5ndGggPSB0aGlzLnBhdGNoLmluc3RhbmNpbmcubnVtQ3ljbGVzKCk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9pbnN0YW5jZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VzW2ldID0gdGhpcy5wYXRjaC5jcmVhdGVPcCh0aGlzLm9iak5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlc1tpXS5pbnN0YW5jZWQgPSBmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VzW2ldLnVpQXR0cih0aGlzLnVpQXR0cmlicyk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpcG8gPSAwOyBpcG8gPCB0aGlzLnBvcnRzT3V0Lmxlbmd0aDsgaXBvKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3J0c091dFtpcG9dLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9GVU5DVElPTilcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VzW2ldLmdldFBvcnRCeU5hbWUodGhpcy5wb3J0c091dFtpcG9dLm5hbWUpLnRyaWdnZXIgPSB0aGlzLnBvcnRzT3V0W2lwb10udHJpZ2dlci5iaW5kKHRoaXMucG9ydHNPdXRbaXBvXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaXBpID0gMDsgaXBpIDwgdGhpcy5wb3J0c0luLmxlbmd0aDsgaXBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0c0luW2lwaV0ub25DaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucG9ydHNJbltpcGldLm9uVmFsdWVDaGFuZ2VkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRoZVRyaWdnZXJQb3J0ID0gbnVsbDtcbiAgICAgICAgZm9yIChpcGkgPSAwOyBpcGkgPCB0aGlzLnBvcnRzSW4ubGVuZ3RoOyBpcGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHRoaXMucG9ydHNJbltpcGldLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9WQUxVRSB8fFxuICAgICAgICAgICAgICAgIHRoaXMucG9ydHNJbltpcGldLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9BUlJBWVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlc1t0aGlzLnBhdGNoLmluc3RhbmNpbmcuaW5kZXgoKV0ucG9ydHNJbltpcGldLnNldCh0aGlzLnBvcnRzSW5baXBpXS5nZXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wb3J0c0luW2lwaV0udHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0ZVTkNUSU9OKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGlmKHRoaXMuX2luc3RhbmNlc1sgdGhpcy5wYXRjaC5pbnN0YW5jaW5nLmluZGV4KCkgXS5wb3J0c0luW2lwaV0ubmFtZT09dHJpZ2dlclBvcnQubmFtZSlcbiAgICAgICAgICAgICAgICAvLyB0aGVUcmlnZ2VyUG9ydD10aGlzLl9pbnN0YW5jZXNbIHRoaXMucGF0Y2guaW5zdGFuY2luZy5pbmRleCgpIF0ucG9ydHNJbltpcGldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoZVRyaWdnZXJQb3J0KSB0aGVUcmlnZ2VyUG9ydC5vblRyaWdnZXJlZCgpO1xuXG4gICAgICAgIGZvciAoaXBpID0gMDsgaXBpIDwgdGhpcy5wb3J0c091dC5sZW5ndGg7IGlwaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3J0c091dFtpcGldLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9WQUxVRSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcnRzT3V0W2lwaV0uc2V0KHRoaXMuX2luc3RhbmNlc1t0aGlzLnBhdGNoLmluc3RhbmNpbmcuaW5kZXgoKV0ucG9ydHNPdXRbaXBpXS5nZXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLy8gdG9kbzogY2hlY2sgaW5zdGFuY2luZyBzdHVmZj9cbiAgICBPcC5wcm90b3R5cGUuaW5pdEluc3RhbmNhYmxlID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vICAgICAgICAgaWYodGhpcy5pc0luc3RhbmNlZClcbiAgICAgICAgLy8gICAgICAgICB7XG4gICAgICAgIC8vICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjYW5jZWwgaW5zdGFuY2luZycpO1xuICAgICAgICAvLyAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAvLyAgICAgICAgIHRoaXMuX2luc3RhbmNlcz1bXTtcbiAgICAgICAgLy8gICAgICAgICBmb3IodmFyIGlwaT0wO2lwaTx0aGlzLnBvcnRzSW4ubGVuZ3RoO2lwaSsrKVxuICAgICAgICAvLyAgICAgICAgIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgaWYodGhpcy5wb3J0c0luW2lwaV0udHlwZT09Q09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9WQUxVRSlcbiAgICAgICAgLy8gICAgICAgICAgICAge1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgICAgIGlmKHRoaXMucG9ydHNJbltpcGldLnR5cGU9PUNPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfRlVOQ1RJT04pXG4gICAgICAgIC8vICAgICAgICAgICAgIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIC8vIHZhciBwaUluZGV4PWlwaTtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHRoaXMucG9ydHNJbltpcGldLm9uVHJpZ2dlcmVkPWZ1bmN0aW9uKHBpSW5kZXgpXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgdmFyIGk9MDtcbiAgICAgICAgLy8gLy8gY29uc29sZS5sb2coJ3RyaWdnZXInLHRoaXMuX2luc3RhbmNlcy5sZW5ndGgpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMsaXBpICk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICAgICAgIH1cbiAgICAgICAgLy8gfTtcbiAgICAgICAgLy8gdGhpcy5faW5zdGFuY2VzPW51bGw7XG4gICAgfTtcblxuICAgIE9wLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbiAob2JqKVxuICAgIHtcbiAgICAgICAgZm9yIChjb25zdCBpIGluIG9iailcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcG9ydCA9IHRoaXMuZ2V0UG9ydEJ5TmFtZShpKTtcbiAgICAgICAgICAgIGlmIChwb3J0KSBwb3J0LnNldChvYmpbaV0pO1xuICAgICAgICAgICAgZWxzZSB0aGlzLl9sb2cud2FybihcIm9wLnNldFZhbHVlczogcG9ydCBub3QgZm91bmQ6XCIsIGkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0cnVlIGlmIG9wIGhhcyB0aGlzIGVycm9yIG1lc3NhZ2UgaWRcbiAgICAgKiBAZnVuY3Rpb24gaGFzVWlFcnJvclxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7aWR9IGVycm9yIGlkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IC0gaGFzIGlkXG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLmhhc1VpRXJyb3IgPSBmdW5jdGlvbiAoaWQpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdWlFcnJvcnMuaGFzT3duUHJvcGVydHkoaWQpICYmIHRoaXMuX3VpRXJyb3JzW2lkXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2hvdyBvcCBlcnJvciBtZXNzYWdlIC0gc2V0IG1lc3NhZ2UgdG8gbnVsbCB0byByZW1vdmUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBmdW5jdGlvbiBzZXRVaUVycm9yXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtpZH0gZXJyb3IgaWRcbiAgICAgKiBAcGFyYW0ge3R4dH0gdGV4dCBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtsZXZlbH0gbGV2ZWxcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUuc2V0VWlFcnJvciA9IGZ1bmN0aW9uIChpZCwgdHh0LCBsZXZlbClcbiAgICB7XG4gICAgICAgIGlmICghdHh0ICYmICF0aGlzLmhhc1VpRXJyb3JzKSByZXR1cm47XG4gICAgICAgIGlmICghdHh0ICYmICF0aGlzLl91aUVycm9ycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX3VpRXJyb3JzLmhhc093blByb3BlcnR5KGlkKSAmJiB0aGlzLl91aUVycm9yc1tpZF0udHh0ID09IHR4dCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChpZC5pbmRleE9mKFwiIFwiKSA+IC0xKSB0aGlzLl9sb2cud2FybihcInNldHVpZXJyb3IgaWQgY2FudCBoYXZlIHNwYWNlcyEgXCIsIGlkKTtcbiAgICAgICAgaWQgPSBpZC5yZXBsYWNlQWxsKFwiIFwiLCBcIl9cIik7XG5cbiAgICAgICAgaWYgKCF0eHQgJiYgdGhpcy5fdWlFcnJvcnMuaGFzT3duUHJvcGVydHkoaWQpKSBkZWxldGUgdGhpcy5fdWlFcnJvcnNbaWRdO1xuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0eHQgJiYgKCF0aGlzLl91aUVycm9ycy5oYXNPd25Qcm9wZXJ0eShpZCkgfHwgdGhpcy5fdWlFcnJvcnNbaWRdLnR4dCAhPSB0eHQpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA9PSB1bmRlZmluZWQpIGxldmVsID0gMjtcbiAgICAgICAgICAgICAgICB0aGlzLl91aUVycm9yc1tpZF0gPSB7IFwidHh0XCI6IHR4dCwgXCJsZXZlbFwiOiBsZXZlbCwgXCJpZFwiOiBpZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyb3JBcnIgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpIGluIHRoaXMuX3VpRXJyb3JzKSBlcnJvckFyci5wdXNoKHRoaXMuX3VpRXJyb3JzW2ldKTtcblxuICAgICAgICB0aGlzLnVpQXR0cih7IFwidWllcnJvcnNcIjogZXJyb3JBcnIgfSk7XG4gICAgICAgIHRoaXMuaGFzVWlFcnJvcnMgPSBPYmplY3Qua2V5cyh0aGlzLl91aUVycm9ycykubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwidWlFcnJvckNoYW5nZVwiKTtcbiAgICB9O1xuXG4gICAgLy8gdG9kbzogcmVtb3ZlXG4gICAgT3AucHJvdG90eXBlLnNldEVycm9yID0gZnVuY3Rpb24gKGlkLCB0eHQpXG4gICAge1xuICAgICAgICB0aGlzLl9sb2cud2FybihcIm9sZCBlcnJvciBtZXNzYWdlIG9wLmVycm9yKCkgLSB1c2Ugb3Auc2V0VWlFcnJvcigpXCIpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIGVuYWJsZS9kaXNhYmxlIG9wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtib29sZWFufVxuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5zZXRFbmFibGVkID0gZnVuY3Rpb24gKGIpXG4gICAge1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSBiO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcIm9uRW5hYmxlZENoYW5nZVwiLCBiKTtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHRoaXMuc2V0VWlFcnJvcihcIl9kaXNhYmxlZFwiLCBcIk9wIGlzIGRpc2FibGVkXCIsIDApO1xuICAgICAgICBlbHNlIHRoaXMuc2V0VWlFcnJvcihcIl9kaXNhYmxlZFwiLCBudWxsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogb3JnYW5pemUgcG9ydHMgaW50byBhIGdyb3VwXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb3J0c1xuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5zZXRQb3J0R3JvdXAgPSBmdW5jdGlvbiAobmFtZSwgcG9ydHMpXG4gICAge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvcnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAocG9ydHNbaV0pXG4gICAgICAgICAgICAgICAgaWYgKHBvcnRzW2ldLnNldFVpQXR0cmlicykgcG9ydHNbaV0uc2V0VWlBdHRyaWJzKHsgXCJncm91cFwiOiBuYW1lIH0pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihcInNldFBvcnRHcm91cDogaW52YWxpZCBwb3J0IVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdmlzdWFsbHkgaW5kaWNhdGUgcG9ydHMgdGhhdCB0aGV5IGFyZSBjb29yZGluYXRlIGlucHV0c1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBPcFxuICAgICAqIEBwYXJhbSB7UG9ydH0gcG9ydFhcbiAgICAgKiBAcGFyYW0ge1BvcnR9IHBvcnRZXG4gICAgICogQHBhcmFtIHtQb3J0fSBwb3J0WlxuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5zZXRVaUF4aXNQb3J0cyA9IGZ1bmN0aW9uIChweCwgcHksIHB6KVxuICAgIHtcbiAgICAgICAgaWYgKHB4KSBweC5zZXRVaUF0dHJpYnMoeyBcImF4aXNcIjogXCJYXCIgfSk7XG4gICAgICAgIGlmIChweSkgcHkuc2V0VWlBdHRyaWJzKHsgXCJheGlzXCI6IFwiWVwiIH0pO1xuICAgICAgICBpZiAocHopIHB6LnNldFVpQXR0cmlicyh7IFwiYXhpc1wiOiBcIlpcIiB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHBvcnQgZnJvbSBvcFxuICAgICAqIEBmdW5jdGlvbiByZW1vdmVQb3J0XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtQb3J0fSBwb3J0IHRvIHJlbW92ZVxuICAgICAqL1xuICAgIE9wLnByb3RvdHlwZS5yZW1vdmVQb3J0ID0gZnVuY3Rpb24gKHBvcnQpXG4gICAge1xuICAgICAgICBmb3IgKGxldCBpcGkgPSAwOyBpcGkgPCB0aGlzLnBvcnRzSW4ubGVuZ3RoOyBpcGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9ydHNJbltpcGldID09IHBvcnQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0c0luLnNwbGljZShpcGksIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwib25VaUF0dHJpYnNDaGFuZ2VcIiwge30pO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwib25Qb3J0UmVtb3ZlZFwiLCB7fSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIE9wLnByb3RvdHlwZS5fY2hlY2tMaW5rc05lZWRlZFRvV29yayA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLyoqXG4gICAgICogc2hvdyBhIHdhcm5pbmcgb2YgdGhpcyBvcCBpcyBub3QgYSBjaGlsZCBvZiBwYXJlbnRPcE5hbWVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50T3BOYW1lXG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLnRvV29ya05lZWRzUGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudE9wTmFtZSlcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5wYXRjaC5pc0VkaXRvck1vZGUoKSkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX2xpbmtUaW1lUnVsZXMubmVlZHNQYXJlbnRPcCA9IHBhcmVudE9wTmFtZTtcbiAgICB9O1xuXG4gICAgLy8gLyoqXG4gICAgLy8gICogc2hvdyBhIHdhcm5pbmcgb2YgdGhpcyBvcCBpcyBhIGNoaWxkIG9mIHBhcmVudE9wTmFtZVxuICAgIC8vICAqIEBmdW5jdGlvblxuICAgIC8vICAqIEBpbnN0YW5jZVxuICAgIC8vICAqIEBtZW1iZXJvZiBPcFxuICAgIC8vICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnRPcE5hbWVcbiAgICAvLyAgKi9cbiAgICBPcC5wcm90b3R5cGUudG9Xb3JrU2hvdWxkTm90QmVDaGlsZCA9IGZ1bmN0aW9uIChwYXJlbnRPcE5hbWUsIHR5cGUpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMucGF0Y2guaXNFZGl0b3JNb2RlKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fbGlua1RpbWVSdWxlcy5mb3JiaWRkZW5QYXJlbnQgPSBwYXJlbnRPcE5hbWU7XG4gICAgICAgIGlmICh0eXBlICE9IHVuZGVmaW5lZCkgdGhpcy5fbGlua1RpbWVSdWxlcy5mb3JiaWRkZW5QYXJlbnRUeXBlID0gdHlwZTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBzaG93IGEgc21hbGwgWCB0byBpbmRpY2F0ZSBvcCBpcyBub3Qgd29ya2luZyB3aGVuIGdpdmVuIHBvcnRzIGFyZSBub3QgbGlua2VkXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtQb3J0fSBwb3J0MVxuICAgICAqIEBwYXJhbSB7UG9ydH0gcG9ydDJcbiAgICAgKiBAcGFyYW0ge1BvcnR9IHBvcnQzXG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLnRvV29ya1BvcnRzTmVlZFRvQmVMaW5rZWQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhdGNoLmlzRWRpdG9yTW9kZSgpKSByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmtUaW1lUnVsZXMubmVlZHNMaW5rZWRUb1dvcmsuaW5kZXhPZihhcmd1bWVudHNbaV0pID09IC0xKSB0aGlzLl9saW5rVGltZVJ1bGVzLm5lZWRzTGlua2VkVG9Xb3JrLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9O1xuICAgIE9wLnByb3RvdHlwZS50b1dvcmtQb3J0c05lZWRUb0JlTGlua2VkUmVzZXQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhdGNoLmlzRWRpdG9yTW9kZSgpKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2xpbmtUaW1lUnVsZXMubmVlZHNMaW5rZWRUb1dvcmsubGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tMaW5rVGltZVdhcm5pbmdzKSB0aGlzLmNoZWNrTGlua1RpbWVXYXJuaW5ncygpO1xuICAgIH07XG5cbiAgICBPcC5wcm90b3R5cGUuaW5pdFZhclBvcnRzID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wb3J0c0luLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3J0c0luW2ldLmdldFZhcmlhYmxlTmFtZSgpKSB0aGlzLnBvcnRzSW5baV0uc2V0VmFyaWFibGUodGhpcy5wb3J0c0luW2ldLmdldFZhcmlhYmxlTmFtZSgpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZWZyZXNoIG9wIHBhcmFtZXRlcnMsIGlmIGN1cnJlbnQgb3AgaXMgc2VsZWN0ZWRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKi9cbiAgICBPcC5wcm90b3R5cGUucmVmcmVzaFBhcmFtcyA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5wYXRjaCAmJiB0aGlzLnBhdGNoLmlzRWRpdG9yTW9kZSgpICYmIHRoaXMuaXNDdXJyZW50VWlPcCgpKVxuICAgICAgICB7XG4gICAgICAgICAgICBndWkub3BQYXJhbXMuc2hvdyh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb3AgaXMgc2VsZWN0ZWQgYW5kIHBhcmFtZXRlciBhcmUgc2hvd24gaW4gdGhlIGVkaXRvciwgY2FuIG9ubHkgcmV0dXJuIHRydWUgaWYgaW4gZWRpdG9yL3VpXG4gICAgICogQGZ1bmN0aW9uIGlzQ3VycmVudFVpT3BcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgT3BcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBpcyBjdXJyZW50IHVpIG9wXG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLmlzQ3VycmVudFVpT3AgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMucGF0Y2guaXNFZGl0b3JNb2RlKCkpIHJldHVybiBndWkucGF0Y2hWaWV3LmlzQ3VycmVudE9wKHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnQgdG8gcmVuZGVyIDJkIGNhbnZhcyBiYXNlZCBncmFwaGljcyBmcm9tIGluIGFuIG9wXG4gICAgICogQGZ1bmN0aW9uIHJlbmRlclZpekxheWVyXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE9wXG4gICAgICogQHBhcmFtIHtjdHh9IGNvbnRleHQgb2YgY2FudmFzIDJkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxheWVyIGluZm9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF5ZXIueCB4IHBvc2l0aW9uIG9uIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXllci55IHkgcG9zaXRpb24gb24gY2FudmFzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxheWVyLndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXllci5oZWlnaHQgaGVpZ2h0IG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXllci5zY2FsZSBjdXJyZW50IHNjYWxpbmcgb2YgcGF0Y2hmaWVsZCB2aWV3XG4gICAgICovXG4gICAgT3AucHJvdG90eXBlLnJlbmRlclZpekxheWVyID0gbnVsbDsgLy8gb3B0aW9uYWx5IGRlZmluZWQgaW4gb3AgaW5zdGFuY2Vcbn1cblxuZXhwb3J0IHsgT3AgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/core_op.js\n");

/***/ }),

/***/ "./src/core/core_patch.js":
/*!********************************!*\
  !*** ./src/core/core_patch.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n/* harmony import */ var _eventtarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eventtarget.js */ \"./src/core/eventtarget.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"./src/core/utils.js\");\n/* harmony import */ var _loadingstatus_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loadingstatus.js */ \"./src/core/loadingstatus.js\");\n/* harmony import */ var _instancing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./instancing.js */ \"./src/core/instancing.js\");\n/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./timer.js */ \"./src/core/timer.js\");\n/* harmony import */ var _core_link_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core_link.js */ \"./src/core/core_link.js\");\n/* harmony import */ var _core_profiler_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core_profiler.js */ \"./src/core/core_profiler.js\");\n/* harmony import */ var _cgl_cgl_state_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cgl/cgl_state.js */ \"./src/core/cgl/cgl_state.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./constants.js */ \"./src/core/constants.js\");\n/* harmony import */ var _core_variable_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core_variable.js */ \"./src/core/core_variable.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Patch class, contains all operators,values,links etc. manages loading and running of the whole patch\n *\n * see {@link PatchConfig}\n *\n * @external CABLES\n * @namespace Patch\n * @hideconstructor\n * @param {PatchConfig} config The configuration object.\n * @class\n * @example\n * CABLES.patch=new CABLES.Patch(\n * {\n *     patch:pStr,\n *     glCanvasId:'glcanvas',\n *     glCanvasResizeToWindow:true,\n *     canvas:{powerPreference:\"high-performance\"},\n *     prefixAssetPath:'/assets/',\n *     prefixJsPath:'/js/',\n *     onError:function(e){console.log(e);}\n *     glslPrecision:'highp'\n * });\n */\n\nconst Patch = function (cfg)\n{\n    _eventtarget_js__WEBPACK_IMPORTED_MODULE_0__.EventTarget.apply(this);\n\n    this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"core_patch\");\n    this.ops = [];\n    this.settings = {};\n    this.config = cfg ||\n        {\n            \"glCanvasResizeToWindow\": false,\n            \"prefixAssetPath\": \"\",\n            \"prefixJsPath\": \"\",\n            \"silent\": true,\n            \"onError\": null,\n            \"onFinishedLoading\": null,\n            \"onFirstFrameRendered\": null,\n            \"onPatchLoaded\": null,\n            \"fpsLimit\": 0,\n        };\n    this.timer = new _timer_js__WEBPACK_IMPORTED_MODULE_2__.Timer();\n    this.freeTimer = new _timer_js__WEBPACK_IMPORTED_MODULE_2__.Timer();\n    this.animFrameOps = [];\n    this.animFrameCallbacks = [];\n    this.gui = false;\n    CABLES.logSilent = this.silent = true;\n    this.profiler = null;\n    this.aborted = false;\n    this._crashedOps = [];\n    this._renderOneFrame = false;\n    this._animReq = null;\n    this._opIdCache = {};\n    this._triggerStack = [];\n    this.storeObjNames = false; // remove after may release\n\n    this.loading = new _loadingstatus_js__WEBPACK_IMPORTED_MODULE_3__.LoadingStatus(this);\n\n    this._volumeListeners = [];\n    this._paused = false;\n    this._frameNum = 0;\n    this.instancing = new _instancing_js__WEBPACK_IMPORTED_MODULE_4__.Instancing();\n    this.onOneFrameRendered = null;\n    this.namedTriggers = {};\n\n    this._origData = null;\n    this._frameNext = 0;\n    this._frameInterval = 0;\n    this._lastFrameTime = 0;\n    this._frameWasdelayed = true;\n    this.frameStore = {};\n    this.deSerialized = false;\n    this._lastReqAnimTimeStamp = 0;\n\n    this.cgCanvas = null;\n\n    if (!(function () { return !this; }())) console.log(\"not in strict mode: core patch\");\n\n    this._isLocal = document.location.href.indexOf(\"file:\") === 0;\n\n    if (this.config.hasOwnProperty(\"silent\")) this.silent = CABLES.logSilent = this.config.silent;\n    if (!this.config.hasOwnProperty(\"doRequestAnimation\")) this.config.doRequestAnimation = true;\n\n    if (!this.config.prefixAssetPath) this.config.prefixAssetPath = \"\";\n    if (!this.config.prefixJsPath) this.config.prefixJsPath = \"\";\n    if (!this.config.masterVolume) this.config.masterVolume = 1.0;\n\n    this._variables = {};\n    this._variableListeners = [];\n    this.vars = {};\n    if (cfg && cfg.vars) this.vars = cfg.vars; // vars is old!\n\n    this.cgl = new _cgl_cgl_state_js__WEBPACK_IMPORTED_MODULE_5__.Context(this);\n    this.cgp = null;\n\n    this._subpatchOpCache = {};\n\n    this.cgl.setCanvas(this.config.glCanvasId || this.config.glCanvas || \"glcanvas\");\n    if (this.config.glCanvasResizeToWindow === true) this.cgl.setAutoResize(\"window\");\n    if (this.config.glCanvasResizeToParent === true) this.cgl.setAutoResize(\"parent\");\n    this.loading.setOnFinishedLoading(this.config.onFinishedLoading);\n\n    if (this.cgl.aborted) this.aborted = true;\n    if (this.cgl.silent) this.silent = true;\n\n    this.freeTimer.play();\n    this.exec();\n\n    if (!this.aborted)\n    {\n        if (this.config.patch)\n        {\n            this.deSerialize(this.config.patch);\n        }\n        else if (this.config.patchFile)\n        {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.ajax)(\n                this.config.patchFile,\n                (err, _data) =>\n                {\n                    const data = JSON.parse(_data);\n                    if (err)\n                    {\n                        const txt = \"\";\n                        this._log.error(\"err\", err);\n                        this._log.error(\"data\", data);\n                        this._log.error(\"data\", data.msg);\n                        return;\n                    }\n                    this.deSerialize(data);\n                }\n            );\n        }\n        this.timer.play();\n    }\n\n    console.log(\"made with https://cables.gl\"); // eslint-disable-line\n};\n\nPatch.prototype.isPlaying = function ()\n{\n    return !this._paused;\n};\n\nPatch.prototype.isRenderingOneFrame = function ()\n{\n    return this._renderOneFrame;\n};\n\n\nPatch.prototype.renderOneFrame = function ()\n{\n    this._paused = true;\n    this._renderOneFrame = true;\n    this.exec();\n    this._renderOneFrame = false;\n};\n\n/**\n * current number of frames per second\n * @function getFPS\n * @memberof Patch\n * @instance\n * @return {Number} fps\n */\nPatch.prototype.getFPS = function ()\n{\n    console.log(\"deprecated getfps\");\n    return 0;\n};\n\n/**\n * returns true if patch is opened in editor/gui mode\n * @function isEditorMode\n * @memberof Patch\n * @instance\n * @return {Boolean} editor mode\n */\nPatch.prototype.isEditorMode = function ()\n{\n    return this.config.editorMode === true;\n};\n\n/**\n * pauses patch execution\n * @function pause\n * @memberof Patch\n * @instance\n */\nPatch.prototype.pause = function ()\n{\n    cancelAnimationFrame(this._animReq);\n    this.emitEvent(\"pause\");\n    this._animReq = null;\n    this._paused = true;\n    this.freeTimer.pause();\n};\n\n/**\n * resumes patch execution\n * @function resume\n * @memberof Patch\n * @instance\n */\nPatch.prototype.resume = function ()\n{\n    if (this._paused)\n    {\n        cancelAnimationFrame(this._animReq);\n        this._paused = false;\n        this.freeTimer.play();\n        this.emitEvent(\"resume\");\n        this.exec();\n    }\n};\n\n/**\n * set volume [0-1]\n * @function setVolume\n * @param {Number} volume\n * @memberof Patch\n * @instance\n */\nPatch.prototype.setVolume = function (v)\n{\n    this.config.masterVolume = v;\n    for (let i = 0; i < this._volumeListeners.length; i++) this._volumeListeners[i].onMasterVolumeChanged(v);\n};\n\n\n/**\n * get asset path\n * @function getAssetPath\n * @memberof Patch\n * @instance\n */\nPatch.prototype.getAssetPath = function (patchId = null)\n{\n    if (this.isEditorMode())\n    {\n        let id = patchId || gui.project()._id;\n        return \"/assets/\" + id + \"/\";\n    }\n    else if (document.location.href.indexOf(\"cables.gl\") > 0 || document.location.href.indexOf(\"cables.local\") > 0)\n    {\n        const parts = document.location.pathname.split(\"/\");\n        let id = patchId || parts[parts.length - 1];\n        return \"/assets/\" + id + \"/\";\n    }\n    else if (this.config.hasOwnProperty(\"assetPath\"))\n    {\n        return this.config.assetPath;\n    }\n    else\n    {\n        return \"assets/\";\n    }\n};\n\n/**\n * get js path\n * @function getJsPath\n * @memberof Patch\n * @instance\n */\nPatch.prototype.getJsPath = function ()\n{\n    if (this.config.hasOwnProperty(\"jsPath\"))\n    {\n        return this.config.jsPath;\n    }\n    else\n    {\n        return \"js/\";\n    }\n};\n\n/**\n * get url/filepath for a filename\n * this uses prefixAssetpath in exported patches\n * @function getFilePath\n * @memberof Patch\n * @instance\n * @param {String} filename\n * @return {String} url\n */\nPatch.prototype.getFilePath = function (filename)\n{\n    if (!filename) return filename;\n    filename = String(filename);\n    if (filename.indexOf(\"https:\") === 0 || filename.indexOf(\"http:\") === 0) return filename;\n    if (filename.indexOf(\"data:\") === 0) return filename;\n    if (filename.indexOf(\"file:\") === 0) return filename;\n\n    filename = filename.replace(\"//\", \"/\");\n    return this.config.prefixAssetPath + filename + (this.config.suffixAssetPath || \"\");\n};\n\nPatch.prototype.clear = function ()\n{\n    this.emitEvent(\"patchClearStart\");\n    this.cgl.TextureEffectMesh = null;\n    this.animFrameOps.length = 0;\n    this.timer = new _timer_js__WEBPACK_IMPORTED_MODULE_2__.Timer();\n    while (this.ops.length > 0) this.deleteOp(this.ops[0].id);\n\n    this._opIdCache = {};\n    this.emitEvent(\"patchClearEnd\");\n};\n\nPatch.getOpClass = function (objName)\n{\n    const parts = objName.split(\".\");\n    let opObj = null;\n\n    try\n    {\n        if (parts.length == 2) opObj = window[parts[0]][parts[1]];\n        else if (parts.length == 3) opObj = window[parts[0]][parts[1]][parts[2]];\n        else if (parts.length == 4) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]];\n        else if (parts.length == 5) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]];\n        else if (parts.length == 6) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]];\n        else if (parts.length == 7) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]];\n        else if (parts.length == 8) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]];\n        else if (parts.length == 9) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]];\n        else if (parts.length == 10) opObj = window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]][parts[9]];\n        return opObj;\n    }\n    catch (e)\n    {\n        return null;\n    }\n};\n\nPatch.prototype.createOp = function (identifier, id, opName = null)\n{\n    let op = null;\n    let objName = \"\";\n\n    try\n    {\n        if (!identifier)\n        {\n            console.error(\"createop identifier false\", identifier);\n            console.log((new Error()).stack);\n            return;\n        }\n        if (identifier.indexOf(\"Ops.\") === -1)\n        {\n            // this should be a uuid, not a namespace\n            // creating ops by id should be the default way from now on!\n            const opId = identifier;\n\n\n\n            if (CABLES.OPS[opId])\n            {\n                objName = CABLES.OPS[opId].objName;\n                op = new CABLES.OPS[opId].f(this, objName, id, opId);\n                op.opId = opId;\n            }\n            else\n            {\n                if (opName)\n                {\n                    identifier = opName;\n                    console.log(\"could not find op by id: \" + opId);\n                }\n                else\n                {\n                    throw new Error(\"could not find op by id: \" + opId);\n                }\n            }\n        }\n\n        if (!op)\n        {\n            // fallback: create by objname!\n            objName = identifier;\n            const parts = identifier.split(\".\");\n            const opObj = Patch.getOpClass(objName);\n\n            if (!opObj)\n            {\n                this.emitEvent(\"criticalError\", { \"title\": \"unknown op\" + objName, \"text\": \"unknown op: \" + objName });\n\n                this._log.error(\"unknown op: \" + objName);\n                throw new Error(\"unknown op: \" + objName);\n            }\n            else\n            {\n                if (parts.length == 2) op = new window[parts[0]][parts[1]](this, objName, id);\n                else if (parts.length == 3) op = new window[parts[0]][parts[1]][parts[2]](this, objName, id);\n                else if (parts.length == 4) op = new window[parts[0]][parts[1]][parts[2]][parts[3]](this, objName, id);\n                else if (parts.length == 5) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]](this, objName, id);\n                else if (parts.length == 6) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]](this, objName, id);\n                else if (parts.length == 7) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]](this, objName, id);\n                else if (parts.length == 8) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]](this, objName, id);\n                else if (parts.length == 9) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]](this, objName, id);\n                else if (parts.length == 10) op = new window[parts[0]][parts[1]][parts[2]][parts[3]][parts[4]][parts[5]][parts[6]][parts[7]][parts[8]][parts[9]](this, objName, id);\n                else console.log(\"parts.length\", parts.length);\n            }\n\n            if (op)\n            {\n                op.opId = null;\n                for (const i in CABLES.OPS)\n                {\n                    if (CABLES.OPS[i].objName == objName) op.opId = i;\n                }\n            }\n        }\n    }\n    catch (e)\n    {\n        this._crashedOps.push(objName);\n\n        this.emitEvent(\"exceptionOp\", e, objName, op);\n\n        if (!this.isEditorMode())\n        {\n            this._log.error(e);\n            this._log.error(\"[instancing error] \" + objName, e);\n\n            if (CABLES.api) CABLES.api.sendErrorReport(e);\n            this.exitError(\"INSTANCE_ERR\", \"Instancing Error 1\" + objName, e);\n            throw new Error(\"instancing error 1\" + objName);\n        }\n    }\n\n    if (op)\n    {\n        op._objName = objName;\n        op.patch = this;\n    }\n    else\n    {\n        this._log.log(\"no op was created!?\", identifier, id);\n    }\n    return op;\n};\n\n/**\n * create a new op in patch\n * @function addOp\n * @memberof Patch\n * @instance\n * @param {String} opIdentifier, uuid or name, e.g. Ops.Math.Sum\n * @param {Object} uiAttribs Attributes\n * @param {String} id\n * @param {boolean} fromDeserialize\n * @param {String} opName, e.g. Ops.Math.Sum\n * @example\n * // add invisible op\n * patch.addOp('Ops.Math.Sum', { showUiAttribs: false });\n */\nPatch.prototype.addOp = function (opIdentifier, uiAttribs, id, fromDeserialize, opName)\n{\n    const op = this.createOp(opIdentifier, id, opName);\n\n    if (op)\n    {\n        uiAttribs = uiAttribs || {};\n        if (uiAttribs.hasOwnProperty(\"errors\")) delete uiAttribs.errors;\n        if (uiAttribs.hasOwnProperty(\"error\")) delete uiAttribs.error;\n        uiAttribs.subPatch = uiAttribs.subPatch || 0;\n\n        op.setUiAttribs(uiAttribs);\n        if (op.onCreate) op.onCreate();\n\n        if (op.hasOwnProperty(\"onAnimFrame\")) this.addOnAnimFrame(op);\n        if (op.hasOwnProperty(\"onMasterVolumeChanged\")) this._volumeListeners.push(op);\n\n        if (this._opIdCache[op.id])\n        {\n            console.log(\"opid with id \" + op.id + \" already exists in patch!\");\n            this.deleteOp(op.id); // strange with subpatch ops: why is this needed, somehow ops get added twice ???.....\n            // return;\n        }\n\n        this.ops.push(op);\n        this._opIdCache[op.id] = op;\n\n        if (this._subPatchCacheAdd) this._subPatchCacheAdd(uiAttribs.subPatch, op);\n        this.emitEvent(\"onOpAdd\", op, fromDeserialize);\n\n        if (op.init) op.init();\n\n        op.emitEvent(\"init\", fromDeserialize);\n    }\n    else\n    {\n        this._log.error(\"addop: no op.....\");\n    }\n\n    return op;\n};\n\nPatch.prototype.addOnAnimFrame = function (op)\n{\n    for (let i = 0; i < this.animFrameOps.length; i++) if (this.animFrameOps[i] == op) { return; }\n\n    this.animFrameOps.push(op);\n};\n\nPatch.prototype.removeOnAnimFrame = function (op)\n{\n    for (let i = 0; i < this.animFrameOps.length; i++)\n    {\n        if (this.animFrameOps[i] == op)\n        {\n            this.animFrameOps.splice(i, 1);\n            return;\n        }\n    }\n};\n\nPatch.prototype.addOnAnimFrameCallback = function (cb)\n{\n    this.animFrameCallbacks.push(cb);\n};\n\nPatch.prototype.removeOnAnimCallback = function (cb)\n{\n    for (let i = 0; i < this.animFrameCallbacks.length; i++)\n    {\n        if (this.animFrameCallbacks[i] == cb)\n        {\n            this.animFrameCallbacks.splice(i, 1);\n            return;\n        }\n    }\n};\n\nPatch.prototype.deleteOp = function (opid, tryRelink, reloadingOp)\n{\n    let found = false;\n    for (const i in this.ops)\n    {\n        if (this.ops[i].id == opid)\n        {\n            const op = this.ops[i];\n            let reLinkP1 = null;\n            let reLinkP2 = null;\n\n            if (op)\n            {\n                found = true;\n                if (tryRelink)\n                {\n                    if (op.portsIn.length > 0 && op.portsIn[0].isLinked() && (op.portsOut.length > 0 && op.portsOut[0].isLinked()))\n                    {\n                        if (op.portsIn[0].getType() == op.portsOut[0].getType() && op.portsIn[0].links[0])\n                        {\n                            reLinkP1 = op.portsIn[0].links[0].getOtherPort(op.portsIn[0]);\n                            reLinkP2 = op.portsOut[0].links[0].getOtherPort(op.portsOut[0]);\n                        }\n                    }\n                }\n\n                const opToDelete = this.ops[i];\n                opToDelete.removeLinks();\n\n                if (this.onDelete)\n                {\n                    // todo: remove\n                    console.log(\"deprecated this.onDelete\", this.onDelete);\n                    this.onDelete(opToDelete);\n                }\n\n                this.ops.splice(i, 1);\n                opToDelete.emitEvent(\"delete\", opToDelete);\n                this.emitEvent(\"onOpDelete\", opToDelete, reloadingOp);\n\n                if (this.clearSubPatchCache) this.clearSubPatchCache(opToDelete.uiAttribs.subPatch);\n\n                if (opToDelete.onDelete) opToDelete.onDelete(reloadingOp);\n                opToDelete.cleanUp();\n\n                if (reLinkP1 !== null && reLinkP2 !== null)\n                {\n                    this.link(reLinkP1.op, reLinkP1.getName(), reLinkP2.op, reLinkP2.getName());\n                }\n\n                delete this._opIdCache[opid];\n                break;\n            }\n        }\n    }\n\n    if (!found) console.log(\"core patch deleteop: not found...\", opid);\n};\n\nPatch.prototype.getFrameNum = function ()\n{\n    return this._frameNum;\n};\n\nPatch.prototype.emitOnAnimFrameEvent = function (time, delta)\n{\n    time = time || this.timer.getTime();\n\n    for (let i = 0; i < this.animFrameCallbacks.length; ++i)\n        if (this.animFrameCallbacks[i])\n            this.animFrameCallbacks[i](time, this._frameNum, delta);\n\n    for (let i = 0; i < this.animFrameOps.length; ++i)\n        if (this.animFrameOps[i].onAnimFrame)\n            this.animFrameOps[i].onAnimFrame(time, this._frameNum, delta);\n};\n\nPatch.prototype.renderFrame = function (timestamp)\n{\n    // console.log(\"renderframe\", this._paused, this._frameNum);\n\n    this.timer.update();\n    this.freeTimer.update();\n    const time = this.timer.getTime();\n    const startTime = performance.now();\n    this.cgl.frameStartTime = this.timer.getTime();\n\n    const delta = timestamp - this._lastReqAnimTimeStamp || timestamp;\n\n    this.emitOnAnimFrameEvent(null, delta);\n\n    this.cgl.profileData.profileFrameDelta = delta;\n    this._lastReqAnimTimeStamp = timestamp;\n    this.cgl.profileData.profileOnAnimFrameOps = performance.now() - startTime;\n\n    this.emitEvent(\"onRenderFrame\", time);\n\n    this._frameNum++;\n    if (this._frameNum == 1)\n    {\n        if (this.config.onFirstFrameRendered) this.config.onFirstFrameRendered();\n    }\n};\n\nPatch.prototype.exec = function (timestamp)\n{\n    if (!this._renderOneFrame && (this._paused || this.aborted)) return;\n    this.emitEvent(\"reqAnimFrame\");\n    cancelAnimationFrame(this._animReq);\n\n    this.config.fpsLimit = this.config.fpsLimit || 0;\n    if (this.config.fpsLimit)\n    {\n        this._frameInterval = 1000 / this.config.fpsLimit;\n    }\n\n    const now = CABLES.now();\n    const frameDelta = now - this._frameNext;\n\n\n\n    if (this.isEditorMode())\n    {\n        if (!this._renderOneFrame)\n        {\n            if (now - this._lastFrameTime >= 500 && this._lastFrameTime !== 0 && !this._frameWasdelayed)\n            {\n                this._lastFrameTime = 0;\n                setTimeout(this.exec.bind(this), 500);\n                this.emitEvent(\"renderDelayStart\");\n                this._frameWasdelayed = true;\n                return;\n            }\n        }\n    }\n\n    if (this._renderOneFrame || this.config.fpsLimit === 0 || frameDelta > this._frameInterval || this._frameWasdelayed)\n    {\n        this.renderFrame(timestamp);\n\n        if (this._frameInterval) this._frameNext = now - (frameDelta % this._frameInterval);\n    }\n\n    if (this._frameWasdelayed)\n    {\n        this.emitEvent(\"renderDelayEnd\");\n        this._frameWasdelayed = false;\n    }\n\n    if (this._renderOneFrame)\n    {\n        if (this.onOneFrameRendered) this.onOneFrameRendered(); // todo remove everywhere and use propper event...\n        this.emitEvent(\"renderedOneFrame\");\n        this._renderOneFrame = false;\n    }\n\n\n    if (this.config.doRequestAnimation) this._animReq = this.cgl.canvas.ownerDocument.defaultView.requestAnimationFrame(this.exec.bind(this));\n};\n\n// Patch.prototype.linkPorts = function (port1, port2)\n// {\n//     this.link(port1.parent, port1.id, port2.parent, port2.id);\n// };\n\n/**\n * link two ops/ports\n * @function link\n * @memberof Patch\n * @instance\n * @param {Op} op1\n * @param {String} portName1\n * @param {Op} op2\n * @param {String} portName2\n */\nPatch.prototype.link = function (op1, port1Name, op2, port2Name, lowerCase, fromDeserialize)\n{\n    if (!op1)\n    {\n        console.warn(\"link: op1 is null \");\n        return;\n    }\n    if (!op2)\n    {\n        console.warn(\"link: op2 is null\");\n        return;\n    }\n\n    const port1 = op1.getPort(port1Name, lowerCase);\n    const port2 = op2.getPort(port2Name, lowerCase);\n\n    if (!port1)\n    {\n        console.warn(\"port1 not found! \" + port1Name + \"(\" + op1.objName + \")\");\n        return;\n    }\n\n    if (!port2)\n    {\n        console.warn(\"port2 not found! \" + port2Name + \" of \" + op2.name + \"(\" + op2.objName + \")\", op2);\n        return;\n    }\n\n    if (!port1.shouldLink(port1, port2) || !port2.shouldLink(port1, port2))\n    {\n        return false;\n    }\n\n    if (_core_link_js__WEBPACK_IMPORTED_MODULE_7__.Link.canLink(port1, port2))\n    {\n        const link = new _core_link_js__WEBPACK_IMPORTED_MODULE_7__.Link(this);\n        link.link(port1, port2);\n\n        this.emitEvent(\"onLink\", port1, port2, link, fromDeserialize);\n        return link;\n    }\n};\n\nPatch.prototype.serialize = function (options)\n{\n    const obj = {};\n\n    options = options || {};\n    obj.ops = [];\n    obj.settings = this.settings;\n    for (const i in this.ops)\n    {\n        const op = this.ops[i];\n        obj.ops.push(op.getSerialized());\n    }\n\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.cleanJson)(obj);\n\n    if (options.asObject) return obj;\n    return JSON.stringify(obj);\n};\n\nPatch.prototype.getOpsByRefId = function (refId)\n{\n    const perf = CABLES.UI.uiProfiler.start(\"[corepatchetend] getOpsByRefId\");\n    const refOps = [];\n    const ops = gui.corePatch().ops;\n    for (let i = 0; i < ops.length; i++)\n        if (ops[i].storage && ops[i].storage.ref == refId) refOps.push(ops[i]);\n    perf.finish();\n    return refOps;\n};\n\n\nPatch.prototype.getOpById = function (opid)\n{\n    return this._opIdCache[opid];\n    // this.timeNeededGetOpById = this.timeNeededGetOpById || 0;\n\n    // const startTime = performance.now();\n    // for (const i in this.ops)\n    // {\n    //     if (this.ops[i].id == opid)\n    //     {\n    //         this.timeNeededGetOpById += (performance.now() - startTime);\n    //         return this.ops[i];\n    //     }\n    // }\n};\n\n// Patch.prototype.getOpsById = function (opIds)\n// {\n//     const ops = [];\n//     for (const i in this.ops)\n//         for (let j = 0; j < opIds.length; j++)\n//             if (this.ops[i].id === opIds[j])\n//             {\n//                 ops.push(this.ops[i]);\n//                 break;\n//             }\n//     return ops;\n// };\n\nPatch.prototype.getOpsByName = function (name)\n{\n    // TODO: is this still needed ? unclear behaviour....\n    const arr = [];\n    for (const i in this.ops)\n        if (this.ops[i].name == name) arr.push(this.ops[i]);\n    return arr;\n};\n\nPatch.prototype.getOpsByObjName = function (name)\n{\n    const arr = [];\n    for (const i in this.ops)\n        if (this.ops[i].objName == name) arr.push(this.ops[i]);\n    return arr;\n};\n\nPatch.prototype.getOpsByOpId = function (opid)\n{\n    const arr = [];\n    for (const i in this.ops)\n        if (this.ops[i].opId == opid) arr.push(this.ops[i]);\n    return arr;\n};\n\nPatch.prototype.loadLib = function (which)\n{\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.ajaxSync)(\n        \"/ui/libs/\" + which + \".js\",\n        (err, res) =>\n        {\n            const se = document.createElement(\"script\");\n            se.type = \"text/javascript\";\n            se.text = res;\n            document.getElementsByTagName(\"head\")[0].appendChild(se);\n        },\n        \"GET\",\n    );\n    // open and send a synchronous request\n    // xhrObj.open('GET', '/ui/libs/'+which+'.js', false);\n    // xhrObj.send('');\n    // add the returned content to a newly created script tag\n};\n\n\nPatch.prototype.getSubPatchOp = function (patchId, objName)\n{\n    for (const i in this.ops)\n        if (this.ops[i].uiAttribs && this.ops[i].uiAttribs.subPatch == patchId && this.ops[i].objName == objName)\n            return this.ops[i];\n    return false;\n};\n\n// Patch.prototype.getSubPatchOuterOp = function (subPatchId) // remove !! moved to extend class\n// {\n//     const ops = this.ops;\n//     for (let i = 0; i < ops.length; i++)\n//     {\n//         const op = ops[i];\n//         if (op.isSubPatchOp() && op.patchId.get() == subPatchId) return op;\n//     }\n// };\n\n\n\n\n\nPatch.prototype._addLink = function (opinid, opoutid, inName, outName)\n{\n    this.link(this.getOpById(opinid), inName, this.getOpById(opoutid), outName, false, true);\n};\n\nPatch.prototype.deSerialize = function (obj, options)\n{\n    options = options || { \"genIds\": false, \"createRef\": false };\n    if (this.aborted) return;\n    const newOps = [];\n    const loadingId = this.loading.start(\"core\", \"deserialize\");\n\n    this.namespace = obj.namespace || \"\";\n    this.name = obj.name || \"\";\n\n    if (typeof obj === \"string\") obj = JSON.parse(obj);\n\n    this.settings = obj.settings;\n\n    this.emitEvent(\"patchLoadStart\");\n\n    if (window.logStartup)logStartup(\"add \" + obj.ops.length + \" ops... \");\n\n    const addedOps = [];\n    // add ops...\n    for (let iop = 0; iop < obj.ops.length; iop++)\n    {\n        const start = CABLES.now();\n        const opData = obj.ops[iop];\n        let op = null;\n\n        try\n        {\n            if (opData.opId) op = this.addOp(opData.opId, opData.uiAttribs, opData.id, true, opData.objName);\n            else op = this.addOp(opData.objName, opData.uiAttribs, opData.id, true);\n        }\n        catch (e)\n        {\n            console.log(\"[instancing error] op data:\", opData, e);\n            throw new Error(\"could not create op by id: <b>\" + (opData.objName || opData.opId) + \"</b> (\" + opData.id + \")\");\n        }\n\n        if (op)\n        {\n            addedOps.push(op);\n            if (options.genIds) op.id = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.shortId)();\n            op.portsInData = opData.portsIn;\n            op._origData = JSON.parse(JSON.stringify(opData));\n            op.storage = opData.storage;\n            // if (opData.hasOwnProperty(\"disabled\"))op.setEnabled(!opData.disabled);\n\n            for (const ipi in opData.portsIn)\n            {\n                const objPort = opData.portsIn[ipi];\n                if (objPort && objPort.hasOwnProperty(\"name\"))\n                {\n                    const port = op.getPort(objPort.name);\n\n                    if (port && (port.uiAttribs.display == \"bool\" || port.uiAttribs.type == \"bool\") && !isNaN(objPort.value)) objPort.value = objPort.value == true;\n                    if (port && objPort.value !== undefined && port.type != _constants_js__WEBPACK_IMPORTED_MODULE_8__.CONSTANTS.OP.OP_PORT_TYPE_TEXTURE) port.set(objPort.value);\n\n                    if (port) port.deSerializeSettings(objPort);\n                }\n            }\n\n            for (const ipo in opData.portsOut)\n            {\n                const objPort = opData.portsOut[ipo];\n                if (objPort && objPort.hasOwnProperty(\"name\"))\n                {\n                    const port2 = op.getPort(objPort.name);\n                    if (port2 && port2.type != _constants_js__WEBPACK_IMPORTED_MODULE_8__.CONSTANTS.OP.OP_PORT_TYPE_TEXTURE && objPort.hasOwnProperty(\"value\"))\n                        port2.set(obj.ops[iop].portsOut[ipo].value);\n\n                    if (port2 && objPort.expose) port2.setUiAttribs({ \"expose\": true });\n                }\n            }\n            newOps.push(op);\n        }\n\n        const timeused = Math.round(100 * (CABLES.now() - start)) / 100;\n        if (!this.silent && timeused > 5) console.log(\"long op init \", obj.ops[iop].objName, timeused);\n    }\n    if (window.logStartup)logStartup(\"add ops done\");\n\n    for (const i in this.ops)\n    {\n        if (this.ops[i].onLoadedValueSet)\n        {\n            this.ops[i].onLoadedValueSet(this.ops[i]._origData);\n            this.ops[i].onLoadedValueSet = null;\n            this.ops[i]._origData = null;\n        }\n        this.ops[i].emitEvent(\"loadedValueSet\");\n    }\n\n    if (window.logStartup)logStartup(\"creating links\");\n\n    if (options.opsCreated)options.opsCreated(addedOps);\n\n    // create links...\n    if (obj.ops)\n    {\n        for (let iop = 0; iop < obj.ops.length; iop++)\n        {\n            if (obj.ops[iop].portsIn)\n            {\n                for (let ipi2 = 0; ipi2 < obj.ops[iop].portsIn.length; ipi2++)\n                {\n                    if (obj.ops[iop].portsIn[ipi2] && obj.ops[iop].portsIn[ipi2].links)\n                    {\n                        for (let ili = 0; ili < obj.ops[iop].portsIn[ipi2].links.length; ili++)\n                        {\n                            let found = false;\n\n                            this._addLink(\n                                obj.ops[iop].portsIn[ipi2].links[ili].objIn,\n                                obj.ops[iop].portsIn[ipi2].links[ili].objOut,\n                                obj.ops[iop].portsIn[ipi2].links[ili].portIn,\n                                obj.ops[iop].portsIn[ipi2].links[ili].portOut);\n\n                            // const took = performance.now - startTime;\n                            // if (took > 100)console.log(obj().ops[iop].portsIn[ipi2].links[ili].objIn, obj.ops[iop].portsIn[ipi2].links[ili].objOut, took);\n                        }\n                    }\n                }\n            }\n            if (obj.ops[iop].portsOut)\n                for (let ipi2 = 0; ipi2 < obj.ops[iop].portsOut.length; ipi2++)\n                    if (obj.ops[iop].portsOut[ipi2] && obj.ops[iop].portsOut[ipi2].links)\n                    {\n                        for (let ili = 0; ili < obj.ops[iop].portsOut[ipi2].links.length; ili++)\n                        {\n                            if (obj.ops[iop].portsOut[ipi2].links[ili])\n                            {\n                                if (obj.ops[iop].portsOut[ipi2].links[ili].subOpRef)\n                                {\n                                    // lost link\n                                    const outOp = this.getOpById(obj.ops[iop].portsOut[ipi2].links[ili].objOut);\n                                    let dstOp = null;\n                                    let theSubPatch = 0;\n\n                                    for (let i = 0; i < this.ops.length; i++)\n                                    {\n                                        if (\n                                            this.ops[i].storage &&\n                                            this.ops[i].storage.ref == obj.ops[iop].portsOut[ipi2].links[ili].subOpRef &&\n                                            outOp.uiAttribs.subPatch == this.ops[i].uiAttribs.subPatch\n                                        )\n                                        {\n                                            theSubPatch = this.ops[i].patchId.get();\n                                            break;\n                                        }\n                                    }\n\n                                    for (let i = 0; i < this.ops.length; i++)\n                                    {\n                                        if (\n                                            this.ops[i].storage &&\n                                            this.ops[i].storage.ref == obj.ops[iop].portsOut[ipi2].links[ili].refOp &&\n                                            this.ops[i].uiAttribs.subPatch == theSubPatch)\n                                        {\n                                            dstOp = this.ops[i];\n                                            break;\n                                        }\n                                    }\n\n                                    if (!dstOp) this._log.warn(\"could not find op for lost link\");\n                                    else\n                                        this._addLink(\n                                            dstOp.id,\n                                            obj.ops[iop].portsOut[ipi2].links[ili].objOut,\n\n                                            obj.ops[iop].portsOut[ipi2].links[ili].portIn,\n                                            obj.ops[iop].portsOut[ipi2].links[ili].portOut);\n                                }\n                                else\n                                {\n                                    this._addLink(obj.ops[iop].portsOut[ipi2].links[ili].objIn, obj.ops[iop].portsOut[ipi2].links[ili].objOut, obj.ops[iop].portsOut[ipi2].links[ili].portIn, obj.ops[iop].portsOut[ipi2].links[ili].portOut);\n                                }\n                            }\n                        }\n                    }\n        }\n    }\n\n    if (window.logStartup)logStartup(\"calling ops onloaded\");\n\n    for (const i in this.ops)\n    {\n        if (this.ops[i].onLoaded)\n        {\n            // TODO: deprecate!!!\n            this.ops[i].onLoaded();\n            this.ops[i].onLoaded = null;\n        }\n    }\n\n    if (window.logStartup)logStartup(\"initializing ops...\");\n    for (const i in this.ops)\n    {\n        if (this.ops[i].init)\n        {\n            this.ops[i].init();\n            this.ops[i].init = null;\n        }\n    }\n\n    if (window.logStartup)logStartup(\"initializing vars...\");\n\n    if (this.config.variables)\n        for (const varName in this.config.variables)\n            this.setVarValue(varName, this.config.variables[varName]);\n\n    if (window.logStartup)logStartup(\"initializing var ports\");\n\n    for (const i in this.ops)\n    {\n        this.ops[i].initVarPorts();\n        delete this.ops[i].uiAttribs.pasted;\n    }\n\n    setTimeout(() => { this.loading.finished(loadingId); }, 100);\n\n    if (window.logStartup)logStartup(\"calling onPatchLoaded/patchLoadEnd\");\n\n    if (this.config.onPatchLoaded) this.config.onPatchLoaded(this);\n\n    this.deSerialized = true;\n    this.emitEvent(\"patchLoadEnd\", newOps, obj, options.genIds);\n};\n\nPatch.prototype.profile = function (enable)\n{\n    this.profiler = new _core_profiler_js__WEBPACK_IMPORTED_MODULE_9__.Profiler(this);\n    for (const i in this.ops)\n    {\n        this.ops[i].profile(enable);\n    }\n};\n\n// ----------------------\n\n/**\n * set variable value\n * @function setVariable\n * @memberof Patch\n * @instance\n * @param {String} name of variable\n * @param {Number|String|Boolean} value\n */\nPatch.prototype.setVariable = function (name, val)\n{\n    // if (this._variables.hasOwnProperty(name))\n    if (this._variables[name] !== undefined)\n    {\n        this._variables[name].setValue(val);\n    }\n    else\n    {\n        console.log(\"variable \" + name + \" not found!\");\n    }\n};\n\nPatch.prototype._sortVars = function ()\n{\n    if (!this.isEditorMode()) return;\n    const ordered = {};\n    Object.keys(this._variables).sort(\n        (a, b) =>\n        { return a.localeCompare(b, \"en\", { \"sensitivity\": \"base\" }); }\n    ).forEach((key) =>\n    {\n        ordered[key] = this._variables[key];\n    });\n    this._variables = ordered;\n};\n\n/**\n * has variable\n * @function hasVariable\n * @memberof Patch\n * @instance\n * @param {String} name of variable\n */\nPatch.prototype.hasVar = function (name)\n{\n    return this._variables[name] !== undefined;\n\n    // return this._variables.hasOwnProperty(name);\n};\n\n// used internally\nPatch.prototype.setVarValue = function (name, val, type)\n{\n    if (this.hasVar(name))\n    {\n        this._variables[name].setValue(val);\n    }\n    else\n    {\n        this._variables[name] = new _core_variable_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"](name, val, type);\n        this._sortVars();\n        this.emitEvent(\"variablesChanged\");\n    }\n    return this._variables[name];\n};\n// old?\nPatch.prototype.getVarValue = function (name, val)\n{\n    if (this._variables.hasOwnProperty(name)) return this._variables[name].getValue();\n};\n\n/**\n * @function getVar\n * @memberof Patch\n * @instance\n * @param {String} name\n * @return {Variable} variable\n */\nPatch.prototype.getVar = function (name)\n{\n    if (this._variables.hasOwnProperty(name)) return this._variables[name];\n};\n\n\nPatch.prototype.deleteVar = function (name)\n{\n    for (let i = 0; i < this.ops.length; i++)\n        for (let j = 0; j < this.ops[i].portsIn.length; j++)\n            if (this.ops[i].portsIn[j].getVariableName() == name)\n                this.ops[i].portsIn[j].setVariable(null);\n\n    delete this._variables[name];\n    this.emitEvent(\"variableDeleted\", name);\n    this.emitEvent(\"variablesChanged\");\n};\n\n/**\n * @function getVars\n * @memberof Patch\n * @instance\n * @return {Array<Variable>} variables\n * @function\n */\nPatch.prototype.getVars = function (t)\n{\n    if (t === undefined) return this._variables;\n\n    const vars = [];\n    if (t == CABLES.OP_PORT_TYPE_STRING) t = \"string\";\n    if (t == CABLES.OP_PORT_TYPE_VALUE) t = \"number\";\n    if (t == CABLES.OP_PORT_TYPE_ARRAY) t = \"array\";\n    if (t == CABLES.OP_PORT_TYPE_OBJECT) t = \"object\";\n\n    for (const i in this._variables)\n    {\n        if (!this._variables[i].type || this._variables[i].type == t) vars.push(this._variables[i]);\n    }\n    return vars;\n};\n\n/**\n * @function exitError\n * @memberof Patch\n * @instance\n * @description cancel patch execution and quit showing an errormessage\n * @function\n */\nPatch.prototype.exitError = function (errorId, errorMessage, ex)\n{\n    this.aborted = true;\n\n    if (this && this.config && this.config.onError)\n    {\n        this.config.onError(errorId, errorMessage);\n    }\n    else\n    {\n        if (!this.isEditorMode())\n        {\n            const newDiv = document.createElement(\"div\");\n\n            const rect = this.cgl.canvas.getBoundingClientRect();\n\n            newDiv.setAttribute(\"style\", \"position:absolute;border:5px solid red;padding:15px;background-color:black;color:white;font-family:monospace;\");\n            newDiv.style.top = rect.top + \"px\";\n            newDiv.style.left = rect.left + \"px\";\n            let str = \"cables - An error occured:<br/>\";\n            str += \"[\" + errorId + \"] - \" + errorMessage;\n            if (ex)str += \"<br/>Exception: \" + ex.message;\n            newDiv.innerHTML = str;\n\n            const pe = this.cgl.canvas.parentElement;\n\n            while (pe.hasChildNodes()) pe.removeChild(pe.lastChild);\n\n            document.body.appendChild(newDiv);\n        }\n    }\n};\n\n/**\n * @function preRenderOps\n * @memberof Patch\n * @instance\n * @description invoke pre rendering of ops\n * @function\n */\nPatch.prototype.preRenderOps = function ()\n{\n    this._log.log(\"prerendering...\");\n\n    for (let i = 0; i < this.ops.length; i++)\n    {\n        if (this.ops[i].preRender)\n        {\n            this.ops[i].preRender();\n            this._log.log(\"prerender \" + this.ops[i].objName);\n        }\n    }\n};\n\n/**\n * @function dispose\n * @memberof Patch\n * @instance\n * @description stop, dispose and cleanup patch\n */\nPatch.prototype.dispose = function ()\n{\n    this.pause();\n    this.clear();\n    this.cgl.dispose();\n};\n\nPatch.prototype.pushTriggerStack = function (p)\n{\n    this._triggerStack.push(p);\n};\n\nPatch.prototype.popTriggerStack = function ()\n{\n    this._triggerStack.pop();\n};\n\nPatch.prototype.printTriggerStack = function ()\n{\n    if (this._triggerStack.length == 0)\n    {\n        // console.log(\"stack length\", this._triggerStack.length); // eslint-disable-line\n        return;\n    }\n    console.groupCollapsed( // eslint-disable-line\n        \"trigger port stack \" + this._triggerStack[this._triggerStack.length - 1].op.name + \".\" + this._triggerStack[this._triggerStack.length - 1].name,\n    );\n\n    const rows = [];\n    for (let i = 0; i < this._triggerStack.length; i++)\n    {\n        rows.push(i + \". \" + this._triggerStack[i].op.name + \" \" + this._triggerStack[i].name);\n    }\n\n    console.table(rows); // eslint-disable-line\n    console.groupEnd(); // eslint-disable-line\n};\n\n/**\n * returns document object of the patch could be != global document object when opening canvas ina popout window\n * @function getDocument\n * @memberof Patch\n * @instance\n * @return {Object} document\n */\nPatch.prototype.getDocument = function ()\n{\n    return this.cgl.canvas.ownerDocument;\n};\n\nPatch.replaceOpIds = function (json, options)\n{\n    const opids = {};\n    for (const i in json.ops)\n    {\n        opids[json.ops[i].id] = json.ops[i];\n    }\n\n    for (const j in json.ops)\n    {\n        for (const k in json.ops[j].portsOut)\n        {\n            const links = json.ops[j].portsOut[k].links;\n            if (links)\n            {\n                let l = links.length;\n\n                while (l--)\n                {\n                    if (links[l] && (!opids[links[l].objIn] || !opids[links[l].objOut]))\n                    {\n                        if (!options.doNotUnlinkLostLinks)\n                        {\n                            links.splice(l, 1);\n                        }\n                        else\n                        {\n                            if (options.fixLostLinks)\n                            {\n                                // console.log(\"lost link...?\", links[l]);\n                                const op = gui.corePatch().getOpById(links[l].objIn);\n                                if (!op) console.log(\"op not found!\");\n                                else\n                                {\n                                    const outerOp = gui.patchView.getSubPatchOuterOp(op.uiAttribs.subPatch);\n                                    if (outerOp)\n                                    {\n                                        op.storage = op.storage || {};\n                                        op.storage.ref = op.storage.ref || CABLES.shortId();\n                                        links[l].refOp = op.storage.ref;\n                                        links[l].subOpRef = outerOp.storage.ref;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n\n    for (const i in json.ops)\n    {\n        const op = json.ops[i];\n        const oldId = op.id;\n        let newId = CABLES.shortId();\n\n        if (options.prefixHash) newId = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.prefixedHash)(options.prefixHash + oldId);\n\n        else if (options.prefixId) newId = options.prefixId + oldId;\n        else if (options.refAsId) // when saving json\n        {\n            if (op.storage && op.storage.ref)\n            {\n                newId = op.storage.ref;\n                delete op.storage.ref;\n            }\n            else\n            {\n                op.storage = op.storage || {};\n                op.storage.ref = newId = CABLES.shortId();\n            }\n        }\n\n        const newID = op.id = newId;\n\n        if (options.oldIdAsRef) // when loading json\n        {\n            op.storage = op.storage || {};\n            op.storage.ref = oldId;\n        }\n\n        for (const j in json.ops)\n        {\n            if (json.ops[j].portsIn)\n                for (const k in json.ops[j].portsIn)\n                {\n                    if (json.ops[j].portsIn[k].links)\n                    {\n                        let l = json.ops[j].portsIn[k].links.length;\n\n                        while (l--) if (json.ops[j].portsIn[k].links[l] === null) json.ops[j].portsIn[k].links.splice(l, 1);\n\n                        for (l in json.ops[j].portsIn[k].links)\n                        {\n                            if (json.ops[j].portsIn[k].links[l].objIn === oldId) json.ops[j].portsIn[k].links[l].objIn = newID;\n                            if (json.ops[j].portsIn[k].links[l].objOut === oldId) json.ops[j].portsIn[k].links[l].objOut = newID;\n                        }\n                    }\n                }\n\n            if (json.ops[j].portsOut)\n                for (const k in json.ops[j].portsOut)\n                {\n                    if (json.ops[j].portsOut[k].links)\n                    {\n                        let l = json.ops[j].portsOut[k].links.length;\n\n                        while (l--) if (json.ops[j].portsOut[k].links[l] === null) json.ops[j].portsOut[k].links.splice(l, 1);\n\n                        for (l in json.ops[j].portsOut[k].links)\n                        {\n                            if (json.ops[j].portsOut[k].links[l].objIn === oldId) json.ops[j].portsOut[k].links[l].objIn = newID;\n                            if (json.ops[j].portsOut[k].links[l].objOut === oldId) json.ops[j].portsOut[k].links[l].objOut = newID;\n                        }\n                    }\n                }\n        }\n    }\n\n    // set correct subpatch\n    const subpatchIds = [];\n    const fixedSubPatches = [];\n\n    for (let i = 0; i < json.ops.length; i++)\n    {\n        // if (CABLES.Op.isSubPatchOpName(json.ops[i].objName))\n        if (json.ops[i].storage && json.ops[i].storage.subPatchVer)\n        {\n            for (const k in json.ops[i].portsIn)\n            {\n                if (json.ops[i].portsIn[k].name === \"patchId\")\n                {\n                    let newId = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.shortId)();\n\n                    if (options.prefixHash) newId = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.prefixedHash)(options.prefixHash + json.ops[i].portsIn[k].value);\n\n                    const oldSubPatchId = json.ops[i].portsIn[k].value;\n                    const newSubPatchId = json.ops[i].portsIn[k].value = newId;\n\n                    subpatchIds.push(newSubPatchId);\n\n                    for (let j = 0; j < json.ops.length; j++)\n                    {\n                        // op has no uiAttribs in export, we don't care about subpatches in export though\n                        if (json.ops[j].uiAttribs)\n                        {\n                            if (json.ops[j].uiAttribs.subPatch === oldSubPatchId)\n                            {\n                                json.ops[j].uiAttribs.subPatch = newSubPatchId;\n                                fixedSubPatches.push(json.ops[j].id);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (const kk in json.ops)\n    {\n        let found = false;\n        for (let j = 0; j < fixedSubPatches.length; j++)\n        {\n            if (json.ops[kk].id === fixedSubPatches[j])\n            {\n                found = true;\n                break;\n            }\n        }\n        // op has no uiAttribs in export, we don't care about subpatches in export though\n        if (!found && json.ops[kk].uiAttribs && options.parentSubPatchId != null)\n            json.ops[kk].uiAttribs.subPatch = options.parentSubPatchId;\n    }\n\n    return json;\n};\n\n/**\n * remove an eventlistener\n * @instance\n * @function addEventListener\n * @param {String} name of event\n * @param {function} callback\n */\n\n/**\n * remove an eventlistener\n * @instance\n * @function removeEventListener\n * @param {String} name of event\n * @param {function} callback\n */\n\n/**\n * op added to patch event\n * @event onOpAdd\n *\n * @memberof Patch\n * @type {Object}\n * @property {Op} op new op\n */\n\n/**\n * op deleted from patch\n * @event onOpDelete\n * @memberof Patch\n * @type {Object}\n * @property {Op} op that will be deleted\n */\n\n/**\n * link event - two ports will be linked\n * @event onLink\n * @memberof Patch\n * @type {Object}\n * @property {Port} port1\n * @property {Port} port2\n */\n\n/**\n * unlink event - a link was deleted\n * @event onUnLink\n * @memberof Patch\n * @type {Object}\n */\n\n/**\n * variables has been changed / a variable has been added to the patch\n * @event variablesChanged\n * @memberof Patch\n * @type {Object}\n * @property {Port} port1\n * @property {Port} port2\n */\n\n/**\n * configuration object for loading a patch\n * @typedef {Object} PatchConfig\n * @hideconstructor\n * @property {String} [prefixAssetPath=''] prefix for path to assets\n * @property {String} [assetPath=''] path to assets\n * @property {String} [jsPath=''] path to javascript files\n * @property {String} [glCanvasId='glcanvas'] dom element id of canvas element\n * @property {Function} [onError=null] called when an error occurs\n * @property {Function} [onFinishedLoading=null] called when patch finished loading all assets\n * @property {Function} [onFirstFrameRendered=null] called when patch rendered it's first frame\n * @property {Boolean} [glCanvasResizeToWindow=false] resize canvas automatically to window size\n * @property {Boolean} [doRequestAnimation=true] do requestAnimationFrame set to false if you want to trigger exec() from outside (only do if you know what you are doing)\n * @property {Boolean} [clearCanvasColor=true] clear canvas in transparent color every frame\n * @property {Boolean} [clearCanvasDepth=true] clear depth every frame\n * @property {Boolean} [glValidateShader=true] enable/disable validation of shaders *\n * @property {Boolean} [silent=false]\n * @property {Number} [fpsLimit=0] 0 for maximum possible frames per second\n * @property {String} [glslPrecision='mediump'] default precision for glsl shader\n *\n */\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Patch);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX3BhdGNoLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY29yZV9wYXRjaC5qcz85ODc4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJjYWJsZXMtc2hhcmVkLWNsaWVudFwiO1xuaW1wb3J0IHsgRXZlbnRUYXJnZXQgfSBmcm9tIFwiLi9ldmVudHRhcmdldC5qc1wiO1xuaW1wb3J0IHsgYWpheCwgYWpheFN5bmMsIHByZWZpeGVkSGFzaCwgY2xlYW5Kc29uLCBzaG9ydElkIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IExvYWRpbmdTdGF0dXMgfSBmcm9tIFwiLi9sb2FkaW5nc3RhdHVzLmpzXCI7XG5pbXBvcnQgeyBJbnN0YW5jaW5nIH0gZnJvbSBcIi4vaW5zdGFuY2luZy5qc1wiO1xuaW1wb3J0IHsgVGltZXIgfSBmcm9tIFwiLi90aW1lci5qc1wiO1xuaW1wb3J0IHsgTGluayB9IGZyb20gXCIuL2NvcmVfbGluay5qc1wiO1xuaW1wb3J0IHsgUHJvZmlsZXIgfSBmcm9tIFwiLi9jb3JlX3Byb2ZpbGVyLmpzXCI7XG5pbXBvcnQgeyBDb250ZXh0IH0gZnJvbSBcIi4vY2dsL2NnbF9zdGF0ZS5qc1wiO1xuaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgUGF0Y2hWYXJpYWJsZSBmcm9tIFwiLi9jb3JlX3ZhcmlhYmxlLmpzXCI7XG5cblxuLyoqXG4gKiBQYXRjaCBjbGFzcywgY29udGFpbnMgYWxsIG9wZXJhdG9ycyx2YWx1ZXMsbGlua3MgZXRjLiBtYW5hZ2VzIGxvYWRpbmcgYW5kIHJ1bm5pbmcgb2YgdGhlIHdob2xlIHBhdGNoXG4gKlxuICogc2VlIHtAbGluayBQYXRjaENvbmZpZ31cbiAqXG4gKiBAZXh0ZXJuYWwgQ0FCTEVTXG4gKiBAbmFtZXNwYWNlIFBhdGNoXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1BhdGNoQ29uZmlnfSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICogQGNsYXNzXG4gKiBAZXhhbXBsZVxuICogQ0FCTEVTLnBhdGNoPW5ldyBDQUJMRVMuUGF0Y2goXG4gKiB7XG4gKiAgICAgcGF0Y2g6cFN0cixcbiAqICAgICBnbENhbnZhc0lkOidnbGNhbnZhcycsXG4gKiAgICAgZ2xDYW52YXNSZXNpemVUb1dpbmRvdzp0cnVlLFxuICogICAgIGNhbnZhczp7cG93ZXJQcmVmZXJlbmNlOlwiaGlnaC1wZXJmb3JtYW5jZVwifSxcbiAqICAgICBwcmVmaXhBc3NldFBhdGg6Jy9hc3NldHMvJyxcbiAqICAgICBwcmVmaXhKc1BhdGg6Jy9qcy8nLFxuICogICAgIG9uRXJyb3I6ZnVuY3Rpb24oZSl7Y29uc29sZS5sb2coZSk7fVxuICogICAgIGdsc2xQcmVjaXNpb246J2hpZ2hwJ1xuICogfSk7XG4gKi9cblxuY29uc3QgUGF0Y2ggPSBmdW5jdGlvbiAoY2ZnKVxue1xuICAgIEV2ZW50VGFyZ2V0LmFwcGx5KHRoaXMpO1xuXG4gICAgdGhpcy5fbG9nID0gbmV3IExvZ2dlcihcImNvcmVfcGF0Y2hcIik7XG4gICAgdGhpcy5vcHMgPSBbXTtcbiAgICB0aGlzLnNldHRpbmdzID0ge307XG4gICAgdGhpcy5jb25maWcgPSBjZmcgfHxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJnbENhbnZhc1Jlc2l6ZVRvV2luZG93XCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJwcmVmaXhBc3NldFBhdGhcIjogXCJcIixcbiAgICAgICAgICAgIFwicHJlZml4SnNQYXRoXCI6IFwiXCIsXG4gICAgICAgICAgICBcInNpbGVudFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJvbkVycm9yXCI6IG51bGwsXG4gICAgICAgICAgICBcIm9uRmluaXNoZWRMb2FkaW5nXCI6IG51bGwsXG4gICAgICAgICAgICBcIm9uRmlyc3RGcmFtZVJlbmRlcmVkXCI6IG51bGwsXG4gICAgICAgICAgICBcIm9uUGF0Y2hMb2FkZWRcIjogbnVsbCxcbiAgICAgICAgICAgIFwiZnBzTGltaXRcIjogMCxcbiAgICAgICAgfTtcbiAgICB0aGlzLnRpbWVyID0gbmV3IFRpbWVyKCk7XG4gICAgdGhpcy5mcmVlVGltZXIgPSBuZXcgVGltZXIoKTtcbiAgICB0aGlzLmFuaW1GcmFtZU9wcyA9IFtdO1xuICAgIHRoaXMuYW5pbUZyYW1lQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5ndWkgPSBmYWxzZTtcbiAgICBDQUJMRVMubG9nU2lsZW50ID0gdGhpcy5zaWxlbnQgPSB0cnVlO1xuICAgIHRoaXMucHJvZmlsZXIgPSBudWxsO1xuICAgIHRoaXMuYWJvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NyYXNoZWRPcHMgPSBbXTtcbiAgICB0aGlzLl9yZW5kZXJPbmVGcmFtZSA9IGZhbHNlO1xuICAgIHRoaXMuX2FuaW1SZXEgPSBudWxsO1xuICAgIHRoaXMuX29wSWRDYWNoZSA9IHt9O1xuICAgIHRoaXMuX3RyaWdnZXJTdGFjayA9IFtdO1xuICAgIHRoaXMuc3RvcmVPYmpOYW1lcyA9IGZhbHNlOyAvLyByZW1vdmUgYWZ0ZXIgbWF5IHJlbGVhc2VcblxuICAgIHRoaXMubG9hZGluZyA9IG5ldyBMb2FkaW5nU3RhdHVzKHRoaXMpO1xuXG4gICAgdGhpcy5fdm9sdW1lTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fZnJhbWVOdW0gPSAwO1xuICAgIHRoaXMuaW5zdGFuY2luZyA9IG5ldyBJbnN0YW5jaW5nKCk7XG4gICAgdGhpcy5vbk9uZUZyYW1lUmVuZGVyZWQgPSBudWxsO1xuICAgIHRoaXMubmFtZWRUcmlnZ2VycyA9IHt9O1xuXG4gICAgdGhpcy5fb3JpZ0RhdGEgPSBudWxsO1xuICAgIHRoaXMuX2ZyYW1lTmV4dCA9IDA7XG4gICAgdGhpcy5fZnJhbWVJbnRlcnZhbCA9IDA7XG4gICAgdGhpcy5fbGFzdEZyYW1lVGltZSA9IDA7XG4gICAgdGhpcy5fZnJhbWVXYXNkZWxheWVkID0gdHJ1ZTtcbiAgICB0aGlzLmZyYW1lU3RvcmUgPSB7fTtcbiAgICB0aGlzLmRlU2VyaWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xhc3RSZXFBbmltVGltZVN0YW1wID0gMDtcblxuICAgIHRoaXMuY2dDYW52YXMgPSBudWxsO1xuXG4gICAgaWYgKCEoZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXM7IH0oKSkpIGNvbnNvbGUubG9nKFwibm90IGluIHN0cmljdCBtb2RlOiBjb3JlIHBhdGNoXCIpO1xuXG4gICAgdGhpcy5faXNMb2NhbCA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWYuaW5kZXhPZihcImZpbGU6XCIpID09PSAwO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmhhc093blByb3BlcnR5KFwic2lsZW50XCIpKSB0aGlzLnNpbGVudCA9IENBQkxFUy5sb2dTaWxlbnQgPSB0aGlzLmNvbmZpZy5zaWxlbnQ7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5oYXNPd25Qcm9wZXJ0eShcImRvUmVxdWVzdEFuaW1hdGlvblwiKSkgdGhpcy5jb25maWcuZG9SZXF1ZXN0QW5pbWF0aW9uID0gdHJ1ZTtcblxuICAgIGlmICghdGhpcy5jb25maWcucHJlZml4QXNzZXRQYXRoKSB0aGlzLmNvbmZpZy5wcmVmaXhBc3NldFBhdGggPSBcIlwiO1xuICAgIGlmICghdGhpcy5jb25maWcucHJlZml4SnNQYXRoKSB0aGlzLmNvbmZpZy5wcmVmaXhKc1BhdGggPSBcIlwiO1xuICAgIGlmICghdGhpcy5jb25maWcubWFzdGVyVm9sdW1lKSB0aGlzLmNvbmZpZy5tYXN0ZXJWb2x1bWUgPSAxLjA7XG5cbiAgICB0aGlzLl92YXJpYWJsZXMgPSB7fTtcbiAgICB0aGlzLl92YXJpYWJsZUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMudmFycyA9IHt9O1xuICAgIGlmIChjZmcgJiYgY2ZnLnZhcnMpIHRoaXMudmFycyA9IGNmZy52YXJzOyAvLyB2YXJzIGlzIG9sZCFcblxuICAgIHRoaXMuY2dsID0gbmV3IENvbnRleHQodGhpcyk7XG4gICAgdGhpcy5jZ3AgPSBudWxsO1xuXG4gICAgdGhpcy5fc3VicGF0Y2hPcENhY2hlID0ge307XG5cbiAgICB0aGlzLmNnbC5zZXRDYW52YXModGhpcy5jb25maWcuZ2xDYW52YXNJZCB8fCB0aGlzLmNvbmZpZy5nbENhbnZhcyB8fCBcImdsY2FudmFzXCIpO1xuICAgIGlmICh0aGlzLmNvbmZpZy5nbENhbnZhc1Jlc2l6ZVRvV2luZG93ID09PSB0cnVlKSB0aGlzLmNnbC5zZXRBdXRvUmVzaXplKFwid2luZG93XCIpO1xuICAgIGlmICh0aGlzLmNvbmZpZy5nbENhbnZhc1Jlc2l6ZVRvUGFyZW50ID09PSB0cnVlKSB0aGlzLmNnbC5zZXRBdXRvUmVzaXplKFwicGFyZW50XCIpO1xuICAgIHRoaXMubG9hZGluZy5zZXRPbkZpbmlzaGVkTG9hZGluZyh0aGlzLmNvbmZpZy5vbkZpbmlzaGVkTG9hZGluZyk7XG5cbiAgICBpZiAodGhpcy5jZ2wuYWJvcnRlZCkgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5jZ2wuc2lsZW50KSB0aGlzLnNpbGVudCA9IHRydWU7XG5cbiAgICB0aGlzLmZyZWVUaW1lci5wbGF5KCk7XG4gICAgdGhpcy5leGVjKCk7XG5cbiAgICBpZiAoIXRoaXMuYWJvcnRlZClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5wYXRjaClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5kZVNlcmlhbGl6ZSh0aGlzLmNvbmZpZy5wYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb25maWcucGF0Y2hGaWxlKVxuICAgICAgICB7XG4gICAgICAgICAgICBhamF4KFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnBhdGNoRmlsZSxcbiAgICAgICAgICAgICAgICAoZXJyLCBfZGF0YSkgPT5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKF9kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihcImVyclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwiZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihcImRhdGFcIiwgZGF0YS5tc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVTZXJpYWxpemUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVyLnBsYXkoKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcIm1hZGUgd2l0aCBodHRwczovL2NhYmxlcy5nbFwiKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufTtcblxuUGF0Y2gucHJvdG90eXBlLmlzUGxheWluZyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuICF0aGlzLl9wYXVzZWQ7XG59O1xuXG5QYXRjaC5wcm90b3R5cGUuaXNSZW5kZXJpbmdPbmVGcmFtZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlck9uZUZyYW1lO1xufTtcblxuXG5QYXRjaC5wcm90b3R5cGUucmVuZGVyT25lRnJhbWUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5fcmVuZGVyT25lRnJhbWUgPSB0cnVlO1xuICAgIHRoaXMuZXhlYygpO1xuICAgIHRoaXMuX3JlbmRlck9uZUZyYW1lID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIGN1cnJlbnQgbnVtYmVyIG9mIGZyYW1lcyBwZXIgc2Vjb25kXG4gKiBAZnVuY3Rpb24gZ2V0RlBTXG4gKiBAbWVtYmVyb2YgUGF0Y2hcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybiB7TnVtYmVyfSBmcHNcbiAqL1xuUGF0Y2gucHJvdG90eXBlLmdldEZQUyA9IGZ1bmN0aW9uICgpXG57XG4gICAgY29uc29sZS5sb2coXCJkZXByZWNhdGVkIGdldGZwc1wiKTtcbiAgICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogcmV0dXJucyB0cnVlIGlmIHBhdGNoIGlzIG9wZW5lZCBpbiBlZGl0b3IvZ3VpIG1vZGVcbiAqIEBmdW5jdGlvbiBpc0VkaXRvck1vZGVcbiAqIEBtZW1iZXJvZiBQYXRjaFxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlZGl0b3IgbW9kZVxuICovXG5QYXRjaC5wcm90b3R5cGUuaXNFZGl0b3JNb2RlID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZWRpdG9yTW9kZSA9PT0gdHJ1ZTtcbn07XG5cbi8qKlxuICogcGF1c2VzIHBhdGNoIGV4ZWN1dGlvblxuICogQGZ1bmN0aW9uIHBhdXNlXG4gKiBAbWVtYmVyb2YgUGF0Y2hcbiAqIEBpbnN0YW5jZVxuICovXG5QYXRjaC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKVxue1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1SZXEpO1xuICAgIHRoaXMuZW1pdEV2ZW50KFwicGF1c2VcIik7XG4gICAgdGhpcy5fYW5pbVJlcSA9IG51bGw7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmZyZWVUaW1lci5wYXVzZSgpO1xufTtcblxuLyoqXG4gKiByZXN1bWVzIHBhdGNoIGV4ZWN1dGlvblxuICogQGZ1bmN0aW9uIHJlc3VtZVxuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAaW5zdGFuY2VcbiAqL1xuUGF0Y2gucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX3BhdXNlZClcbiAgICB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1SZXEpO1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mcmVlVGltZXIucGxheSgpO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcInJlc3VtZVwiKTtcbiAgICAgICAgdGhpcy5leGVjKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBzZXQgdm9sdW1lIFswLTFdXG4gKiBAZnVuY3Rpb24gc2V0Vm9sdW1lXG4gKiBAcGFyYW0ge051bWJlcn0gdm9sdW1lXG4gKiBAbWVtYmVyb2YgUGF0Y2hcbiAqIEBpbnN0YW5jZVxuICovXG5QYXRjaC5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHYpXG57XG4gICAgdGhpcy5jb25maWcubWFzdGVyVm9sdW1lID0gdjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3ZvbHVtZUxpc3RlbmVycy5sZW5ndGg7IGkrKykgdGhpcy5fdm9sdW1lTGlzdGVuZXJzW2ldLm9uTWFzdGVyVm9sdW1lQ2hhbmdlZCh2KTtcbn07XG5cblxuLyoqXG4gKiBnZXQgYXNzZXQgcGF0aFxuICogQGZ1bmN0aW9uIGdldEFzc2V0UGF0aFxuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAaW5zdGFuY2VcbiAqL1xuUGF0Y2gucHJvdG90eXBlLmdldEFzc2V0UGF0aCA9IGZ1bmN0aW9uIChwYXRjaElkID0gbnVsbClcbntcbiAgICBpZiAodGhpcy5pc0VkaXRvck1vZGUoKSlcbiAgICB7XG4gICAgICAgIGxldCBpZCA9IHBhdGNoSWQgfHwgZ3VpLnByb2plY3QoKS5faWQ7XG4gICAgICAgIHJldHVybiBcIi9hc3NldHMvXCIgKyBpZCArIFwiL1wiO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb2N1bWVudC5sb2NhdGlvbi5ocmVmLmluZGV4T2YoXCJjYWJsZXMuZ2xcIikgPiAwIHx8IGRvY3VtZW50LmxvY2F0aW9uLmhyZWYuaW5kZXhPZihcImNhYmxlcy5sb2NhbFwiKSA+IDApXG4gICAge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGRvY3VtZW50LmxvY2F0aW9uLnBhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgbGV0IGlkID0gcGF0Y2hJZCB8fCBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIFwiL2Fzc2V0cy9cIiArIGlkICsgXCIvXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuY29uZmlnLmhhc093blByb3BlcnR5KFwiYXNzZXRQYXRoXCIpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmFzc2V0UGF0aDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIFwiYXNzZXRzL1wiO1xuICAgIH1cbn07XG5cbi8qKlxuICogZ2V0IGpzIHBhdGhcbiAqIEBmdW5jdGlvbiBnZXRKc1BhdGhcbiAqIEBtZW1iZXJvZiBQYXRjaFxuICogQGluc3RhbmNlXG4gKi9cblBhdGNoLnByb3RvdHlwZS5nZXRKc1BhdGggPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLmNvbmZpZy5oYXNPd25Qcm9wZXJ0eShcImpzUGF0aFwiKSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5qc1BhdGg7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJldHVybiBcImpzL1wiO1xuICAgIH1cbn07XG5cbi8qKlxuICogZ2V0IHVybC9maWxlcGF0aCBmb3IgYSBmaWxlbmFtZVxuICogdGhpcyB1c2VzIHByZWZpeEFzc2V0cGF0aCBpbiBleHBvcnRlZCBwYXRjaGVzXG4gKiBAZnVuY3Rpb24gZ2V0RmlsZVBhdGhcbiAqIEBtZW1iZXJvZiBQYXRjaFxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gdXJsXG4gKi9cblBhdGNoLnByb3RvdHlwZS5nZXRGaWxlUGF0aCA9IGZ1bmN0aW9uIChmaWxlbmFtZSlcbntcbiAgICBpZiAoIWZpbGVuYW1lKSByZXR1cm4gZmlsZW5hbWU7XG4gICAgZmlsZW5hbWUgPSBTdHJpbmcoZmlsZW5hbWUpO1xuICAgIGlmIChmaWxlbmFtZS5pbmRleE9mKFwiaHR0cHM6XCIpID09PSAwIHx8IGZpbGVuYW1lLmluZGV4T2YoXCJodHRwOlwiKSA9PT0gMCkgcmV0dXJuIGZpbGVuYW1lO1xuICAgIGlmIChmaWxlbmFtZS5pbmRleE9mKFwiZGF0YTpcIikgPT09IDApIHJldHVybiBmaWxlbmFtZTtcbiAgICBpZiAoZmlsZW5hbWUuaW5kZXhPZihcImZpbGU6XCIpID09PSAwKSByZXR1cm4gZmlsZW5hbWU7XG5cbiAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnJlcGxhY2UoXCIvL1wiLCBcIi9cIik7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnByZWZpeEFzc2V0UGF0aCArIGZpbGVuYW1lICsgKHRoaXMuY29uZmlnLnN1ZmZpeEFzc2V0UGF0aCB8fCBcIlwiKTtcbn07XG5cblBhdGNoLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5lbWl0RXZlbnQoXCJwYXRjaENsZWFyU3RhcnRcIik7XG4gICAgdGhpcy5jZ2wuVGV4dHVyZUVmZmVjdE1lc2ggPSBudWxsO1xuICAgIHRoaXMuYW5pbUZyYW1lT3BzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy50aW1lciA9IG5ldyBUaW1lcigpO1xuICAgIHdoaWxlICh0aGlzLm9wcy5sZW5ndGggPiAwKSB0aGlzLmRlbGV0ZU9wKHRoaXMub3BzWzBdLmlkKTtcblxuICAgIHRoaXMuX29wSWRDYWNoZSA9IHt9O1xuICAgIHRoaXMuZW1pdEV2ZW50KFwicGF0Y2hDbGVhckVuZFwiKTtcbn07XG5cblBhdGNoLmdldE9wQ2xhc3MgPSBmdW5jdGlvbiAob2JqTmFtZSlcbntcbiAgICBjb25zdCBwYXJ0cyA9IG9iak5hbWUuc3BsaXQoXCIuXCIpO1xuICAgIGxldCBvcE9iaiA9IG51bGw7XG5cbiAgICB0cnlcbiAgICB7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMikgb3BPYmogPSB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXTtcbiAgICAgICAgZWxzZSBpZiAocGFydHMubGVuZ3RoID09IDMpIG9wT2JqID0gd2luZG93W3BhcnRzWzBdXVtwYXJ0c1sxXV1bcGFydHNbMl1dO1xuICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gNCkgb3BPYmogPSB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV1bcGFydHNbM11dO1xuICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gNSkgb3BPYmogPSB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV1bcGFydHNbM11dW3BhcnRzWzRdXTtcbiAgICAgICAgZWxzZSBpZiAocGFydHMubGVuZ3RoID09IDYpIG9wT2JqID0gd2luZG93W3BhcnRzWzBdXVtwYXJ0c1sxXV1bcGFydHNbMl1dW3BhcnRzWzNdXVtwYXJ0c1s0XV1bcGFydHNbNV1dO1xuICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gNykgb3BPYmogPSB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV1bcGFydHNbM11dW3BhcnRzWzRdXVtwYXJ0c1s1XV1bcGFydHNbNl1dO1xuICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gOCkgb3BPYmogPSB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV1bcGFydHNbM11dW3BhcnRzWzRdXVtwYXJ0c1s1XV1bcGFydHNbNl1dW3BhcnRzWzddXTtcbiAgICAgICAgZWxzZSBpZiAocGFydHMubGVuZ3RoID09IDkpIG9wT2JqID0gd2luZG93W3BhcnRzWzBdXVtwYXJ0c1sxXV1bcGFydHNbMl1dW3BhcnRzWzNdXVtwYXJ0c1s0XV1bcGFydHNbNV1dW3BhcnRzWzZdXVtwYXJ0c1s3XV1bcGFydHNbOF1dO1xuICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gMTApIG9wT2JqID0gd2luZG93W3BhcnRzWzBdXVtwYXJ0c1sxXV1bcGFydHNbMl1dW3BhcnRzWzNdXVtwYXJ0c1s0XV1bcGFydHNbNV1dW3BhcnRzWzZdXVtwYXJ0c1s3XV1bcGFydHNbOF1dW3BhcnRzWzldXTtcbiAgICAgICAgcmV0dXJuIG9wT2JqO1xuICAgIH1cbiAgICBjYXRjaCAoZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cblBhdGNoLnByb3RvdHlwZS5jcmVhdGVPcCA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCBpZCwgb3BOYW1lID0gbnVsbClcbntcbiAgICBsZXQgb3AgPSBudWxsO1xuICAgIGxldCBvYmpOYW1lID0gXCJcIjtcblxuICAgIHRyeVxuICAgIHtcbiAgICAgICAgaWYgKCFpZGVudGlmaWVyKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiY3JlYXRlb3AgaWRlbnRpZmllciBmYWxzZVwiLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZGVudGlmaWVyLmluZGV4T2YoXCJPcHMuXCIpID09PSAtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gdGhpcyBzaG91bGQgYmUgYSB1dWlkLCBub3QgYSBuYW1lc3BhY2VcbiAgICAgICAgICAgIC8vIGNyZWF0aW5nIG9wcyBieSBpZCBzaG91bGQgYmUgdGhlIGRlZmF1bHQgd2F5IGZyb20gbm93IG9uIVxuICAgICAgICAgICAgY29uc3Qgb3BJZCA9IGlkZW50aWZpZXI7XG5cblxuXG4gICAgICAgICAgICBpZiAoQ0FCTEVTLk9QU1tvcElkXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvYmpOYW1lID0gQ0FCTEVTLk9QU1tvcElkXS5vYmpOYW1lO1xuICAgICAgICAgICAgICAgIG9wID0gbmV3IENBQkxFUy5PUFNbb3BJZF0uZih0aGlzLCBvYmpOYW1lLCBpZCwgb3BJZCk7XG4gICAgICAgICAgICAgICAgb3Aub3BJZCA9IG9wSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKG9wTmFtZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBvcE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY291bGQgbm90IGZpbmQgb3AgYnkgaWQ6IFwiICsgb3BJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkIG5vdCBmaW5kIG9wIGJ5IGlkOiBcIiArIG9wSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3ApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrOiBjcmVhdGUgYnkgb2JqbmFtZSFcbiAgICAgICAgICAgIG9iak5hbWUgPSBpZGVudGlmaWVyO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBpZGVudGlmaWVyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgIGNvbnN0IG9wT2JqID0gUGF0Y2guZ2V0T3BDbGFzcyhvYmpOYW1lKTtcblxuICAgICAgICAgICAgaWYgKCFvcE9iailcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcImNyaXRpY2FsRXJyb3JcIiwgeyBcInRpdGxlXCI6IFwidW5rbm93biBvcFwiICsgb2JqTmFtZSwgXCJ0ZXh0XCI6IFwidW5rbm93biBvcDogXCIgKyBvYmpOYW1lIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmVycm9yKFwidW5rbm93biBvcDogXCIgKyBvYmpOYW1lKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIG9wOiBcIiArIG9iak5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMikgb3AgPSBuZXcgd2luZG93W3BhcnRzWzBdXVtwYXJ0c1sxXV0odGhpcywgb2JqTmFtZSwgaWQpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PSAzKSBvcCA9IG5ldyB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV0odGhpcywgb2JqTmFtZSwgaWQpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PSA0KSBvcCA9IG5ldyB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV1bcGFydHNbM11dKHRoaXMsIG9iak5hbWUsIGlkKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gNSkgb3AgPSBuZXcgd2luZG93W3BhcnRzWzBdXVtwYXJ0c1sxXV1bcGFydHNbMl1dW3BhcnRzWzNdXVtwYXJ0c1s0XV0odGhpcywgb2JqTmFtZSwgaWQpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PSA2KSBvcCA9IG5ldyB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV1bcGFydHNbM11dW3BhcnRzWzRdXVtwYXJ0c1s1XV0odGhpcywgb2JqTmFtZSwgaWQpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PSA3KSBvcCA9IG5ldyB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV1bcGFydHNbM11dW3BhcnRzWzRdXVtwYXJ0c1s1XV1bcGFydHNbNl1dKHRoaXMsIG9iak5hbWUsIGlkKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gOCkgb3AgPSBuZXcgd2luZG93W3BhcnRzWzBdXVtwYXJ0c1sxXV1bcGFydHNbMl1dW3BhcnRzWzNdXVtwYXJ0c1s0XV1bcGFydHNbNV1dW3BhcnRzWzZdXVtwYXJ0c1s3XV0odGhpcywgb2JqTmFtZSwgaWQpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PSA5KSBvcCA9IG5ldyB3aW5kb3dbcGFydHNbMF1dW3BhcnRzWzFdXVtwYXJ0c1syXV1bcGFydHNbM11dW3BhcnRzWzRdXVtwYXJ0c1s1XV1bcGFydHNbNl1dW3BhcnRzWzddXVtwYXJ0c1s4XV0odGhpcywgb2JqTmFtZSwgaWQpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PSAxMCkgb3AgPSBuZXcgd2luZG93W3BhcnRzWzBdXVtwYXJ0c1sxXV1bcGFydHNbMl1dW3BhcnRzWzNdXVtwYXJ0c1s0XV1bcGFydHNbNV1dW3BhcnRzWzZdXVtwYXJ0c1s3XV1bcGFydHNbOF1dW3BhcnRzWzldXSh0aGlzLCBvYmpOYW1lLCBpZCk7XG4gICAgICAgICAgICAgICAgZWxzZSBjb25zb2xlLmxvZyhcInBhcnRzLmxlbmd0aFwiLCBwYXJ0cy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3ApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3Aub3BJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpIGluIENBQkxFUy5PUFMpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQ0FCTEVTLk9QU1tpXS5vYmpOYW1lID09IG9iak5hbWUpIG9wLm9wSWQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2NyYXNoZWRPcHMucHVzaChvYmpOYW1lKTtcblxuICAgICAgICB0aGlzLmVtaXRFdmVudChcImV4Y2VwdGlvbk9wXCIsIGUsIG9iak5hbWUsIG9wKTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNFZGl0b3JNb2RlKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihlKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihcIltpbnN0YW5jaW5nIGVycm9yXSBcIiArIG9iak5hbWUsIGUpO1xuXG4gICAgICAgICAgICBpZiAoQ0FCTEVTLmFwaSkgQ0FCTEVTLmFwaS5zZW5kRXJyb3JSZXBvcnQoZSk7XG4gICAgICAgICAgICB0aGlzLmV4aXRFcnJvcihcIklOU1RBTkNFX0VSUlwiLCBcIkluc3RhbmNpbmcgRXJyb3IgMVwiICsgb2JqTmFtZSwgZSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnN0YW5jaW5nIGVycm9yIDFcIiArIG9iak5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wKVxuICAgIHtcbiAgICAgICAgb3AuX29iak5hbWUgPSBvYmpOYW1lO1xuICAgICAgICBvcC5wYXRjaCA9IHRoaXM7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZy5sb2coXCJubyBvcCB3YXMgY3JlYXRlZCE/XCIsIGlkZW50aWZpZXIsIGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wO1xufTtcblxuLyoqXG4gKiBjcmVhdGUgYSBuZXcgb3AgaW4gcGF0Y2hcbiAqIEBmdW5jdGlvbiBhZGRPcFxuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcElkZW50aWZpZXIsIHV1aWQgb3IgbmFtZSwgZS5nLiBPcHMuTWF0aC5TdW1cbiAqIEBwYXJhbSB7T2JqZWN0fSB1aUF0dHJpYnMgQXR0cmlidXRlc1xuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZyb21EZXNlcmlhbGl6ZVxuICogQHBhcmFtIHtTdHJpbmd9IG9wTmFtZSwgZS5nLiBPcHMuTWF0aC5TdW1cbiAqIEBleGFtcGxlXG4gKiAvLyBhZGQgaW52aXNpYmxlIG9wXG4gKiBwYXRjaC5hZGRPcCgnT3BzLk1hdGguU3VtJywgeyBzaG93VWlBdHRyaWJzOiBmYWxzZSB9KTtcbiAqL1xuUGF0Y2gucHJvdG90eXBlLmFkZE9wID0gZnVuY3Rpb24gKG9wSWRlbnRpZmllciwgdWlBdHRyaWJzLCBpZCwgZnJvbURlc2VyaWFsaXplLCBvcE5hbWUpXG57XG4gICAgY29uc3Qgb3AgPSB0aGlzLmNyZWF0ZU9wKG9wSWRlbnRpZmllciwgaWQsIG9wTmFtZSk7XG5cbiAgICBpZiAob3ApXG4gICAge1xuICAgICAgICB1aUF0dHJpYnMgPSB1aUF0dHJpYnMgfHwge307XG4gICAgICAgIGlmICh1aUF0dHJpYnMuaGFzT3duUHJvcGVydHkoXCJlcnJvcnNcIikpIGRlbGV0ZSB1aUF0dHJpYnMuZXJyb3JzO1xuICAgICAgICBpZiAodWlBdHRyaWJzLmhhc093blByb3BlcnR5KFwiZXJyb3JcIikpIGRlbGV0ZSB1aUF0dHJpYnMuZXJyb3I7XG4gICAgICAgIHVpQXR0cmlicy5zdWJQYXRjaCA9IHVpQXR0cmlicy5zdWJQYXRjaCB8fCAwO1xuXG4gICAgICAgIG9wLnNldFVpQXR0cmlicyh1aUF0dHJpYnMpO1xuICAgICAgICBpZiAob3Aub25DcmVhdGUpIG9wLm9uQ3JlYXRlKCk7XG5cbiAgICAgICAgaWYgKG9wLmhhc093blByb3BlcnR5KFwib25BbmltRnJhbWVcIikpIHRoaXMuYWRkT25BbmltRnJhbWUob3ApO1xuICAgICAgICBpZiAob3AuaGFzT3duUHJvcGVydHkoXCJvbk1hc3RlclZvbHVtZUNoYW5nZWRcIikpIHRoaXMuX3ZvbHVtZUxpc3RlbmVycy5wdXNoKG9wKTtcblxuICAgICAgICBpZiAodGhpcy5fb3BJZENhY2hlW29wLmlkXSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJvcGlkIHdpdGggaWQgXCIgKyBvcC5pZCArIFwiIGFscmVhZHkgZXhpc3RzIGluIHBhdGNoIVwiKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlT3Aob3AuaWQpOyAvLyBzdHJhbmdlIHdpdGggc3VicGF0Y2ggb3BzOiB3aHkgaXMgdGhpcyBuZWVkZWQsIHNvbWVob3cgb3BzIGdldCBhZGRlZCB0d2ljZSA/Pz8uLi4uLlxuICAgICAgICAgICAgLy8gcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHMucHVzaChvcCk7XG4gICAgICAgIHRoaXMuX29wSWRDYWNoZVtvcC5pZF0gPSBvcDtcblxuICAgICAgICBpZiAodGhpcy5fc3ViUGF0Y2hDYWNoZUFkZCkgdGhpcy5fc3ViUGF0Y2hDYWNoZUFkZCh1aUF0dHJpYnMuc3ViUGF0Y2gsIG9wKTtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJvbk9wQWRkXCIsIG9wLCBmcm9tRGVzZXJpYWxpemUpO1xuXG4gICAgICAgIGlmIChvcC5pbml0KSBvcC5pbml0KCk7XG5cbiAgICAgICAgb3AuZW1pdEV2ZW50KFwiaW5pdFwiLCBmcm9tRGVzZXJpYWxpemUpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJhZGRvcDogbm8gb3AuLi4uLlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3A7XG59O1xuXG5QYXRjaC5wcm90b3R5cGUuYWRkT25BbmltRnJhbWUgPSBmdW5jdGlvbiAob3ApXG57XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFuaW1GcmFtZU9wcy5sZW5ndGg7IGkrKykgaWYgKHRoaXMuYW5pbUZyYW1lT3BzW2ldID09IG9wKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5hbmltRnJhbWVPcHMucHVzaChvcCk7XG59O1xuXG5QYXRjaC5wcm90b3R5cGUucmVtb3ZlT25BbmltRnJhbWUgPSBmdW5jdGlvbiAob3ApXG57XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFuaW1GcmFtZU9wcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1GcmFtZU9wc1tpXSA9PSBvcClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hbmltRnJhbWVPcHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUGF0Y2gucHJvdG90eXBlLmFkZE9uQW5pbUZyYW1lQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2IpXG57XG4gICAgdGhpcy5hbmltRnJhbWVDYWxsYmFja3MucHVzaChjYik7XG59O1xuXG5QYXRjaC5wcm90b3R5cGUucmVtb3ZlT25BbmltQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2IpXG57XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFuaW1GcmFtZUNhbGxiYWNrcy5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1GcmFtZUNhbGxiYWNrc1tpXSA9PSBjYilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5hbmltRnJhbWVDYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUGF0Y2gucHJvdG90eXBlLmRlbGV0ZU9wID0gZnVuY3Rpb24gKG9waWQsIHRyeVJlbGluaywgcmVsb2FkaW5nT3ApXG57XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMub3BzKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMub3BzW2ldLmlkID09IG9waWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG9wID0gdGhpcy5vcHNbaV07XG4gICAgICAgICAgICBsZXQgcmVMaW5rUDEgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHJlTGlua1AyID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKG9wKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHJ5UmVsaW5rKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wLnBvcnRzSW4ubGVuZ3RoID4gMCAmJiBvcC5wb3J0c0luWzBdLmlzTGlua2VkKCkgJiYgKG9wLnBvcnRzT3V0Lmxlbmd0aCA+IDAgJiYgb3AucG9ydHNPdXRbMF0uaXNMaW5rZWQoKSkpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcC5wb3J0c0luWzBdLmdldFR5cGUoKSA9PSBvcC5wb3J0c091dFswXS5nZXRUeXBlKCkgJiYgb3AucG9ydHNJblswXS5saW5rc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZUxpbmtQMSA9IG9wLnBvcnRzSW5bMF0ubGlua3NbMF0uZ2V0T3RoZXJQb3J0KG9wLnBvcnRzSW5bMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlTGlua1AyID0gb3AucG9ydHNPdXRbMF0ubGlua3NbMF0uZ2V0T3RoZXJQb3J0KG9wLnBvcnRzT3V0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG9wVG9EZWxldGUgPSB0aGlzLm9wc1tpXTtcbiAgICAgICAgICAgICAgICBvcFRvRGVsZXRlLnJlbW92ZUxpbmtzKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkRlbGV0ZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvZG86IHJlbW92ZVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImRlcHJlY2F0ZWQgdGhpcy5vbkRlbGV0ZVwiLCB0aGlzLm9uRGVsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkRlbGV0ZShvcFRvRGVsZXRlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9wcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgb3BUb0RlbGV0ZS5lbWl0RXZlbnQoXCJkZWxldGVcIiwgb3BUb0RlbGV0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJvbk9wRGVsZXRlXCIsIG9wVG9EZWxldGUsIHJlbG9hZGluZ09wKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsZWFyU3ViUGF0Y2hDYWNoZSkgdGhpcy5jbGVhclN1YlBhdGNoQ2FjaGUob3BUb0RlbGV0ZS51aUF0dHJpYnMuc3ViUGF0Y2gpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wVG9EZWxldGUub25EZWxldGUpIG9wVG9EZWxldGUub25EZWxldGUocmVsb2FkaW5nT3ApO1xuICAgICAgICAgICAgICAgIG9wVG9EZWxldGUuY2xlYW5VcCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlTGlua1AxICE9PSBudWxsICYmIHJlTGlua1AyICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rKHJlTGlua1AxLm9wLCByZUxpbmtQMS5nZXROYW1lKCksIHJlTGlua1AyLm9wLCByZUxpbmtQMi5nZXROYW1lKCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9vcElkQ2FjaGVbb3BpZF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZvdW5kKSBjb25zb2xlLmxvZyhcImNvcmUgcGF0Y2ggZGVsZXRlb3A6IG5vdCBmb3VuZC4uLlwiLCBvcGlkKTtcbn07XG5cblBhdGNoLnByb3RvdHlwZS5nZXRGcmFtZU51bSA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX2ZyYW1lTnVtO1xufTtcblxuUGF0Y2gucHJvdG90eXBlLmVtaXRPbkFuaW1GcmFtZUV2ZW50ID0gZnVuY3Rpb24gKHRpbWUsIGRlbHRhKVxue1xuICAgIHRpbWUgPSB0aW1lIHx8IHRoaXMudGltZXIuZ2V0VGltZSgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFuaW1GcmFtZUNhbGxiYWNrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKHRoaXMuYW5pbUZyYW1lQ2FsbGJhY2tzW2ldKVxuICAgICAgICAgICAgdGhpcy5hbmltRnJhbWVDYWxsYmFja3NbaV0odGltZSwgdGhpcy5fZnJhbWVOdW0sIGRlbHRhKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hbmltRnJhbWVPcHMubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmICh0aGlzLmFuaW1GcmFtZU9wc1tpXS5vbkFuaW1GcmFtZSlcbiAgICAgICAgICAgIHRoaXMuYW5pbUZyYW1lT3BzW2ldLm9uQW5pbUZyYW1lKHRpbWUsIHRoaXMuX2ZyYW1lTnVtLCBkZWx0YSk7XG59O1xuXG5QYXRjaC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAodGltZXN0YW1wKVxue1xuICAgIC8vIGNvbnNvbGUubG9nKFwicmVuZGVyZnJhbWVcIiwgdGhpcy5fcGF1c2VkLCB0aGlzLl9mcmFtZU51bSk7XG5cbiAgICB0aGlzLnRpbWVyLnVwZGF0ZSgpO1xuICAgIHRoaXMuZnJlZVRpbWVyLnVwZGF0ZSgpO1xuICAgIGNvbnN0IHRpbWUgPSB0aGlzLnRpbWVyLmdldFRpbWUoKTtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLmNnbC5mcmFtZVN0YXJ0VGltZSA9IHRoaXMudGltZXIuZ2V0VGltZSgpO1xuXG4gICAgY29uc3QgZGVsdGEgPSB0aW1lc3RhbXAgLSB0aGlzLl9sYXN0UmVxQW5pbVRpbWVTdGFtcCB8fCB0aW1lc3RhbXA7XG5cbiAgICB0aGlzLmVtaXRPbkFuaW1GcmFtZUV2ZW50KG51bGwsIGRlbHRhKTtcblxuICAgIHRoaXMuY2dsLnByb2ZpbGVEYXRhLnByb2ZpbGVGcmFtZURlbHRhID0gZGVsdGE7XG4gICAgdGhpcy5fbGFzdFJlcUFuaW1UaW1lU3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgdGhpcy5jZ2wucHJvZmlsZURhdGEucHJvZmlsZU9uQW5pbUZyYW1lT3BzID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICB0aGlzLmVtaXRFdmVudChcIm9uUmVuZGVyRnJhbWVcIiwgdGltZSk7XG5cbiAgICB0aGlzLl9mcmFtZU51bSsrO1xuICAgIGlmICh0aGlzLl9mcmFtZU51bSA9PSAxKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLm9uRmlyc3RGcmFtZVJlbmRlcmVkKSB0aGlzLmNvbmZpZy5vbkZpcnN0RnJhbWVSZW5kZXJlZCgpO1xuICAgIH1cbn07XG5cblBhdGNoLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKHRpbWVzdGFtcClcbntcbiAgICBpZiAoIXRoaXMuX3JlbmRlck9uZUZyYW1lICYmICh0aGlzLl9wYXVzZWQgfHwgdGhpcy5hYm9ydGVkKSkgcmV0dXJuO1xuICAgIHRoaXMuZW1pdEV2ZW50KFwicmVxQW5pbUZyYW1lXCIpO1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1SZXEpO1xuXG4gICAgdGhpcy5jb25maWcuZnBzTGltaXQgPSB0aGlzLmNvbmZpZy5mcHNMaW1pdCB8fCAwO1xuICAgIGlmICh0aGlzLmNvbmZpZy5mcHNMaW1pdClcbiAgICB7XG4gICAgICAgIHRoaXMuX2ZyYW1lSW50ZXJ2YWwgPSAxMDAwIC8gdGhpcy5jb25maWcuZnBzTGltaXQ7XG4gICAgfVxuXG4gICAgY29uc3Qgbm93ID0gQ0FCTEVTLm5vdygpO1xuICAgIGNvbnN0IGZyYW1lRGVsdGEgPSBub3cgLSB0aGlzLl9mcmFtZU5leHQ7XG5cblxuXG4gICAgaWYgKHRoaXMuaXNFZGl0b3JNb2RlKCkpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlck9uZUZyYW1lKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAobm93IC0gdGhpcy5fbGFzdEZyYW1lVGltZSA+PSA1MDAgJiYgdGhpcy5fbGFzdEZyYW1lVGltZSAhPT0gMCAmJiAhdGhpcy5fZnJhbWVXYXNkZWxheWVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZVRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5leGVjLmJpbmQodGhpcyksIDUwMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJyZW5kZXJEZWxheVN0YXJ0XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZyYW1lV2FzZGVsYXllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbmRlck9uZUZyYW1lIHx8IHRoaXMuY29uZmlnLmZwc0xpbWl0ID09PSAwIHx8IGZyYW1lRGVsdGEgPiB0aGlzLl9mcmFtZUludGVydmFsIHx8IHRoaXMuX2ZyYW1lV2FzZGVsYXllZClcbiAgICB7XG4gICAgICAgIHRoaXMucmVuZGVyRnJhbWUodGltZXN0YW1wKTtcblxuICAgICAgICBpZiAodGhpcy5fZnJhbWVJbnRlcnZhbCkgdGhpcy5fZnJhbWVOZXh0ID0gbm93IC0gKGZyYW1lRGVsdGEgJSB0aGlzLl9mcmFtZUludGVydmFsKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZnJhbWVXYXNkZWxheWVkKVxuICAgIHtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJyZW5kZXJEZWxheUVuZFwiKTtcbiAgICAgICAgdGhpcy5fZnJhbWVXYXNkZWxheWVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbmRlck9uZUZyYW1lKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMub25PbmVGcmFtZVJlbmRlcmVkKSB0aGlzLm9uT25lRnJhbWVSZW5kZXJlZCgpOyAvLyB0b2RvIHJlbW92ZSBldmVyeXdoZXJlIGFuZCB1c2UgcHJvcHBlciBldmVudC4uLlxuICAgICAgICB0aGlzLmVtaXRFdmVudChcInJlbmRlcmVkT25lRnJhbWVcIik7XG4gICAgICAgIHRoaXMuX3JlbmRlck9uZUZyYW1lID0gZmFsc2U7XG4gICAgfVxuXG5cbiAgICBpZiAodGhpcy5jb25maWcuZG9SZXF1ZXN0QW5pbWF0aW9uKSB0aGlzLl9hbmltUmVxID0gdGhpcy5jZ2wuY2FudmFzLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuZXhlYy5iaW5kKHRoaXMpKTtcbn07XG5cbi8vIFBhdGNoLnByb3RvdHlwZS5saW5rUG9ydHMgPSBmdW5jdGlvbiAocG9ydDEsIHBvcnQyKVxuLy8ge1xuLy8gICAgIHRoaXMubGluayhwb3J0MS5wYXJlbnQsIHBvcnQxLmlkLCBwb3J0Mi5wYXJlbnQsIHBvcnQyLmlkKTtcbi8vIH07XG5cbi8qKlxuICogbGluayB0d28gb3BzL3BvcnRzXG4gKiBAZnVuY3Rpb24gbGlua1xuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T3B9IG9wMVxuICogQHBhcmFtIHtTdHJpbmd9IHBvcnROYW1lMVxuICogQHBhcmFtIHtPcH0gb3AyXG4gKiBAcGFyYW0ge1N0cmluZ30gcG9ydE5hbWUyXG4gKi9cblBhdGNoLnByb3RvdHlwZS5saW5rID0gZnVuY3Rpb24gKG9wMSwgcG9ydDFOYW1lLCBvcDIsIHBvcnQyTmFtZSwgbG93ZXJDYXNlLCBmcm9tRGVzZXJpYWxpemUpXG57XG4gICAgaWYgKCFvcDEpXG4gICAge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJsaW5rOiBvcDEgaXMgbnVsbCBcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFvcDIpXG4gICAge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJsaW5rOiBvcDIgaXMgbnVsbFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBvcnQxID0gb3AxLmdldFBvcnQocG9ydDFOYW1lLCBsb3dlckNhc2UpO1xuICAgIGNvbnN0IHBvcnQyID0gb3AyLmdldFBvcnQocG9ydDJOYW1lLCBsb3dlckNhc2UpO1xuXG4gICAgaWYgKCFwb3J0MSlcbiAgICB7XG4gICAgICAgIGNvbnNvbGUud2FybihcInBvcnQxIG5vdCBmb3VuZCEgXCIgKyBwb3J0MU5hbWUgKyBcIihcIiArIG9wMS5vYmpOYW1lICsgXCIpXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFwb3J0MilcbiAgICB7XG4gICAgICAgIGNvbnNvbGUud2FybihcInBvcnQyIG5vdCBmb3VuZCEgXCIgKyBwb3J0Mk5hbWUgKyBcIiBvZiBcIiArIG9wMi5uYW1lICsgXCIoXCIgKyBvcDIub2JqTmFtZSArIFwiKVwiLCBvcDIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFwb3J0MS5zaG91bGRMaW5rKHBvcnQxLCBwb3J0MikgfHwgIXBvcnQyLnNob3VsZExpbmsocG9ydDEsIHBvcnQyKSlcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoTGluay5jYW5MaW5rKHBvcnQxLCBwb3J0MikpXG4gICAge1xuICAgICAgICBjb25zdCBsaW5rID0gbmV3IExpbmsodGhpcyk7XG4gICAgICAgIGxpbmsubGluayhwb3J0MSwgcG9ydDIpO1xuXG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwib25MaW5rXCIsIHBvcnQxLCBwb3J0MiwgbGluaywgZnJvbURlc2VyaWFsaXplKTtcbiAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgfVxufTtcblxuUGF0Y2gucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKVxue1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb2JqLm9wcyA9IFtdO1xuICAgIG9iai5zZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMub3BzKVxuICAgIHtcbiAgICAgICAgY29uc3Qgb3AgPSB0aGlzLm9wc1tpXTtcbiAgICAgICAgb2JqLm9wcy5wdXNoKG9wLmdldFNlcmlhbGl6ZWQoKSk7XG4gICAgfVxuXG4gICAgY2xlYW5Kc29uKG9iaik7XG5cbiAgICBpZiAob3B0aW9ucy5hc09iamVjdCkgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcbn07XG5cblBhdGNoLnByb3RvdHlwZS5nZXRPcHNCeVJlZklkID0gZnVuY3Rpb24gKHJlZklkKVxue1xuICAgIGNvbnN0IHBlcmYgPSBDQUJMRVMuVUkudWlQcm9maWxlci5zdGFydChcIltjb3JlcGF0Y2hldGVuZF0gZ2V0T3BzQnlSZWZJZFwiKTtcbiAgICBjb25zdCByZWZPcHMgPSBbXTtcbiAgICBjb25zdCBvcHMgPSBndWkuY29yZVBhdGNoKCkub3BzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAob3BzW2ldLnN0b3JhZ2UgJiYgb3BzW2ldLnN0b3JhZ2UucmVmID09IHJlZklkKSByZWZPcHMucHVzaChvcHNbaV0pO1xuICAgIHBlcmYuZmluaXNoKCk7XG4gICAgcmV0dXJuIHJlZk9wcztcbn07XG5cblxuUGF0Y2gucHJvdG90eXBlLmdldE9wQnlJZCA9IGZ1bmN0aW9uIChvcGlkKVxue1xuICAgIHJldHVybiB0aGlzLl9vcElkQ2FjaGVbb3BpZF07XG4gICAgLy8gdGhpcy50aW1lTmVlZGVkR2V0T3BCeUlkID0gdGhpcy50aW1lTmVlZGVkR2V0T3BCeUlkIHx8IDA7XG5cbiAgICAvLyBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAvLyBmb3IgKGNvbnN0IGkgaW4gdGhpcy5vcHMpXG4gICAgLy8ge1xuICAgIC8vICAgICBpZiAodGhpcy5vcHNbaV0uaWQgPT0gb3BpZClcbiAgICAvLyAgICAge1xuICAgIC8vICAgICAgICAgdGhpcy50aW1lTmVlZGVkR2V0T3BCeUlkICs9IChwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSk7XG4gICAgLy8gICAgICAgICByZXR1cm4gdGhpcy5vcHNbaV07XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG59O1xuXG4vLyBQYXRjaC5wcm90b3R5cGUuZ2V0T3BzQnlJZCA9IGZ1bmN0aW9uIChvcElkcylcbi8vIHtcbi8vICAgICBjb25zdCBvcHMgPSBbXTtcbi8vICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5vcHMpXG4vLyAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3BJZHMubGVuZ3RoOyBqKyspXG4vLyAgICAgICAgICAgICBpZiAodGhpcy5vcHNbaV0uaWQgPT09IG9wSWRzW2pdKVxuLy8gICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgIG9wcy5wdXNoKHRoaXMub3BzW2ldKTtcbi8vICAgICAgICAgICAgICAgICBicmVhaztcbi8vICAgICAgICAgICAgIH1cbi8vICAgICByZXR1cm4gb3BzO1xuLy8gfTtcblxuUGF0Y2gucHJvdG90eXBlLmdldE9wc0J5TmFtZSA9IGZ1bmN0aW9uIChuYW1lKVxue1xuICAgIC8vIFRPRE86IGlzIHRoaXMgc3RpbGwgbmVlZGVkID8gdW5jbGVhciBiZWhhdmlvdXIuLi4uXG4gICAgY29uc3QgYXJyID0gW107XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMub3BzKVxuICAgICAgICBpZiAodGhpcy5vcHNbaV0ubmFtZSA9PSBuYW1lKSBhcnIucHVzaCh0aGlzLm9wc1tpXSk7XG4gICAgcmV0dXJuIGFycjtcbn07XG5cblBhdGNoLnByb3RvdHlwZS5nZXRPcHNCeU9iak5hbWUgPSBmdW5jdGlvbiAobmFtZSlcbntcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5vcHMpXG4gICAgICAgIGlmICh0aGlzLm9wc1tpXS5vYmpOYW1lID09IG5hbWUpIGFyci5wdXNoKHRoaXMub3BzW2ldKTtcbiAgICByZXR1cm4gYXJyO1xufTtcblxuUGF0Y2gucHJvdG90eXBlLmdldE9wc0J5T3BJZCA9IGZ1bmN0aW9uIChvcGlkKVxue1xuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLm9wcylcbiAgICAgICAgaWYgKHRoaXMub3BzW2ldLm9wSWQgPT0gb3BpZCkgYXJyLnB1c2godGhpcy5vcHNbaV0pO1xuICAgIHJldHVybiBhcnI7XG59O1xuXG5QYXRjaC5wcm90b3R5cGUubG9hZExpYiA9IGZ1bmN0aW9uICh3aGljaClcbntcbiAgICBhamF4U3luYyhcbiAgICAgICAgXCIvdWkvbGlicy9cIiArIHdoaWNoICsgXCIuanNcIixcbiAgICAgICAgKGVyciwgcmVzKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBzZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzZS50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcbiAgICAgICAgICAgIHNlLnRleHQgPSByZXM7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQoc2UpO1xuICAgICAgICB9LFxuICAgICAgICBcIkdFVFwiLFxuICAgICk7XG4gICAgLy8gb3BlbiBhbmQgc2VuZCBhIHN5bmNocm9ub3VzIHJlcXVlc3RcbiAgICAvLyB4aHJPYmoub3BlbignR0VUJywgJy91aS9saWJzLycrd2hpY2grJy5qcycsIGZhbHNlKTtcbiAgICAvLyB4aHJPYmouc2VuZCgnJyk7XG4gICAgLy8gYWRkIHRoZSByZXR1cm5lZCBjb250ZW50IHRvIGEgbmV3bHkgY3JlYXRlZCBzY3JpcHQgdGFnXG59O1xuXG5cblBhdGNoLnByb3RvdHlwZS5nZXRTdWJQYXRjaE9wID0gZnVuY3Rpb24gKHBhdGNoSWQsIG9iak5hbWUpXG57XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMub3BzKVxuICAgICAgICBpZiAodGhpcy5vcHNbaV0udWlBdHRyaWJzICYmIHRoaXMub3BzW2ldLnVpQXR0cmlicy5zdWJQYXRjaCA9PSBwYXRjaElkICYmIHRoaXMub3BzW2ldLm9iak5hbWUgPT0gb2JqTmFtZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wc1tpXTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBQYXRjaC5wcm90b3R5cGUuZ2V0U3ViUGF0Y2hPdXRlck9wID0gZnVuY3Rpb24gKHN1YlBhdGNoSWQpIC8vIHJlbW92ZSAhISBtb3ZlZCB0byBleHRlbmQgY2xhc3Ncbi8vIHtcbi8vICAgICBjb25zdCBvcHMgPSB0aGlzLm9wcztcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKylcbi8vICAgICB7XG4vLyAgICAgICAgIGNvbnN0IG9wID0gb3BzW2ldO1xuLy8gICAgICAgICBpZiAob3AuaXNTdWJQYXRjaE9wKCkgJiYgb3AucGF0Y2hJZC5nZXQoKSA9PSBzdWJQYXRjaElkKSByZXR1cm4gb3A7XG4vLyAgICAgfVxuLy8gfTtcblxuXG5cblxuXG5QYXRjaC5wcm90b3R5cGUuX2FkZExpbmsgPSBmdW5jdGlvbiAob3BpbmlkLCBvcG91dGlkLCBpbk5hbWUsIG91dE5hbWUpXG57XG4gICAgdGhpcy5saW5rKHRoaXMuZ2V0T3BCeUlkKG9waW5pZCksIGluTmFtZSwgdGhpcy5nZXRPcEJ5SWQob3BvdXRpZCksIG91dE5hbWUsIGZhbHNlLCB0cnVlKTtcbn07XG5cblBhdGNoLnByb3RvdHlwZS5kZVNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMpXG57XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBcImdlbklkc1wiOiBmYWxzZSwgXCJjcmVhdGVSZWZcIjogZmFsc2UgfTtcbiAgICBpZiAodGhpcy5hYm9ydGVkKSByZXR1cm47XG4gICAgY29uc3QgbmV3T3BzID0gW107XG4gICAgY29uc3QgbG9hZGluZ0lkID0gdGhpcy5sb2FkaW5nLnN0YXJ0KFwiY29yZVwiLCBcImRlc2VyaWFsaXplXCIpO1xuXG4gICAgdGhpcy5uYW1lc3BhY2UgPSBvYmoubmFtZXNwYWNlIHx8IFwiXCI7XG4gICAgdGhpcy5uYW1lID0gb2JqLm5hbWUgfHwgXCJcIjtcblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSBvYmogPSBKU09OLnBhcnNlKG9iaik7XG5cbiAgICB0aGlzLnNldHRpbmdzID0gb2JqLnNldHRpbmdzO1xuXG4gICAgdGhpcy5lbWl0RXZlbnQoXCJwYXRjaExvYWRTdGFydFwiKTtcblxuICAgIGlmICh3aW5kb3cubG9nU3RhcnR1cClsb2dTdGFydHVwKFwiYWRkIFwiICsgb2JqLm9wcy5sZW5ndGggKyBcIiBvcHMuLi4gXCIpO1xuXG4gICAgY29uc3QgYWRkZWRPcHMgPSBbXTtcbiAgICAvLyBhZGQgb3BzLi4uXG4gICAgZm9yIChsZXQgaW9wID0gMDsgaW9wIDwgb2JqLm9wcy5sZW5ndGg7IGlvcCsrKVxuICAgIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBDQUJMRVMubm93KCk7XG4gICAgICAgIGNvbnN0IG9wRGF0YSA9IG9iai5vcHNbaW9wXTtcbiAgICAgICAgbGV0IG9wID0gbnVsbDtcblxuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKG9wRGF0YS5vcElkKSBvcCA9IHRoaXMuYWRkT3Aob3BEYXRhLm9wSWQsIG9wRGF0YS51aUF0dHJpYnMsIG9wRGF0YS5pZCwgdHJ1ZSwgb3BEYXRhLm9iak5hbWUpO1xuICAgICAgICAgICAgZWxzZSBvcCA9IHRoaXMuYWRkT3Aob3BEYXRhLm9iak5hbWUsIG9wRGF0YS51aUF0dHJpYnMsIG9wRGF0YS5pZCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW2luc3RhbmNpbmcgZXJyb3JdIG9wIGRhdGE6XCIsIG9wRGF0YSwgZSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZCBub3QgY3JlYXRlIG9wIGJ5IGlkOiA8Yj5cIiArIChvcERhdGEub2JqTmFtZSB8fCBvcERhdGEub3BJZCkgKyBcIjwvYj4gKFwiICsgb3BEYXRhLmlkICsgXCIpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wKVxuICAgICAgICB7XG4gICAgICAgICAgICBhZGRlZE9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmdlbklkcykgb3AuaWQgPSBzaG9ydElkKCk7XG4gICAgICAgICAgICBvcC5wb3J0c0luRGF0YSA9IG9wRGF0YS5wb3J0c0luO1xuICAgICAgICAgICAgb3AuX29yaWdEYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcERhdGEpKTtcbiAgICAgICAgICAgIG9wLnN0b3JhZ2UgPSBvcERhdGEuc3RvcmFnZTtcbiAgICAgICAgICAgIC8vIGlmIChvcERhdGEuaGFzT3duUHJvcGVydHkoXCJkaXNhYmxlZFwiKSlvcC5zZXRFbmFibGVkKCFvcERhdGEuZGlzYWJsZWQpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlwaSBpbiBvcERhdGEucG9ydHNJbilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmpQb3J0ID0gb3BEYXRhLnBvcnRzSW5baXBpXTtcbiAgICAgICAgICAgICAgICBpZiAob2JqUG9ydCAmJiBvYmpQb3J0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcnQgPSBvcC5nZXRQb3J0KG9ialBvcnQubmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcnQgJiYgKHBvcnQudWlBdHRyaWJzLmRpc3BsYXkgPT0gXCJib29sXCIgfHwgcG9ydC51aUF0dHJpYnMudHlwZSA9PSBcImJvb2xcIikgJiYgIWlzTmFOKG9ialBvcnQudmFsdWUpKSBvYmpQb3J0LnZhbHVlID0gb2JqUG9ydC52YWx1ZSA9PSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9ydCAmJiBvYmpQb3J0LnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcG9ydC50eXBlICE9IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVEVYVFVSRSkgcG9ydC5zZXQob2JqUG9ydC52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcnQpIHBvcnQuZGVTZXJpYWxpemVTZXR0aW5ncyhvYmpQb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXBvIGluIG9wRGF0YS5wb3J0c091dClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmpQb3J0ID0gb3BEYXRhLnBvcnRzT3V0W2lwb107XG4gICAgICAgICAgICAgICAgaWYgKG9ialBvcnQgJiYgb2JqUG9ydC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3J0MiA9IG9wLmdldFBvcnQob2JqUG9ydC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcnQyICYmIHBvcnQyLnR5cGUgIT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9URVhUVVJFICYmIG9ialBvcnQuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQyLnNldChvYmoub3BzW2lvcF0ucG9ydHNPdXRbaXBvXS52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcnQyICYmIG9ialBvcnQuZXhwb3NlKSBwb3J0Mi5zZXRVaUF0dHJpYnMoeyBcImV4cG9zZVwiOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld09wcy5wdXNoKG9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRpbWV1c2VkID0gTWF0aC5yb3VuZCgxMDAgKiAoQ0FCTEVTLm5vdygpIC0gc3RhcnQpKSAvIDEwMDtcbiAgICAgICAgaWYgKCF0aGlzLnNpbGVudCAmJiB0aW1ldXNlZCA+IDUpIGNvbnNvbGUubG9nKFwibG9uZyBvcCBpbml0IFwiLCBvYmoub3BzW2lvcF0ub2JqTmFtZSwgdGltZXVzZWQpO1xuICAgIH1cbiAgICBpZiAod2luZG93LmxvZ1N0YXJ0dXApbG9nU3RhcnR1cChcImFkZCBvcHMgZG9uZVwiKTtcblxuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLm9wcylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLm9wc1tpXS5vbkxvYWRlZFZhbHVlU2V0KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm9wc1tpXS5vbkxvYWRlZFZhbHVlU2V0KHRoaXMub3BzW2ldLl9vcmlnRGF0YSk7XG4gICAgICAgICAgICB0aGlzLm9wc1tpXS5vbkxvYWRlZFZhbHVlU2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMub3BzW2ldLl9vcmlnRGF0YSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHNbaV0uZW1pdEV2ZW50KFwibG9hZGVkVmFsdWVTZXRcIik7XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5sb2dTdGFydHVwKWxvZ1N0YXJ0dXAoXCJjcmVhdGluZyBsaW5rc1wiKTtcblxuICAgIGlmIChvcHRpb25zLm9wc0NyZWF0ZWQpb3B0aW9ucy5vcHNDcmVhdGVkKGFkZGVkT3BzKTtcblxuICAgIC8vIGNyZWF0ZSBsaW5rcy4uLlxuICAgIGlmIChvYmoub3BzKVxuICAgIHtcbiAgICAgICAgZm9yIChsZXQgaW9wID0gMDsgaW9wIDwgb2JqLm9wcy5sZW5ndGg7IGlvcCsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAob2JqLm9wc1tpb3BdLnBvcnRzSW4pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaXBpMiA9IDA7IGlwaTIgPCBvYmoub3BzW2lvcF0ucG9ydHNJbi5sZW5ndGg7IGlwaTIrKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmoub3BzW2lvcF0ucG9ydHNJbltpcGkyXSAmJiBvYmoub3BzW2lvcF0ucG9ydHNJbltpcGkyXS5saW5rcylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaWxpID0gMDsgaWxpIDwgb2JqLm9wc1tpb3BdLnBvcnRzSW5baXBpMl0ubGlua3MubGVuZ3RoOyBpbGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZExpbmsoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5vcHNbaW9wXS5wb3J0c0luW2lwaTJdLmxpbmtzW2lsaV0ub2JqSW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5vcHNbaW9wXS5wb3J0c0luW2lwaTJdLmxpbmtzW2lsaV0ub2JqT3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoub3BzW2lvcF0ucG9ydHNJbltpcGkyXS5saW5rc1tpbGldLnBvcnRJbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLm9wc1tpb3BdLnBvcnRzSW5baXBpMl0ubGlua3NbaWxpXS5wb3J0T3V0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IHRvb2sgPSBwZXJmb3JtYW5jZS5ub3cgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHRvb2sgPiAxMDApY29uc29sZS5sb2cob2JqKCkub3BzW2lvcF0ucG9ydHNJbltpcGkyXS5saW5rc1tpbGldLm9iakluLCBvYmoub3BzW2lvcF0ucG9ydHNJbltpcGkyXS5saW5rc1tpbGldLm9iak91dCwgdG9vayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLm9wc1tpb3BdLnBvcnRzT3V0KVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlwaTIgPSAwOyBpcGkyIDwgb2JqLm9wc1tpb3BdLnBvcnRzT3V0Lmxlbmd0aDsgaXBpMisrKVxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqLm9wc1tpb3BdLnBvcnRzT3V0W2lwaTJdICYmIG9iai5vcHNbaW9wXS5wb3J0c091dFtpcGkyXS5saW5rcylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaWxpID0gMDsgaWxpIDwgb2JqLm9wc1tpb3BdLnBvcnRzT3V0W2lwaTJdLmxpbmtzLmxlbmd0aDsgaWxpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5vcHNbaW9wXS5wb3J0c091dFtpcGkyXS5saW5rc1tpbGldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5vcHNbaW9wXS5wb3J0c091dFtpcGkyXS5saW5rc1tpbGldLnN1Yk9wUmVmKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb3N0IGxpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dE9wID0gdGhpcy5nZXRPcEJ5SWQob2JqLm9wc1tpb3BdLnBvcnRzT3V0W2lwaTJdLmxpbmtzW2lsaV0ub2JqT3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkc3RPcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGhlU3ViUGF0Y2ggPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3BzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHNbaV0uc3RvcmFnZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wc1tpXS5zdG9yYWdlLnJlZiA9PSBvYmoub3BzW2lvcF0ucG9ydHNPdXRbaXBpMl0ubGlua3NbaWxpXS5zdWJPcFJlZiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRPcC51aUF0dHJpYnMuc3ViUGF0Y2ggPT0gdGhpcy5vcHNbaV0udWlBdHRyaWJzLnN1YlBhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlU3ViUGF0Y2ggPSB0aGlzLm9wc1tpXS5wYXRjaElkLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vcHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wc1tpXS5zdG9yYWdlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3BzW2ldLnN0b3JhZ2UucmVmID09IG9iai5vcHNbaW9wXS5wb3J0c091dFtpcGkyXS5saW5rc1tpbGldLnJlZk9wICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3BzW2ldLnVpQXR0cmlicy5zdWJQYXRjaCA9PSB0aGVTdWJQYXRjaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRzdE9wID0gdGhpcy5vcHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkc3RPcCkgdGhpcy5fbG9nLndhcm4oXCJjb3VsZCBub3QgZmluZCBvcCBmb3IgbG9zdCBsaW5rXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZExpbmsoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRzdE9wLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoub3BzW2lvcF0ucG9ydHNPdXRbaXBpMl0ubGlua3NbaWxpXS5vYmpPdXQsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLm9wc1tpb3BdLnBvcnRzT3V0W2lwaTJdLmxpbmtzW2lsaV0ucG9ydEluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmoub3BzW2lvcF0ucG9ydHNPdXRbaXBpMl0ubGlua3NbaWxpXS5wb3J0T3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZExpbmsob2JqLm9wc1tpb3BdLnBvcnRzT3V0W2lwaTJdLmxpbmtzW2lsaV0ub2JqSW4sIG9iai5vcHNbaW9wXS5wb3J0c091dFtpcGkyXS5saW5rc1tpbGldLm9iak91dCwgb2JqLm9wc1tpb3BdLnBvcnRzT3V0W2lwaTJdLmxpbmtzW2lsaV0ucG9ydEluLCBvYmoub3BzW2lvcF0ucG9ydHNPdXRbaXBpMl0ubGlua3NbaWxpXS5wb3J0T3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5sb2dTdGFydHVwKWxvZ1N0YXJ0dXAoXCJjYWxsaW5nIG9wcyBvbmxvYWRlZFwiKTtcblxuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLm9wcylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLm9wc1tpXS5vbkxvYWRlZClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gVE9ETzogZGVwcmVjYXRlISEhXG4gICAgICAgICAgICB0aGlzLm9wc1tpXS5vbkxvYWRlZCgpO1xuICAgICAgICAgICAgdGhpcy5vcHNbaV0ub25Mb2FkZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5sb2dTdGFydHVwKWxvZ1N0YXJ0dXAoXCJpbml0aWFsaXppbmcgb3BzLi4uXCIpO1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLm9wcylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLm9wc1tpXS5pbml0KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm9wc1tpXS5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLm9wc1tpXS5pbml0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aW5kb3cubG9nU3RhcnR1cClsb2dTdGFydHVwKFwiaW5pdGlhbGl6aW5nIHZhcnMuLi5cIik7XG5cbiAgICBpZiAodGhpcy5jb25maWcudmFyaWFibGVzKVxuICAgICAgICBmb3IgKGNvbnN0IHZhck5hbWUgaW4gdGhpcy5jb25maWcudmFyaWFibGVzKVxuICAgICAgICAgICAgdGhpcy5zZXRWYXJWYWx1ZSh2YXJOYW1lLCB0aGlzLmNvbmZpZy52YXJpYWJsZXNbdmFyTmFtZV0pO1xuXG4gICAgaWYgKHdpbmRvdy5sb2dTdGFydHVwKWxvZ1N0YXJ0dXAoXCJpbml0aWFsaXppbmcgdmFyIHBvcnRzXCIpO1xuXG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMub3BzKVxuICAgIHtcbiAgICAgICAgdGhpcy5vcHNbaV0uaW5pdFZhclBvcnRzKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm9wc1tpXS51aUF0dHJpYnMucGFzdGVkO1xuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmxvYWRpbmcuZmluaXNoZWQobG9hZGluZ0lkKTsgfSwgMTAwKTtcblxuICAgIGlmICh3aW5kb3cubG9nU3RhcnR1cClsb2dTdGFydHVwKFwiY2FsbGluZyBvblBhdGNoTG9hZGVkL3BhdGNoTG9hZEVuZFwiKTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5vblBhdGNoTG9hZGVkKSB0aGlzLmNvbmZpZy5vblBhdGNoTG9hZGVkKHRoaXMpO1xuXG4gICAgdGhpcy5kZVNlcmlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdEV2ZW50KFwicGF0Y2hMb2FkRW5kXCIsIG5ld09wcywgb2JqLCBvcHRpb25zLmdlbklkcyk7XG59O1xuXG5QYXRjaC5wcm90b3R5cGUucHJvZmlsZSA9IGZ1bmN0aW9uIChlbmFibGUpXG57XG4gICAgdGhpcy5wcm9maWxlciA9IG5ldyBQcm9maWxlcih0aGlzKTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5vcHMpXG4gICAge1xuICAgICAgICB0aGlzLm9wc1tpXS5wcm9maWxlKGVuYWJsZSk7XG4gICAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIHNldCB2YXJpYWJsZSB2YWx1ZVxuICogQGZ1bmN0aW9uIHNldFZhcmlhYmxlXG4gKiBAbWVtYmVyb2YgUGF0Y2hcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdmFyaWFibGVcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xCb29sZWFufSB2YWx1ZVxuICovXG5QYXRjaC5wcm90b3R5cGUuc2V0VmFyaWFibGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsKVxue1xuICAgIC8vIGlmICh0aGlzLl92YXJpYWJsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgaWYgKHRoaXMuX3ZhcmlhYmxlc1tuYW1lXSAhPT0gdW5kZWZpbmVkKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdmFyaWFibGVzW25hbWVdLnNldFZhbHVlKHZhbCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwidmFyaWFibGUgXCIgKyBuYW1lICsgXCIgbm90IGZvdW5kIVwiKTtcbiAgICB9XG59O1xuXG5QYXRjaC5wcm90b3R5cGUuX3NvcnRWYXJzID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAoIXRoaXMuaXNFZGl0b3JNb2RlKCkpIHJldHVybjtcbiAgICBjb25zdCBvcmRlcmVkID0ge307XG4gICAgT2JqZWN0LmtleXModGhpcy5fdmFyaWFibGVzKS5zb3J0KFxuICAgICAgICAoYSwgYikgPT5cbiAgICAgICAgeyByZXR1cm4gYS5sb2NhbGVDb21wYXJlKGIsIFwiZW5cIiwgeyBcInNlbnNpdGl2aXR5XCI6IFwiYmFzZVwiIH0pOyB9XG4gICAgKS5mb3JFYWNoKChrZXkpID0+XG4gICAge1xuICAgICAgICBvcmRlcmVkW2tleV0gPSB0aGlzLl92YXJpYWJsZXNba2V5XTtcbiAgICB9KTtcbiAgICB0aGlzLl92YXJpYWJsZXMgPSBvcmRlcmVkO1xufTtcblxuLyoqXG4gKiBoYXMgdmFyaWFibGVcbiAqIEBmdW5jdGlvbiBoYXNWYXJpYWJsZVxuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHZhcmlhYmxlXG4gKi9cblBhdGNoLnByb3RvdHlwZS5oYXNWYXIgPSBmdW5jdGlvbiAobmFtZSlcbntcbiAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzW25hbWVdICE9PSB1bmRlZmluZWQ7XG5cbiAgICAvLyByZXR1cm4gdGhpcy5fdmFyaWFibGVzLmhhc093blByb3BlcnR5KG5hbWUpO1xufTtcblxuLy8gdXNlZCBpbnRlcm5hbGx5XG5QYXRjaC5wcm90b3R5cGUuc2V0VmFyVmFsdWUgPSBmdW5jdGlvbiAobmFtZSwgdmFsLCB0eXBlKVxue1xuICAgIGlmICh0aGlzLmhhc1ZhcihuYW1lKSlcbiAgICB7XG4gICAgICAgIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXS5zZXRWYWx1ZSh2YWwpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLl92YXJpYWJsZXNbbmFtZV0gPSBuZXcgUGF0Y2hWYXJpYWJsZShuYW1lLCB2YWwsIHR5cGUpO1xuICAgICAgICB0aGlzLl9zb3J0VmFycygpO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcInZhcmlhYmxlc0NoYW5nZWRcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92YXJpYWJsZXNbbmFtZV07XG59O1xuLy8gb2xkP1xuUGF0Y2gucHJvdG90eXBlLmdldFZhclZhbHVlID0gZnVuY3Rpb24gKG5hbWUsIHZhbClcbntcbiAgICBpZiAodGhpcy5fdmFyaWFibGVzLmhhc093blByb3BlcnR5KG5hbWUpKSByZXR1cm4gdGhpcy5fdmFyaWFibGVzW25hbWVdLmdldFZhbHVlKCk7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBnZXRWYXJcbiAqIEBtZW1iZXJvZiBQYXRjaFxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7VmFyaWFibGV9IHZhcmlhYmxlXG4gKi9cblBhdGNoLnByb3RvdHlwZS5nZXRWYXIgPSBmdW5jdGlvbiAobmFtZSlcbntcbiAgICBpZiAodGhpcy5fdmFyaWFibGVzLmhhc093blByb3BlcnR5KG5hbWUpKSByZXR1cm4gdGhpcy5fdmFyaWFibGVzW25hbWVdO1xufTtcblxuXG5QYXRjaC5wcm90b3R5cGUuZGVsZXRlVmFyID0gZnVuY3Rpb24gKG5hbWUpXG57XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wcy5sZW5ndGg7IGkrKylcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLm9wc1tpXS5wb3J0c0luLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgaWYgKHRoaXMub3BzW2ldLnBvcnRzSW5bal0uZ2V0VmFyaWFibGVOYW1lKCkgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICB0aGlzLm9wc1tpXS5wb3J0c0luW2pdLnNldFZhcmlhYmxlKG51bGwpO1xuXG4gICAgZGVsZXRlIHRoaXMuX3ZhcmlhYmxlc1tuYW1lXTtcbiAgICB0aGlzLmVtaXRFdmVudChcInZhcmlhYmxlRGVsZXRlZFwiLCBuYW1lKTtcbiAgICB0aGlzLmVtaXRFdmVudChcInZhcmlhYmxlc0NoYW5nZWRcIik7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBnZXRWYXJzXG4gKiBAbWVtYmVyb2YgUGF0Y2hcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybiB7QXJyYXk8VmFyaWFibGU+fSB2YXJpYWJsZXNcbiAqIEBmdW5jdGlvblxuICovXG5QYXRjaC5wcm90b3R5cGUuZ2V0VmFycyA9IGZ1bmN0aW9uICh0KVxue1xuICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLl92YXJpYWJsZXM7XG5cbiAgICBjb25zdCB2YXJzID0gW107XG4gICAgaWYgKHQgPT0gQ0FCTEVTLk9QX1BPUlRfVFlQRV9TVFJJTkcpIHQgPSBcInN0cmluZ1wiO1xuICAgIGlmICh0ID09IENBQkxFUy5PUF9QT1JUX1RZUEVfVkFMVUUpIHQgPSBcIm51bWJlclwiO1xuICAgIGlmICh0ID09IENBQkxFUy5PUF9QT1JUX1RZUEVfQVJSQVkpIHQgPSBcImFycmF5XCI7XG4gICAgaWYgKHQgPT0gQ0FCTEVTLk9QX1BPUlRfVFlQRV9PQkpFQ1QpIHQgPSBcIm9iamVjdFwiO1xuXG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX3ZhcmlhYmxlcylcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5fdmFyaWFibGVzW2ldLnR5cGUgfHwgdGhpcy5fdmFyaWFibGVzW2ldLnR5cGUgPT0gdCkgdmFycy5wdXNoKHRoaXMuX3ZhcmlhYmxlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiB2YXJzO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gZXhpdEVycm9yXG4gKiBAbWVtYmVyb2YgUGF0Y2hcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIGNhbmNlbCBwYXRjaCBleGVjdXRpb24gYW5kIHF1aXQgc2hvd2luZyBhbiBlcnJvcm1lc3NhZ2VcbiAqIEBmdW5jdGlvblxuICovXG5QYXRjaC5wcm90b3R5cGUuZXhpdEVycm9yID0gZnVuY3Rpb24gKGVycm9ySWQsIGVycm9yTWVzc2FnZSwgZXgpXG57XG4gICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzICYmIHRoaXMuY29uZmlnICYmIHRoaXMuY29uZmlnLm9uRXJyb3IpXG4gICAge1xuICAgICAgICB0aGlzLmNvbmZpZy5vbkVycm9yKGVycm9ySWQsIGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5pc0VkaXRvck1vZGUoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgbmV3RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHRoaXMuY2dsLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgbmV3RGl2LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwicG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyOjVweCBzb2xpZCByZWQ7cGFkZGluZzoxNXB4O2JhY2tncm91bmQtY29sb3I6YmxhY2s7Y29sb3I6d2hpdGU7Zm9udC1mYW1pbHk6bW9ub3NwYWNlO1wiKTtcbiAgICAgICAgICAgIG5ld0Rpdi5zdHlsZS50b3AgPSByZWN0LnRvcCArIFwicHhcIjtcbiAgICAgICAgICAgIG5ld0Rpdi5zdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgbGV0IHN0ciA9IFwiY2FibGVzIC0gQW4gZXJyb3Igb2NjdXJlZDo8YnIvPlwiO1xuICAgICAgICAgICAgc3RyICs9IFwiW1wiICsgZXJyb3JJZCArIFwiXSAtIFwiICsgZXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgaWYgKGV4KXN0ciArPSBcIjxici8+RXhjZXB0aW9uOiBcIiArIGV4Lm1lc3NhZ2U7XG4gICAgICAgICAgICBuZXdEaXYuaW5uZXJIVE1MID0gc3RyO1xuXG4gICAgICAgICAgICBjb25zdCBwZSA9IHRoaXMuY2dsLmNhbnZhcy5wYXJlbnRFbGVtZW50O1xuXG4gICAgICAgICAgICB3aGlsZSAocGUuaGFzQ2hpbGROb2RlcygpKSBwZS5yZW1vdmVDaGlsZChwZS5sYXN0Q2hpbGQpO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5ld0Rpdik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBwcmVSZW5kZXJPcHNcbiAqIEBtZW1iZXJvZiBQYXRjaFxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gaW52b2tlIHByZSByZW5kZXJpbmcgb2Ygb3BzXG4gKiBAZnVuY3Rpb25cbiAqL1xuUGF0Y2gucHJvdG90eXBlLnByZVJlbmRlck9wcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fbG9nLmxvZyhcInByZXJlbmRlcmluZy4uLlwiKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vcHMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZiAodGhpcy5vcHNbaV0ucHJlUmVuZGVyKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm9wc1tpXS5wcmVSZW5kZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5sb2coXCJwcmVyZW5kZXIgXCIgKyB0aGlzLm9wc1tpXS5vYmpOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGRpc3Bvc2VcbiAqIEBtZW1iZXJvZiBQYXRjaFxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gc3RvcCwgZGlzcG9zZSBhbmQgY2xlYW51cCBwYXRjaFxuICovXG5QYXRjaC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5wYXVzZSgpO1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLmNnbC5kaXNwb3NlKCk7XG59O1xuXG5QYXRjaC5wcm90b3R5cGUucHVzaFRyaWdnZXJTdGFjayA9IGZ1bmN0aW9uIChwKVxue1xuICAgIHRoaXMuX3RyaWdnZXJTdGFjay5wdXNoKHApO1xufTtcblxuUGF0Y2gucHJvdG90eXBlLnBvcFRyaWdnZXJTdGFjayA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fdHJpZ2dlclN0YWNrLnBvcCgpO1xufTtcblxuUGF0Y2gucHJvdG90eXBlLnByaW50VHJpZ2dlclN0YWNrID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fdHJpZ2dlclN0YWNrLmxlbmd0aCA9PSAwKVxuICAgIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJzdGFjayBsZW5ndGhcIiwgdGhpcy5fdHJpZ2dlclN0YWNrLmxlbmd0aCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIFwidHJpZ2dlciBwb3J0IHN0YWNrIFwiICsgdGhpcy5fdHJpZ2dlclN0YWNrW3RoaXMuX3RyaWdnZXJTdGFjay5sZW5ndGggLSAxXS5vcC5uYW1lICsgXCIuXCIgKyB0aGlzLl90cmlnZ2VyU3RhY2tbdGhpcy5fdHJpZ2dlclN0YWNrLmxlbmd0aCAtIDFdLm5hbWUsXG4gICAgKTtcblxuICAgIGNvbnN0IHJvd3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3RyaWdnZXJTdGFjay5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHJvd3MucHVzaChpICsgXCIuIFwiICsgdGhpcy5fdHJpZ2dlclN0YWNrW2ldLm9wLm5hbWUgKyBcIiBcIiArIHRoaXMuX3RyaWdnZXJTdGFja1tpXS5uYW1lKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLnRhYmxlKHJvd3MpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgY29uc29sZS5ncm91cEVuZCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59O1xuXG4vKipcbiAqIHJldHVybnMgZG9jdW1lbnQgb2JqZWN0IG9mIHRoZSBwYXRjaCBjb3VsZCBiZSAhPSBnbG9iYWwgZG9jdW1lbnQgb2JqZWN0IHdoZW4gb3BlbmluZyBjYW52YXMgaW5hIHBvcG91dCB3aW5kb3dcbiAqIEBmdW5jdGlvbiBnZXREb2N1bWVudFxuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm4ge09iamVjdH0gZG9jdW1lbnRcbiAqL1xuUGF0Y2gucHJvdG90eXBlLmdldERvY3VtZW50ID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5jZ2wuY2FudmFzLm93bmVyRG9jdW1lbnQ7XG59O1xuXG5QYXRjaC5yZXBsYWNlT3BJZHMgPSBmdW5jdGlvbiAoanNvbiwgb3B0aW9ucylcbntcbiAgICBjb25zdCBvcGlkcyA9IHt9O1xuICAgIGZvciAoY29uc3QgaSBpbiBqc29uLm9wcylcbiAgICB7XG4gICAgICAgIG9waWRzW2pzb24ub3BzW2ldLmlkXSA9IGpzb24ub3BzW2ldO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgaiBpbiBqc29uLm9wcylcbiAgICB7XG4gICAgICAgIGZvciAoY29uc3QgayBpbiBqc29uLm9wc1tqXS5wb3J0c091dClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgbGlua3MgPSBqc29uLm9wc1tqXS5wb3J0c091dFtrXS5saW5rcztcbiAgICAgICAgICAgIGlmIChsaW5rcylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgbCA9IGxpbmtzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChsLS0pXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlua3NbbF0gJiYgKCFvcGlkc1tsaW5rc1tsXS5vYmpJbl0gfHwgIW9waWRzW2xpbmtzW2xdLm9iak91dF0pKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuZG9Ob3RVbmxpbmtMb3N0TGlua3MpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3Muc3BsaWNlKGwsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZpeExvc3RMaW5rcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwibG9zdCBsaW5rLi4uP1wiLCBsaW5rc1tsXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wID0gZ3VpLmNvcmVQYXRjaCgpLmdldE9wQnlJZChsaW5rc1tsXS5vYmpJbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3ApIGNvbnNvbGUubG9nKFwib3Agbm90IGZvdW5kIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRlck9wID0gZ3VpLnBhdGNoVmlldy5nZXRTdWJQYXRjaE91dGVyT3Aob3AudWlBdHRyaWJzLnN1YlBhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRlck9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wLnN0b3JhZ2UgPSBvcC5zdG9yYWdlIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wLnN0b3JhZ2UucmVmID0gb3Auc3RvcmFnZS5yZWYgfHwgQ0FCTEVTLnNob3J0SWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rc1tsXS5yZWZPcCA9IG9wLnN0b3JhZ2UucmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzW2xdLnN1Yk9wUmVmID0gb3V0ZXJPcC5zdG9yYWdlLnJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG5cbiAgICBmb3IgKGNvbnN0IGkgaW4ganNvbi5vcHMpXG4gICAge1xuICAgICAgICBjb25zdCBvcCA9IGpzb24ub3BzW2ldO1xuICAgICAgICBjb25zdCBvbGRJZCA9IG9wLmlkO1xuICAgICAgICBsZXQgbmV3SWQgPSBDQUJMRVMuc2hvcnRJZCgpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnByZWZpeEhhc2gpIG5ld0lkID0gcHJlZml4ZWRIYXNoKG9wdGlvbnMucHJlZml4SGFzaCArIG9sZElkKTtcblxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLnByZWZpeElkKSBuZXdJZCA9IG9wdGlvbnMucHJlZml4SWQgKyBvbGRJZDtcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5yZWZBc0lkKSAvLyB3aGVuIHNhdmluZyBqc29uXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChvcC5zdG9yYWdlICYmIG9wLnN0b3JhZ2UucmVmKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5ld0lkID0gb3Auc3RvcmFnZS5yZWY7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wLnN0b3JhZ2UucmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9wLnN0b3JhZ2UgPSBvcC5zdG9yYWdlIHx8IHt9O1xuICAgICAgICAgICAgICAgIG9wLnN0b3JhZ2UucmVmID0gbmV3SWQgPSBDQUJMRVMuc2hvcnRJZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV3SUQgPSBvcC5pZCA9IG5ld0lkO1xuXG4gICAgICAgIGlmIChvcHRpb25zLm9sZElkQXNSZWYpIC8vIHdoZW4gbG9hZGluZyBqc29uXG4gICAgICAgIHtcbiAgICAgICAgICAgIG9wLnN0b3JhZ2UgPSBvcC5zdG9yYWdlIHx8IHt9O1xuICAgICAgICAgICAgb3Auc3RvcmFnZS5yZWYgPSBvbGRJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgaiBpbiBqc29uLm9wcylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGpzb24ub3BzW2pdLnBvcnRzSW4pXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGpzb24ub3BzW2pdLnBvcnRzSW4pXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi5vcHNbal0ucG9ydHNJbltrXS5saW5rcylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGwgPSBqc29uLm9wc1tqXS5wb3J0c0luW2tdLmxpbmtzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGwtLSkgaWYgKGpzb24ub3BzW2pdLnBvcnRzSW5ba10ubGlua3NbbF0gPT09IG51bGwpIGpzb24ub3BzW2pdLnBvcnRzSW5ba10ubGlua3Muc3BsaWNlKGwsIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGwgaW4ganNvbi5vcHNbal0ucG9ydHNJbltrXS5saW5rcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi5vcHNbal0ucG9ydHNJbltrXS5saW5rc1tsXS5vYmpJbiA9PT0gb2xkSWQpIGpzb24ub3BzW2pdLnBvcnRzSW5ba10ubGlua3NbbF0ub2JqSW4gPSBuZXdJRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi5vcHNbal0ucG9ydHNJbltrXS5saW5rc1tsXS5vYmpPdXQgPT09IG9sZElkKSBqc29uLm9wc1tqXS5wb3J0c0luW2tdLmxpbmtzW2xdLm9iak91dCA9IG5ld0lEO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoanNvbi5vcHNbal0ucG9ydHNPdXQpXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGpzb24ub3BzW2pdLnBvcnRzT3V0KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24ub3BzW2pdLnBvcnRzT3V0W2tdLmxpbmtzKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbCA9IGpzb24ub3BzW2pdLnBvcnRzT3V0W2tdLmxpbmtzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGwtLSkgaWYgKGpzb24ub3BzW2pdLnBvcnRzT3V0W2tdLmxpbmtzW2xdID09PSBudWxsKSBqc29uLm9wc1tqXS5wb3J0c091dFtrXS5saW5rcy5zcGxpY2UobCwgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobCBpbiBqc29uLm9wc1tqXS5wb3J0c091dFtrXS5saW5rcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi5vcHNbal0ucG9ydHNPdXRba10ubGlua3NbbF0ub2JqSW4gPT09IG9sZElkKSBqc29uLm9wc1tqXS5wb3J0c091dFtrXS5saW5rc1tsXS5vYmpJbiA9IG5ld0lEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uLm9wc1tqXS5wb3J0c091dFtrXS5saW5rc1tsXS5vYmpPdXQgPT09IG9sZElkKSBqc29uLm9wc1tqXS5wb3J0c091dFtrXS5saW5rc1tsXS5vYmpPdXQgPSBuZXdJRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldCBjb3JyZWN0IHN1YnBhdGNoXG4gICAgY29uc3Qgc3VicGF0Y2hJZHMgPSBbXTtcbiAgICBjb25zdCBmaXhlZFN1YlBhdGNoZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5vcHMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICAvLyBpZiAoQ0FCTEVTLk9wLmlzU3ViUGF0Y2hPcE5hbWUoanNvbi5vcHNbaV0ub2JqTmFtZSkpXG4gICAgICAgIGlmIChqc29uLm9wc1tpXS5zdG9yYWdlICYmIGpzb24ub3BzW2ldLnN0b3JhZ2Uuc3ViUGF0Y2hWZXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBqc29uLm9wc1tpXS5wb3J0c0luKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChqc29uLm9wc1tpXS5wb3J0c0luW2tdLm5hbWUgPT09IFwicGF0Y2hJZFwiKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0lkID0gc2hvcnRJZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnByZWZpeEhhc2gpIG5ld0lkID0gcHJlZml4ZWRIYXNoKG9wdGlvbnMucHJlZml4SGFzaCArIGpzb24ub3BzW2ldLnBvcnRzSW5ba10udmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFN1YlBhdGNoSWQgPSBqc29uLm9wc1tpXS5wb3J0c0luW2tdLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdTdWJQYXRjaElkID0ganNvbi5vcHNbaV0ucG9ydHNJbltrXS52YWx1ZSA9IG5ld0lkO1xuXG4gICAgICAgICAgICAgICAgICAgIHN1YnBhdGNoSWRzLnB1c2gobmV3U3ViUGF0Y2hJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBqc29uLm9wcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3AgaGFzIG5vIHVpQXR0cmlicyBpbiBleHBvcnQsIHdlIGRvbid0IGNhcmUgYWJvdXQgc3VicGF0Y2hlcyBpbiBleHBvcnQgdGhvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbi5vcHNbal0udWlBdHRyaWJzKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uLm9wc1tqXS51aUF0dHJpYnMuc3ViUGF0Y2ggPT09IG9sZFN1YlBhdGNoSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uLm9wc1tqXS51aUF0dHJpYnMuc3ViUGF0Y2ggPSBuZXdTdWJQYXRjaElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXhlZFN1YlBhdGNoZXMucHVzaChqc29uLm9wc1tqXS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrayBpbiBqc29uLm9wcylcbiAgICB7XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpeGVkU3ViUGF0Y2hlcy5sZW5ndGg7IGorKylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGpzb24ub3BzW2trXS5pZCA9PT0gZml4ZWRTdWJQYXRjaGVzW2pdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvcCBoYXMgbm8gdWlBdHRyaWJzIGluIGV4cG9ydCwgd2UgZG9uJ3QgY2FyZSBhYm91dCBzdWJwYXRjaGVzIGluIGV4cG9ydCB0aG91Z2hcbiAgICAgICAgaWYgKCFmb3VuZCAmJiBqc29uLm9wc1tra10udWlBdHRyaWJzICYmIG9wdGlvbnMucGFyZW50U3ViUGF0Y2hJZCAhPSBudWxsKVxuICAgICAgICAgICAganNvbi5vcHNba2tdLnVpQXR0cmlicy5zdWJQYXRjaCA9IG9wdGlvbnMucGFyZW50U3ViUGF0Y2hJZDtcbiAgICB9XG5cbiAgICByZXR1cm4ganNvbjtcbn07XG5cbi8qKlxuICogcmVtb3ZlIGFuIGV2ZW50bGlzdGVuZXJcbiAqIEBpbnN0YW5jZVxuICogQGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIGV2ZW50XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5cbi8qKlxuICogcmVtb3ZlIGFuIGV2ZW50bGlzdGVuZXJcbiAqIEBpbnN0YW5jZVxuICogQGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIGV2ZW50XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5cbi8qKlxuICogb3AgYWRkZWQgdG8gcGF0Y2ggZXZlbnRcbiAqIEBldmVudCBvbk9wQWRkXG4gKlxuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtPcH0gb3AgbmV3IG9wXG4gKi9cblxuLyoqXG4gKiBvcCBkZWxldGVkIGZyb20gcGF0Y2hcbiAqIEBldmVudCBvbk9wRGVsZXRlXG4gKiBAbWVtYmVyb2YgUGF0Y2hcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge09wfSBvcCB0aGF0IHdpbGwgYmUgZGVsZXRlZFxuICovXG5cbi8qKlxuICogbGluayBldmVudCAtIHR3byBwb3J0cyB3aWxsIGJlIGxpbmtlZFxuICogQGV2ZW50IG9uTGlua1xuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtQb3J0fSBwb3J0MVxuICogQHByb3BlcnR5IHtQb3J0fSBwb3J0MlxuICovXG5cbi8qKlxuICogdW5saW5rIGV2ZW50IC0gYSBsaW5rIHdhcyBkZWxldGVkXG4gKiBAZXZlbnQgb25VbkxpbmtcbiAqIEBtZW1iZXJvZiBQYXRjaFxuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG4vKipcbiAqIHZhcmlhYmxlcyBoYXMgYmVlbiBjaGFuZ2VkIC8gYSB2YXJpYWJsZSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgcGF0Y2hcbiAqIEBldmVudCB2YXJpYWJsZXNDaGFuZ2VkXG4gKiBAbWVtYmVyb2YgUGF0Y2hcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge1BvcnR9IHBvcnQxXG4gKiBAcHJvcGVydHkge1BvcnR9IHBvcnQyXG4gKi9cblxuLyoqXG4gKiBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgbG9hZGluZyBhIHBhdGNoXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQYXRjaENvbmZpZ1xuICogQGhpZGVjb25zdHJ1Y3RvclxuICogQHByb3BlcnR5IHtTdHJpbmd9IFtwcmVmaXhBc3NldFBhdGg9JyddIHByZWZpeCBmb3IgcGF0aCB0byBhc3NldHNcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbYXNzZXRQYXRoPScnXSBwYXRoIHRvIGFzc2V0c1xuICogQHByb3BlcnR5IHtTdHJpbmd9IFtqc1BhdGg9JyddIHBhdGggdG8gamF2YXNjcmlwdCBmaWxlc1xuICogQHByb3BlcnR5IHtTdHJpbmd9IFtnbENhbnZhc0lkPSdnbGNhbnZhcyddIGRvbSBlbGVtZW50IGlkIG9mIGNhbnZhcyBlbGVtZW50XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb25FcnJvcj1udWxsXSBjYWxsZWQgd2hlbiBhbiBlcnJvciBvY2N1cnNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtvbkZpbmlzaGVkTG9hZGluZz1udWxsXSBjYWxsZWQgd2hlbiBwYXRjaCBmaW5pc2hlZCBsb2FkaW5nIGFsbCBhc3NldHNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtvbkZpcnN0RnJhbWVSZW5kZXJlZD1udWxsXSBjYWxsZWQgd2hlbiBwYXRjaCByZW5kZXJlZCBpdCdzIGZpcnN0IGZyYW1lXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnbENhbnZhc1Jlc2l6ZVRvV2luZG93PWZhbHNlXSByZXNpemUgY2FudmFzIGF1dG9tYXRpY2FsbHkgdG8gd2luZG93IHNpemVcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2RvUmVxdWVzdEFuaW1hdGlvbj10cnVlXSBkbyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgc2V0IHRvIGZhbHNlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgZXhlYygpIGZyb20gb3V0c2lkZSAob25seSBkbyBpZiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcpXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IFtjbGVhckNhbnZhc0NvbG9yPXRydWVdIGNsZWFyIGNhbnZhcyBpbiB0cmFuc3BhcmVudCBjb2xvciBldmVyeSBmcmFtZVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbY2xlYXJDYW52YXNEZXB0aD10cnVlXSBjbGVhciBkZXB0aCBldmVyeSBmcmFtZVxuICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2xWYWxpZGF0ZVNoYWRlcj10cnVlXSBlbmFibGUvZGlzYWJsZSB2YWxpZGF0aW9uIG9mIHNoYWRlcnMgKlxuICogQHByb3BlcnR5IHtCb29sZWFufSBbc2lsZW50PWZhbHNlXVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtmcHNMaW1pdD0wXSAwIGZvciBtYXhpbXVtIHBvc3NpYmxlIGZyYW1lcyBwZXIgc2Vjb25kXG4gKiBAcHJvcGVydHkge1N0cmluZ30gW2dsc2xQcmVjaXNpb249J21lZGl1bXAnXSBkZWZhdWx0IHByZWNpc2lvbiBmb3IgZ2xzbCBzaGFkZXJcbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgUGF0Y2g7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/core_patch.js\n");

/***/ }),

/***/ "./src/core/core_port.js":
/*!*******************************!*\
  !*** ./src/core/core_port.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Port\": () => (/* binding */ Port)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n/* harmony import */ var _eventtarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eventtarget.js */ \"./src/core/eventtarget.js\");\n/* harmony import */ var _anim_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anim.js */ \"./src/core/anim.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"./src/core/constants.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ \"./src/core/utils.js\");\n\n\n\n\n\n\n\n/**\n * data is coming into and out of ops through input and output ports\n * @external CABLES\n * @namespace Port\n * @class\n * @hideconstructor\n * @example\n * const myPort=op.inString(\"String Port\");\n */\nconst Port = function (___op, name, type, uiAttribs)\n{\n    _eventtarget_js__WEBPACK_IMPORTED_MODULE_0__.EventTarget.apply(this);\n\n    this.data = {}; // UNUSED, DEPRECATED, only left in for backwards compatibility with userops\n    this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"core_port\");\n    /**\n     * @type {Number}\n     * @name direction\n     * @instance\n     * @memberof Port\n     * @description direction of port (input(0) or output(1))\n     */\n    this.direction = _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.PORT.PORT_DIR_IN;\n    this.id = String(CABLES.simpleId());\n    this._op = ___op;\n\n    /**\n     * @type {Array<Link>}\n     * @name links\n     * @instance\n     * @memberof Port\n     * @description links of port\n     */\n    this.links = [];\n    this.value = 0.0;\n    this.name = name;\n    this.type = type || _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE;\n    this.uiAttribs = uiAttribs || {};\n    this.anim = null;\n    this._oldAnimVal = -5711;\n    this.defaultValue = null;\n\n\n    this._uiActiveState = true;\n    this.ignoreValueSerialize = false;\n    this.onLinkChanged = null;\n    this.crashed = false;\n\n    this._valueBeforeLink = null;\n    this._lastAnimFrame = -1;\n    this._animated = false;\n\n    this.onValueChanged = null;\n    this.onTriggered = null;\n    this.onUiActiveStateChange = null;\n    this.changeAlways = false;\n    this.forceRefChange = false;\n\n    this._useVariableName = null;\n\n    this.activityCounter = 0;\n    this.apf = 0;\n    this.activityCounterStartFrame = 0;\n\n    this._tempLastUiValue = null;\n\n    Object.defineProperty(this, \"title\", {\n        get()\n        {\n            return this.uiAttribs.title || this.name;\n        } });\n\n\n    Object.defineProperty(this, \"parent\", {\n        get()\n        {\n            this._log.stack(\"use port.op, not .parent\");\n            return this._op;\n        } });\n\n\n\n    Object.defineProperty(this, \"op\", {\n        get()\n        {\n            return this._op;\n        } });\n\n\n    Object.defineProperty(this, \"val\", {\n        get()\n        {\n            this._log.warn(\"val getter deprecated!\", this);\n            this._log.stack(\"val getter deprecated\");\n            return this.get();\n        },\n        set(v)\n        {\n            this._log.warn(\"val setter deprecated!\", this);\n            this._log.stack(\"val setter deprecated\");\n            this.setValue(v);\n        }\n    });\n};\n\n\n/**\n * copy over a uiattrib from an external connected port to another port\n * @function copyLinkedUiAttrib\n * @memberof Port\n * @param {which} attrib name\n * @param {Port} source port\n * @instance\n * @example\n\ninArray.onLinkChanged=()=>\n{\n    if(inArray) inArray.copyLinkedUiAttrib(\"stride\", outArray);\n};\n\n */\nPort.prototype.copyLinkedUiAttrib = function (which, port)\n{\n    if (!CABLES.UI) return;\n    if (!this.isLinked()) return;\n\n    const attr = {};\n    attr[which] = this.links[0].getOtherPort(this).getUiAttrib(which);\n    port.setUiAttribs(attr);\n};\n\n\n// TODO make extend class for ports, like for ops only for ui\nPort.prototype.getValueForDisplay = function ()\n{\n    let str = this.value;\n\n    if (typeof this.value === \"string\" || this.value instanceof String)\n    {\n        if (str.length > 1000)\n        {\n            str = str.substring(0, 999);\n            str += \"...\";\n        }\n        if (this.uiAttribs && (this.uiAttribs.display == \"boolnum\"))\n        {\n            str += \" - \";\n\n            if (!this.value) str += \"false\";\n            else str += \"true\";\n        }\n\n        str = str.replace(/[\\u00A0-\\u9999<>\\&]/g, function (i)\n        {\n            return \"&#\" + i.charCodeAt(0) + \";\";\n        });\n\n\n        if (str.length > 100) str = str.substring(0, 100);\n    }\n    else\n    {\n        str = this.value;\n    }\n    return str;\n};\n\n/**\n * change listener for input value ports, overwrite to react to changes\n * @function onChange\n * @memberof Port\n * @instance\n * @example\n * const myPort=op.inString(\"MyPort\");\n * myPort.onChange=function()\n * {\n *   console.log(\"was changed to: \",myPort.get());\n * }\n *\n */\nPort.prototype.onAnimToggle = function () {};\nPort.prototype._onAnimToggle = function ()\n{\n    this.onAnimToggle();\n};\n\n\n/**\n * @function remove\n * @memberof Port\n * @instance\n * @description remove port\n */\nPort.prototype.remove = function ()\n{\n    // this.setUiAttribs({hidePort:true});\n    this.removeLinks();\n    this._op.removePort(this);\n};\n\n/**\n * set ui attributes\n * @function setUiAttribs\n * @memberof Port\n * @instance\n * @param {Object} newAttribs\n * <pre>\n * title - overwrite title of port (by default this is portname)\n * greyout - port paramater will appear greyed out, can not be\n * hidePort - port will be hidden from op\n * hideParam - port params will be hidden from parameter panel\n * showIndex - only for dropdowns - show value index (e.g. `0 - normal` )\n * editorSyntax - set syntax highlighting theme for editor port\n * ignoreObjTypeErrors - do not auto check object types\n * </pre>\n * @example\n * myPort.setUiAttribs({greyout:true});\n */\nPort.prototype.setUiAttribs = function (newAttribs)\n{\n    let changed = false;\n    if (!this.uiAttribs) this.uiAttribs = {};\n\n    for (const p in newAttribs)\n    {\n        if (this.uiAttribs[p] != newAttribs[p]) changed = true;\n        this.uiAttribs[p] = newAttribs[p];\n\n        if (p == \"group\" && this.indexPort) this.indexPort.setUiAttribs({ \"group\": newAttribs[p] });\n    }\n\n    if (newAttribs.hasOwnProperty(\"expose\")) this._op.patch.emitEvent(\"subpatchExpose\", this._op.uiAttribs.subPatch);\n\n    if (changed) this.emitEvent(\"onUiAttrChange\", newAttribs, this);\n};\n\n/**\n * get ui attributes\n * @function getUiAttribs\n * @memberof Port\n * @example\n * myPort.getUiAttribs();\n */\nPort.prototype.getUiAttribs = function ()\n{\n    return this.uiAttribs;\n};\n\n/**\n * get ui attribute\n * @function getUiAttrib\n * @memberof Port\n * @instance\n * @param {String} attribName\n * <pre>\n * attribName - return value of the ui-attribute, or null on unknown attribute\n * </pre>\n * @example\n * myPort.setUiAttribs(\"values\");\n */\nPort.prototype.getUiAttrib = function (attribName)\n{\n    if (!this.uiAttribs || !this.uiAttribs.hasOwnProperty(attribName))\n    {\n        return null;\n    }\n    return this.uiAttribs[attribName];\n};\n\n/**\n * @function get\n * @memberof Port\n * @instance\n * @description get value of port\n */\nPort.prototype.get = function ()\n{\n    if (this._animated && this._lastAnimFrame != this._op.patch.getFrameNum())\n    {\n        this._lastAnimFrame = this._op.patch.getFrameNum();\n        this.value = this.anim.getValue(this._op.patch.timer.getTime());\n\n        this._oldAnimVal = this.value;\n        this.forceChange();\n    }\n\n    return this.value;\n};\n\nPort.prototype.setRef = function (v)\n{\n    this.forceRefChange = true;\n    this.set(v);\n};\n\n/**\n * @function setValue\n * @memberof Port\n * @instance\n * @description set value of port / will send value to all linked ports (only for output ports)\n */\nPort.prototype.set = Port.prototype.setValue = function (v)\n{\n    if (v === undefined) v = null;\n\n    if (this._op.enabled && !this.crashed)\n    {\n        if (v !== this.value || this.changeAlways || this.type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_TEXTURE || this.type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_ARRAY)\n        {\n            if (this._animated)\n            {\n                this.anim.setValue(this._op.patch.timer.getTime(), v);\n            }\n            else\n            {\n                try\n                {\n                    this.value = v;\n                    this.forceChange();\n                }\n                catch (ex)\n                {\n                    this.crashed = true;\n                    this.op.crashed = true;\n                    console.log(\"crash\", this.op.objName);\n                    this.setValue = function (_v) {};\n                    this.onTriggered = function () {};\n\n                    this._log.error(\"onvaluechanged exception cought\", ex);\n                    this._log.error(ex.stack);\n                    this._log.warn(\"exception in: \" + this._op.name);\n\n                    if (this._op.patch.isEditorMode()) gui.showOpCrash(this._op);\n\n                    this._op.patch.emitEvent(\"exception\", ex, this._op);\n                    if (this._op.onError) this._op.onError(ex);\n                }\n\n                if (this._op && this._op.patch && this._op.patch.isEditorMode() && this.type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_TEXTURE) gui.texturePreview().updateTexturePort(this);\n            }\n\n            if (this.direction == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.PORT.PORT_DIR_OUT) for (let i = 0; i < this.links.length; ++i) this.links[i].setValue();\n        }\n    }\n};\n\nPort.prototype.updateAnim = function ()\n{\n    if (this._animated)\n    {\n        this.value = this.get();\n\n        if (this._oldAnimVal != this.value || this.changeAlways)\n        {\n            this._oldAnimVal = this.value;\n            this.forceChange();\n        }\n        this._oldAnimVal = this.value;\n    }\n};\n\nPort.args = function (func)\n{\n    return (func + \"\")\n        .replace(/[/][/].*$/gm, \"\") // strip single-line comments\n        .replace(/\\s+/g, \"\") // strip white space\n        .replace(/[/][*][^/*]*[*][/]/g, \"\") // strip multi-line comments\n        .split(\"){\", 1)[0]\n        .replace(/^[^(]*[(]/, \"\") // extract the parameters\n        .replace(/=[^,]+/g, \"\") // strip any ES6 defaults\n        .split(\",\")\n        .filter(Boolean); // split & filter [\"\"]\n};\n\nPort.prototype.forceChange = function ()\n{\n    if (this.onValueChanged || this.onChange)\n    {\n        // very temporary: deprecated warning!!!!!!!!!\n        // var params=Port.args(this.onValueChanged||this.onChange)\n        // if(params.length>0) this._log.warn('TOM: port has onchange params!',this._op.objName,this.name);\n    }\n    this._activity();\n    this.emitEvent(\"change\", this.value, this);\n\n    if (this.onChange) this.onChange(this, this.value);\n    else if (this.onValueChanged) this.onValueChanged(this, this.value); // deprecated\n};\n\n/**\n * @function getTypeString\n * @memberof Port\n * @instance\n * @description get port type as string, e.g. \"Function\",\"Value\"...\n * @return {String} type\n */\nPort.prototype.getTypeString = function ()\n{\n    if (this.type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE) return \"Number\";\n    if (this.type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION) return \"Trigger\";\n    if (this.type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT) return \"Object\";\n    if (this.type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return \"Dynamic\";\n    if (this.type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_ARRAY) return \"Array\";\n    if (this.type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_STRING) return \"String\";\n    return \"Unknown\";\n};\n\nPort.prototype.deSerializeSettings = function (objPort)\n{\n    if (!objPort) return;\n    if (objPort.animated) this.setAnimated(objPort.animated);\n    if (objPort.useVariable) this.setVariableName(objPort.useVariable);\n    if (objPort.title) this.setUiAttribs({ \"title\": objPort.title });\n    if (objPort.expose) this.setUiAttribs({ \"expose\": true });\n    if (objPort.order) this.setUiAttribs({ \"order\": objPort.order });\n    if (objPort.anim)\n    {\n        if (!this.anim) this.anim = new _anim_js__WEBPACK_IMPORTED_MODULE_3__.Anim({ \"name\": \"port \" + this.name });\n        this._op._hasAnimPort = true;\n        this.anim.addEventListener(\"onChange\", () =>\n        {\n            this._op.patch.emitEvent(\"portAnimUpdated\", this._op, this, this.anim);\n        });\n        if (objPort.anim.loop) this.anim.loop = objPort.anim.loop;\n        for (const ani in objPort.anim.keys)\n        {\n            this.anim.keys.push(new _anim_js__WEBPACK_IMPORTED_MODULE_3__.ANIM.Key(objPort.anim.keys[ani]));\n        }\n        this.anim.sortKeys();\n    }\n};\n\nPort.prototype.getSerialized = function ()\n{\n    let obj = {};\n    obj.name = this.getName();\n\n    if (!this.ignoreValueSerialize && this.links.length === 0)\n    {\n        if (this.type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT && this.value && this.value.tex)\n        {\n        }\n        else obj.value = this.value;\n    }\n    if (this._useVariableName) obj.useVariable = this._useVariableName;\n    if (this._animated) obj.animated = true;\n    if (this.anim) obj.anim = this.anim.getSerialized();\n    if (this.uiAttribs.display == \"file\") obj.display = this.uiAttribs.display;\n    if (this.uiAttribs.expose)\n    {\n        obj.expose = true;\n        if (this.uiAttribs.hasOwnProperty(\"order\")) obj.order = this.uiAttribs.order;\n    }\n    if (this.uiAttribs.title) obj.title = this.uiAttribs.title;\n    if (this.direction == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.PORT.PORT_DIR_OUT && this.links.length > 0)\n    {\n        obj.links = [];\n        for (const i in this.links)\n        {\n            if (!this.links[i].ignoreInSerialize && (this.links[i].portIn && this.links[i].portOut)) obj.links.push(this.links[i].getSerialized());\n        }\n    }\n\n    if (this.direction == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.PORT.PORT_DIR_IN && this.links.length > 0)\n    {\n        for (const i in this.links)\n        {\n            if (!this.links[i].portIn || !this.links[i].portOut) continue;\n\n            const otherp = this.links[i].getOtherPort(this);\n            if (otherp.op.isInBlueprint2() && !this.op.isInBlueprint2())\n            {\n                obj.links = obj.links || [];\n                obj.links.push(this.links[i].getSerialized());\n            }\n        }\n    }\n\n    if (obj.links && obj.links.length == 0) delete obj.links;\n    if (this.type === _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION) delete obj.value;\n    if (this.type === _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION && this.links.length == 0) obj = null;\n    if (obj && Object.keys(obj).length == 1 && obj.name)obj = null;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.cleanJson)(obj);\n\n    return obj;\n};\n\nPort.prototype.shouldLink = function ()\n{\n    return true;\n};\n\n/**\n * @function removeLinks\n * @memberof Port\n * @instance\n * @description remove all links from port\n */\nPort.prototype.removeLinks = function ()\n{\n    let count = 0;\n    while (this.links.length > 0)\n    {\n        count++;\n        if (count > 5000)\n        {\n            this._log.warn(\"could not delete links... / infinite loop\");\n            this.links.length = 0;\n            break;\n        }\n        this.links[0].remove();\n    }\n};\n\n/**\n * @function removeLink\n * @memberof Port\n * @instance\n * @description remove all link from port\n * @param {CABLES.Link} link\n */\nPort.prototype.removeLink = function (link)\n{\n    for (const i in this.links)\n        if (this.links[i] == link)\n            this.links.splice(i, 1);\n\n    if (this.direction == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.PORT.PORT_DIR_IN)\n    {\n        if (this.type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE) this.setValue(this._valueBeforeLink || 0);\n        else this.setValue(this._valueBeforeLink || null);\n    }\n\n    if (CABLES.UI && this._op.checkLinkTimeWarnings) this._op.checkLinkTimeWarnings();\n\n    if (this.onLinkChanged) this.onLinkChanged();\n    this.emitEvent(\"onLinkChanged\");\n    this._op.emitEvent(\"onLinkChanged\");\n};\n\n/**\n * @function getName\n * @memberof Port\n * @instance\n * @description return port name\n */\nPort.prototype.getName = function ()\n{\n    return this.name;\n};\n\n/**\n * @function getTitle\n * @memberof Port\n * @instance\n * @description return port name or title\n */\nPort.prototype.getTitle = function ()\n{\n    if (this.uiAttribs.title) return this.uiAttribs.title;\n    return this.name;\n};\n\nPort.prototype.addLink = function (l)\n{\n    this._valueBeforeLink = this.value;\n    this.links.push(l);\n    if (CABLES.UI && this._op.checkLinkTimeWarnings) this._op.checkLinkTimeWarnings();\n\n    if (this.onLinkChanged) this.onLinkChanged();\n    this.emitEvent(\"onLinkChanged\");\n    this._op.emitEvent(\"onLinkChanged\");\n};\n\n/**\n * @function getLinkTo\n * @memberof Port\n * @instance\n * @param {Port} otherPort\n * @description return link, which is linked to otherPort\n */\nPort.prototype.getLinkTo = function (p2)\n{\n    for (const i in this.links) if (this.links[i].portIn == p2 || this.links[i].portOut == p2) return this.links[i];\n};\n\n/**\n * @function removeLinkTo\n * @memberof Port\n * @instance\n * @param {Port} otherPort\n * @description removes link, which is linked to otherPort\n */\nPort.prototype.removeLinkTo = function (p2)\n{\n    for (const i in this.links)\n    {\n        if (this.links[i].portIn == p2 || this.links[i].portOut == p2)\n        {\n            this.links[i].remove();\n            if (CABLES.UI && this._op.checkLinkTimeWarnings) this._op.checkLinkTimeWarnings();\n\n            if (this.onLinkChanged) this.onLinkChanged();\n            this.emitEvent(\"onLinkChanged\");\n            return;\n        }\n    }\n};\n\n/**\n * @function isLinkedTo\n * @memberof Port\n * @instance\n * @param {Port} otherPort\n * @description returns true if port is linked to otherPort\n */\nPort.prototype.isLinkedTo = function (p2)\n{\n    for (const i in this.links) if (this.links[i].portIn == p2 || this.links[i].portOut == p2) return true;\n\n    return false;\n};\n\nPort.prototype._activity = function ()\n{\n    this.activityCounter++;\n};\n\n/**\n * @function trigger\n * @memberof Port\n * @instance\n * @description trigger the linked port (usually invoked on an output function port)\n */\nPort.prototype.trigger = function ()\n{\n    const linksLength = this.links.length;\n\n    this._activity();\n    if (linksLength === 0) return;\n    if (!this._op.enabled) return;\n\n    let portTriggered = null;\n    try\n    {\n        for (let i = 0; i < linksLength; ++i)\n        {\n            if (this.links[i].portIn)\n            {\n                portTriggered = this.links[i].portIn;\n\n                portTriggered.op.patch.pushTriggerStack(portTriggered);\n                portTriggered._onTriggered();\n\n                portTriggered.op.patch.popTriggerStack();\n            }\n            if (this.links[i]) this.links[i].activity();\n        }\n    }\n    catch (ex)\n    {\n        portTriggered.op.enabled = false;\n\n        if (this._op.patch.isEditorMode())\n        {\n            this._op.patch.emitEvent(\"exception\", ex, portTriggered.op);\n            this._op.patch.emitEvent(\"opcrash\", portTriggered);\n            console.log(\"crash\", portTriggered.op.objName);\n\n            if (portTriggered.op.onError) portTriggered.op.onError(ex);\n        }\n        this._log.warn(\"exception!\");\n        this._log.error(\"ontriggered exception caught\", ex);\n        this._log.error(ex.stack);\n        this._log.warn(\"exception in: \" + portTriggered.op.name);\n    }\n};\n\nPort.prototype.call = function ()\n{\n    this._log.warn(\"call deprecated - use trigger() \");\n    this.trigger();\n};\n\nPort.prototype.execute = function ()\n{\n    this._log.warn(\"### execute port: \" + this.getName(), this.goals.length);\n};\n\nPort.prototype.setVariableName = function (n)\n{\n    this._useVariableName = n;\n\n\n    this._op.patch.on(\"variableRename\", (oldname, newname) =>\n    {\n        if (oldname != this._useVariableName) return;\n        this._useVariableName = newname;\n    });\n};\n\nPort.prototype.getVariableName = function ()\n{\n    return this._useVariableName;\n};\n\nPort.prototype.setVariable = function (v)\n{\n    this.setAnimated(false);\n    const attr = { \"useVariable\": false };\n\n    if (this._variableIn && this._varChangeListenerId)\n    {\n        this._variableIn.off(this._varChangeListenerId);\n        this._variableIn = null;\n    }\n\n    if (v)\n    {\n        this._variableIn = this._op.patch.getVar(v);\n\n        if (!this._variableIn)\n        {\n            this._log.warn(\"PORT VAR NOT FOUND!!!\", v);\n        }\n        else\n        {\n            if (this.type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT)\n            {\n                this._varChangeListenerId = this._variableIn.on(\"change\", () => { this.set(null); this.set(this._variableIn.getValue()); });\n            }\n            else\n            {\n                this._varChangeListenerId = this._variableIn.on(\"change\", this.set.bind(this));\n            }\n            this.set(this._variableIn.getValue());\n        }\n        this._useVariableName = v;\n        attr.useVariable = true;\n        attr.variableName = this._useVariableName;\n    }\n    else\n    {\n        attr.variableName = this._useVariableName = null;\n        attr.useVariable = false;\n    }\n\n    this.setUiAttribs(attr);\n    this._op.patch.emitEvent(\"portSetVariable\", this._op, this, v);\n};\n\nPort.prototype._handleNoTriggerOpAnimUpdates = function (a)\n{\n    let hasTriggerPort = false;\n    for (let i = 0; i < this._op.portsIn.length; i++)\n    {\n        if (this._op.portsIn.type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION)\n        {\n            hasTriggerPort = true;\n            break;\n        }\n    }\n\n    if (!hasTriggerPort)\n    {\n        if (a) this._notriggerAnimUpdate = this._op.patch.on(\"onRenderFrame\",\n            () =>\n            {\n                this.updateAnim();\n            });\n        else this._op.patch.removeEventListener(this._notriggerAnimUpdate);\n    }\n};\n\nPort.prototype.setAnimated = function (a)\n{\n    if (this._animated != a)\n    {\n        this._animated = a;\n        this._op._hasAnimPort = true;\n\n        if (this._animated && !this.anim)\n        {\n            this.anim = new _anim_js__WEBPACK_IMPORTED_MODULE_3__.Anim({ \"name\": \"port \" + this.name });\n            this.anim.addEventListener(\"onChange\", () =>\n            {\n                this._op.patch.emitEvent(\"portAnimUpdated\", this._op, this, this.anim);\n            });\n        }\n        this._onAnimToggle();\n    }\n\n    this._handleNoTriggerOpAnimUpdates(a);\n    if (!a)\n    {\n        this.anim = null;\n    }\n\n    this.setUiAttribs({ \"isAnimated\": this._animated });\n};\n\nPort.prototype.toggleAnim = function ()\n{\n    this._animated = !this._animated;\n    if (this._animated && !this.anim)\n    {\n        this.anim = new _anim_js__WEBPACK_IMPORTED_MODULE_3__.Anim({ \"name\": \"port \" + this.name });\n        this.anim.addEventListener(\"onChange\", () =>\n        {\n            this._op.patch.emitEvent(\"portAnimUpdated\", this._op, this, this.anim);\n        });\n    }\n    this.setAnimated(this._animated);\n    this._onAnimToggle();\n    this.setUiAttribs({ \"isAnimated\": this._animated });\n};\n\n/**\n * <pre>\n * CABLES.CONSTANTS.OP.OP_PORT_TYPE_VALUE = 0;\n * CABLES.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION = 1;\n * CABLES.CONSTANTS.OP.OP_PORT_TYPE_OBJECT = 2;\n * CABLES.CONSTANTS.OP.OP_PORT_TYPE_TEXTURE = 2;\n * CABLES.CONSTANTS.OP.OP_PORT_TYPE_ARRAY = 3;\n * CABLES.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC = 4;\n * CABLES.CONSTANTS.OP.OP_PORT_TYPE_STRING = 5;\n * </pre>\n * @function getType\n * @memberof Port\n * @instance\n * @return {Number} type of port\n */\nPort.prototype.getType = function ()\n{\n    return this.type;\n};\n\n/**\n * @function isLinked\n * @memberof Port\n * @instance\n * @return {Boolean} true if port is linked\n */\nPort.prototype.isLinked = function ()\n{\n    return this.links.length > 0 || this._animated || this._useVariableName != null;\n};\n\nPort.prototype.isBoundToVar = function ()\n{\n    const b = this._useVariableName != null;\n    this.uiAttribs.boundToVar = b;\n    return b;\n};\n/**\n * @function isAnimated\n * @memberof Port\n * @instance\n * @return {Boolean} true if port is animated\n */\nPort.prototype.isAnimated = function ()\n{\n    return this._animated;\n};\n\n/**\n * @function isHidden\n * @memberof Port\n * @instance\n * @return {Boolean} true if port is hidden\n */\nPort.prototype.isHidden = function ()\n{\n    return this.uiAttribs.hidePort;\n};\n\n/**\n * @function onTriggered\n * @memberof Port\n * @instance\n * @param {onTriggeredCallback} callback\n * @description set callback, which will be executed when port was triggered (usually output port)\n */\nPort.prototype._onTriggered = function (a)\n{\n    this._activity();\n    this._op.updateAnims();\n    if (this._op.enabled && this.onTriggered) this.onTriggered(a);\n};\n\nPort.prototype._onSetProfiling = function (v)\n{\n    this._op.patch.profiler.add(\"port\", this);\n    this.setValue(v);\n    // if (this._op.enabled && this.onTriggered) this.onTriggered();\n    this._op.patch.profiler.add(\"port\", null);\n};\n\nPort.prototype._onTriggeredProfiling = function ()\n{\n    // this._op.updateAnims();\n\n    if (this._op.enabled && this.onTriggered)\n    {\n        this._op.patch.profiler.add(\"port\", this);\n        this.onTriggered();\n        this._op.patch.profiler.add(\"port\", null);\n    }\n};\n\nPort.prototype.onValueChange = function (cb)\n{\n    // deprecated\n    this.onChange = cb;\n};\n\nPort.prototype.getUiActiveState = function ()\n{\n    return this._uiActiveState;\n};\n\nPort.prototype.setUiActiveState = function (onoff)\n{\n    this._uiActiveState = onoff;\n    if (this.onUiActiveStateChange) this.onUiActiveStateChange();\n};\n\nPort.prototype.hidePort = function ()\n{\n    this._log.warn(\"op.hideport() is deprecated, do not use it!\");\n};\n\n\n/**\n * Returns the port type string, e.g. \"value\" based on the port type number\n * @function portTypeNumberToString\n * @instance\n * @memberof Port\n * @param {Number} type - The port type number\n * @returns {String} - The port type as string\n */\nPort.portTypeNumberToString = function (type)\n{\n    if (type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_VALUE) return \"value\";\n    if (type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_FUNCTION) return \"function\";\n    if (type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT) return \"object\";\n    if (type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_ARRAY) return \"array\";\n    if (type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_STRING) return \"string\";\n    if (type == _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONSTANTS.OP.OP_PORT_TYPE_DYNAMIC) return \"dynamic\";\n    return \"unknown\";\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX3BvcnQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jb3JlX3BvcnQuanM/NzE2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiY2FibGVzLXNoYXJlZC1jbGllbnRcIjtcbmltcG9ydCB7IEV2ZW50VGFyZ2V0IH0gZnJvbSBcIi4vZXZlbnR0YXJnZXQuanNcIjtcbmltcG9ydCB7IEFuaW0sIEFOSU0gfSBmcm9tIFwiLi9hbmltLmpzXCI7XG5pbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IGNsZWFuSnNvbiB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5cblxuLyoqXG4gKiBkYXRhIGlzIGNvbWluZyBpbnRvIGFuZCBvdXQgb2Ygb3BzIHRocm91Z2ggaW5wdXQgYW5kIG91dHB1dCBwb3J0c1xuICogQGV4dGVybmFsIENBQkxFU1xuICogQG5hbWVzcGFjZSBQb3J0XG4gKiBAY2xhc3NcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBteVBvcnQ9b3AuaW5TdHJpbmcoXCJTdHJpbmcgUG9ydFwiKTtcbiAqL1xuY29uc3QgUG9ydCA9IGZ1bmN0aW9uIChfX19vcCwgbmFtZSwgdHlwZSwgdWlBdHRyaWJzKVxue1xuICAgIEV2ZW50VGFyZ2V0LmFwcGx5KHRoaXMpO1xuXG4gICAgdGhpcy5kYXRhID0ge307IC8vIFVOVVNFRCwgREVQUkVDQVRFRCwgb25seSBsZWZ0IGluIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHVzZXJvcHNcbiAgICB0aGlzLl9sb2cgPSBuZXcgTG9nZ2VyKFwiY29yZV9wb3J0XCIpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQG5hbWUgZGlyZWN0aW9uXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIFBvcnRcbiAgICAgKiBAZGVzY3JpcHRpb24gZGlyZWN0aW9uIG9mIHBvcnQgKGlucHV0KDApIG9yIG91dHB1dCgxKSlcbiAgICAgKi9cbiAgICB0aGlzLmRpcmVjdGlvbiA9IENPTlNUQU5UUy5QT1JULlBPUlRfRElSX0lOO1xuICAgIHRoaXMuaWQgPSBTdHJpbmcoQ0FCTEVTLnNpbXBsZUlkKCkpO1xuICAgIHRoaXMuX29wID0gX19fb3A7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8TGluaz59XG4gICAgICogQG5hbWUgbGlua3NcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgUG9ydFxuICAgICAqIEBkZXNjcmlwdGlvbiBsaW5rcyBvZiBwb3J0XG4gICAgICovXG4gICAgdGhpcy5saW5rcyA9IFtdO1xuICAgIHRoaXMudmFsdWUgPSAwLjA7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUU7XG4gICAgdGhpcy51aUF0dHJpYnMgPSB1aUF0dHJpYnMgfHwge307XG4gICAgdGhpcy5hbmltID0gbnVsbDtcbiAgICB0aGlzLl9vbGRBbmltVmFsID0gLTU3MTE7XG4gICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBudWxsO1xuXG5cbiAgICB0aGlzLl91aUFjdGl2ZVN0YXRlID0gdHJ1ZTtcbiAgICB0aGlzLmlnbm9yZVZhbHVlU2VyaWFsaXplID0gZmFsc2U7XG4gICAgdGhpcy5vbkxpbmtDaGFuZ2VkID0gbnVsbDtcbiAgICB0aGlzLmNyYXNoZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX3ZhbHVlQmVmb3JlTGluayA9IG51bGw7XG4gICAgdGhpcy5fbGFzdEFuaW1GcmFtZSA9IC0xO1xuICAgIHRoaXMuX2FuaW1hdGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLm9uVmFsdWVDaGFuZ2VkID0gbnVsbDtcbiAgICB0aGlzLm9uVHJpZ2dlcmVkID0gbnVsbDtcbiAgICB0aGlzLm9uVWlBY3RpdmVTdGF0ZUNoYW5nZSA9IG51bGw7XG4gICAgdGhpcy5jaGFuZ2VBbHdheXMgPSBmYWxzZTtcbiAgICB0aGlzLmZvcmNlUmVmQ2hhbmdlID0gZmFsc2U7XG5cbiAgICB0aGlzLl91c2VWYXJpYWJsZU5hbWUgPSBudWxsO1xuXG4gICAgdGhpcy5hY3Rpdml0eUNvdW50ZXIgPSAwO1xuICAgIHRoaXMuYXBmID0gMDtcbiAgICB0aGlzLmFjdGl2aXR5Q291bnRlclN0YXJ0RnJhbWUgPSAwO1xuXG4gICAgdGhpcy5fdGVtcExhc3RVaVZhbHVlID0gbnVsbDtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRpdGxlXCIsIHtcbiAgICAgICAgZ2V0KClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudWlBdHRyaWJzLnRpdGxlIHx8IHRoaXMubmFtZTtcbiAgICAgICAgfSB9KTtcblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGFyZW50XCIsIHtcbiAgICAgICAgZ2V0KClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9nLnN0YWNrKFwidXNlIHBvcnQub3AsIG5vdCAucGFyZW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wO1xuICAgICAgICB9IH0pO1xuXG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9wXCIsIHtcbiAgICAgICAgZ2V0KClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wO1xuICAgICAgICB9IH0pO1xuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWxcIiwge1xuICAgICAgICBnZXQoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9sb2cud2FybihcInZhbCBnZXR0ZXIgZGVwcmVjYXRlZCFcIiwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9sb2cuc3RhY2soXCJ2YWwgZ2V0dGVyIGRlcHJlY2F0ZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHYpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwidmFsIHNldHRlciBkZXByZWNhdGVkIVwiLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5zdGFjayhcInZhbCBzZXR0ZXIgZGVwcmVjYXRlZFwiKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodik7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBjb3B5IG92ZXIgYSB1aWF0dHJpYiBmcm9tIGFuIGV4dGVybmFsIGNvbm5lY3RlZCBwb3J0IHRvIGFub3RoZXIgcG9ydFxuICogQGZ1bmN0aW9uIGNvcHlMaW5rZWRVaUF0dHJpYlxuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBwYXJhbSB7d2hpY2h9IGF0dHJpYiBuYW1lXG4gKiBAcGFyYW0ge1BvcnR9IHNvdXJjZSBwb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEBleGFtcGxlXG5cbmluQXJyYXkub25MaW5rQ2hhbmdlZD0oKT0+XG57XG4gICAgaWYoaW5BcnJheSkgaW5BcnJheS5jb3B5TGlua2VkVWlBdHRyaWIoXCJzdHJpZGVcIiwgb3V0QXJyYXkpO1xufTtcblxuICovXG5Qb3J0LnByb3RvdHlwZS5jb3B5TGlua2VkVWlBdHRyaWIgPSBmdW5jdGlvbiAod2hpY2gsIHBvcnQpXG57XG4gICAgaWYgKCFDQUJMRVMuVUkpIHJldHVybjtcbiAgICBpZiAoIXRoaXMuaXNMaW5rZWQoKSkgcmV0dXJuO1xuXG4gICAgY29uc3QgYXR0ciA9IHt9O1xuICAgIGF0dHJbd2hpY2hdID0gdGhpcy5saW5rc1swXS5nZXRPdGhlclBvcnQodGhpcykuZ2V0VWlBdHRyaWIod2hpY2gpO1xuICAgIHBvcnQuc2V0VWlBdHRyaWJzKGF0dHIpO1xufTtcblxuXG4vLyBUT0RPIG1ha2UgZXh0ZW5kIGNsYXNzIGZvciBwb3J0cywgbGlrZSBmb3Igb3BzIG9ubHkgZm9yIHVpXG5Qb3J0LnByb3RvdHlwZS5nZXRWYWx1ZUZvckRpc3BsYXkgPSBmdW5jdGlvbiAoKVxue1xuICAgIGxldCBzdHIgPSB0aGlzLnZhbHVlO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLnZhbHVlID09PSBcInN0cmluZ1wiIHx8IHRoaXMudmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpXG4gICAge1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDEwMDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgOTk5KTtcbiAgICAgICAgICAgIHN0ciArPSBcIi4uLlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVpQXR0cmlicyAmJiAodGhpcy51aUF0dHJpYnMuZGlzcGxheSA9PSBcImJvb2xudW1cIikpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0ciArPSBcIiAtIFwiO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMudmFsdWUpIHN0ciArPSBcImZhbHNlXCI7XG4gICAgICAgICAgICBlbHNlIHN0ciArPSBcInRydWVcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9bXFx1MDBBMC1cXHU5OTk5PD5cXCZdL2csIGZ1bmN0aW9uIChpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gXCImI1wiICsgaS5jaGFyQ29kZUF0KDApICsgXCI7XCI7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgMTAwKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgc3RyID0gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogY2hhbmdlIGxpc3RlbmVyIGZvciBpbnB1dCB2YWx1ZSBwb3J0cywgb3ZlcndyaXRlIHRvIHJlYWN0IHRvIGNoYW5nZXNcbiAqIEBmdW5jdGlvbiBvbkNoYW5nZVxuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBpbnN0YW5jZVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG15UG9ydD1vcC5pblN0cmluZyhcIk15UG9ydFwiKTtcbiAqIG15UG9ydC5vbkNoYW5nZT1mdW5jdGlvbigpXG4gKiB7XG4gKiAgIGNvbnNvbGUubG9nKFwid2FzIGNoYW5nZWQgdG86IFwiLG15UG9ydC5nZXQoKSk7XG4gKiB9XG4gKlxuICovXG5Qb3J0LnByb3RvdHlwZS5vbkFuaW1Ub2dnbGUgPSBmdW5jdGlvbiAoKSB7fTtcblBvcnQucHJvdG90eXBlLl9vbkFuaW1Ub2dnbGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMub25BbmltVG9nZ2xlKCk7XG59O1xuXG5cbi8qKlxuICogQGZ1bmN0aW9uIHJlbW92ZVxuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIHJlbW92ZSBwb3J0XG4gKi9cblBvcnQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gdGhpcy5zZXRVaUF0dHJpYnMoe2hpZGVQb3J0OnRydWV9KTtcbiAgICB0aGlzLnJlbW92ZUxpbmtzKCk7XG4gICAgdGhpcy5fb3AucmVtb3ZlUG9ydCh0aGlzKTtcbn07XG5cbi8qKlxuICogc2V0IHVpIGF0dHJpYnV0ZXNcbiAqIEBmdW5jdGlvbiBzZXRVaUF0dHJpYnNcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXdBdHRyaWJzXG4gKiA8cHJlPlxuICogdGl0bGUgLSBvdmVyd3JpdGUgdGl0bGUgb2YgcG9ydCAoYnkgZGVmYXVsdCB0aGlzIGlzIHBvcnRuYW1lKVxuICogZ3JleW91dCAtIHBvcnQgcGFyYW1hdGVyIHdpbGwgYXBwZWFyIGdyZXllZCBvdXQsIGNhbiBub3QgYmVcbiAqIGhpZGVQb3J0IC0gcG9ydCB3aWxsIGJlIGhpZGRlbiBmcm9tIG9wXG4gKiBoaWRlUGFyYW0gLSBwb3J0IHBhcmFtcyB3aWxsIGJlIGhpZGRlbiBmcm9tIHBhcmFtZXRlciBwYW5lbFxuICogc2hvd0luZGV4IC0gb25seSBmb3IgZHJvcGRvd25zIC0gc2hvdyB2YWx1ZSBpbmRleCAoZS5nLiBgMCAtIG5vcm1hbGAgKVxuICogZWRpdG9yU3ludGF4IC0gc2V0IHN5bnRheCBoaWdobGlnaHRpbmcgdGhlbWUgZm9yIGVkaXRvciBwb3J0XG4gKiBpZ25vcmVPYmpUeXBlRXJyb3JzIC0gZG8gbm90IGF1dG8gY2hlY2sgb2JqZWN0IHR5cGVzXG4gKiA8L3ByZT5cbiAqIEBleGFtcGxlXG4gKiBteVBvcnQuc2V0VWlBdHRyaWJzKHtncmV5b3V0OnRydWV9KTtcbiAqL1xuUG9ydC5wcm90b3R5cGUuc2V0VWlBdHRyaWJzID0gZnVuY3Rpb24gKG5ld0F0dHJpYnMpXG57XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMudWlBdHRyaWJzKSB0aGlzLnVpQXR0cmlicyA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBwIGluIG5ld0F0dHJpYnMpXG4gICAge1xuICAgICAgICBpZiAodGhpcy51aUF0dHJpYnNbcF0gIT0gbmV3QXR0cmlic1twXSkgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudWlBdHRyaWJzW3BdID0gbmV3QXR0cmlic1twXTtcblxuICAgICAgICBpZiAocCA9PSBcImdyb3VwXCIgJiYgdGhpcy5pbmRleFBvcnQpIHRoaXMuaW5kZXhQb3J0LnNldFVpQXR0cmlicyh7IFwiZ3JvdXBcIjogbmV3QXR0cmlic1twXSB9KTtcbiAgICB9XG5cbiAgICBpZiAobmV3QXR0cmlicy5oYXNPd25Qcm9wZXJ0eShcImV4cG9zZVwiKSkgdGhpcy5fb3AucGF0Y2guZW1pdEV2ZW50KFwic3VicGF0Y2hFeHBvc2VcIiwgdGhpcy5fb3AudWlBdHRyaWJzLnN1YlBhdGNoKTtcblxuICAgIGlmIChjaGFuZ2VkKSB0aGlzLmVtaXRFdmVudChcIm9uVWlBdHRyQ2hhbmdlXCIsIG5ld0F0dHJpYnMsIHRoaXMpO1xufTtcblxuLyoqXG4gKiBnZXQgdWkgYXR0cmlidXRlc1xuICogQGZ1bmN0aW9uIGdldFVpQXR0cmlic1xuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBleGFtcGxlXG4gKiBteVBvcnQuZ2V0VWlBdHRyaWJzKCk7XG4gKi9cblBvcnQucHJvdG90eXBlLmdldFVpQXR0cmlicyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMudWlBdHRyaWJzO1xufTtcblxuLyoqXG4gKiBnZXQgdWkgYXR0cmlidXRlXG4gKiBAZnVuY3Rpb24gZ2V0VWlBdHRyaWJcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJOYW1lXG4gKiA8cHJlPlxuICogYXR0cmliTmFtZSAtIHJldHVybiB2YWx1ZSBvZiB0aGUgdWktYXR0cmlidXRlLCBvciBudWxsIG9uIHVua25vd24gYXR0cmlidXRlXG4gKiA8L3ByZT5cbiAqIEBleGFtcGxlXG4gKiBteVBvcnQuc2V0VWlBdHRyaWJzKFwidmFsdWVzXCIpO1xuICovXG5Qb3J0LnByb3RvdHlwZS5nZXRVaUF0dHJpYiA9IGZ1bmN0aW9uIChhdHRyaWJOYW1lKVxue1xuICAgIGlmICghdGhpcy51aUF0dHJpYnMgfHwgIXRoaXMudWlBdHRyaWJzLmhhc093blByb3BlcnR5KGF0dHJpYk5hbWUpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVpQXR0cmlic1thdHRyaWJOYW1lXTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGdldFxuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIGdldCB2YWx1ZSBvZiBwb3J0XG4gKi9cblBvcnQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX2FuaW1hdGVkICYmIHRoaXMuX2xhc3RBbmltRnJhbWUgIT0gdGhpcy5fb3AucGF0Y2guZ2V0RnJhbWVOdW0oKSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2xhc3RBbmltRnJhbWUgPSB0aGlzLl9vcC5wYXRjaC5nZXRGcmFtZU51bSgpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5hbmltLmdldFZhbHVlKHRoaXMuX29wLnBhdGNoLnRpbWVyLmdldFRpbWUoKSk7XG5cbiAgICAgICAgdGhpcy5fb2xkQW5pbVZhbCA9IHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMuZm9yY2VDaGFuZ2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5cblBvcnQucHJvdG90eXBlLnNldFJlZiA9IGZ1bmN0aW9uICh2KVxue1xuICAgIHRoaXMuZm9yY2VSZWZDaGFuZ2UgPSB0cnVlO1xuICAgIHRoaXMuc2V0KHYpO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gc2V0VmFsdWVcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEBkZXNjcmlwdGlvbiBzZXQgdmFsdWUgb2YgcG9ydCAvIHdpbGwgc2VuZCB2YWx1ZSB0byBhbGwgbGlua2VkIHBvcnRzIChvbmx5IGZvciBvdXRwdXQgcG9ydHMpXG4gKi9cblBvcnQucHJvdG90eXBlLnNldCA9IFBvcnQucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHYpXG57XG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkgdiA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5fb3AuZW5hYmxlZCAmJiAhdGhpcy5jcmFzaGVkKVxuICAgIHtcbiAgICAgICAgaWYgKHYgIT09IHRoaXMudmFsdWUgfHwgdGhpcy5jaGFuZ2VBbHdheXMgfHwgdGhpcy50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVEVYVFVSRSB8fCB0aGlzLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9BUlJBWSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbS5zZXRWYWx1ZSh0aGlzLl9vcC5wYXRjaC50aW1lci5nZXRUaW1lKCksIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGV4KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmFzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcC5jcmFzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjcmFzaFwiLCB0aGlzLm9wLm9iak5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlID0gZnVuY3Rpb24gKF92KSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblRyaWdnZXJlZCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihcIm9udmFsdWVjaGFuZ2VkIGV4Y2VwdGlvbiBjb3VnaHRcIiwgZXgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IoZXguc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2FybihcImV4Y2VwdGlvbiBpbjogXCIgKyB0aGlzLl9vcC5uYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3AucGF0Y2guaXNFZGl0b3JNb2RlKCkpIGd1aS5zaG93T3BDcmFzaCh0aGlzLl9vcCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3AucGF0Y2guZW1pdEV2ZW50KFwiZXhjZXB0aW9uXCIsIGV4LCB0aGlzLl9vcCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcC5vbkVycm9yKSB0aGlzLl9vcC5vbkVycm9yKGV4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3AgJiYgdGhpcy5fb3AucGF0Y2ggJiYgdGhpcy5fb3AucGF0Y2guaXNFZGl0b3JNb2RlKCkgJiYgdGhpcy50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVEVYVFVSRSkgZ3VpLnRleHR1cmVQcmV2aWV3KCkudXBkYXRlVGV4dHVyZVBvcnQodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PSBDT05TVEFOVFMuUE9SVC5QT1JUX0RJUl9PVVQpIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5saW5rcy5sZW5ndGg7ICsraSkgdGhpcy5saW5rc1tpXS5zZXRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUG9ydC5wcm90b3R5cGUudXBkYXRlQW5pbSA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX2FuaW1hdGVkKVxuICAgIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX29sZEFuaW1WYWwgIT0gdGhpcy52YWx1ZSB8fCB0aGlzLmNoYW5nZUFsd2F5cylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fb2xkQW5pbVZhbCA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB0aGlzLmZvcmNlQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2xkQW5pbVZhbCA9IHRoaXMudmFsdWU7XG4gICAgfVxufTtcblxuUG9ydC5hcmdzID0gZnVuY3Rpb24gKGZ1bmMpXG57XG4gICAgcmV0dXJuIChmdW5jICsgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoL1svXVsvXS4qJC9nbSwgXCJcIikgLy8gc3RyaXAgc2luZ2xlLWxpbmUgY29tbWVudHNcbiAgICAgICAgLnJlcGxhY2UoL1xccysvZywgXCJcIikgLy8gc3RyaXAgd2hpdGUgc3BhY2VcbiAgICAgICAgLnJlcGxhY2UoL1svXVsqXVteLypdKlsqXVsvXS9nLCBcIlwiKSAvLyBzdHJpcCBtdWx0aS1saW5lIGNvbW1lbnRzXG4gICAgICAgIC5zcGxpdChcIil7XCIsIDEpWzBdXG4gICAgICAgIC5yZXBsYWNlKC9eW14oXSpbKF0vLCBcIlwiKSAvLyBleHRyYWN0IHRoZSBwYXJhbWV0ZXJzXG4gICAgICAgIC5yZXBsYWNlKC89W14sXSsvZywgXCJcIikgLy8gc3RyaXAgYW55IEVTNiBkZWZhdWx0c1xuICAgICAgICAuc3BsaXQoXCIsXCIpXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbik7IC8vIHNwbGl0ICYgZmlsdGVyIFtcIlwiXVxufTtcblxuUG9ydC5wcm90b3R5cGUuZm9yY2VDaGFuZ2UgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLm9uVmFsdWVDaGFuZ2VkIHx8IHRoaXMub25DaGFuZ2UpXG4gICAge1xuICAgICAgICAvLyB2ZXJ5IHRlbXBvcmFyeTogZGVwcmVjYXRlZCB3YXJuaW5nISEhISEhISEhXG4gICAgICAgIC8vIHZhciBwYXJhbXM9UG9ydC5hcmdzKHRoaXMub25WYWx1ZUNoYW5nZWR8fHRoaXMub25DaGFuZ2UpXG4gICAgICAgIC8vIGlmKHBhcmFtcy5sZW5ndGg+MCkgdGhpcy5fbG9nLndhcm4oJ1RPTTogcG9ydCBoYXMgb25jaGFuZ2UgcGFyYW1zIScsdGhpcy5fb3Aub2JqTmFtZSx0aGlzLm5hbWUpO1xuICAgIH1cbiAgICB0aGlzLl9hY3Rpdml0eSgpO1xuICAgIHRoaXMuZW1pdEV2ZW50KFwiY2hhbmdlXCIsIHRoaXMudmFsdWUsIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMub25DaGFuZ2UpIHRoaXMub25DaGFuZ2UodGhpcywgdGhpcy52YWx1ZSk7XG4gICAgZWxzZSBpZiAodGhpcy5vblZhbHVlQ2hhbmdlZCkgdGhpcy5vblZhbHVlQ2hhbmdlZCh0aGlzLCB0aGlzLnZhbHVlKTsgLy8gZGVwcmVjYXRlZFxufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gZ2V0VHlwZVN0cmluZ1xuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIGdldCBwb3J0IHR5cGUgYXMgc3RyaW5nLCBlLmcuIFwiRnVuY3Rpb25cIixcIlZhbHVlXCIuLi5cbiAqIEByZXR1cm4ge1N0cmluZ30gdHlwZVxuICovXG5Qb3J0LnByb3RvdHlwZS5nZXRUeXBlU3RyaW5nID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUpIHJldHVybiBcIk51bWJlclwiO1xuICAgIGlmICh0aGlzLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9GVU5DVElPTikgcmV0dXJuIFwiVHJpZ2dlclwiO1xuICAgIGlmICh0aGlzLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9PQkpFQ1QpIHJldHVybiBcIk9iamVjdFwiO1xuICAgIGlmICh0aGlzLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9EWU5BTUlDKSByZXR1cm4gXCJEeW5hbWljXCI7XG4gICAgaWYgKHRoaXMudHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0FSUkFZKSByZXR1cm4gXCJBcnJheVwiO1xuICAgIGlmICh0aGlzLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9TVFJJTkcpIHJldHVybiBcIlN0cmluZ1wiO1xuICAgIHJldHVybiBcIlVua25vd25cIjtcbn07XG5cblBvcnQucHJvdG90eXBlLmRlU2VyaWFsaXplU2V0dGluZ3MgPSBmdW5jdGlvbiAob2JqUG9ydClcbntcbiAgICBpZiAoIW9ialBvcnQpIHJldHVybjtcbiAgICBpZiAob2JqUG9ydC5hbmltYXRlZCkgdGhpcy5zZXRBbmltYXRlZChvYmpQb3J0LmFuaW1hdGVkKTtcbiAgICBpZiAob2JqUG9ydC51c2VWYXJpYWJsZSkgdGhpcy5zZXRWYXJpYWJsZU5hbWUob2JqUG9ydC51c2VWYXJpYWJsZSk7XG4gICAgaWYgKG9ialBvcnQudGl0bGUpIHRoaXMuc2V0VWlBdHRyaWJzKHsgXCJ0aXRsZVwiOiBvYmpQb3J0LnRpdGxlIH0pO1xuICAgIGlmIChvYmpQb3J0LmV4cG9zZSkgdGhpcy5zZXRVaUF0dHJpYnMoeyBcImV4cG9zZVwiOiB0cnVlIH0pO1xuICAgIGlmIChvYmpQb3J0Lm9yZGVyKSB0aGlzLnNldFVpQXR0cmlicyh7IFwib3JkZXJcIjogb2JqUG9ydC5vcmRlciB9KTtcbiAgICBpZiAob2JqUG9ydC5hbmltKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLmFuaW0pIHRoaXMuYW5pbSA9IG5ldyBBbmltKHsgXCJuYW1lXCI6IFwicG9ydCBcIiArIHRoaXMubmFtZSB9KTtcbiAgICAgICAgdGhpcy5fb3AuX2hhc0FuaW1Qb3J0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbmltLmFkZEV2ZW50TGlzdGVuZXIoXCJvbkNoYW5nZVwiLCAoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vcC5wYXRjaC5lbWl0RXZlbnQoXCJwb3J0QW5pbVVwZGF0ZWRcIiwgdGhpcy5fb3AsIHRoaXMsIHRoaXMuYW5pbSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob2JqUG9ydC5hbmltLmxvb3ApIHRoaXMuYW5pbS5sb29wID0gb2JqUG9ydC5hbmltLmxvb3A7XG4gICAgICAgIGZvciAoY29uc3QgYW5pIGluIG9ialBvcnQuYW5pbS5rZXlzKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFuaW0ua2V5cy5wdXNoKG5ldyBBTklNLktleShvYmpQb3J0LmFuaW0ua2V5c1thbmldKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltLnNvcnRLZXlzKCk7XG4gICAgfVxufTtcblxuUG9ydC5wcm90b3R5cGUuZ2V0U2VyaWFsaXplZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgbGV0IG9iaiA9IHt9O1xuICAgIG9iai5uYW1lID0gdGhpcy5nZXROYW1lKCk7XG5cbiAgICBpZiAoIXRoaXMuaWdub3JlVmFsdWVTZXJpYWxpemUgJiYgdGhpcy5saW5rcy5sZW5ndGggPT09IDApXG4gICAge1xuICAgICAgICBpZiAodGhpcy50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfT0JKRUNUICYmIHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZS50ZXgpXG4gICAgICAgIHtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIG9iai52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl91c2VWYXJpYWJsZU5hbWUpIG9iai51c2VWYXJpYWJsZSA9IHRoaXMuX3VzZVZhcmlhYmxlTmFtZTtcbiAgICBpZiAodGhpcy5fYW5pbWF0ZWQpIG9iai5hbmltYXRlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuYW5pbSkgb2JqLmFuaW0gPSB0aGlzLmFuaW0uZ2V0U2VyaWFsaXplZCgpO1xuICAgIGlmICh0aGlzLnVpQXR0cmlicy5kaXNwbGF5ID09IFwiZmlsZVwiKSBvYmouZGlzcGxheSA9IHRoaXMudWlBdHRyaWJzLmRpc3BsYXk7XG4gICAgaWYgKHRoaXMudWlBdHRyaWJzLmV4cG9zZSlcbiAgICB7XG4gICAgICAgIG9iai5leHBvc2UgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy51aUF0dHJpYnMuaGFzT3duUHJvcGVydHkoXCJvcmRlclwiKSkgb2JqLm9yZGVyID0gdGhpcy51aUF0dHJpYnMub3JkZXI7XG4gICAgfVxuICAgIGlmICh0aGlzLnVpQXR0cmlicy50aXRsZSkgb2JqLnRpdGxlID0gdGhpcy51aUF0dHJpYnMudGl0bGU7XG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uID09IENPTlNUQU5UUy5QT1JULlBPUlRfRElSX09VVCAmJiB0aGlzLmxpbmtzLmxlbmd0aCA+IDApXG4gICAge1xuICAgICAgICBvYmoubGlua3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpIGluIHRoaXMubGlua3MpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5saW5rc1tpXS5pZ25vcmVJblNlcmlhbGl6ZSAmJiAodGhpcy5saW5rc1tpXS5wb3J0SW4gJiYgdGhpcy5saW5rc1tpXS5wb3J0T3V0KSkgb2JqLmxpbmtzLnB1c2godGhpcy5saW5rc1tpXS5nZXRTZXJpYWxpemVkKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uID09IENPTlNUQU5UUy5QT1JULlBPUlRfRElSX0lOICYmIHRoaXMubGlua3MubGVuZ3RoID4gMClcbiAgICB7XG4gICAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLmxpbmtzKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGlua3NbaV0ucG9ydEluIHx8ICF0aGlzLmxpbmtzW2ldLnBvcnRPdXQpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCBvdGhlcnAgPSB0aGlzLmxpbmtzW2ldLmdldE90aGVyUG9ydCh0aGlzKTtcbiAgICAgICAgICAgIGlmIChvdGhlcnAub3AuaXNJbkJsdWVwcmludDIoKSAmJiAhdGhpcy5vcC5pc0luQmx1ZXByaW50MigpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9iai5saW5rcyA9IG9iai5saW5rcyB8fCBbXTtcbiAgICAgICAgICAgICAgICBvYmoubGlua3MucHVzaCh0aGlzLmxpbmtzW2ldLmdldFNlcmlhbGl6ZWQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2JqLmxpbmtzICYmIG9iai5saW5rcy5sZW5ndGggPT0gMCkgZGVsZXRlIG9iai5saW5rcztcbiAgICBpZiAodGhpcy50eXBlID09PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0ZVTkNUSU9OKSBkZWxldGUgb2JqLnZhbHVlO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfRlVOQ1RJT04gJiYgdGhpcy5saW5rcy5sZW5ndGggPT0gMCkgb2JqID0gbnVsbDtcbiAgICBpZiAob2JqICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09IDEgJiYgb2JqLm5hbWUpb2JqID0gbnVsbDtcbiAgICBjbGVhbkpzb24ob2JqKTtcblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5zaG91bGRMaW5rID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIHJlbW92ZUxpbmtzXG4gKiBAbWVtYmVyb2YgUG9ydFxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gcmVtb3ZlIGFsbCBsaW5rcyBmcm9tIHBvcnRcbiAqL1xuUG9ydC5wcm90b3R5cGUucmVtb3ZlTGlua3MgPSBmdW5jdGlvbiAoKVxue1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgd2hpbGUgKHRoaXMubGlua3MubGVuZ3RoID4gMClcbiAgICB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIGlmIChjb3VudCA+IDUwMDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiY291bGQgbm90IGRlbGV0ZSBsaW5rcy4uLiAvIGluZmluaXRlIGxvb3BcIik7XG4gICAgICAgICAgICB0aGlzLmxpbmtzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmtzWzBdLnJlbW92ZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIHJlbW92ZUxpbmtcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEBkZXNjcmlwdGlvbiByZW1vdmUgYWxsIGxpbmsgZnJvbSBwb3J0XG4gKiBAcGFyYW0ge0NBQkxFUy5MaW5rfSBsaW5rXG4gKi9cblBvcnQucHJvdG90eXBlLnJlbW92ZUxpbmsgPSBmdW5jdGlvbiAobGluaylcbntcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5saW5rcylcbiAgICAgICAgaWYgKHRoaXMubGlua3NbaV0gPT0gbGluaylcbiAgICAgICAgICAgIHRoaXMubGlua3Muc3BsaWNlKGksIDEpO1xuXG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uID09IENPTlNUQU5UUy5QT1JULlBPUlRfRElSX0lOKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFKSB0aGlzLnNldFZhbHVlKHRoaXMuX3ZhbHVlQmVmb3JlTGluayB8fCAwKTtcbiAgICAgICAgZWxzZSB0aGlzLnNldFZhbHVlKHRoaXMuX3ZhbHVlQmVmb3JlTGluayB8fCBudWxsKTtcbiAgICB9XG5cbiAgICBpZiAoQ0FCTEVTLlVJICYmIHRoaXMuX29wLmNoZWNrTGlua1RpbWVXYXJuaW5ncykgdGhpcy5fb3AuY2hlY2tMaW5rVGltZVdhcm5pbmdzKCk7XG5cbiAgICBpZiAodGhpcy5vbkxpbmtDaGFuZ2VkKSB0aGlzLm9uTGlua0NoYW5nZWQoKTtcbiAgICB0aGlzLmVtaXRFdmVudChcIm9uTGlua0NoYW5nZWRcIik7XG4gICAgdGhpcy5fb3AuZW1pdEV2ZW50KFwib25MaW5rQ2hhbmdlZFwiKTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIGdldE5hbWVcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEBkZXNjcmlwdGlvbiByZXR1cm4gcG9ydCBuYW1lXG4gKi9cblBvcnQucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBnZXRUaXRsZVxuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBpbnN0YW5jZVxuICogQGRlc2NyaXB0aW9uIHJldHVybiBwb3J0IG5hbWUgb3IgdGl0bGVcbiAqL1xuUG9ydC5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLnVpQXR0cmlicy50aXRsZSkgcmV0dXJuIHRoaXMudWlBdHRyaWJzLnRpdGxlO1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5hZGRMaW5rID0gZnVuY3Rpb24gKGwpXG57XG4gICAgdGhpcy5fdmFsdWVCZWZvcmVMaW5rID0gdGhpcy52YWx1ZTtcbiAgICB0aGlzLmxpbmtzLnB1c2gobCk7XG4gICAgaWYgKENBQkxFUy5VSSAmJiB0aGlzLl9vcC5jaGVja0xpbmtUaW1lV2FybmluZ3MpIHRoaXMuX29wLmNoZWNrTGlua1RpbWVXYXJuaW5ncygpO1xuXG4gICAgaWYgKHRoaXMub25MaW5rQ2hhbmdlZCkgdGhpcy5vbkxpbmtDaGFuZ2VkKCk7XG4gICAgdGhpcy5lbWl0RXZlbnQoXCJvbkxpbmtDaGFuZ2VkXCIpO1xuICAgIHRoaXMuX29wLmVtaXRFdmVudChcIm9uTGlua0NoYW5nZWRcIik7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBnZXRMaW5rVG9cbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7UG9ydH0gb3RoZXJQb3J0XG4gKiBAZGVzY3JpcHRpb24gcmV0dXJuIGxpbmssIHdoaWNoIGlzIGxpbmtlZCB0byBvdGhlclBvcnRcbiAqL1xuUG9ydC5wcm90b3R5cGUuZ2V0TGlua1RvID0gZnVuY3Rpb24gKHAyKVxue1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLmxpbmtzKSBpZiAodGhpcy5saW5rc1tpXS5wb3J0SW4gPT0gcDIgfHwgdGhpcy5saW5rc1tpXS5wb3J0T3V0ID09IHAyKSByZXR1cm4gdGhpcy5saW5rc1tpXTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIHJlbW92ZUxpbmtUb1xuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtQb3J0fSBvdGhlclBvcnRcbiAqIEBkZXNjcmlwdGlvbiByZW1vdmVzIGxpbmssIHdoaWNoIGlzIGxpbmtlZCB0byBvdGhlclBvcnRcbiAqL1xuUG9ydC5wcm90b3R5cGUucmVtb3ZlTGlua1RvID0gZnVuY3Rpb24gKHAyKVxue1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLmxpbmtzKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMubGlua3NbaV0ucG9ydEluID09IHAyIHx8IHRoaXMubGlua3NbaV0ucG9ydE91dCA9PSBwMilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5saW5rc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICAgIGlmIChDQUJMRVMuVUkgJiYgdGhpcy5fb3AuY2hlY2tMaW5rVGltZVdhcm5pbmdzKSB0aGlzLl9vcC5jaGVja0xpbmtUaW1lV2FybmluZ3MoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub25MaW5rQ2hhbmdlZCkgdGhpcy5vbkxpbmtDaGFuZ2VkKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcIm9uTGlua0NoYW5nZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBpc0xpbmtlZFRvXG4gKiBAbWVtYmVyb2YgUG9ydFxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1BvcnR9IG90aGVyUG9ydFxuICogQGRlc2NyaXB0aW9uIHJldHVybnMgdHJ1ZSBpZiBwb3J0IGlzIGxpbmtlZCB0byBvdGhlclBvcnRcbiAqL1xuUG9ydC5wcm90b3R5cGUuaXNMaW5rZWRUbyA9IGZ1bmN0aW9uIChwMilcbntcbiAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5saW5rcykgaWYgKHRoaXMubGlua3NbaV0ucG9ydEluID09IHAyIHx8IHRoaXMubGlua3NbaV0ucG9ydE91dCA9PSBwMikgcmV0dXJuIHRydWU7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5fYWN0aXZpdHkgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuYWN0aXZpdHlDb3VudGVyKys7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiB0cmlnZ2VyXG4gKiBAbWVtYmVyb2YgUG9ydFxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gdHJpZ2dlciB0aGUgbGlua2VkIHBvcnQgKHVzdWFsbHkgaW52b2tlZCBvbiBhbiBvdXRwdXQgZnVuY3Rpb24gcG9ydClcbiAqL1xuUG9ydC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uICgpXG57XG4gICAgY29uc3QgbGlua3NMZW5ndGggPSB0aGlzLmxpbmtzLmxlbmd0aDtcblxuICAgIHRoaXMuX2FjdGl2aXR5KCk7XG4gICAgaWYgKGxpbmtzTGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgaWYgKCF0aGlzLl9vcC5lbmFibGVkKSByZXR1cm47XG5cbiAgICBsZXQgcG9ydFRyaWdnZXJlZCA9IG51bGw7XG4gICAgdHJ5XG4gICAge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtzTGVuZ3RoOyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmtzW2ldLnBvcnRJbilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwb3J0VHJpZ2dlcmVkID0gdGhpcy5saW5rc1tpXS5wb3J0SW47XG5cbiAgICAgICAgICAgICAgICBwb3J0VHJpZ2dlcmVkLm9wLnBhdGNoLnB1c2hUcmlnZ2VyU3RhY2socG9ydFRyaWdnZXJlZCk7XG4gICAgICAgICAgICAgICAgcG9ydFRyaWdnZXJlZC5fb25UcmlnZ2VyZWQoKTtcblxuICAgICAgICAgICAgICAgIHBvcnRUcmlnZ2VyZWQub3AucGF0Y2gucG9wVHJpZ2dlclN0YWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5saW5rc1tpXSkgdGhpcy5saW5rc1tpXS5hY3Rpdml0eSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChleClcbiAgICB7XG4gICAgICAgIHBvcnRUcmlnZ2VyZWQub3AuZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLl9vcC5wYXRjaC5pc0VkaXRvck1vZGUoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fb3AucGF0Y2guZW1pdEV2ZW50KFwiZXhjZXB0aW9uXCIsIGV4LCBwb3J0VHJpZ2dlcmVkLm9wKTtcbiAgICAgICAgICAgIHRoaXMuX29wLnBhdGNoLmVtaXRFdmVudChcIm9wY3Jhc2hcIiwgcG9ydFRyaWdnZXJlZCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNyYXNoXCIsIHBvcnRUcmlnZ2VyZWQub3Aub2JqTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChwb3J0VHJpZ2dlcmVkLm9wLm9uRXJyb3IpIHBvcnRUcmlnZ2VyZWQub3Aub25FcnJvcihleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJleGNlcHRpb24hXCIpO1xuICAgICAgICB0aGlzLl9sb2cuZXJyb3IoXCJvbnRyaWdnZXJlZCBleGNlcHRpb24gY2F1Z2h0XCIsIGV4KTtcbiAgICAgICAgdGhpcy5fbG9nLmVycm9yKGV4LnN0YWNrKTtcbiAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJleGNlcHRpb24gaW46IFwiICsgcG9ydFRyaWdnZXJlZC5vcC5uYW1lKTtcbiAgICB9XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9sb2cud2FybihcImNhbGwgZGVwcmVjYXRlZCAtIHVzZSB0cmlnZ2VyKCkgXCIpO1xuICAgIHRoaXMudHJpZ2dlcigpO1xufTtcblxuUG9ydC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fbG9nLndhcm4oXCIjIyMgZXhlY3V0ZSBwb3J0OiBcIiArIHRoaXMuZ2V0TmFtZSgpLCB0aGlzLmdvYWxzLmxlbmd0aCk7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5zZXRWYXJpYWJsZU5hbWUgPSBmdW5jdGlvbiAobilcbntcbiAgICB0aGlzLl91c2VWYXJpYWJsZU5hbWUgPSBuO1xuXG5cbiAgICB0aGlzLl9vcC5wYXRjaC5vbihcInZhcmlhYmxlUmVuYW1lXCIsIChvbGRuYW1lLCBuZXduYW1lKSA9PlxuICAgIHtcbiAgICAgICAgaWYgKG9sZG5hbWUgIT0gdGhpcy5fdXNlVmFyaWFibGVOYW1lKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3VzZVZhcmlhYmxlTmFtZSA9IG5ld25hbWU7XG4gICAgfSk7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5nZXRWYXJpYWJsZU5hbWUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl91c2VWYXJpYWJsZU5hbWU7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5zZXRWYXJpYWJsZSA9IGZ1bmN0aW9uICh2KVxue1xuICAgIHRoaXMuc2V0QW5pbWF0ZWQoZmFsc2UpO1xuICAgIGNvbnN0IGF0dHIgPSB7IFwidXNlVmFyaWFibGVcIjogZmFsc2UgfTtcblxuICAgIGlmICh0aGlzLl92YXJpYWJsZUluICYmIHRoaXMuX3ZhckNoYW5nZUxpc3RlbmVySWQpXG4gICAge1xuICAgICAgICB0aGlzLl92YXJpYWJsZUluLm9mZih0aGlzLl92YXJDaGFuZ2VMaXN0ZW5lcklkKTtcbiAgICAgICAgdGhpcy5fdmFyaWFibGVJbiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHYpXG4gICAge1xuICAgICAgICB0aGlzLl92YXJpYWJsZUluID0gdGhpcy5fb3AucGF0Y2guZ2V0VmFyKHYpO1xuXG4gICAgICAgIGlmICghdGhpcy5fdmFyaWFibGVJbilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJQT1JUIFZBUiBOT1QgRk9VTkQhISFcIiwgdik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfT0JKRUNUKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhckNoYW5nZUxpc3RlbmVySWQgPSB0aGlzLl92YXJpYWJsZUluLm9uKFwiY2hhbmdlXCIsICgpID0+IHsgdGhpcy5zZXQobnVsbCk7IHRoaXMuc2V0KHRoaXMuX3ZhcmlhYmxlSW4uZ2V0VmFsdWUoKSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhckNoYW5nZUxpc3RlbmVySWQgPSB0aGlzLl92YXJpYWJsZUluLm9uKFwiY2hhbmdlXCIsIHRoaXMuc2V0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXQodGhpcy5fdmFyaWFibGVJbi5nZXRWYWx1ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91c2VWYXJpYWJsZU5hbWUgPSB2O1xuICAgICAgICBhdHRyLnVzZVZhcmlhYmxlID0gdHJ1ZTtcbiAgICAgICAgYXR0ci52YXJpYWJsZU5hbWUgPSB0aGlzLl91c2VWYXJpYWJsZU5hbWU7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGF0dHIudmFyaWFibGVOYW1lID0gdGhpcy5fdXNlVmFyaWFibGVOYW1lID0gbnVsbDtcbiAgICAgICAgYXR0ci51c2VWYXJpYWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VWlBdHRyaWJzKGF0dHIpO1xuICAgIHRoaXMuX29wLnBhdGNoLmVtaXRFdmVudChcInBvcnRTZXRWYXJpYWJsZVwiLCB0aGlzLl9vcCwgdGhpcywgdik7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5faGFuZGxlTm9UcmlnZ2VyT3BBbmltVXBkYXRlcyA9IGZ1bmN0aW9uIChhKVxue1xuICAgIGxldCBoYXNUcmlnZ2VyUG9ydCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fb3AucG9ydHNJbi5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9vcC5wb3J0c0luLnR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9GVU5DVElPTilcbiAgICAgICAge1xuICAgICAgICAgICAgaGFzVHJpZ2dlclBvcnQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWhhc1RyaWdnZXJQb3J0KVxuICAgIHtcbiAgICAgICAgaWYgKGEpIHRoaXMuX25vdHJpZ2dlckFuaW1VcGRhdGUgPSB0aGlzLl9vcC5wYXRjaC5vbihcIm9uUmVuZGVyRnJhbWVcIixcbiAgICAgICAgICAgICgpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVBbmltKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgZWxzZSB0aGlzLl9vcC5wYXRjaC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX25vdHJpZ2dlckFuaW1VcGRhdGUpO1xuICAgIH1cbn07XG5cblBvcnQucHJvdG90eXBlLnNldEFuaW1hdGVkID0gZnVuY3Rpb24gKGEpXG57XG4gICAgaWYgKHRoaXMuX2FuaW1hdGVkICE9IGEpXG4gICAge1xuICAgICAgICB0aGlzLl9hbmltYXRlZCA9IGE7XG4gICAgICAgIHRoaXMuX29wLl9oYXNBbmltUG9ydCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGVkICYmICF0aGlzLmFuaW0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbSA9IG5ldyBBbmltKHsgXCJuYW1lXCI6IFwicG9ydCBcIiArIHRoaXMubmFtZSB9KTtcbiAgICAgICAgICAgIHRoaXMuYW5pbS5hZGRFdmVudExpc3RlbmVyKFwib25DaGFuZ2VcIiwgKCkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcC5wYXRjaC5lbWl0RXZlbnQoXCJwb3J0QW5pbVVwZGF0ZWRcIiwgdGhpcy5fb3AsIHRoaXMsIHRoaXMuYW5pbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vbkFuaW1Ub2dnbGUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVOb1RyaWdnZXJPcEFuaW1VcGRhdGVzKGEpO1xuICAgIGlmICghYSlcbiAgICB7XG4gICAgICAgIHRoaXMuYW5pbSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRVaUF0dHJpYnMoeyBcImlzQW5pbWF0ZWRcIjogdGhpcy5fYW5pbWF0ZWQgfSk7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS50b2dnbGVBbmltID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9hbmltYXRlZCA9ICF0aGlzLl9hbmltYXRlZDtcbiAgICBpZiAodGhpcy5fYW5pbWF0ZWQgJiYgIXRoaXMuYW5pbSlcbiAgICB7XG4gICAgICAgIHRoaXMuYW5pbSA9IG5ldyBBbmltKHsgXCJuYW1lXCI6IFwicG9ydCBcIiArIHRoaXMubmFtZSB9KTtcbiAgICAgICAgdGhpcy5hbmltLmFkZEV2ZW50TGlzdGVuZXIoXCJvbkNoYW5nZVwiLCAoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vcC5wYXRjaC5lbWl0RXZlbnQoXCJwb3J0QW5pbVVwZGF0ZWRcIiwgdGhpcy5fb3AsIHRoaXMsIHRoaXMuYW5pbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnNldEFuaW1hdGVkKHRoaXMuX2FuaW1hdGVkKTtcbiAgICB0aGlzLl9vbkFuaW1Ub2dnbGUoKTtcbiAgICB0aGlzLnNldFVpQXR0cmlicyh7IFwiaXNBbmltYXRlZFwiOiB0aGlzLl9hbmltYXRlZCB9KTtcbn07XG5cbi8qKlxuICogPHByZT5cbiAqIENBQkxFUy5DT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1ZBTFVFID0gMDtcbiAqIENBQkxFUy5DT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0ZVTkNUSU9OID0gMTtcbiAqIENBQkxFUy5DT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX09CSkVDVCA9IDI7XG4gKiBDQUJMRVMuQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9URVhUVVJFID0gMjtcbiAqIENBQkxFUy5DT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0FSUkFZID0gMztcbiAqIENBQkxFUy5DT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX0RZTkFNSUMgPSA0O1xuICogQ0FCTEVTLkNPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfU1RSSU5HID0gNTtcbiAqIDwvcHJlPlxuICogQGZ1bmN0aW9uIGdldFR5cGVcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm4ge051bWJlcn0gdHlwZSBvZiBwb3J0XG4gKi9cblBvcnQucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLnR5cGU7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBpc0xpbmtlZFxuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBwb3J0IGlzIGxpbmtlZFxuICovXG5Qb3J0LnByb3RvdHlwZS5pc0xpbmtlZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMubGlua3MubGVuZ3RoID4gMCB8fCB0aGlzLl9hbmltYXRlZCB8fCB0aGlzLl91c2VWYXJpYWJsZU5hbWUgIT0gbnVsbDtcbn07XG5cblBvcnQucHJvdG90eXBlLmlzQm91bmRUb1ZhciA9IGZ1bmN0aW9uICgpXG57XG4gICAgY29uc3QgYiA9IHRoaXMuX3VzZVZhcmlhYmxlTmFtZSAhPSBudWxsO1xuICAgIHRoaXMudWlBdHRyaWJzLmJvdW5kVG9WYXIgPSBiO1xuICAgIHJldHVybiBiO1xufTtcbi8qKlxuICogQGZ1bmN0aW9uIGlzQW5pbWF0ZWRcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcG9ydCBpcyBhbmltYXRlZFxuICovXG5Qb3J0LnByb3RvdHlwZS5pc0FuaW1hdGVkID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZWQ7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBpc0hpZGRlblxuICogQG1lbWJlcm9mIFBvcnRcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBwb3J0IGlzIGhpZGRlblxuICovXG5Qb3J0LnByb3RvdHlwZS5pc0hpZGRlbiA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMudWlBdHRyaWJzLmhpZGVQb3J0O1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gb25UcmlnZ2VyZWRcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7b25UcmlnZ2VyZWRDYWxsYmFja30gY2FsbGJhY2tcbiAqIEBkZXNjcmlwdGlvbiBzZXQgY2FsbGJhY2ssIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBwb3J0IHdhcyB0cmlnZ2VyZWQgKHVzdWFsbHkgb3V0cHV0IHBvcnQpXG4gKi9cblBvcnQucHJvdG90eXBlLl9vblRyaWdnZXJlZCA9IGZ1bmN0aW9uIChhKVxue1xuICAgIHRoaXMuX2FjdGl2aXR5KCk7XG4gICAgdGhpcy5fb3AudXBkYXRlQW5pbXMoKTtcbiAgICBpZiAodGhpcy5fb3AuZW5hYmxlZCAmJiB0aGlzLm9uVHJpZ2dlcmVkKSB0aGlzLm9uVHJpZ2dlcmVkKGEpO1xufTtcblxuUG9ydC5wcm90b3R5cGUuX29uU2V0UHJvZmlsaW5nID0gZnVuY3Rpb24gKHYpXG57XG4gICAgdGhpcy5fb3AucGF0Y2gucHJvZmlsZXIuYWRkKFwicG9ydFwiLCB0aGlzKTtcbiAgICB0aGlzLnNldFZhbHVlKHYpO1xuICAgIC8vIGlmICh0aGlzLl9vcC5lbmFibGVkICYmIHRoaXMub25UcmlnZ2VyZWQpIHRoaXMub25UcmlnZ2VyZWQoKTtcbiAgICB0aGlzLl9vcC5wYXRjaC5wcm9maWxlci5hZGQoXCJwb3J0XCIsIG51bGwpO1xufTtcblxuUG9ydC5wcm90b3R5cGUuX29uVHJpZ2dlcmVkUHJvZmlsaW5nID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyB0aGlzLl9vcC51cGRhdGVBbmltcygpO1xuXG4gICAgaWYgKHRoaXMuX29wLmVuYWJsZWQgJiYgdGhpcy5vblRyaWdnZXJlZClcbiAgICB7XG4gICAgICAgIHRoaXMuX29wLnBhdGNoLnByb2ZpbGVyLmFkZChcInBvcnRcIiwgdGhpcyk7XG4gICAgICAgIHRoaXMub25UcmlnZ2VyZWQoKTtcbiAgICAgICAgdGhpcy5fb3AucGF0Y2gucHJvZmlsZXIuYWRkKFwicG9ydFwiLCBudWxsKTtcbiAgICB9XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5vblZhbHVlQ2hhbmdlID0gZnVuY3Rpb24gKGNiKVxue1xuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICB0aGlzLm9uQ2hhbmdlID0gY2I7XG59O1xuXG5Qb3J0LnByb3RvdHlwZS5nZXRVaUFjdGl2ZVN0YXRlID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fdWlBY3RpdmVTdGF0ZTtcbn07XG5cblBvcnQucHJvdG90eXBlLnNldFVpQWN0aXZlU3RhdGUgPSBmdW5jdGlvbiAob25vZmYpXG57XG4gICAgdGhpcy5fdWlBY3RpdmVTdGF0ZSA9IG9ub2ZmO1xuICAgIGlmICh0aGlzLm9uVWlBY3RpdmVTdGF0ZUNoYW5nZSkgdGhpcy5vblVpQWN0aXZlU3RhdGVDaGFuZ2UoKTtcbn07XG5cblBvcnQucHJvdG90eXBlLmhpZGVQb3J0ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9sb2cud2FybihcIm9wLmhpZGVwb3J0KCkgaXMgZGVwcmVjYXRlZCwgZG8gbm90IHVzZSBpdCFcIik7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcG9ydCB0eXBlIHN0cmluZywgZS5nLiBcInZhbHVlXCIgYmFzZWQgb24gdGhlIHBvcnQgdHlwZSBudW1iZXJcbiAqIEBmdW5jdGlvbiBwb3J0VHlwZU51bWJlclRvU3RyaW5nXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBQb3J0XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSAtIFRoZSBwb3J0IHR5cGUgbnVtYmVyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAtIFRoZSBwb3J0IHR5cGUgYXMgc3RyaW5nXG4gKi9cblBvcnQucG9ydFR5cGVOdW1iZXJUb1N0cmluZyA9IGZ1bmN0aW9uICh0eXBlKVxue1xuICAgIGlmICh0eXBlID09IENPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfVkFMVUUpIHJldHVybiBcInZhbHVlXCI7XG4gICAgaWYgKHR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9GVU5DVElPTikgcmV0dXJuIFwiZnVuY3Rpb25cIjtcbiAgICBpZiAodHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX09CSkVDVCkgcmV0dXJuIFwib2JqZWN0XCI7XG4gICAgaWYgKHR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9BUlJBWSkgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICBpZiAodHlwZSA9PSBDT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX1NUUklORykgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgaWYgKHR5cGUgPT0gQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9EWU5BTUlDKSByZXR1cm4gXCJkeW5hbWljXCI7XG4gICAgcmV0dXJuIFwidW5rbm93blwiO1xufTtcblxuZXhwb3J0IHsgUG9ydCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/core_port.js\n");

/***/ }),

/***/ "./src/core/core_port_select.js":
/*!**************************************!*\
  !*** ./src/core/core_port_select.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ValueSelectPort\": () => (/* binding */ ValueSelectPort)\n/* harmony export */ });\n/* harmony import */ var _core_port_switch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core_port_switch.js */ \"./src/core/core_port_switch.js\");\n\n\n\n\nclass ValueSelectPort extends _core_port_switch_js__WEBPACK_IMPORTED_MODULE_0__.SwitchPort\n{\n    setUiAttribs(newAttribs)\n    {\n        // never unhide valuePort when indexPort is linked\n        if (this.indexPort.isLinked())\n        {\n            for (const p in newAttribs)\n            {\n                if (p == \"greyout\" && !newAttribs[p]) newAttribs[p] = \"true\";\n            }\n        }\n        super.setUiAttribs(newAttribs);\n    }\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX3BvcnRfc2VsZWN0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvY29yZV9wb3J0X3NlbGVjdC5qcz8wNzU5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgU3dpdGNoUG9ydCB9IGZyb20gXCIuL2NvcmVfcG9ydF9zd2l0Y2guanNcIjtcblxuXG5jbGFzcyBWYWx1ZVNlbGVjdFBvcnQgZXh0ZW5kcyBTd2l0Y2hQb3J0XG57XG4gICAgc2V0VWlBdHRyaWJzKG5ld0F0dHJpYnMpXG4gICAge1xuICAgICAgICAvLyBuZXZlciB1bmhpZGUgdmFsdWVQb3J0IHdoZW4gaW5kZXhQb3J0IGlzIGxpbmtlZFxuICAgICAgICBpZiAodGhpcy5pbmRleFBvcnQuaXNMaW5rZWQoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwIGluIG5ld0F0dHJpYnMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHAgPT0gXCJncmV5b3V0XCIgJiYgIW5ld0F0dHJpYnNbcF0pIG5ld0F0dHJpYnNbcF0gPSBcInRydWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5zZXRVaUF0dHJpYnMobmV3QXR0cmlicyk7XG4gICAgfVxufVxuXG5cblxuZXhwb3J0IHsgVmFsdWVTZWxlY3RQb3J0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/core_port_select.js\n");

/***/ }),

/***/ "./src/core/core_port_switch.js":
/*!**************************************!*\
  !*** ./src/core/core_port_switch.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SwitchPort\": () => (/* binding */ SwitchPort)\n/* harmony export */ });\n/* harmony import */ var _core_port_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core_port.js */ \"./src/core/core_port.js\");\n\n\n\n\nclass SwitchPort extends _core_port_js__WEBPACK_IMPORTED_MODULE_0__.Port\n{\n    constructor(__parent, name, type, uiAttribs, indexPort)\n    {\n        super(__parent, name, type, uiAttribs);\n\n        this.get = () =>\n        {\n            let s = super.get();\n\n            if (CABLES.UI)\n            {\n                if (\n                    s === \"\" ||\n                    s === null ||\n                    s === undefined ||\n                    (uiAttribs.values && uiAttribs.values.indexOf(String(s)) === -1)\n                )\n                {\n                    this.op.setUiError(\"invalidswitch\", \"Invalid Value [\" + this.name + \"]: \\\"\" + s + \"\\\"\");\n                }\n                else this.op.setUiError(\"invalidswitch\", null);\n            }\n\n            if (s === null || s === undefined)s = \"\";\n\n            return s;\n        };\n\n        this.indexPort = indexPort;\n        this.indexPort.set = (value) =>\n        {\n            const values = uiAttribs.values;\n\n            if (!values)\n            {\n                // console.log(\"switch port has no values\", this);\n                return;\n            }\n\n            let intValue = Math.floor(value);\n\n            intValue = Math.min(intValue, values.length - 1);\n            intValue = Math.max(intValue, 0);\n\n            this.indexPort.setValue(intValue);\n            this.set(values[intValue]);\n\n            if (this.op.patch.isEditorMode() && performance.now() - (this.lastTime || 0) > 100 && window.gui && gui.patchView.isCurrentOp(this.op))\n            {\n                gui.opParams.show(this.op);\n                this.lastTime = performance.now();\n            }\n        };\n    }\n\n    setUiAttribs(attribs)\n    {\n        const hidePort = attribs.hidePort;\n        attribs.hidePort = true;\n        super.setUiAttribs(attribs);\n        if (typeof hidePort !== \"undefined\")\n        {\n            this.indexPort.setUiAttribs({ hidePort });\n        }\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX3BvcnRfc3dpdGNoLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NvcmVfcG9ydF9zd2l0Y2guanM/MDkwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IFBvcnQgfSBmcm9tIFwiLi9jb3JlX3BvcnQuanNcIjtcblxuXG5jbGFzcyBTd2l0Y2hQb3J0IGV4dGVuZHMgUG9ydFxue1xuICAgIGNvbnN0cnVjdG9yKF9fcGFyZW50LCBuYW1lLCB0eXBlLCB1aUF0dHJpYnMsIGluZGV4UG9ydClcbiAgICB7XG4gICAgICAgIHN1cGVyKF9fcGFyZW50LCBuYW1lLCB0eXBlLCB1aUF0dHJpYnMpO1xuXG4gICAgICAgIHRoaXMuZ2V0ID0gKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHMgPSBzdXBlci5nZXQoKTtcblxuICAgICAgICAgICAgaWYgKENBQkxFUy5VSSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHMgPT09IFwiXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgcyA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICBzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgKHVpQXR0cmlicy52YWx1ZXMgJiYgdWlBdHRyaWJzLnZhbHVlcy5pbmRleE9mKFN0cmluZyhzKSkgPT09IC0xKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3Auc2V0VWlFcnJvcihcImludmFsaWRzd2l0Y2hcIiwgXCJJbnZhbGlkIFZhbHVlIFtcIiArIHRoaXMubmFtZSArIFwiXTogXFxcIlwiICsgcyArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB0aGlzLm9wLnNldFVpRXJyb3IoXCJpbnZhbGlkc3dpdGNoXCIsIG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocyA9PT0gbnVsbCB8fCBzID09PSB1bmRlZmluZWQpcyA9IFwiXCI7XG5cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaW5kZXhQb3J0ID0gaW5kZXhQb3J0O1xuICAgICAgICB0aGlzLmluZGV4UG9ydC5zZXQgPSAodmFsdWUpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHVpQXR0cmlicy52YWx1ZXM7XG5cbiAgICAgICAgICAgIGlmICghdmFsdWVzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwic3dpdGNoIHBvcnQgaGFzIG5vIHZhbHVlc1wiLCB0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBpbnRWYWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuXG4gICAgICAgICAgICBpbnRWYWx1ZSA9IE1hdGgubWluKGludFZhbHVlLCB2YWx1ZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBpbnRWYWx1ZSA9IE1hdGgubWF4KGludFZhbHVlLCAwKTtcblxuICAgICAgICAgICAgdGhpcy5pbmRleFBvcnQuc2V0VmFsdWUoaW50VmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zZXQodmFsdWVzW2ludFZhbHVlXSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wLnBhdGNoLmlzRWRpdG9yTW9kZSgpICYmIHBlcmZvcm1hbmNlLm5vdygpIC0gKHRoaXMubGFzdFRpbWUgfHwgMCkgPiAxMDAgJiYgd2luZG93Lmd1aSAmJiBndWkucGF0Y2hWaWV3LmlzQ3VycmVudE9wKHRoaXMub3ApKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGd1aS5vcFBhcmFtcy5zaG93KHRoaXMub3ApO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzZXRVaUF0dHJpYnMoYXR0cmlicylcbiAgICB7XG4gICAgICAgIGNvbnN0IGhpZGVQb3J0ID0gYXR0cmlicy5oaWRlUG9ydDtcbiAgICAgICAgYXR0cmlicy5oaWRlUG9ydCA9IHRydWU7XG4gICAgICAgIHN1cGVyLnNldFVpQXR0cmlicyhhdHRyaWJzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBoaWRlUG9ydCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5pbmRleFBvcnQuc2V0VWlBdHRyaWJzKHsgaGlkZVBvcnQgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IFN3aXRjaFBvcnQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/core_port_switch.js\n");

/***/ }),

/***/ "./src/core/core_profiler.js":
/*!***********************************!*\
  !*** ./src/core/core_profiler.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Profiler\": () => (/* binding */ Profiler)\n/* harmony export */ });\n/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ \"./src/core/timer.js\");\n\n\nclass Profiler\n{\n    constructor(patch)\n    {\n        this.startFrame = patch.getFrameNum();\n        this.items = {};\n        this.currentId = null;\n        this.currentStart = 0;\n        this._patch = patch;\n    }\n\n    getItems()\n    {\n        return this.items;\n    }\n\n    clear()\n    {\n        if (this.paused) return;\n        this.items = {};\n    }\n\n    togglePause()\n    {\n        this.paused = !this.paused;\n        if (!this.paused)\n        {\n            this.items = {};\n            this.currentStart = performance.now();\n        }\n    }\n\n    add(type, object)\n    {\n        if (this.paused) return;\n\n        if (this.currentId !== null)\n        {\n            if (!object || object.id != this.currentId)\n            {\n                if (this.items[this.currentId])\n                {\n                    this.items[this.currentId].timeUsed += performance.now() - this.currentStart;\n\n                    if (!this.items[this.currentId].peakTime || (0,_timer_js__WEBPACK_IMPORTED_MODULE_0__.now)() - this.items[this.currentId].peakTime > 5000)\n                    {\n                        this.items[this.currentId].peak = 0;\n                        this.items[this.currentId].peakTime = (0,_timer_js__WEBPACK_IMPORTED_MODULE_0__.now)();\n                    }\n                    this.items[this.currentId].peak = Math.max(this.items[this.currentId].peak, performance.now() - this.currentStart);\n                }\n            }\n        }\n\n        if (object !== null)\n        {\n            if (!this.items[object.id])\n            {\n                this.items[object.id] = {\n                    \"numTriggers\": 0,\n                    \"timeUsed\": 0,\n                };\n            }\n\n            if (this.items[object.id].lastFrame != this._patch.getFrameNum()) this.items[object.id].numTriggers = 0;\n\n            this.items[object.id].lastFrame = this._patch.getFrameNum();\n            this.items[object.id].numTriggers++;\n            this.items[object.id].opid = object.op.id;\n            this.items[object.id].title = object.op.name + \".\" + object.name;\n            this.items[object.id].subPatch = object.op.uiAttribs.subPatch;\n\n            this.currentId = object.id;\n            this.currentStart = performance.now();\n        }\n        else\n        {\n            this.currentId = null;\n        }\n    }\n\n    print()\n    {\n        console.log(\"--------\");\n        for (const i in this.items)\n        {\n            console.log(this.items[i].title + \": \" + this.items[i].numTriggers + \" / \" + this.items[i].timeUsed);\n        }\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX3Byb2ZpbGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2NvcmVfcHJvZmlsZXIuanM/MjE2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBub3cgfSBmcm9tIFwiLi90aW1lci5qc1wiO1xuXG5jbGFzcyBQcm9maWxlclxue1xuICAgIGNvbnN0cnVjdG9yKHBhdGNoKVxuICAgIHtcbiAgICAgICAgdGhpcy5zdGFydEZyYW1lID0gcGF0Y2guZ2V0RnJhbWVOdW0oKTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5fcGF0Y2ggPSBwYXRjaDtcbiAgICB9XG5cbiAgICBnZXRJdGVtcygpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcztcbiAgICB9XG5cbiAgICBjbGVhcigpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHJldHVybjtcbiAgICAgICAgdGhpcy5pdGVtcyA9IHt9O1xuICAgIH1cblxuICAgIHRvZ2dsZVBhdXNlKClcbiAgICB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gIXRoaXMucGF1c2VkO1xuICAgICAgICBpZiAoIXRoaXMucGF1c2VkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zID0ge307XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkKHR5cGUsIG9iamVjdClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkgcmV0dXJuO1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRJZCAhPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFvYmplY3QgfHwgb2JqZWN0LmlkICE9IHRoaXMuY3VycmVudElkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW3RoaXMuY3VycmVudElkXSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNbdGhpcy5jdXJyZW50SWRdLnRpbWVVc2VkICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5jdXJyZW50U3RhcnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLml0ZW1zW3RoaXMuY3VycmVudElkXS5wZWFrVGltZSB8fCBub3coKSAtIHRoaXMuaXRlbXNbdGhpcy5jdXJyZW50SWRdLnBlYWtUaW1lID4gNTAwMClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtc1t0aGlzLmN1cnJlbnRJZF0ucGVhayA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zW3RoaXMuY3VycmVudElkXS5wZWFrVGltZSA9IG5vdygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNbdGhpcy5jdXJyZW50SWRdLnBlYWsgPSBNYXRoLm1heCh0aGlzLml0ZW1zW3RoaXMuY3VycmVudElkXS5wZWFrLCBwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuY3VycmVudFN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqZWN0ICE9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXRlbXNbb2JqZWN0LmlkXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zW29iamVjdC5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIFwibnVtVHJpZ2dlcnNcIjogMCxcbiAgICAgICAgICAgICAgICAgICAgXCJ0aW1lVXNlZFwiOiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW29iamVjdC5pZF0ubGFzdEZyYW1lICE9IHRoaXMuX3BhdGNoLmdldEZyYW1lTnVtKCkpIHRoaXMuaXRlbXNbb2JqZWN0LmlkXS5udW1UcmlnZ2VycyA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuaXRlbXNbb2JqZWN0LmlkXS5sYXN0RnJhbWUgPSB0aGlzLl9wYXRjaC5nZXRGcmFtZU51bSgpO1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tvYmplY3QuaWRdLm51bVRyaWdnZXJzKys7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW29iamVjdC5pZF0ub3BpZCA9IG9iamVjdC5vcC5pZDtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbb2JqZWN0LmlkXS50aXRsZSA9IG9iamVjdC5vcC5uYW1lICsgXCIuXCIgKyBvYmplY3QubmFtZTtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbb2JqZWN0LmlkXS5zdWJQYXRjaCA9IG9iamVjdC5vcC51aUF0dHJpYnMuc3ViUGF0Y2g7XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudElkID0gb2JqZWN0LmlkO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaW50KClcbiAgICB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiLS0tLS0tLS1cIik7XG4gICAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLml0ZW1zKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLml0ZW1zW2ldLnRpdGxlICsgXCI6IFwiICsgdGhpcy5pdGVtc1tpXS5udW1UcmlnZ2VycyArIFwiIC8gXCIgKyB0aGlzLml0ZW1zW2ldLnRpbWVVc2VkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgUHJvZmlsZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/core_profiler.js\n");

/***/ }),

/***/ "./src/core/core_variable.js":
/*!***********************************!*\
  !*** ./src/core/core_variable.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/eventtarget.js\");\n\n\n/**\n * @type {Object}\n * @name Variable\n * @param {String} name\n * @param {String|Number} value\n * @memberof Patch\n * @constructor\n */\nclass PatchVariable extends cables_shared_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n{\n    constructor(name, val, type)\n    {\n        super();\n        this._name = name;\n        this.type = type;\n        this.setValue(val);\n    }\n\n    /**\n     * keeping this for backwards compatibility in older\n     * exports before using eventtarget\n     *\n     * @param cb\n     */\n    addListener(cb)\n    {\n        this.on(\"change\", cb, \"var\");\n    }\n\n    /**\n     * @function Variable.getValue\n     * @memberof Variable\n     * @returns {String|Number|Boolean}\n     */\n\n    getValue()\n    {\n        return this._v;\n    }\n\n    /**\n     * @function getName\n     * @memberof Variable\n     * @instance\n     * @returns {String|Number|Boolean}\n     * @function\n     */\n    getName()\n    {\n        return this._name;\n    }\n\n    /**\n     * @function setValue\n     * @memberof Variable\n     * @instance\n     * @returns {String|Number|Boolean}\n     * @function\n     */\n    setValue(v)\n    {\n        this._v = v;\n        this.emitEvent(\"change\", v, this);\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PatchVariable);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb3JlX3ZhcmlhYmxlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9jb3JlX3ZhcmlhYmxlLmpzPzA1MTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSBcImNhYmxlcy1zaGFyZWQtY2xpZW50XCI7XG5cbi8qKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBuYW1lIFZhcmlhYmxlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWx1ZVxuICogQG1lbWJlcm9mIFBhdGNoXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgUGF0Y2hWYXJpYWJsZSBleHRlbmRzIEV2ZW50c1xue1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZhbCwgdHlwZSlcbiAgICB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNldFZhbHVlKHZhbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICoga2VlcGluZyB0aGlzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBpbiBvbGRlclxuICAgICAqIGV4cG9ydHMgYmVmb3JlIHVzaW5nIGV2ZW50dGFyZ2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2JcbiAgICAgKi9cbiAgICBhZGRMaXN0ZW5lcihjYilcbiAgICB7XG4gICAgICAgIHRoaXMub24oXCJjaGFuZ2VcIiwgY2IsIFwidmFyXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBWYXJpYWJsZS5nZXRWYWx1ZVxuICAgICAqIEBtZW1iZXJvZiBWYXJpYWJsZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfEJvb2xlYW59XG4gICAgICovXG5cbiAgICBnZXRWYWx1ZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gZ2V0TmFtZVxuICAgICAqIEBtZW1iZXJvZiBWYXJpYWJsZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfEJvb2xlYW59XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgZ2V0TmFtZSgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gc2V0VmFsdWVcbiAgICAgKiBAbWVtYmVyb2YgVmFyaWFibGVcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfE51bWJlcnxCb29sZWFufVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIHNldFZhbHVlKHYpXG4gICAge1xuICAgICAgICB0aGlzLl92ID0gdjtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJjaGFuZ2VcIiwgdiwgdGhpcyk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXRjaFZhcmlhYmxlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/core_variable.js\n");

/***/ }),

/***/ "./src/core/embedding.js":
/*!*******************************!*\
  !*** ./src/core/embedding.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EMBED\": () => (/* binding */ EMBED)\n/* harmony export */ });\n/* harmony import */ var _core_patch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core_patch.js */ \"./src/core/core_patch.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/core/utils.js\");\n\n\n\nconst EMBED = {};\n\n/**\n * add patch into html element (will create canvas and set size to fill containerElement)\n * @name CABLES.EMBED#addPatch\n * @param {object|string} containerElement dom element or id of element\n * @param {options} patch options\n * @function\n */\nEMBED.addPatch = function (_element, options)\n{\n    let el = _element;\n    let id = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.generateUUID)();\n    if (typeof _element == \"string\")\n    {\n        id = _element;\n        el = document.getElementById(id);\n\n        if (!el)\n        {\n            console.error(id + \" Polyshape Container Element not found!\");\n            return;\n        }\n    }\n\n    const canvEl = document.createElement(\"canvas\");\n    canvEl.id = \"glcanvas_\" + id;\n    canvEl.width = el.clientWidth;\n    canvEl.height = el.clientHeight;\n\n    window.addEventListener(\n        \"resize\",\n        function ()\n        {\n            this.setAttribute(\"width\", el.clientWidth);\n            this.height = el.clientHeight;\n        }.bind(canvEl),\n    );\n\n    el.appendChild(canvEl);\n\n    options = options || {};\n    options.glCanvasId = canvEl.id;\n\n    if (!options.onError)\n    {\n        options.onError = function (err)\n        {\n            console.error(err);\n        };\n    }\n\n    CABLES.patch = new _core_patch_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](options);\n    return canvEl;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9lbWJlZGRpbmcuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9lbWJlZGRpbmcuanM/OGVlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUGF0Y2ggZnJvbSBcIi4vY29yZV9wYXRjaC5qc1wiO1xuaW1wb3J0IHsgZ2VuZXJhdGVVVUlEIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcblxuY29uc3QgRU1CRUQgPSB7fTtcblxuLyoqXG4gKiBhZGQgcGF0Y2ggaW50byBodG1sIGVsZW1lbnQgKHdpbGwgY3JlYXRlIGNhbnZhcyBhbmQgc2V0IHNpemUgdG8gZmlsbCBjb250YWluZXJFbGVtZW50KVxuICogQG5hbWUgQ0FCTEVTLkVNQkVEI2FkZFBhdGNoXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IGNvbnRhaW5lckVsZW1lbnQgZG9tIGVsZW1lbnQgb3IgaWQgb2YgZWxlbWVudFxuICogQHBhcmFtIHtvcHRpb25zfSBwYXRjaCBvcHRpb25zXG4gKiBAZnVuY3Rpb25cbiAqL1xuRU1CRUQuYWRkUGF0Y2ggPSBmdW5jdGlvbiAoX2VsZW1lbnQsIG9wdGlvbnMpXG57XG4gICAgbGV0IGVsID0gX2VsZW1lbnQ7XG4gICAgbGV0IGlkID0gZ2VuZXJhdGVVVUlEKCk7XG4gICAgaWYgKHR5cGVvZiBfZWxlbWVudCA9PSBcInN0cmluZ1wiKVxuICAgIHtcbiAgICAgICAgaWQgPSBfZWxlbWVudDtcbiAgICAgICAgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5cbiAgICAgICAgaWYgKCFlbClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihpZCArIFwiIFBvbHlzaGFwZSBDb250YWluZXIgRWxlbWVudCBub3QgZm91bmQhXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2FudkVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52RWwuaWQgPSBcImdsY2FudmFzX1wiICsgaWQ7XG4gICAgY2FudkVsLndpZHRoID0gZWwuY2xpZW50V2lkdGg7XG4gICAgY2FudkVsLmhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcInJlc2l6ZVwiLFxuICAgICAgICBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIGVsLmNsaWVudFdpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9LmJpbmQoY2FudkVsKSxcbiAgICApO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQoY2FudkVsKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuZ2xDYW52YXNJZCA9IGNhbnZFbC5pZDtcblxuICAgIGlmICghb3B0aW9ucy5vbkVycm9yKVxuICAgIHtcbiAgICAgICAgb3B0aW9ucy5vbkVycm9yID0gZnVuY3Rpb24gKGVycilcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIENBQkxFUy5wYXRjaCA9IG5ldyBQYXRjaChvcHRpb25zKTtcbiAgICByZXR1cm4gY2FudkVsO1xufTtcblxuZXhwb3J0IHsgRU1CRUQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/embedding.js\n");

/***/ }),

/***/ "./src/core/eventtarget.js":
/*!*********************************!*\
  !*** ./src/core/eventtarget.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EventTarget\": () => (/* binding */ EventTarget)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n\n\nconst EventTarget = function ()\n{\n    this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"eventtarget\");\n    this._eventCallbacks = {};\n    this._logName = \"\";\n    this._logEvents = false;\n    this._listeners = {};\n\n    this.addEventListener = this.on = function (which, cb, idPrefix)\n    {\n        const event =\n        {\n            \"id\": (idPrefix || \"\") + CABLES.simpleId(),\n            \"name\": which,\n            \"cb\": cb,\n        };\n        if (!this._eventCallbacks[which]) this._eventCallbacks[which] = [event];\n        else this._eventCallbacks[which].push(event);\n\n        this._listeners[event.id] = event;\n\n        return event.id;\n    };\n\n    this.hasEventListener = function (which, cb)\n    {\n        if (which && !cb)\n        {\n            // check by id\n            if (this._listeners[which]) return true;\n            else return false;\n        }\n        else\n        {\n            this._log.warn(\"old eventtarget function haseventlistener!\");\n            if (which && cb)\n            {\n                if (this._eventCallbacks[which])\n                {\n                    const idx = this._eventCallbacks[which].indexOf(cb);\n                    if (idx == -1) return false;\n                    return true;\n                }\n            }\n        }\n    };\n\n    this.hasListenerForEventName = function (eventName)\n    {\n        return this._eventCallbacks[eventName] && this._eventCallbacks[eventName].length > 0;\n    };\n\n    this.removeEventListener = this.off = function (which, cb)\n    {\n        if (which === null || which === undefined) return;\n\n        if (!cb) // new style, remove by id, not by name/callback\n        {\n            const event = this._listeners[which];\n            if (!event)\n            {\n                this._log.log(\"could not find event...\");\n                return;\n            }\n\n            let found = true;\n            while (found)\n            {\n                found = false;\n                let index = -1;\n                for (let i = 0; i < this._eventCallbacks[event.name].length; i++)\n                {\n                    if (this._eventCallbacks[event.name][i].id.startsWith(which)) // this._eventCallbacks[event.name][i].id == which ||\n                    {\n                        found = true;\n                        index = i;\n                    }\n                }\n\n                if (index !== -1)\n                {\n                    this._eventCallbacks[event.name].splice(index, 1);\n                    delete this._listeners[which];\n                }\n            }\n\n            return;\n        }\n\n        this._log.info(\"[eventtaget] \", \"old function signature: removeEventListener! use listener id\");\n        this._log.log((new Error()).stack);\n\n        let index = null;\n        for (let i = 0; i < this._eventCallbacks[which].length; i++)\n            if (this._eventCallbacks[which][i].cb == cb)\n                index = i;\n\n        if (index !== null)\n        {\n            delete this._eventCallbacks[index];\n        }\n        else this._log.warn(\"removeEventListener not found \" + which);\n    };\n\n    this.logEvents = function (enabled, name)\n    {\n        this._logEvents = enabled;\n        this._logName = name;\n    };\n\n    this.emitEvent = function (which, param1, param2, param3, param4, param5, param6)\n    {\n        if (this._logEvents) this._log.log(\"[event] \", this._logName, which, this._eventCallbacks);\n\n        if (this._eventCallbacks[which])\n        {\n            for (let i = 0; i < this._eventCallbacks[which].length; i++)\n            {\n                if (this._eventCallbacks[which][i])\n                {\n                    this._eventCallbacks[which][i].cb(param1, param2, param3, param4, param5, param6);\n                }\n            }\n        }\n        else\n        {\n            if (this._logEvents) this._log.log(\"[event] has no event callback\", which, this._eventCallbacks);\n        }\n    };\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9ldmVudHRhcmdldC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2V2ZW50dGFyZ2V0LmpzP2M0ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcImNhYmxlcy1zaGFyZWQtY2xpZW50XCI7XG5cbmNvbnN0IEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9sb2cgPSBuZXcgTG9nZ2VyKFwiZXZlbnR0YXJnZXRcIik7XG4gICAgdGhpcy5fZXZlbnRDYWxsYmFja3MgPSB7fTtcbiAgICB0aGlzLl9sb2dOYW1lID0gXCJcIjtcbiAgICB0aGlzLl9sb2dFdmVudHMgPSBmYWxzZTtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IHRoaXMub24gPSBmdW5jdGlvbiAod2hpY2gsIGNiLCBpZFByZWZpeClcbiAgICB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID1cbiAgICAgICAge1xuICAgICAgICAgICAgXCJpZFwiOiAoaWRQcmVmaXggfHwgXCJcIikgKyBDQUJMRVMuc2ltcGxlSWQoKSxcbiAgICAgICAgICAgIFwibmFtZVwiOiB3aGljaCxcbiAgICAgICAgICAgIFwiY2JcIjogY2IsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRDYWxsYmFja3Nbd2hpY2hdKSB0aGlzLl9ldmVudENhbGxiYWNrc1t3aGljaF0gPSBbZXZlbnRdO1xuICAgICAgICBlbHNlIHRoaXMuX2V2ZW50Q2FsbGJhY2tzW3doaWNoXS5wdXNoKGV2ZW50KTtcblxuICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnQuaWRdID0gZXZlbnQ7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50LmlkO1xuICAgIH07XG5cbiAgICB0aGlzLmhhc0V2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAod2hpY2gsIGNiKVxuICAgIHtcbiAgICAgICAgaWYgKHdoaWNoICYmICFjYilcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY2hlY2sgYnkgaWRcbiAgICAgICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbd2hpY2hdKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJvbGQgZXZlbnR0YXJnZXQgZnVuY3Rpb24gaGFzZXZlbnRsaXN0ZW5lciFcIik7XG4gICAgICAgICAgICBpZiAod2hpY2ggJiYgY2IpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50Q2FsbGJhY2tzW3doaWNoXSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX2V2ZW50Q2FsbGJhY2tzW3doaWNoXS5pbmRleE9mKGNiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA9PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5oYXNMaXN0ZW5lckZvckV2ZW50TmFtZSA9IGZ1bmN0aW9uIChldmVudE5hbWUpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRDYWxsYmFja3NbZXZlbnROYW1lXSAmJiB0aGlzLl9ldmVudENhbGxiYWNrc1tldmVudE5hbWVdLmxlbmd0aCA+IDA7XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHRoaXMub2ZmID0gZnVuY3Rpb24gKHdoaWNoLCBjYilcbiAgICB7XG4gICAgICAgIGlmICh3aGljaCA9PT0gbnVsbCB8fCB3aGljaCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCFjYikgLy8gbmV3IHN0eWxlLCByZW1vdmUgYnkgaWQsIG5vdCBieSBuYW1lL2NhbGxiYWNrXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5fbGlzdGVuZXJzW3doaWNoXTtcbiAgICAgICAgICAgIGlmICghZXZlbnQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmxvZyhcImNvdWxkIG5vdCBmaW5kIGV2ZW50Li4uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChmb3VuZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRDYWxsYmFja3NbZXZlbnQubmFtZV0ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRDYWxsYmFja3NbZXZlbnQubmFtZV1baV0uaWQuc3RhcnRzV2l0aCh3aGljaCkpIC8vIHRoaXMuX2V2ZW50Q2FsbGJhY2tzW2V2ZW50Lm5hbWVdW2ldLmlkID09IHdoaWNoIHx8XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudENhbGxiYWNrc1tldmVudC5uYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3doaWNoXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvZy5pbmZvKFwiW2V2ZW50dGFnZXRdIFwiLCBcIm9sZCBmdW5jdGlvbiBzaWduYXR1cmU6IHJlbW92ZUV2ZW50TGlzdGVuZXIhIHVzZSBsaXN0ZW5lciBpZFwiKTtcbiAgICAgICAgdGhpcy5fbG9nLmxvZygobmV3IEVycm9yKCkpLnN0YWNrKTtcblxuICAgICAgICBsZXQgaW5kZXggPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2V2ZW50Q2FsbGJhY2tzW3doaWNoXS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudENhbGxiYWNrc1t3aGljaF1baV0uY2IgPT0gY2IpXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuXG4gICAgICAgIGlmIChpbmRleCAhPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50Q2FsbGJhY2tzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHRoaXMuX2xvZy53YXJuKFwicmVtb3ZlRXZlbnRMaXN0ZW5lciBub3QgZm91bmQgXCIgKyB3aGljaCk7XG4gICAgfTtcblxuICAgIHRoaXMubG9nRXZlbnRzID0gZnVuY3Rpb24gKGVuYWJsZWQsIG5hbWUpXG4gICAge1xuICAgICAgICB0aGlzLl9sb2dFdmVudHMgPSBlbmFibGVkO1xuICAgICAgICB0aGlzLl9sb2dOYW1lID0gbmFtZTtcbiAgICB9O1xuXG4gICAgdGhpcy5lbWl0RXZlbnQgPSBmdW5jdGlvbiAod2hpY2gsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMsIHBhcmFtNCwgcGFyYW01LCBwYXJhbTYpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fbG9nRXZlbnRzKSB0aGlzLl9sb2cubG9nKFwiW2V2ZW50XSBcIiwgdGhpcy5fbG9nTmFtZSwgd2hpY2gsIHRoaXMuX2V2ZW50Q2FsbGJhY2tzKTtcblxuICAgICAgICBpZiAodGhpcy5fZXZlbnRDYWxsYmFja3Nbd2hpY2hdKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2V2ZW50Q2FsbGJhY2tzW3doaWNoXS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRDYWxsYmFja3Nbd2hpY2hdW2ldKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRDYWxsYmFja3Nbd2hpY2hdW2ldLmNiKHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMsIHBhcmFtNCwgcGFyYW01LCBwYXJhbTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb2dFdmVudHMpIHRoaXMuX2xvZy5sb2coXCJbZXZlbnRdIGhhcyBubyBldmVudCBjYWxsYmFja1wiLCB3aGljaCwgdGhpcy5fZXZlbnRDYWxsYmFja3MpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbmV4cG9ydCB7IEV2ZW50VGFyZ2V0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/eventtarget.js\n");

/***/ }),

/***/ "./src/core/index.js":
/*!***************************!*\
  !*** ./src/core/index.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./base64.js */ \"./src/core/base64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./utils.js */ \"./src/core/utils.js\");\n/* harmony import */ var _anim_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./anim.js */ \"./src/core/anim.js\");\n/* harmony import */ var _core_link_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core_link.js */ \"./src/core/core_link.js\");\n/* harmony import */ var _core_port_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core_port.js */ \"./src/core/core_port.js\");\n/* harmony import */ var _core_op_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core_op.js */ \"./src/core/core_op.js\");\n/* harmony import */ var _embedding_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./embedding.js */ \"./src/core/embedding.js\");\n/* harmony import */ var _core_profiler_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core_profiler.js */ \"./src/core/core_profiler.js\");\n/* harmony import */ var _core_patch_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./core_patch.js */ \"./src/core/core_patch.js\");\n/* harmony import */ var _instancing_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./instancing.js */ \"./src/core/instancing.js\");\n/* harmony import */ var _loadingstatus_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./loadingstatus.js */ \"./src/core/loadingstatus.js\");\n/* harmony import */ var _webaudio_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./webaudio.js */ \"./src/core/webaudio.js\");\n/* harmony import */ var _sessionvar_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./sessionvar.js */ \"./src/core/sessionvar.js\");\n/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./timer.js */ \"./src/core/timer.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./constants.js */ \"./src/core/constants.js\");\n/* harmony import */ var _banchprofiler_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./banchprofiler.js */ \"./src/core/banchprofiler.js\");\n/* harmony import */ var _cgp_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cgp/index.js */ \"./src/core/cgp/index.js\");\n/* harmony import */ var _cg_cg_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cg/cg_constants.js */ \"./src/core/cg/cg_constants.js\");\n/* harmony import */ var _cgl_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cgl/index.js */ \"./src/core/cgl/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nwindow.CABLES = window.CABLES || {};\n\nCABLES.CGL = _cgl_index_js__WEBPACK_IMPORTED_MODULE_0__.CGL;\nCABLES.CG = _cg_cg_constants_js__WEBPACK_IMPORTED_MODULE_1__.CG;\nCABLES.CGP = _cgp_index_js__WEBPACK_IMPORTED_MODULE_2__.CGP;\nCABLES.EMBED = _embedding_js__WEBPACK_IMPORTED_MODULE_3__.EMBED;\nCABLES.Link = _core_link_js__WEBPACK_IMPORTED_MODULE_4__.Link;\nCABLES.Port = _core_port_js__WEBPACK_IMPORTED_MODULE_5__.Port;\nCABLES.Op = _core_op_js__WEBPACK_IMPORTED_MODULE_6__.Op;\nCABLES.Profiler = _core_profiler_js__WEBPACK_IMPORTED_MODULE_7__.Profiler;\nCABLES.Patch = _core_patch_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"];\nCABLES.Instancing = _instancing_js__WEBPACK_IMPORTED_MODULE_9__.Instancing;\nCABLES.Timer = _timer_js__WEBPACK_IMPORTED_MODULE_10__.Timer;\nCABLES.WEBAUDIO = _webaudio_js__WEBPACK_IMPORTED_MODULE_11__.WEBAUDIO;\nCABLES.Variable = _sessionvar_js__WEBPACK_IMPORTED_MODULE_12__.Variable;\nCABLES.LoadingStatus = _loadingstatus_js__WEBPACK_IMPORTED_MODULE_13__.LoadingStatus;\nCABLES.now = _timer_js__WEBPACK_IMPORTED_MODULE_10__.now;\nCABLES.internalNow = _timer_js__WEBPACK_IMPORTED_MODULE_10__.internalNow;\nCABLES.BranchStack = _banchprofiler_js__WEBPACK_IMPORTED_MODULE_14__.BranchStack;\nCABLES.Branch = _banchprofiler_js__WEBPACK_IMPORTED_MODULE_14__.Branch;\n\n\nCABLES = Object.assign(CABLES,\n    _base64_js__WEBPACK_IMPORTED_MODULE_15__,\n    _utils_js__WEBPACK_IMPORTED_MODULE_16__,\n    _anim_js__WEBPACK_IMPORTED_MODULE_17__,\n    _constants_js__WEBPACK_IMPORTED_MODULE_18__.CONSTANTS.PORT,\n    _constants_js__WEBPACK_IMPORTED_MODULE_18__.CONSTANTS.PACO,\n    _constants_js__WEBPACK_IMPORTED_MODULE_18__.CONSTANTS.ANIM,\n    _constants_js__WEBPACK_IMPORTED_MODULE_18__.CONSTANTS.OP\n);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CABLES);\n\nif (!(function () { return !this; }())) console.warn(\"not in strict mode: index core\"); // eslint-disable-line\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9pbmRleC5qcz9jYjIxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGJhc2U2NCBmcm9tIFwiLi9iYXNlNjQuanNcIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBhbmltIGZyb20gXCIuL2FuaW0uanNcIjtcbmltcG9ydCB7IExpbmsgfSBmcm9tIFwiLi9jb3JlX2xpbmsuanNcIjtcbmltcG9ydCB7IFBvcnQgfSBmcm9tIFwiLi9jb3JlX3BvcnQuanNcIjtcbmltcG9ydCB7IE9wIH0gZnJvbSBcIi4vY29yZV9vcC5qc1wiO1xuaW1wb3J0IHsgRU1CRUQgfSBmcm9tIFwiLi9lbWJlZGRpbmcuanNcIjtcbmltcG9ydCB7IFByb2ZpbGVyIH0gZnJvbSBcIi4vY29yZV9wcm9maWxlci5qc1wiO1xuaW1wb3J0IFBhdGNoIGZyb20gXCIuL2NvcmVfcGF0Y2guanNcIjtcbmltcG9ydCB7IEluc3RhbmNpbmcgfSBmcm9tIFwiLi9pbnN0YW5jaW5nLmpzXCI7XG5pbXBvcnQgeyBMb2FkaW5nU3RhdHVzIH0gZnJvbSBcIi4vbG9hZGluZ3N0YXR1cy5qc1wiO1xuaW1wb3J0IHsgV0VCQVVESU8gfSBmcm9tIFwiLi93ZWJhdWRpby5qc1wiO1xuaW1wb3J0IHsgVmFyaWFibGUgfSBmcm9tIFwiLi9zZXNzaW9udmFyLmpzXCI7XG5pbXBvcnQgeyBUaW1lciwgbm93LCBpbnRlcm5hbE5vdyB9IGZyb20gXCIuL3RpbWVyLmpzXCI7XG5pbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IEJyYW5jaFN0YWNrLCBCcmFuY2ggfSBmcm9tIFwiLi9iYW5jaHByb2ZpbGVyLmpzXCI7XG5pbXBvcnQgeyBDR1AgfSBmcm9tIFwiLi9jZ3AvaW5kZXguanNcIjtcbmltcG9ydCB7IENHIH0gZnJvbSBcIi4vY2cvY2dfY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBDR0wgfSBmcm9tIFwiLi9jZ2wvaW5kZXguanNcIjtcblxud2luZG93LkNBQkxFUyA9IHdpbmRvdy5DQUJMRVMgfHwge307XG5cbkNBQkxFUy5DR0wgPSBDR0w7XG5DQUJMRVMuQ0cgPSBDRztcbkNBQkxFUy5DR1AgPSBDR1A7XG5DQUJMRVMuRU1CRUQgPSBFTUJFRDtcbkNBQkxFUy5MaW5rID0gTGluaztcbkNBQkxFUy5Qb3J0ID0gUG9ydDtcbkNBQkxFUy5PcCA9IE9wO1xuQ0FCTEVTLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5DQUJMRVMuUGF0Y2ggPSBQYXRjaDtcbkNBQkxFUy5JbnN0YW5jaW5nID0gSW5zdGFuY2luZztcbkNBQkxFUy5UaW1lciA9IFRpbWVyO1xuQ0FCTEVTLldFQkFVRElPID0gV0VCQVVESU87XG5DQUJMRVMuVmFyaWFibGUgPSBWYXJpYWJsZTtcbkNBQkxFUy5Mb2FkaW5nU3RhdHVzID0gTG9hZGluZ1N0YXR1cztcbkNBQkxFUy5ub3cgPSBub3c7XG5DQUJMRVMuaW50ZXJuYWxOb3cgPSBpbnRlcm5hbE5vdztcbkNBQkxFUy5CcmFuY2hTdGFjayA9IEJyYW5jaFN0YWNrO1xuQ0FCTEVTLkJyYW5jaCA9IEJyYW5jaDtcblxuXG5DQUJMRVMgPSBPYmplY3QuYXNzaWduKENBQkxFUyxcbiAgICBiYXNlNjQsXG4gICAgdXRpbHMsXG4gICAgYW5pbSxcbiAgICBDT05TVEFOVFMuUE9SVCxcbiAgICBDT05TVEFOVFMuUEFDTyxcbiAgICBDT05TVEFOVFMuQU5JTSxcbiAgICBDT05TVEFOVFMuT1Bcbik7XG5cbmV4cG9ydCBkZWZhdWx0IENBQkxFUztcblxuaWYgKCEoZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXM7IH0oKSkpIGNvbnNvbGUud2FybihcIm5vdCBpbiBzdHJpY3QgbW9kZTogaW5kZXggY29yZVwiKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/index.js\n");

/***/ }),

/***/ "./src/core/instancing.js":
/*!********************************!*\
  !*** ./src/core/instancing.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Instancing\": () => (/* binding */ Instancing)\n/* harmony export */ });\n// todo: needs to be removed...\n\nconst Instancing = function ()\n{\n    this._loops = [];\n    this._indizes = [];\n    this._index = 0;\n};\n\nInstancing.prototype.pushLoop = function (maxNum)\n{\n    this._loops.push(Math.abs(Math.floor(maxNum)));\n    this._indizes.push(this._index);\n};\n\nInstancing.prototype.popLoop = function ()\n{\n    this._loops.pop();\n    // this._index--;\n    this._index = this._indizes.pop();\n    if (this._loops.length === 0) this._index = 0;\n};\n\nInstancing.prototype.numLoops = function ()\n{\n    return this._loops.length;\n};\n\nInstancing.prototype.numCycles = function ()\n{\n    if (this._loops.length === 0) return 0;\n    let num = this._loops[0];\n    for (let i = 1; i < this._loops.length; i++) num *= this._loops[i];\n\n    return num;\n};\n\nInstancing.prototype.inLoop = function ()\n{\n    return this._loops.length > 0;\n};\n\nInstancing.prototype.increment = function ()\n{\n    this._index++;\n};\n\nInstancing.prototype.index = function ()\n{\n    return this._index;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9pbnN0YW5jaW5nLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi9zcmMvY29yZS9pbnN0YW5jaW5nLmpzPzNjYmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdG9kbzogbmVlZHMgdG8gYmUgcmVtb3ZlZC4uLlxuXG5jb25zdCBJbnN0YW5jaW5nID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9sb29wcyA9IFtdO1xuICAgIHRoaXMuX2luZGl6ZXMgPSBbXTtcbiAgICB0aGlzLl9pbmRleCA9IDA7XG59O1xuXG5JbnN0YW5jaW5nLnByb3RvdHlwZS5wdXNoTG9vcCA9IGZ1bmN0aW9uIChtYXhOdW0pXG57XG4gICAgdGhpcy5fbG9vcHMucHVzaChNYXRoLmFicyhNYXRoLmZsb29yKG1heE51bSkpKTtcbiAgICB0aGlzLl9pbmRpemVzLnB1c2godGhpcy5faW5kZXgpO1xufTtcblxuSW5zdGFuY2luZy5wcm90b3R5cGUucG9wTG9vcCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fbG9vcHMucG9wKCk7XG4gICAgLy8gdGhpcy5faW5kZXgtLTtcbiAgICB0aGlzLl9pbmRleCA9IHRoaXMuX2luZGl6ZXMucG9wKCk7XG4gICAgaWYgKHRoaXMuX2xvb3BzLmxlbmd0aCA9PT0gMCkgdGhpcy5faW5kZXggPSAwO1xufTtcblxuSW5zdGFuY2luZy5wcm90b3R5cGUubnVtTG9vcHMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9sb29wcy5sZW5ndGg7XG59O1xuXG5JbnN0YW5jaW5nLnByb3RvdHlwZS5udW1DeWNsZXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLl9sb29wcy5sZW5ndGggPT09IDApIHJldHVybiAwO1xuICAgIGxldCBudW0gPSB0aGlzLl9sb29wc1swXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX2xvb3BzLmxlbmd0aDsgaSsrKSBudW0gKj0gdGhpcy5fbG9vcHNbaV07XG5cbiAgICByZXR1cm4gbnVtO1xufTtcblxuSW5zdGFuY2luZy5wcm90b3R5cGUuaW5Mb29wID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5fbG9vcHMubGVuZ3RoID4gMDtcbn07XG5cbkluc3RhbmNpbmcucHJvdG90eXBlLmluY3JlbWVudCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5faW5kZXgrKztcbn07XG5cbkluc3RhbmNpbmcucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24gKClcbntcbiAgICByZXR1cm4gdGhpcy5faW5kZXg7XG59O1xuXG5leHBvcnQgeyBJbnN0YW5jaW5nIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/instancing.js\n");

/***/ }),

/***/ "./src/core/loadingstatus.js":
/*!***********************************!*\
  !*** ./src/core/loadingstatus.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LoadingStatus\": () => (/* binding */ LoadingStatus)\n/* harmony export */ });\n/* harmony import */ var cables_shared_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cables-shared-client */ \"../shared/client/src/logger.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./src/core/utils.js\");\n/* harmony import */ var _eventtarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eventtarget.js */ \"./src/core/eventtarget.js\");\n\n\n\n\n/**\n * LoadingStatus class, manages asynchronous loading jobs\n *\n * @external CABLES\n * @namespace LoadingStatus\n * @hideconstructor\n * @class\n */\nconst LoadingStatus = function (patch)\n{\n    _eventtarget_js__WEBPACK_IMPORTED_MODULE_0__.EventTarget.apply(this);\n\n    this._log = new cables_shared_client__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"LoadingStatus\");\n    this._loadingAssets = {};\n    this._cbFinished = [];\n    this._assetTasks = [];\n    this._percent = 0;\n    this._count = 0;\n    this._countFinished = 0;\n    this._order = 0;\n    this._startTime = 0;\n    this._patch = patch;\n    this._wasFinishedPrinted = false;\n    this._loadingAssetTaskCb = false;\n};\n\nLoadingStatus.prototype.setOnFinishedLoading = function (cb)\n{\n    this._cbFinished.push(cb);\n};\n\nLoadingStatus.prototype.getNumAssets = function ()\n{\n    return this._countFinished;\n};\n\nLoadingStatus.prototype.getProgress = function ()\n{\n    return this._percent;\n};\n\nLoadingStatus.prototype.checkStatus = function ()\n{\n    this._countFinished = 0;\n    this._count = 0;\n\n    for (const i in this._loadingAssets)\n    {\n        this._count++;\n        if (!this._loadingAssets[i].finished)\n        {\n            this._countFinished++;\n        }\n    }\n\n    this._percent = (this._count - this._countFinished) / this._count;\n\n    if (this._countFinished === 0)\n    {\n        for (let j = 0; j < this._cbFinished.length; j++)\n        {\n            if (this._cbFinished[j])\n            {\n                const cb = this._cbFinished[j];\n                setTimeout(() => { cb(this._patch); this.emitEvent(\"finishedAll\"); }, 100);\n            }\n        }\n\n        if (!this._wasFinishedPrinted)\n        {\n            this._wasFinishedPrinted = true;\n            this.print();\n        }\n        this.emitEvent(\"finishedAll\");\n    }\n};\n\nLoadingStatus.prototype.getList = function ()\n{\n    let arr = [];\n    for (const i in this._loadingAssets)\n    {\n        arr.push(this._loadingAssets[i]);\n    }\n\n    return arr;\n};\n\n\nLoadingStatus.prototype.getListJobs = function ()\n{\n    let arr = [];\n    for (const i in this._loadingAssets)\n    {\n        if (!this._loadingAssets[i].finished)arr.push(this._loadingAssets[i].name);\n    }\n\n    return arr;\n};\n\nLoadingStatus.prototype.print = function ()\n{\n    if (this._patch.config.silent) return;\n\n    const rows = [];\n\n    for (const i in this._loadingAssets)\n    {\n        rows.push([\n            this._loadingAssets[i].order,\n            this._loadingAssets[i].type,\n            this._loadingAssets[i].name,\n            (this._loadingAssets[i].timeEnd - this._loadingAssets[i].timeStart) / 1000 + \"s\",\n        ]);\n    }\n\n    this._log.groupCollapsed(\n        \"finished loading \" + this._order + \" assets in \" + (Date.now() - this._startTime) / 1000 + \"s\",\n    );\n    this._log.table(rows);\n    this._log.groupEnd();\n};\n\nLoadingStatus.prototype.finished = function (id)\n{\n    const l = this._loadingAssets[id];\n    if (l)\n    {\n        if (l.finished) this._log.warn(\"loading job was already finished\", l);\n\n        if (l.op) l.op.setUiAttribs({ \"loading\": false });\n        l.finished = true;\n        l.timeEnd = Date.now();\n    }\n\n    this.checkStatus();\n    this.emitEvent(\"finishedTask\");\n};\n\nLoadingStatus.prototype._startAssetTasks = function ()\n{\n    for (let i = 0; i < this._assetTasks.length; i++) this._assetTasks[i]();\n    this._assetTasks.length = 0;\n};\n\n/**\n * delay an asset loading task, mainly to wait for ui to be finished loading and showing, and only then start loading assets\n * @function addAssetLoadingTask\n * @instance\n * @memberof Op\n * @param {function} callback\n */\nLoadingStatus.prototype.addAssetLoadingTask = function (cb)\n{\n    if (this._patch.isEditorMode() && !CABLES.UI.loaded)\n    {\n        this._assetTasks.push(cb);\n\n        if (!this._loadingAssetTaskCb)window.gui.addEventListener(\"uiloaded\", this._startAssetTasks.bind(this));\n        this._loadingAssetTaskCb = true;\n    }\n    else\n    {\n        cb();\n    }\n    this.emitEvent(\"addAssetTask\");\n};\n\nLoadingStatus.prototype.existByName = function (name)\n{\n    for (let i in this._loadingAssets)\n    {\n        if (this._loadingAssets[i].name == name && !this._loadingAssets[i].finished)\n        {\n            return true;\n        }\n    }\n};\n\nLoadingStatus.prototype.start = function (type, name, op)\n{\n    if (this._startTime == 0) this._startTime = Date.now();\n    const id = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.generateUUID)();\n\n    if (op)op.setUiAttribs({ \"loading\": true });\n\n    this._loadingAssets[id] = {\n        \"id\": id,\n        \"op\": op,\n        \"type\": type,\n        \"name\": name,\n        \"finished\": false,\n        \"timeStart\": Date.now(),\n        \"order\": this._order,\n    };\n    this._order++;\n\n    this.emitEvent(\"startTask\");\n\n    return id;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9sb2FkaW5nc3RhdHVzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL2xvYWRpbmdzdGF0dXMuanM/YzVmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiY2FibGVzLXNoYXJlZC1jbGllbnRcIjtcbmltcG9ydCB7IGdlbmVyYXRlVVVJRCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBFdmVudFRhcmdldCB9IGZyb20gXCIuL2V2ZW50dGFyZ2V0LmpzXCI7XG5cbi8qKlxuICogTG9hZGluZ1N0YXR1cyBjbGFzcywgbWFuYWdlcyBhc3luY2hyb25vdXMgbG9hZGluZyBqb2JzXG4gKlxuICogQGV4dGVybmFsIENBQkxFU1xuICogQG5hbWVzcGFjZSBMb2FkaW5nU3RhdHVzXG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKiBAY2xhc3NcbiAqL1xuY29uc3QgTG9hZGluZ1N0YXR1cyA9IGZ1bmN0aW9uIChwYXRjaClcbntcbiAgICBFdmVudFRhcmdldC5hcHBseSh0aGlzKTtcblxuICAgIHRoaXMuX2xvZyA9IG5ldyBMb2dnZXIoXCJMb2FkaW5nU3RhdHVzXCIpO1xuICAgIHRoaXMuX2xvYWRpbmdBc3NldHMgPSB7fTtcbiAgICB0aGlzLl9jYkZpbmlzaGVkID0gW107XG4gICAgdGhpcy5fYXNzZXRUYXNrcyA9IFtdO1xuICAgIHRoaXMuX3BlcmNlbnQgPSAwO1xuICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICB0aGlzLl9jb3VudEZpbmlzaGVkID0gMDtcbiAgICB0aGlzLl9vcmRlciA9IDA7XG4gICAgdGhpcy5fc3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLl9wYXRjaCA9IHBhdGNoO1xuICAgIHRoaXMuX3dhc0ZpbmlzaGVkUHJpbnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xvYWRpbmdBc3NldFRhc2tDYiA9IGZhbHNlO1xufTtcblxuTG9hZGluZ1N0YXR1cy5wcm90b3R5cGUuc2V0T25GaW5pc2hlZExvYWRpbmcgPSBmdW5jdGlvbiAoY2IpXG57XG4gICAgdGhpcy5fY2JGaW5pc2hlZC5wdXNoKGNiKTtcbn07XG5cbkxvYWRpbmdTdGF0dXMucHJvdG90eXBlLmdldE51bUFzc2V0cyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX2NvdW50RmluaXNoZWQ7XG59O1xuXG5Mb2FkaW5nU3RhdHVzLnByb3RvdHlwZS5nZXRQcm9ncmVzcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX3BlcmNlbnQ7XG59O1xuXG5Mb2FkaW5nU3RhdHVzLnByb3RvdHlwZS5jaGVja1N0YXR1cyA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fY291bnRGaW5pc2hlZCA9IDA7XG4gICAgdGhpcy5fY291bnQgPSAwO1xuXG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2xvYWRpbmdBc3NldHMpXG4gICAge1xuICAgICAgICB0aGlzLl9jb3VudCsrO1xuICAgICAgICBpZiAoIXRoaXMuX2xvYWRpbmdBc3NldHNbaV0uZmluaXNoZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NvdW50RmluaXNoZWQrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3BlcmNlbnQgPSAodGhpcy5fY291bnQgLSB0aGlzLl9jb3VudEZpbmlzaGVkKSAvIHRoaXMuX2NvdW50O1xuXG4gICAgaWYgKHRoaXMuX2NvdW50RmluaXNoZWQgPT09IDApXG4gICAge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX2NiRmluaXNoZWQubGVuZ3RoOyBqKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYkZpbmlzaGVkW2pdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gdGhpcy5fY2JGaW5pc2hlZFtqXTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgY2IodGhpcy5fcGF0Y2gpOyB0aGlzLmVtaXRFdmVudChcImZpbmlzaGVkQWxsXCIpOyB9LCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl93YXNGaW5pc2hlZFByaW50ZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3dhc0ZpbmlzaGVkUHJpbnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnByaW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJmaW5pc2hlZEFsbFwiKTtcbiAgICB9XG59O1xuXG5Mb2FkaW5nU3RhdHVzLnByb3RvdHlwZS5nZXRMaXN0ID0gZnVuY3Rpb24gKClcbntcbiAgICBsZXQgYXJyID0gW107XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2xvYWRpbmdBc3NldHMpXG4gICAge1xuICAgICAgICBhcnIucHVzaCh0aGlzLl9sb2FkaW5nQXNzZXRzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xufTtcblxuXG5Mb2FkaW5nU3RhdHVzLnByb3RvdHlwZS5nZXRMaXN0Sm9icyA9IGZ1bmN0aW9uICgpXG57XG4gICAgbGV0IGFyciA9IFtdO1xuICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLl9sb2FkaW5nQXNzZXRzKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkaW5nQXNzZXRzW2ldLmZpbmlzaGVkKWFyci5wdXNoKHRoaXMuX2xvYWRpbmdBc3NldHNbaV0ubmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbn07XG5cbkxvYWRpbmdTdGF0dXMucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fcGF0Y2guY29uZmlnLnNpbGVudCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgcm93cyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMuX2xvYWRpbmdBc3NldHMpXG4gICAge1xuICAgICAgICByb3dzLnB1c2goW1xuICAgICAgICAgICAgdGhpcy5fbG9hZGluZ0Fzc2V0c1tpXS5vcmRlcixcbiAgICAgICAgICAgIHRoaXMuX2xvYWRpbmdBc3NldHNbaV0udHlwZSxcbiAgICAgICAgICAgIHRoaXMuX2xvYWRpbmdBc3NldHNbaV0ubmFtZSxcbiAgICAgICAgICAgICh0aGlzLl9sb2FkaW5nQXNzZXRzW2ldLnRpbWVFbmQgLSB0aGlzLl9sb2FkaW5nQXNzZXRzW2ldLnRpbWVTdGFydCkgLyAxMDAwICsgXCJzXCIsXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIHRoaXMuX2xvZy5ncm91cENvbGxhcHNlZChcbiAgICAgICAgXCJmaW5pc2hlZCBsb2FkaW5nIFwiICsgdGhpcy5fb3JkZXIgKyBcIiBhc3NldHMgaW4gXCIgKyAoRGF0ZS5ub3coKSAtIHRoaXMuX3N0YXJ0VGltZSkgLyAxMDAwICsgXCJzXCIsXG4gICAgKTtcbiAgICB0aGlzLl9sb2cudGFibGUocm93cyk7XG4gICAgdGhpcy5fbG9nLmdyb3VwRW5kKCk7XG59O1xuXG5Mb2FkaW5nU3RhdHVzLnByb3RvdHlwZS5maW5pc2hlZCA9IGZ1bmN0aW9uIChpZClcbntcbiAgICBjb25zdCBsID0gdGhpcy5fbG9hZGluZ0Fzc2V0c1tpZF07XG4gICAgaWYgKGwpXG4gICAge1xuICAgICAgICBpZiAobC5maW5pc2hlZCkgdGhpcy5fbG9nLndhcm4oXCJsb2FkaW5nIGpvYiB3YXMgYWxyZWFkeSBmaW5pc2hlZFwiLCBsKTtcblxuICAgICAgICBpZiAobC5vcCkgbC5vcC5zZXRVaUF0dHJpYnMoeyBcImxvYWRpbmdcIjogZmFsc2UgfSk7XG4gICAgICAgIGwuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBsLnRpbWVFbmQgPSBEYXRlLm5vdygpO1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tTdGF0dXMoKTtcbiAgICB0aGlzLmVtaXRFdmVudChcImZpbmlzaGVkVGFza1wiKTtcbn07XG5cbkxvYWRpbmdTdGF0dXMucHJvdG90eXBlLl9zdGFydEFzc2V0VGFza3MgPSBmdW5jdGlvbiAoKVxue1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXNzZXRUYXNrcy5sZW5ndGg7IGkrKykgdGhpcy5fYXNzZXRUYXNrc1tpXSgpO1xuICAgIHRoaXMuX2Fzc2V0VGFza3MubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogZGVsYXkgYW4gYXNzZXQgbG9hZGluZyB0YXNrLCBtYWlubHkgdG8gd2FpdCBmb3IgdWkgdG8gYmUgZmluaXNoZWQgbG9hZGluZyBhbmQgc2hvd2luZywgYW5kIG9ubHkgdGhlbiBzdGFydCBsb2FkaW5nIGFzc2V0c1xuICogQGZ1bmN0aW9uIGFkZEFzc2V0TG9hZGluZ1Rhc2tcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlcm9mIE9wXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5Mb2FkaW5nU3RhdHVzLnByb3RvdHlwZS5hZGRBc3NldExvYWRpbmdUYXNrID0gZnVuY3Rpb24gKGNiKVxue1xuICAgIGlmICh0aGlzLl9wYXRjaC5pc0VkaXRvck1vZGUoKSAmJiAhQ0FCTEVTLlVJLmxvYWRlZClcbiAgICB7XG4gICAgICAgIHRoaXMuX2Fzc2V0VGFza3MucHVzaChjYik7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkaW5nQXNzZXRUYXNrQ2Ipd2luZG93Lmd1aS5hZGRFdmVudExpc3RlbmVyKFwidWlsb2FkZWRcIiwgdGhpcy5fc3RhcnRBc3NldFRhc2tzLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9sb2FkaW5nQXNzZXRUYXNrQ2IgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBjYigpO1xuICAgIH1cbiAgICB0aGlzLmVtaXRFdmVudChcImFkZEFzc2V0VGFza1wiKTtcbn07XG5cbkxvYWRpbmdTdGF0dXMucHJvdG90eXBlLmV4aXN0QnlOYW1lID0gZnVuY3Rpb24gKG5hbWUpXG57XG4gICAgZm9yIChsZXQgaSBpbiB0aGlzLl9sb2FkaW5nQXNzZXRzKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvYWRpbmdBc3NldHNbaV0ubmFtZSA9PSBuYW1lICYmICF0aGlzLl9sb2FkaW5nQXNzZXRzW2ldLmZpbmlzaGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkxvYWRpbmdTdGF0dXMucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIG9wKVxue1xuICAgIGlmICh0aGlzLl9zdGFydFRpbWUgPT0gMCkgdGhpcy5fc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBpZCA9IGdlbmVyYXRlVVVJRCgpO1xuXG4gICAgaWYgKG9wKW9wLnNldFVpQXR0cmlicyh7IFwibG9hZGluZ1wiOiB0cnVlIH0pO1xuXG4gICAgdGhpcy5fbG9hZGluZ0Fzc2V0c1tpZF0gPSB7XG4gICAgICAgIFwiaWRcIjogaWQsXG4gICAgICAgIFwib3BcIjogb3AsXG4gICAgICAgIFwidHlwZVwiOiB0eXBlLFxuICAgICAgICBcIm5hbWVcIjogbmFtZSxcbiAgICAgICAgXCJmaW5pc2hlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJ0aW1lU3RhcnRcIjogRGF0ZS5ub3coKSxcbiAgICAgICAgXCJvcmRlclwiOiB0aGlzLl9vcmRlcixcbiAgICB9O1xuICAgIHRoaXMuX29yZGVyKys7XG5cbiAgICB0aGlzLmVtaXRFdmVudChcInN0YXJ0VGFza1wiKTtcblxuICAgIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydCB7IExvYWRpbmdTdGF0dXMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/loadingstatus.js\n");

/***/ }),

/***/ "./src/core/sessionvar.js":
/*!********************************!*\
  !*** ./src/core/sessionvar.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Variable\": () => (/* binding */ Variable)\n/* harmony export */ });\n// todo: old... remove this from ops...\n\nconst Variable = function ()\n{\n    let value = null;\n    const changedCallbacks = [];\n\n    this.onChanged = function (f)\n    {\n        changedCallbacks.push(f);\n    };\n\n    this.getValue = function ()\n    {\n        return value;\n    };\n\n    this.setValue = function (v)\n    {\n        value = v;\n        this.emitChanged();\n    };\n\n    this.emitChanged = function ()\n    {\n        for (let i = 0; i < changedCallbacks.length; i++)\n        {\n            changedCallbacks[i]();\n        }\n    };\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9zZXNzaW9udmFyLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uL3NyYy9jb3JlL3Nlc3Npb252YXIuanM/ZGY1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0b2RvOiBvbGQuLi4gcmVtb3ZlIHRoaXMgZnJvbSBvcHMuLi5cblxuY29uc3QgVmFyaWFibGUgPSBmdW5jdGlvbiAoKVxue1xuICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgY29uc3QgY2hhbmdlZENhbGxiYWNrcyA9IFtdO1xuXG4gICAgdGhpcy5vbkNoYW5nZWQgPSBmdW5jdGlvbiAoZilcbiAgICB7XG4gICAgICAgIGNoYW5nZWRDYWxsYmFja3MucHVzaChmKTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0VmFsdWUgPSBmdW5jdGlvbiAodilcbiAgICB7XG4gICAgICAgIHZhbHVlID0gdjtcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlZCgpO1xuICAgIH07XG5cbiAgICB0aGlzLmVtaXRDaGFuZ2VkID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlZENhbGxiYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgY2hhbmdlZENhbGxiYWNrc1tpXSgpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbmV4cG9ydCB7IFZhcmlhYmxlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/sessionvar.js\n");

/***/ }),

/***/ "./src/core/timer.js":
/*!***************************!*\
  !*** ./src/core/timer.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Timer\": () => (/* binding */ Timer),\n/* harmony export */   \"internalNow\": () => (/* binding */ internalNow),\n/* harmony export */   \"now\": () => (/* binding */ now)\n/* harmony export */ });\n/* harmony import */ var _eventtarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eventtarget.js */ \"./src/core/eventtarget.js\");\n\n\n/** @namespace CABLES */\n\nconst internalNow = function ()\n{\n    return window.performance.now();\n};\n\n/**\n * current time in milliseconds\n * @memberof CABLES\n * @function now\n * @static\n */\nconst now = function ()\n{\n    return internalNow();\n};\n\n// ----------------------------\n\n/**\n * Measuring time\n * @external CABLES\n * @namespace Timer\n * @hideconstructor\n * @class\n */\nconst Timer = function ()\n{\n    _eventtarget_js__WEBPACK_IMPORTED_MODULE_0__.EventTarget.apply(this);\n\n    this._timeStart = internalNow();\n    this._timeOffset = 0;\n\n    this._currentTime = 0;\n    this._lastTime = 0;\n    this._paused = true;\n    this._delay = 0;\n    this.overwriteTime = -1;\n};\n\nTimer.prototype._getTime = function ()\n{\n    this._lastTime = (internalNow() - this._timeStart) / 1000;\n    return this._lastTime + this._timeOffset;\n};\n\nTimer.prototype.setDelay = function (d)\n{\n    this._delay = d;\n    this.emitEvent(\"timeChange\");\n};\n\n/**\n * @function\n * @memberof Timer\n * @instance\n * @description returns true if timer is playing\n * @return {Boolean} value\n */\nTimer.prototype.isPlaying = function ()\n{\n    return !this._paused;\n};\n\n/**\n * @function\n * @memberof Timer\n * @instance\n * @description update timer\n * @return {Number} time\n */\nTimer.prototype.update = function ()\n{\n    if (this._paused) return;\n    this._currentTime = this._getTime();\n\n    return this._currentTime;\n};\n\n/**\n * @function\n * @memberof Timer\n * @instance\n * @return {Number} time in milliseconds\n */\nTimer.prototype.getMillis = function ()\n{\n    return this.get() * 1000;\n};\n\n/**\n * @function\n * @memberof Timer\n * @instance\n * @return {Number} value time in seconds\n */\nTimer.prototype.get = Timer.prototype.getTime = function ()\n{\n    if (this.overwriteTime >= 0) return this.overwriteTime - this._delay;\n    return this._currentTime - this._delay;\n};\n\n/**\n * toggle between play/pause state\n * @function\n * @memberof Timer\n * @instance\n */\nTimer.prototype.togglePlay = function ()\n{\n    if (this._paused) this.play();\n    else this.pause();\n};\n\n/**\n * set current time\n * @function\n * @memberof Timer\n * @instance\n * @param {Number} t\n */\nTimer.prototype.setTime = function (t)\n{\n    if (isNaN(t) || t < 0) t = 0;\n    this._timeStart = internalNow();\n    this._timeOffset = t;\n    this._currentTime = t;\n    this.emitEvent(\"timeChange\");\n};\n\nTimer.prototype.setOffset = function (val)\n{\n    if (this._currentTime + val < 0)\n    {\n        this._timeStart = internalNow();\n        this._timeOffset = 0;\n        this._currentTime = 0;\n    }\n    else\n    {\n        this._timeOffset += val;\n        this._currentTime = this._lastTime + this._timeOffset;\n    }\n    this.emitEvent(\"timeChange\");\n};\n\n/**\n * (re)starts the timer\n * @function\n * @memberof Timer\n * @instance\n */\nTimer.prototype.play = function ()\n{\n    this._timeStart = internalNow();\n    this._paused = false;\n    this.emitEvent(\"playPause\");\n};\n\n/**\n * pauses the timer\n * @function\n * @memberof Timer\n * @instance\n */\nTimer.prototype.pause = function ()\n{\n    this._timeOffset = this._currentTime;\n    this._paused = true;\n    this.emitEvent(\"playPause\");\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS90aW1lci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvdGltZXIuanM/NzJkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudFRhcmdldCB9IGZyb20gXCIuL2V2ZW50dGFyZ2V0LmpzXCI7XG5cbi8qKiBAbmFtZXNwYWNlIENBQkxFUyAqL1xuXG5leHBvcnQgY29uc3QgaW50ZXJuYWxOb3cgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG59O1xuXG4vKipcbiAqIGN1cnJlbnQgdGltZSBpbiBtaWxsaXNlY29uZHNcbiAqIEBtZW1iZXJvZiBDQUJMRVNcbiAqIEBmdW5jdGlvbiBub3dcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0IGNvbnN0IG5vdyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIGludGVybmFsTm93KCk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogTWVhc3VyaW5nIHRpbWVcbiAqIEBleHRlcm5hbCBDQUJMRVNcbiAqIEBuYW1lc3BhY2UgVGltZXJcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqIEBjbGFzc1xuICovXG5jb25zdCBUaW1lciA9IGZ1bmN0aW9uICgpXG57XG4gICAgRXZlbnRUYXJnZXQuYXBwbHkodGhpcyk7XG5cbiAgICB0aGlzLl90aW1lU3RhcnQgPSBpbnRlcm5hbE5vdygpO1xuICAgIHRoaXMuX3RpbWVPZmZzZXQgPSAwO1xuXG4gICAgdGhpcy5fY3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMuX2xhc3RUaW1lID0gMDtcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuX2RlbGF5ID0gMDtcbiAgICB0aGlzLm92ZXJ3cml0ZVRpbWUgPSAtMTtcbn07XG5cblRpbWVyLnByb3RvdHlwZS5fZ2V0VGltZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fbGFzdFRpbWUgPSAoaW50ZXJuYWxOb3coKSAtIHRoaXMuX3RpbWVTdGFydCkgLyAxMDAwO1xuICAgIHJldHVybiB0aGlzLl9sYXN0VGltZSArIHRoaXMuX3RpbWVPZmZzZXQ7XG59O1xuXG5UaW1lci5wcm90b3R5cGUuc2V0RGVsYXkgPSBmdW5jdGlvbiAoZClcbntcbiAgICB0aGlzLl9kZWxheSA9IGQ7XG4gICAgdGhpcy5lbWl0RXZlbnQoXCJ0aW1lQ2hhbmdlXCIpO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBUaW1lclxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gcmV0dXJucyB0cnVlIGlmIHRpbWVyIGlzIHBsYXlpbmdcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHZhbHVlXG4gKi9cblRpbWVyLnByb3RvdHlwZS5pc1BsYXlpbmcgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiAhdGhpcy5fcGF1c2VkO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBUaW1lclxuICogQGluc3RhbmNlXG4gKiBAZGVzY3JpcHRpb24gdXBkYXRlIHRpbWVyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRpbWVcbiAqL1xuVGltZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX3BhdXNlZCkgcmV0dXJuO1xuICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gdGhpcy5fZ2V0VGltZSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUaW1lO1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBUaW1lclxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gKi9cblRpbWVyLnByb3RvdHlwZS5nZXRNaWxsaXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLmdldCgpICogMTAwMDtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgVGltZXJcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybiB7TnVtYmVyfSB2YWx1ZSB0aW1lIGluIHNlY29uZHNcbiAqL1xuVGltZXIucHJvdG90eXBlLmdldCA9IFRpbWVyLnByb3RvdHlwZS5nZXRUaW1lID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5vdmVyd3JpdGVUaW1lID49IDApIHJldHVybiB0aGlzLm92ZXJ3cml0ZVRpbWUgLSB0aGlzLl9kZWxheTtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFRpbWUgLSB0aGlzLl9kZWxheTtcbn07XG5cbi8qKlxuICogdG9nZ2xlIGJldHdlZW4gcGxheS9wYXVzZSBzdGF0ZVxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgVGltZXJcbiAqIEBpbnN0YW5jZVxuICovXG5UaW1lci5wcm90b3R5cGUudG9nZ2xlUGxheSA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX3BhdXNlZCkgdGhpcy5wbGF5KCk7XG4gICAgZWxzZSB0aGlzLnBhdXNlKCk7XG59O1xuXG4vKipcbiAqIHNldCBjdXJyZW50IHRpbWVcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIFRpbWVyXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSB0XG4gKi9cblRpbWVyLnByb3RvdHlwZS5zZXRUaW1lID0gZnVuY3Rpb24gKHQpXG57XG4gICAgaWYgKGlzTmFOKHQpIHx8IHQgPCAwKSB0ID0gMDtcbiAgICB0aGlzLl90aW1lU3RhcnQgPSBpbnRlcm5hbE5vdygpO1xuICAgIHRoaXMuX3RpbWVPZmZzZXQgPSB0O1xuICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gdDtcbiAgICB0aGlzLmVtaXRFdmVudChcInRpbWVDaGFuZ2VcIik7XG59O1xuXG5UaW1lci5wcm90b3R5cGUuc2V0T2Zmc2V0ID0gZnVuY3Rpb24gKHZhbClcbntcbiAgICBpZiAodGhpcy5fY3VycmVudFRpbWUgKyB2YWwgPCAwKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdGltZVN0YXJ0ID0gaW50ZXJuYWxOb3coKTtcbiAgICAgICAgdGhpcy5fdGltZU9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gMDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5fdGltZU9mZnNldCArPSB2YWw7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gdGhpcy5fbGFzdFRpbWUgKyB0aGlzLl90aW1lT2Zmc2V0O1xuICAgIH1cbiAgICB0aGlzLmVtaXRFdmVudChcInRpbWVDaGFuZ2VcIik7XG59O1xuXG4vKipcbiAqIChyZSlzdGFydHMgdGhlIHRpbWVyXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBUaW1lclxuICogQGluc3RhbmNlXG4gKi9cblRpbWVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl90aW1lU3RhcnQgPSBpbnRlcm5hbE5vdygpO1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdEV2ZW50KFwicGxheVBhdXNlXCIpO1xufTtcblxuLyoqXG4gKiBwYXVzZXMgdGhlIHRpbWVyXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBUaW1lclxuICogQGluc3RhbmNlXG4gKi9cblRpbWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fdGltZU9mZnNldCA9IHRoaXMuX2N1cnJlbnRUaW1lO1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0RXZlbnQoXCJwbGF5UGF1c2VcIik7XG59O1xuXG5leHBvcnQgeyBUaW1lciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/timer.js\n");

/***/ }),

/***/ "./src/core/utils.js":
/*!***************************!*\
  !*** ./src/core/utils.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UTILS\": () => (/* binding */ UTILS),\n/* harmony export */   \"ajax\": () => (/* binding */ ajax),\n/* harmony export */   \"ajaxSync\": () => (/* binding */ ajaxSync),\n/* harmony export */   \"basename\": () => (/* binding */ basename),\n/* harmony export */   \"cacheBust\": () => (/* binding */ cacheBust),\n/* harmony export */   \"clamp\": () => (/* binding */ clamp),\n/* harmony export */   \"cleanJson\": () => (/* binding */ cleanJson),\n/* harmony export */   \"copyArray\": () => (/* binding */ copyArray),\n/* harmony export */   \"filename\": () => (/* binding */ filename),\n/* harmony export */   \"generateUUID\": () => (/* binding */ generateUUID),\n/* harmony export */   \"getShortOpName\": () => (/* binding */ getShortOpName),\n/* harmony export */   \"keyCodeToName\": () => (/* binding */ keyCodeToName),\n/* harmony export */   \"logStack\": () => (/* binding */ logStack),\n/* harmony export */   \"map\": () => (/* binding */ map),\n/* harmony export */   \"prefixedHash\": () => (/* binding */ prefixedHash),\n/* harmony export */   \"request\": () => (/* binding */ request),\n/* harmony export */   \"shortId\": () => (/* binding */ shortId),\n/* harmony export */   \"shuffleArray\": () => (/* binding */ shuffleArray),\n/* harmony export */   \"simpleId\": () => (/* binding */ simpleId),\n/* harmony export */   \"smoothStep\": () => (/* binding */ smoothStep),\n/* harmony export */   \"smootherStep\": () => (/* binding */ smootherStep),\n/* harmony export */   \"uuid\": () => (/* binding */ uuid)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./src/core/constants.js\");\n\n/**\n * @external CABLES\n * @namespace Utils\n */\n\n\n\nconst UTILS = {};\n/**\n * Merge two Float32Arrays.\n * @function float32Concat\n * @memberof Utils\n * @param {Float32Array} first Left-hand side array\n * @param {Float32Array} second Right-hand side array\n * @return {Float32Array}\n * @static\n */\nUTILS.float32Concat = function (first, second)\n{\n    if (!(first instanceof Float32Array)) first = new Float32Array(first);\n    if (!(second instanceof Float32Array)) second = new Float32Array(second);\n\n    const result = new Float32Array(first.length + second.length);\n\n    result.set(first);\n    result.set(second, first.length);\n\n    return result;\n};\n\n/**\n * get op shortname: only last part of fullname and without version\n * @function getShortOpName\n * @memberof CABLES\n * @param {String} full op name\n * @static\n */\nconst getShortOpName = function (fullname)\n{\n    let name = fullname.split(\".\")[fullname.split(\".\").length - 1];\n\n    if (name.contains(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_VERSION_PREFIX))\n    {\n        const n = name.split(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_VERSION_PREFIX)[1];\n        name = name.substring(0, name.length - (_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_VERSION_PREFIX + n).length);\n    }\n    return name;\n};\n\n/**\n * randomize order of an array\n * @function shuffleArray\n * @memberof Utils\n * @param {Array|Float32Array} array {Array} original\n * @return {Array|Float32Array} shuffled array\n * @static\n */\nconst shuffleArray = function (array)\n{\n    for (let i = array.length - 1; i > 0; i--)\n    {\n        const j = Math.floor(Math.seededRandom() * (i + 1));\n        const temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    return array;\n};\n\n\n/**\n * generate a short \"relativly unique\" id\n * @function shortId\n * @memberof Utils\n * @return {String} generated ID\n * @static\n */\n\nconst _shortIds = {};\nconst _shortId = function ()\n{\n    let str = Math.random().toString(36).substr(2, 9);\n\n    if (_shortIds.hasOwnProperty(str)) str = _shortId();\n    _shortIds[str] = true;\n    return str;\n};\nconst shortId = _shortId;\n\n\n/**\n * generate a UUID\n * @function uuid\n * @memberof Utils\n * @return {String} generated UUID\n * @static\n */\nconst _uuid = function ()\n{\n    let d = new Date().getTime();\n    const uuid = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) =>\n    {\n        const r = (d + Math.random() * 16) % 16 | 0;\n        d = Math.floor(d / 16);\n        return (c == \"x\" ? r : (r & 0x3) | 0x8).toString(16);\n    });\n    return uuid;\n};\nconst uuid = _uuid;\nconst generateUUID = _uuid;\n\n\n\nfunction cleanJson(obj)\n{\n    for (const i in obj)\n    {\n        if (obj[i] && typeof objValue === \"object\" && obj[i].constructor === Object) obj[i] = cleanJson(obj[i]);\n\n        if (obj[i] === null || obj[i] === undefined) delete obj[i];\n        else if (Array.isArray(obj[i]) && obj[i].length == 0) delete obj[i];\n    }\n\n    return obj;\n}\n\n\n/**\n * @see http://stackoverflow.com/q/7616461/940217\n * @return {string}\n */\nconst _prefixedHash = function (str, prefix = \"id\")\n{\n    let hash = 0;\n    if (Array.prototype.reduce)\n    {\n        hash = str.split(\"\").reduce((a, b) => { a = ((a << 5) - a) + b.charCodeAt(0); return a & a; }, 0);\n    }\n    else\n    {\n        if (str.length > 0)\n        {\n            for (let i = 0; i < str.length; i++)\n            {\n                let character = str.charCodeAt(i);\n                hash = ((hash << 5) - hash) + character;\n                hash &= hash; // Convert to 32bit integer\n            }\n        }\n    }\n    return prefix + \"\" + hash;\n};\nconst prefixedHash = _prefixedHash;\n\n/**\n * generate a simple ID\n * @function simpleId\n * @memberof Utils\n * @return {Number} new id\n * @static\n */\nlet simpleIdCounter = 0;\nconst simpleId = function ()\n{\n    simpleIdCounter++;\n    return simpleIdCounter;\n};\n\n/**\n * smoothStep a value\n * @function smoothStep\n * @memberof Utils\n * @function\n * @param {Number} value value to be smoothed [0-1]\n * @return {Number} smoothed value\n * @static\n */\nconst smoothStep = function (perc)\n{\n    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));\n    perc = x * x * (3 - 2 * x); // smoothstep\n    return perc;\n};\n\n/**\n * smootherstep a value\n * @function smootherStep\n * @memberof Utils\n * @param value {Number} value to be smoothed [0-1]\n * @return {Number} smoothed value\n * @static\n */\nconst smootherStep = function (perc)\n{\n    const x = Math.max(0, Math.min(1, (perc - 0) / (1 - 0)));\n    perc = x * x * x * (x * (x * 6 - 15) + 10); // smootherstep\n    return perc;\n};\n\n\n/**\n * clamp number / make sure its between min/max\n * @function clamp\n * @memberof Utils\n * @param {Number} value value to be mapped\n * @param {Number} min minimum value\n * @param {Number} max maximum value\n * @static\n */\nconst clamp = function (value, min, max)\n{\n    return Math.min(Math.max(value, min), max);\n};\n\n/**\n * map a value in a range to a value in another range\n * @function map\n * @memberof Utils\n * @param {Number} value value to be mapped\n * @param {Number} oldMin old range minimum value\n * @param {Number} oldMax old range maximum value\n * @param {Number} newMin new range minimum value\n * @param {Number} newMax new range maximum value\n * @return {Number} mapped value\n * @static\n */\nconst map = function (x, _oldMin, _oldMax, _newMin, _newMax, _easing)\n{\n    if (x >= _oldMax) return _newMax;\n    if (x <= _oldMin) return _newMin;\n\n    let reverseInput = false;\n    const oldMin = Math.min(_oldMin, _oldMax);\n    const oldMax = Math.max(_oldMin, _oldMax);\n    if (oldMin != _oldMin) reverseInput = true;\n\n    let reverseOutput = false;\n    const newMin = Math.min(_newMin, _newMax);\n    const newMax = Math.max(_newMin, _newMax);\n    if (newMin != _newMin) reverseOutput = true;\n\n    let portion = 0;\n    let r = 0;\n\n    if (reverseInput) portion = ((oldMax - x) * (newMax - newMin)) / (oldMax - oldMin);\n    else portion = ((x - oldMin) * (newMax - newMin)) / (oldMax - oldMin);\n\n    if (reverseOutput) r = newMax - portion;\n    else r = portion + newMin;\n\n    if (!_easing) return r;\n    if (_easing == 1)\n    {\n        // smoothstep\n        x = Math.max(0, Math.min(1, (r - _newMin) / (_newMax - _newMin)));\n        return _newMin + x * x * (3 - 2 * x) * (_newMax - _newMin);\n    }\n    if (_easing == 2)\n    {\n        // smootherstep\n        x = Math.max(0, Math.min(1, (r - _newMin) / (_newMax - _newMin)));\n        return _newMin + x * x * x * (x * (x * 6 - 15) + 10) * (_newMax - _newMin);\n    }\n\n    return r;\n};\n\n/**\n * @namespace Math\n */\n/**\n * set random seed for seededRandom()\n * @memberof Math\n * @type Number\n * @static\n */\nMath.randomSeed = 1;\n\n\nMath.setRandomSeed = function (seed)\n{\n    // https://github.com/cables-gl/cables_docs/issues/622\n    Math.randomSeed = seed * 50728129;\n    if (seed != 0)\n    {\n        Math.randomSeed = Math.seededRandom() * 17624813;\n        Math.randomSeed = Math.seededRandom() * 9737333;\n    }\n};\n\n\n/**\n * generate a seeded random number\n * @function seededRandom\n * @memberof Math\n * @param {Number} max minimum possible random number\n * @param {Number} min maximum possible random number\n * @return {Number} random value\n * @static\n */\nMath.seededRandom = function (max, min)\n{\n    if (Math.randomSeed === 0) Math.randomSeed = Math.random() * 999;\n    max = max || 1;\n    min = min || 0;\n\n    Math.randomSeed = (Math.randomSeed * 9301 + 49297) % 233280;\n    const rnd = Math.randomSeed / 233280.0;\n\n    return min + rnd * (max - min);\n};\n\n\n// ----------------------------------------------------------------\n\n/**\n * returns true if parameter is a number\n * @function isNumeric\n * @memberof Utils\n * @param {Any} value The value to check.\n * @return {Boolean}\n * @static\n */\nUTILS.isNumeric = function (n)\n{\n    return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\n/**\n * returns true if parameter is array\n * @function isArray\n * @param {Any} value Value to check\n * @memberof Utils\n * @return {Boolean}\n * @static\n */\nUTILS.isArray = function (v)\n{\n    return Object.prototype.toString.call(v) === \"[object Array]\";\n};\n\n/**\n * @namespace String\n */\n\n/**\n * append a linebreak to a string\n * @function endl\n * @memberof String\n * @return {String} string with newline break appended ('\\n')\n */\nString.prototype.endl = function ()\n{\n    return this + \"\\n\";\n};\n\n/**\n * return true if string starts with prefix\n * @function startsWith\n * @memberof String\n * @param {String} prefix The prefix to check.\n * @return {Boolean}\n */\nString.prototype.startsWith = function (prefix)\n{\n    return this.indexOf(prefix) === 0;\n};\n\n/**\n * return true if string ends with suffix\n * @function endsWith\n * @memberof String\n * @param {String} suffix\n * @return {Boolean}\n */\nString.prototype.endsWith = String.prototype.endsWith || function (suffix)\n{\n    return this.match(suffix + \"$\") == suffix;\n};\n\n/**\n * return true if string contains string\n * @function contains\n * @memberof String\n * @param {String} searchStr\n * @return {Boolean}\n */\nString.prototype.contains = String.prototype.contains || function (searchStr)\n{\n    return this.indexOf(searchStr) > -1;\n};\n\n\n\n// ----------------------------------------------------------------\n\n/**\n * append a unique/random parameter to a url, so the browser is forced to reload the file, even if its cached\n * @function cacheBust\n * @static\n * @memberof Utils\n * @param {String} url The url to append the cachebuster parameter to.\n * @return {String} url with cachebuster parameter\n */\nconst cacheBust = function (url)\n{\n    if (url.contains(\"?\")) url += \"&\";\n    else url += \"?\";\n    return url + \"cache=\" + CABLES.uuid();\n};\n\n/**\n * copy the content of an array\n * @function copyArray\n * @static\n * @memberof Utils\n * @param {Array} sourceArray\n * @param {Array} dst optional\n * @return {Array} dst\n */\nconst copyArray = function (src, dst)\n{\n    if (!src) return null;\n    dst = dst || [];\n    dst.length = src.length;\n    for (let i = 0; i < src.length; i++)\n    {\n        dst[i] = src[i];\n    }\n\n    return dst;\n};\n\n\n/**\n * return the filename part of a url without extension\n * @function basename\n * @static\n * @memberof Utils\n * @param {String} url\n * @return {String} just the filename\n */\nconst basename = function (url)\n{\n    let name = CABLES.filename(url);\n\n    const parts2 = name.split(\".\");\n    name = parts2[0];\n\n    return name;\n};\n\n/**\n * output a stacktrace to the console\n * @function logStack\n * @static\n * @memberof Utils\n */\nconst logStack = function ()\n{\n    console.log(\"logstack\", (new Error()).stack);\n};\n\n/**\n * return the filename part of a url\n * @function filename\n * @static\n * @memberof Utils\n * @param {String} url\n * @return {String} just the filename\n */\nconst filename = function (url)\n{\n    let name = \"\";\n    if (!url) return \"\";\n\n    if (url.startsWith(\"data:\") && url.contains(\":\"))\n    {\n        const parts = url.split(\",\");\n        return parts[0];\n    }\n\n    const parts = (url + \"\").split(\"/\");\n    if (parts.length > 0)\n    {\n        const str = parts[parts.length - 1];\n        let parts2 = str.split(\"?\");\n        name = parts2[0];\n    }\n\n    return name || \"\";\n};\n\n\nconst ajaxSync = function (url, cb, method, post, contenttype)\n{\n    request({\n        \"url\": url,\n        \"cb\": cb,\n        \"method\": method,\n        \"data\": post,\n        \"contenttype\": contenttype,\n        \"sync\": true,\n    });\n};\n\n/**\n * make an ajax request\n * @function ajax\n * @static\n */\nconst ajax = function (url, cb, method, post, contenttype, jsonP, headers = {})\n{\n    request({\n        \"url\": url,\n        \"cb\": cb,\n        \"method\": method,\n        \"data\": post,\n        \"contenttype\": contenttype,\n        \"sync\": false,\n        \"jsonP\": jsonP,\n        \"headers\": headers,\n    });\n};\n\nconst request = function (options)\n{\n    if (!options.hasOwnProperty(\"asynch\")) options.asynch = true;\n\n    let xhr;\n    try\n    {\n        xhr = new XMLHttpRequest();\n    }\n    catch (e) {}\n\n    xhr.onreadystatechange = function ()\n    {\n        if (xhr.readyState != 4) return;\n\n        if (options.cb)\n        {\n            if (xhr.status == 200 || xhr.status == 0) options.cb(false, xhr.responseText, xhr);\n            else options.cb(true, xhr.responseText, xhr);\n        }\n    };\n\n    xhr.addEventListener(\"progress\", (ev) =>\n    {\n        // console.log('progress',ev.loaded/1024+' kb');\n        // if (ev.lengthComputable)\n        // {\n        //     var percentComplete = ev.loaded / ev.total;\n        //     console.log(url,percentComplete);\n        // }\n    });\n\n    try\n    {\n        xhr.open(options.method ? options.method.toUpperCase() : \"GET\", options.url, !options.sync);\n    }\n    catch (e)\n    {\n        if (options.cb && e) options.cb(true, e.msg, xhr);\n    }\n\n    if (typeof options.headers === \"object\")\n    {\n        const keys = Object.keys(options.headers);\n        for (let i = 0; i < keys.length; i++)\n        {\n            const name = keys[i];\n            const value = options.headers[name];\n            xhr.setRequestHeader(name, value);\n        }\n    }\n\n    try\n    {\n        if (!options.post && !options.data)\n        {\n            xhr.send();\n        }\n        else\n        {\n            xhr.setRequestHeader(\n                \"Content-type\",\n                options.contenttype ? options.contenttype : \"application/x-www-form-urlencoded\",\n            );\n            xhr.send(options.data || options.post);\n        }\n    }\n    catch (e)\n    {\n        if (options.cb) options.cb(true, e.msg, xhr);\n    }\n};\n\n\nconst keyCodeToName = function (keyCode)\n{\n    if (!keyCode && keyCode !== 0) return \"Unidentified\";\n    const keys = {\n        \"8\": \"Backspace\",\n        \"9\": \"Tab\",\n        \"12\": \"Clear\",\n        \"13\": \"Enter\",\n        \"16\": \"Shift\",\n        \"17\": \"Control\",\n        \"18\": \"Alt\",\n        \"19\": \"Pause\",\n        \"20\": \"CapsLock\",\n        \"27\": \"Escape\",\n        \"32\": \"Space\",\n        \"33\": \"PageUp\",\n        \"34\": \"PageDown\",\n        \"35\": \"End\",\n        \"36\": \"Home\",\n        \"37\": \"ArrowLeft\",\n        \"38\": \"ArrowUp\",\n        \"39\": \"ArrowRight\",\n        \"40\": \"ArrowDown\",\n        \"45\": \"Insert\",\n        \"46\": \"Delete\",\n        \"112\": \"F1\",\n        \"113\": \"F2\",\n        \"114\": \"F3\",\n        \"115\": \"F4\",\n        \"116\": \"F5\",\n        \"117\": \"F6\",\n        \"118\": \"F7\",\n        \"119\": \"F8\",\n        \"120\": \"F9\",\n        \"121\": \"F10\",\n        \"122\": \"F11\",\n        \"123\": \"F12\",\n        \"144\": \"NumLock\",\n        \"145\": \"ScrollLock\",\n        \"224\": \"Meta\"\n    };\n    if (keys[keyCode])\n    {\n        return keys[keyCode];\n    }\n    else\n    {\n        return String.fromCharCode(keyCode);\n    }\n};\n// ----------------------------------------------------------------\n\nwindow.performance = window.performance || {\n    \"offset\": Date.now(),\n    \"now\": function now()\n    {\n        return Date.now() - this.offset;\n    },\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS91dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvdXRpbHMuanM/OTQxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQGV4dGVybmFsIENBQkxFU1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICovXG5cbmltcG9ydCB7IENPTlNUQU5UUyB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuXG5jb25zdCBVVElMUyA9IHt9O1xuLyoqXG4gKiBNZXJnZSB0d28gRmxvYXQzMkFycmF5cy5cbiAqIEBmdW5jdGlvbiBmbG9hdDMyQ29uY2F0XG4gKiBAbWVtYmVyb2YgVXRpbHNcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBmaXJzdCBMZWZ0LWhhbmQgc2lkZSBhcnJheVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHNlY29uZCBSaWdodC1oYW5kIHNpZGUgYXJyYXlcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX1cbiAqIEBzdGF0aWNcbiAqL1xuVVRJTFMuZmxvYXQzMkNvbmNhdCA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKVxue1xuICAgIGlmICghKGZpcnN0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkgZmlyc3QgPSBuZXcgRmxvYXQzMkFycmF5KGZpcnN0KTtcbiAgICBpZiAoIShzZWNvbmQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSBzZWNvbmQgPSBuZXcgRmxvYXQzMkFycmF5KHNlY29uZCk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGZpcnN0Lmxlbmd0aCArIHNlY29uZC5sZW5ndGgpO1xuXG4gICAgcmVzdWx0LnNldChmaXJzdCk7XG4gICAgcmVzdWx0LnNldChzZWNvbmQsIGZpcnN0Lmxlbmd0aCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBnZXQgb3Agc2hvcnRuYW1lOiBvbmx5IGxhc3QgcGFydCBvZiBmdWxsbmFtZSBhbmQgd2l0aG91dCB2ZXJzaW9uXG4gKiBAZnVuY3Rpb24gZ2V0U2hvcnRPcE5hbWVcbiAqIEBtZW1iZXJvZiBDQUJMRVNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmdWxsIG9wIG5hbWVcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFNob3J0T3BOYW1lID0gZnVuY3Rpb24gKGZ1bGxuYW1lKVxue1xuICAgIGxldCBuYW1lID0gZnVsbG5hbWUuc3BsaXQoXCIuXCIpW2Z1bGxuYW1lLnNwbGl0KFwiLlwiKS5sZW5ndGggLSAxXTtcblxuICAgIGlmIChuYW1lLmNvbnRhaW5zKENPTlNUQU5UUy5PUC5PUF9WRVJTSU9OX1BSRUZJWCkpXG4gICAge1xuICAgICAgICBjb25zdCBuID0gbmFtZS5zcGxpdChDT05TVEFOVFMuT1AuT1BfVkVSU0lPTl9QUkVGSVgpWzFdO1xuICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5sZW5ndGggLSAoQ09OU1RBTlRTLk9QLk9QX1ZFUlNJT05fUFJFRklYICsgbikubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59O1xuXG4vKipcbiAqIHJhbmRvbWl6ZSBvcmRlciBvZiBhbiBhcnJheVxuICogQGZ1bmN0aW9uIHNodWZmbGVBcnJheVxuICogQG1lbWJlcm9mIFV0aWxzXG4gKiBAcGFyYW0ge0FycmF5fEZsb2F0MzJBcnJheX0gYXJyYXkge0FycmF5fSBvcmlnaW5hbFxuICogQHJldHVybiB7QXJyYXl8RmxvYXQzMkFycmF5fSBzaHVmZmxlZCBhcnJheVxuICogQHN0YXRpY1xuICovXG5leHBvcnQgY29uc3Qgc2h1ZmZsZUFycmF5ID0gZnVuY3Rpb24gKGFycmF5KVxue1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKVxuICAgIHtcbiAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5zZWVkZWRSYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICBjb25zdCB0ZW1wID0gYXJyYXlbaV07XG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbal07XG4gICAgICAgIGFycmF5W2pdID0gdGVtcDtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufTtcblxuXG4vKipcbiAqIGdlbmVyYXRlIGEgc2hvcnQgXCJyZWxhdGl2bHkgdW5pcXVlXCIgaWRcbiAqIEBmdW5jdGlvbiBzaG9ydElkXG4gKiBAbWVtYmVyb2YgVXRpbHNcbiAqIEByZXR1cm4ge1N0cmluZ30gZ2VuZXJhdGVkIElEXG4gKiBAc3RhdGljXG4gKi9cblxuY29uc3QgX3Nob3J0SWRzID0ge307XG5jb25zdCBfc2hvcnRJZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgbGV0IHN0ciA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KTtcblxuICAgIGlmIChfc2hvcnRJZHMuaGFzT3duUHJvcGVydHkoc3RyKSkgc3RyID0gX3Nob3J0SWQoKTtcbiAgICBfc2hvcnRJZHNbc3RyXSA9IHRydWU7XG4gICAgcmV0dXJuIHN0cjtcbn07XG5leHBvcnQgY29uc3Qgc2hvcnRJZCA9IF9zaG9ydElkO1xuXG5cbi8qKlxuICogZ2VuZXJhdGUgYSBVVUlEXG4gKiBAZnVuY3Rpb24gdXVpZFxuICogQG1lbWJlcm9mIFV0aWxzXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGdlbmVyYXRlZCBVVUlEXG4gKiBAc3RhdGljXG4gKi9cbmNvbnN0IF91dWlkID0gZnVuY3Rpb24gKClcbntcbiAgICBsZXQgZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGNvbnN0IHV1aWQgPSBcInh4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eFwiLnJlcGxhY2UoL1t4eV0vZywgKGMpID0+XG4gICAge1xuICAgICAgICBjb25zdCByID0gKGQgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xuICAgICAgICBkID0gTWF0aC5mbG9vcihkIC8gMTYpO1xuICAgICAgICByZXR1cm4gKGMgPT0gXCJ4XCIgPyByIDogKHIgJiAweDMpIHwgMHg4KS50b1N0cmluZygxNik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHV1aWQ7XG59O1xuZXhwb3J0IGNvbnN0IHV1aWQgPSBfdXVpZDtcbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVVVSUQgPSBfdXVpZDtcblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbkpzb24ob2JqKVxue1xuICAgIGZvciAoY29uc3QgaSBpbiBvYmopXG4gICAge1xuICAgICAgICBpZiAob2JqW2ldICYmIHR5cGVvZiBvYmpWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBvYmpbaV0uY29uc3RydWN0b3IgPT09IE9iamVjdCkgb2JqW2ldID0gY2xlYW5Kc29uKG9ialtpXSk7XG5cbiAgICAgICAgaWYgKG9ialtpXSA9PT0gbnVsbCB8fCBvYmpbaV0gPT09IHVuZGVmaW5lZCkgZGVsZXRlIG9ialtpXTtcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmpbaV0pICYmIG9ialtpXS5sZW5ndGggPT0gMCkgZGVsZXRlIG9ialtpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcS83NjE2NDYxLzk0MDIxN1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCBfcHJlZml4ZWRIYXNoID0gZnVuY3Rpb24gKHN0ciwgcHJlZml4ID0gXCJpZFwiKVxue1xuICAgIGxldCBoYXNoID0gMDtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLnJlZHVjZSlcbiAgICB7XG4gICAgICAgIGhhc2ggPSBzdHIuc3BsaXQoXCJcIikucmVkdWNlKChhLCBiKSA9PiB7IGEgPSAoKGEgPDwgNSkgLSBhKSArIGIuY2hhckNvZGVBdCgwKTsgcmV0dXJuIGEgJiBhOyB9LCAwKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hhcmFjdGVyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgY2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgIGhhc2ggJj0gaGFzaDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByZWZpeCArIFwiXCIgKyBoYXNoO1xufTtcbmV4cG9ydCBjb25zdCBwcmVmaXhlZEhhc2ggPSBfcHJlZml4ZWRIYXNoO1xuXG4vKipcbiAqIGdlbmVyYXRlIGEgc2ltcGxlIElEXG4gKiBAZnVuY3Rpb24gc2ltcGxlSWRcbiAqIEBtZW1iZXJvZiBVdGlsc1xuICogQHJldHVybiB7TnVtYmVyfSBuZXcgaWRcbiAqIEBzdGF0aWNcbiAqL1xubGV0IHNpbXBsZUlkQ291bnRlciA9IDA7XG5leHBvcnQgY29uc3Qgc2ltcGxlSWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHNpbXBsZUlkQ291bnRlcisrO1xuICAgIHJldHVybiBzaW1wbGVJZENvdW50ZXI7XG59O1xuXG4vKipcbiAqIHNtb290aFN0ZXAgYSB2YWx1ZVxuICogQGZ1bmN0aW9uIHNtb290aFN0ZXBcbiAqIEBtZW1iZXJvZiBVdGlsc1xuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdmFsdWUgdG8gYmUgc21vb3RoZWQgWzAtMV1cbiAqIEByZXR1cm4ge051bWJlcn0gc21vb3RoZWQgdmFsdWVcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0IGNvbnN0IHNtb290aFN0ZXAgPSBmdW5jdGlvbiAocGVyYylcbntcbiAgICBjb25zdCB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHBlcmMgLSAwKSAvICgxIC0gMCkpKTtcbiAgICBwZXJjID0geCAqIHggKiAoMyAtIDIgKiB4KTsgLy8gc21vb3Roc3RlcFxuICAgIHJldHVybiBwZXJjO1xufTtcblxuLyoqXG4gKiBzbW9vdGhlcnN0ZXAgYSB2YWx1ZVxuICogQGZ1bmN0aW9uIHNtb290aGVyU3RlcFxuICogQG1lbWJlcm9mIFV0aWxzXG4gKiBAcGFyYW0gdmFsdWUge051bWJlcn0gdmFsdWUgdG8gYmUgc21vb3RoZWQgWzAtMV1cbiAqIEByZXR1cm4ge051bWJlcn0gc21vb3RoZWQgdmFsdWVcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0IGNvbnN0IHNtb290aGVyU3RlcCA9IGZ1bmN0aW9uIChwZXJjKVxue1xuICAgIGNvbnN0IHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAocGVyYyAtIDApIC8gKDEgLSAwKSkpO1xuICAgIHBlcmMgPSB4ICogeCAqIHggKiAoeCAqICh4ICogNiAtIDE1KSArIDEwKTsgLy8gc21vb3RoZXJzdGVwXG4gICAgcmV0dXJuIHBlcmM7XG59O1xuXG5cbi8qKlxuICogY2xhbXAgbnVtYmVyIC8gbWFrZSBzdXJlIGl0cyBiZXR3ZWVuIG1pbi9tYXhcbiAqIEBmdW5jdGlvbiBjbGFtcFxuICogQG1lbWJlcm9mIFV0aWxzXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdmFsdWUgdG8gYmUgbWFwcGVkXG4gKiBAcGFyYW0ge051bWJlcn0gbWluIG1pbmltdW0gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggbWF4aW11bSB2YWx1ZVxuICogQHN0YXRpY1xuICovXG5leHBvcnQgY29uc3QgY2xhbXAgPSBmdW5jdGlvbiAodmFsdWUsIG1pbiwgbWF4KVxue1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbn07XG5cbi8qKlxuICogbWFwIGEgdmFsdWUgaW4gYSByYW5nZSB0byBhIHZhbHVlIGluIGFub3RoZXIgcmFuZ2VcbiAqIEBmdW5jdGlvbiBtYXBcbiAqIEBtZW1iZXJvZiBVdGlsc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHZhbHVlIHRvIGJlIG1hcHBlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9sZE1pbiBvbGQgcmFuZ2UgbWluaW11bSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IG9sZE1heCBvbGQgcmFuZ2UgbWF4aW11bSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IG5ld01pbiBuZXcgcmFuZ2UgbWluaW11bSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IG5ld01heCBuZXcgcmFuZ2UgbWF4aW11bSB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfSBtYXBwZWQgdmFsdWVcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcCA9IGZ1bmN0aW9uICh4LCBfb2xkTWluLCBfb2xkTWF4LCBfbmV3TWluLCBfbmV3TWF4LCBfZWFzaW5nKVxue1xuICAgIGlmICh4ID49IF9vbGRNYXgpIHJldHVybiBfbmV3TWF4O1xuICAgIGlmICh4IDw9IF9vbGRNaW4pIHJldHVybiBfbmV3TWluO1xuXG4gICAgbGV0IHJldmVyc2VJbnB1dCA9IGZhbHNlO1xuICAgIGNvbnN0IG9sZE1pbiA9IE1hdGgubWluKF9vbGRNaW4sIF9vbGRNYXgpO1xuICAgIGNvbnN0IG9sZE1heCA9IE1hdGgubWF4KF9vbGRNaW4sIF9vbGRNYXgpO1xuICAgIGlmIChvbGRNaW4gIT0gX29sZE1pbikgcmV2ZXJzZUlucHV0ID0gdHJ1ZTtcblxuICAgIGxldCByZXZlcnNlT3V0cHV0ID0gZmFsc2U7XG4gICAgY29uc3QgbmV3TWluID0gTWF0aC5taW4oX25ld01pbiwgX25ld01heCk7XG4gICAgY29uc3QgbmV3TWF4ID0gTWF0aC5tYXgoX25ld01pbiwgX25ld01heCk7XG4gICAgaWYgKG5ld01pbiAhPSBfbmV3TWluKSByZXZlcnNlT3V0cHV0ID0gdHJ1ZTtcblxuICAgIGxldCBwb3J0aW9uID0gMDtcbiAgICBsZXQgciA9IDA7XG5cbiAgICBpZiAocmV2ZXJzZUlucHV0KSBwb3J0aW9uID0gKChvbGRNYXggLSB4KSAqIChuZXdNYXggLSBuZXdNaW4pKSAvIChvbGRNYXggLSBvbGRNaW4pO1xuICAgIGVsc2UgcG9ydGlvbiA9ICgoeCAtIG9sZE1pbikgKiAobmV3TWF4IC0gbmV3TWluKSkgLyAob2xkTWF4IC0gb2xkTWluKTtcblxuICAgIGlmIChyZXZlcnNlT3V0cHV0KSByID0gbmV3TWF4IC0gcG9ydGlvbjtcbiAgICBlbHNlIHIgPSBwb3J0aW9uICsgbmV3TWluO1xuXG4gICAgaWYgKCFfZWFzaW5nKSByZXR1cm4gcjtcbiAgICBpZiAoX2Vhc2luZyA9PSAxKVxuICAgIHtcbiAgICAgICAgLy8gc21vb3Roc3RlcFxuICAgICAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHIgLSBfbmV3TWluKSAvIChfbmV3TWF4IC0gX25ld01pbikpKTtcbiAgICAgICAgcmV0dXJuIF9uZXdNaW4gKyB4ICogeCAqICgzIC0gMiAqIHgpICogKF9uZXdNYXggLSBfbmV3TWluKTtcbiAgICB9XG4gICAgaWYgKF9lYXNpbmcgPT0gMilcbiAgICB7XG4gICAgICAgIC8vIHNtb290aGVyc3RlcFxuICAgICAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHIgLSBfbmV3TWluKSAvIChfbmV3TWF4IC0gX25ld01pbikpKTtcbiAgICAgICAgcmV0dXJuIF9uZXdNaW4gKyB4ICogeCAqIHggKiAoeCAqICh4ICogNiAtIDE1KSArIDEwKSAqIChfbmV3TWF4IC0gX25ld01pbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgTWF0aFxuICovXG4vKipcbiAqIHNldCByYW5kb20gc2VlZCBmb3Igc2VlZGVkUmFuZG9tKClcbiAqIEBtZW1iZXJvZiBNYXRoXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBzdGF0aWNcbiAqL1xuTWF0aC5yYW5kb21TZWVkID0gMTtcblxuXG5NYXRoLnNldFJhbmRvbVNlZWQgPSBmdW5jdGlvbiAoc2VlZClcbntcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2FibGVzLWdsL2NhYmxlc19kb2NzL2lzc3Vlcy82MjJcbiAgICBNYXRoLnJhbmRvbVNlZWQgPSBzZWVkICogNTA3MjgxMjk7XG4gICAgaWYgKHNlZWQgIT0gMClcbiAgICB7XG4gICAgICAgIE1hdGgucmFuZG9tU2VlZCA9IE1hdGguc2VlZGVkUmFuZG9tKCkgKiAxNzYyNDgxMztcbiAgICAgICAgTWF0aC5yYW5kb21TZWVkID0gTWF0aC5zZWVkZWRSYW5kb20oKSAqIDk3MzczMzM7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIGdlbmVyYXRlIGEgc2VlZGVkIHJhbmRvbSBudW1iZXJcbiAqIEBmdW5jdGlvbiBzZWVkZWRSYW5kb21cbiAqIEBtZW1iZXJvZiBNYXRoXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IG1pbmltdW0gcG9zc2libGUgcmFuZG9tIG51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbiBtYXhpbXVtIHBvc3NpYmxlIHJhbmRvbSBudW1iZXJcbiAqIEByZXR1cm4ge051bWJlcn0gcmFuZG9tIHZhbHVlXG4gKiBAc3RhdGljXG4gKi9cbk1hdGguc2VlZGVkUmFuZG9tID0gZnVuY3Rpb24gKG1heCwgbWluKVxue1xuICAgIGlmIChNYXRoLnJhbmRvbVNlZWQgPT09IDApIE1hdGgucmFuZG9tU2VlZCA9IE1hdGgucmFuZG9tKCkgKiA5OTk7XG4gICAgbWF4ID0gbWF4IHx8IDE7XG4gICAgbWluID0gbWluIHx8IDA7XG5cbiAgICBNYXRoLnJhbmRvbVNlZWQgPSAoTWF0aC5yYW5kb21TZWVkICogOTMwMSArIDQ5Mjk3KSAlIDIzMzI4MDtcbiAgICBjb25zdCBybmQgPSBNYXRoLnJhbmRvbVNlZWQgLyAyMzMyODAuMDtcblxuICAgIHJldHVybiBtaW4gKyBybmQgKiAobWF4IC0gbWluKTtcbn07XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIHJldHVybnMgdHJ1ZSBpZiBwYXJhbWV0ZXIgaXMgYSBudW1iZXJcbiAqIEBmdW5jdGlvbiBpc051bWVyaWNcbiAqIEBtZW1iZXJvZiBVdGlsc1xuICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc3RhdGljXG4gKi9cblVUSUxTLmlzTnVtZXJpYyA9IGZ1bmN0aW9uIChuKVxue1xuICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG59O1xuXG4vKipcbiAqIHJldHVybnMgdHJ1ZSBpZiBwYXJhbWV0ZXIgaXMgYXJyYXlcbiAqIEBmdW5jdGlvbiBpc0FycmF5XG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgVmFsdWUgdG8gY2hlY2tcbiAqIEBtZW1iZXJvZiBVdGlsc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzdGF0aWNcbiAqL1xuVVRJTFMuaXNBcnJheSA9IGZ1bmN0aW9uICh2KVxue1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbn07XG5cbi8qKlxuICogQG5hbWVzcGFjZSBTdHJpbmdcbiAqL1xuXG4vKipcbiAqIGFwcGVuZCBhIGxpbmVicmVhayB0byBhIHN0cmluZ1xuICogQGZ1bmN0aW9uIGVuZGxcbiAqIEBtZW1iZXJvZiBTdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHdpdGggbmV3bGluZSBicmVhayBhcHBlbmRlZCAoJ1xcbicpXG4gKi9cblN0cmluZy5wcm90b3R5cGUuZW5kbCA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMgKyBcIlxcblwiO1xufTtcblxuLyoqXG4gKiByZXR1cm4gdHJ1ZSBpZiBzdHJpbmcgc3RhcnRzIHdpdGggcHJlZml4XG4gKiBAZnVuY3Rpb24gc3RhcnRzV2l0aFxuICogQG1lbWJlcm9mIFN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBUaGUgcHJlZml4IHRvIGNoZWNrLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoID0gZnVuY3Rpb24gKHByZWZpeClcbntcbiAgICByZXR1cm4gdGhpcy5pbmRleE9mKHByZWZpeCkgPT09IDA7XG59O1xuXG4vKipcbiAqIHJldHVybiB0cnVlIGlmIHN0cmluZyBlbmRzIHdpdGggc3VmZml4XG4gKiBAZnVuY3Rpb24gZW5kc1dpdGhcbiAqIEBtZW1iZXJvZiBTdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdWZmaXhcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGggPSBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoIHx8IGZ1bmN0aW9uIChzdWZmaXgpXG57XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goc3VmZml4ICsgXCIkXCIpID09IHN1ZmZpeDtcbn07XG5cbi8qKlxuICogcmV0dXJuIHRydWUgaWYgc3RyaW5nIGNvbnRhaW5zIHN0cmluZ1xuICogQGZ1bmN0aW9uIGNvbnRhaW5zXG4gKiBAbWVtYmVyb2YgU3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoU3RyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5TdHJpbmcucHJvdG90eXBlLmNvbnRhaW5zID0gU3RyaW5nLnByb3RvdHlwZS5jb250YWlucyB8fCBmdW5jdGlvbiAoc2VhcmNoU3RyKVxue1xuICAgIHJldHVybiB0aGlzLmluZGV4T2Yoc2VhcmNoU3RyKSA+IC0xO1xufTtcblxuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBhcHBlbmQgYSB1bmlxdWUvcmFuZG9tIHBhcmFtZXRlciB0byBhIHVybCwgc28gdGhlIGJyb3dzZXIgaXMgZm9yY2VkIHRvIHJlbG9hZCB0aGUgZmlsZSwgZXZlbiBpZiBpdHMgY2FjaGVkXG4gKiBAZnVuY3Rpb24gY2FjaGVCdXN0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgVXRpbHNcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIHVybCB0byBhcHBlbmQgdGhlIGNhY2hlYnVzdGVyIHBhcmFtZXRlciB0by5cbiAqIEByZXR1cm4ge1N0cmluZ30gdXJsIHdpdGggY2FjaGVidXN0ZXIgcGFyYW1ldGVyXG4gKi9cbmV4cG9ydCBjb25zdCBjYWNoZUJ1c3QgPSBmdW5jdGlvbiAodXJsKVxue1xuICAgIGlmICh1cmwuY29udGFpbnMoXCI/XCIpKSB1cmwgKz0gXCImXCI7XG4gICAgZWxzZSB1cmwgKz0gXCI/XCI7XG4gICAgcmV0dXJuIHVybCArIFwiY2FjaGU9XCIgKyBDQUJMRVMudXVpZCgpO1xufTtcblxuLyoqXG4gKiBjb3B5IHRoZSBjb250ZW50IG9mIGFuIGFycmF5XG4gKiBAZnVuY3Rpb24gY29weUFycmF5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgVXRpbHNcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZUFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBkc3Qgb3B0aW9uYWxcbiAqIEByZXR1cm4ge0FycmF5fSBkc3RcbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHlBcnJheSA9IGZ1bmN0aW9uIChzcmMsIGRzdClcbntcbiAgICBpZiAoIXNyYykgcmV0dXJuIG51bGw7XG4gICAgZHN0ID0gZHN0IHx8IFtdO1xuICAgIGRzdC5sZW5ndGggPSBzcmMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgZHN0W2ldID0gc3JjW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBkc3Q7XG59O1xuXG5cbi8qKlxuICogcmV0dXJuIHRoZSBmaWxlbmFtZSBwYXJ0IG9mIGEgdXJsIHdpdGhvdXQgZXh0ZW5zaW9uXG4gKiBAZnVuY3Rpb24gYmFzZW5hbWVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBVdGlsc1xuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHJldHVybiB7U3RyaW5nfSBqdXN0IHRoZSBmaWxlbmFtZVxuICovXG5leHBvcnQgY29uc3QgYmFzZW5hbWUgPSBmdW5jdGlvbiAodXJsKVxue1xuICAgIGxldCBuYW1lID0gQ0FCTEVTLmZpbGVuYW1lKHVybCk7XG5cbiAgICBjb25zdCBwYXJ0czIgPSBuYW1lLnNwbGl0KFwiLlwiKTtcbiAgICBuYW1lID0gcGFydHMyWzBdO1xuXG4gICAgcmV0dXJuIG5hbWU7XG59O1xuXG4vKipcbiAqIG91dHB1dCBhIHN0YWNrdHJhY2UgdG8gdGhlIGNvbnNvbGVcbiAqIEBmdW5jdGlvbiBsb2dTdGFja1xuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFV0aWxzXG4gKi9cbmV4cG9ydCBjb25zdCBsb2dTdGFjayA9IGZ1bmN0aW9uICgpXG57XG4gICAgY29uc29sZS5sb2coXCJsb2dzdGFja1wiLCAobmV3IEVycm9yKCkpLnN0YWNrKTtcbn07XG5cbi8qKlxuICogcmV0dXJuIHRoZSBmaWxlbmFtZSBwYXJ0IG9mIGEgdXJsXG4gKiBAZnVuY3Rpb24gZmlsZW5hbWVcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBVdGlsc1xuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHJldHVybiB7U3RyaW5nfSBqdXN0IHRoZSBmaWxlbmFtZVxuICovXG5leHBvcnQgY29uc3QgZmlsZW5hbWUgPSBmdW5jdGlvbiAodXJsKVxue1xuICAgIGxldCBuYW1lID0gXCJcIjtcbiAgICBpZiAoIXVybCkgcmV0dXJuIFwiXCI7XG5cbiAgICBpZiAodXJsLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSAmJiB1cmwuY29udGFpbnMoXCI6XCIpKVxuICAgIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSB1cmwuc3BsaXQoXCIsXCIpO1xuICAgICAgICByZXR1cm4gcGFydHNbMF07XG4gICAgfVxuXG4gICAgY29uc3QgcGFydHMgPSAodXJsICsgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPiAwKVxuICAgIHtcbiAgICAgICAgY29uc3Qgc3RyID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBwYXJ0czIgPSBzdHIuc3BsaXQoXCI/XCIpO1xuICAgICAgICBuYW1lID0gcGFydHMyWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lIHx8IFwiXCI7XG59O1xuXG5cbmV4cG9ydCBjb25zdCBhamF4U3luYyA9IGZ1bmN0aW9uICh1cmwsIGNiLCBtZXRob2QsIHBvc3QsIGNvbnRlbnR0eXBlKVxue1xuICAgIHJlcXVlc3Qoe1xuICAgICAgICBcInVybFwiOiB1cmwsXG4gICAgICAgIFwiY2JcIjogY2IsXG4gICAgICAgIFwibWV0aG9kXCI6IG1ldGhvZCxcbiAgICAgICAgXCJkYXRhXCI6IHBvc3QsXG4gICAgICAgIFwiY29udGVudHR5cGVcIjogY29udGVudHR5cGUsXG4gICAgICAgIFwic3luY1wiOiB0cnVlLFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBtYWtlIGFuIGFqYXggcmVxdWVzdFxuICogQGZ1bmN0aW9uIGFqYXhcbiAqIEBzdGF0aWNcbiAqL1xuZXhwb3J0IGNvbnN0IGFqYXggPSBmdW5jdGlvbiAodXJsLCBjYiwgbWV0aG9kLCBwb3N0LCBjb250ZW50dHlwZSwganNvblAsIGhlYWRlcnMgPSB7fSlcbntcbiAgICByZXF1ZXN0KHtcbiAgICAgICAgXCJ1cmxcIjogdXJsLFxuICAgICAgICBcImNiXCI6IGNiLFxuICAgICAgICBcIm1ldGhvZFwiOiBtZXRob2QsXG4gICAgICAgIFwiZGF0YVwiOiBwb3N0LFxuICAgICAgICBcImNvbnRlbnR0eXBlXCI6IGNvbnRlbnR0eXBlLFxuICAgICAgICBcInN5bmNcIjogZmFsc2UsXG4gICAgICAgIFwianNvblBcIjoganNvblAsXG4gICAgICAgIFwiaGVhZGVyc1wiOiBoZWFkZXJzLFxuICAgIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucylcbntcbiAgICBpZiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJhc3luY2hcIikpIG9wdGlvbnMuYXN5bmNoID0gdHJ1ZTtcblxuICAgIGxldCB4aHI7XG4gICAgdHJ5XG4gICAge1xuICAgICAgICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHt9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPSA0KSByZXR1cm47XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2IpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09IDIwMCB8fCB4aHIuc3RhdHVzID09IDApIG9wdGlvbnMuY2IoZmFsc2UsIHhoci5yZXNwb25zZVRleHQsIHhocik7XG4gICAgICAgICAgICBlbHNlIG9wdGlvbnMuY2IodHJ1ZSwgeGhyLnJlc3BvbnNlVGV4dCwgeGhyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIChldikgPT5cbiAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdwcm9ncmVzcycsZXYubG9hZGVkLzEwMjQrJyBrYicpO1xuICAgICAgICAvLyBpZiAoZXYubGVuZ3RoQ29tcHV0YWJsZSlcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgdmFyIHBlcmNlbnRDb21wbGV0ZSA9IGV2LmxvYWRlZCAvIGV2LnRvdGFsO1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2codXJsLHBlcmNlbnRDb21wbGV0ZSk7XG4gICAgICAgIC8vIH1cbiAgICB9KTtcblxuICAgIHRyeVxuICAgIHtcbiAgICAgICAgeGhyLm9wZW4ob3B0aW9ucy5tZXRob2QgPyBvcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpIDogXCJHRVRcIiwgb3B0aW9ucy51cmwsICFvcHRpb25zLnN5bmMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSlcbiAgICB7XG4gICAgICAgIGlmIChvcHRpb25zLmNiICYmIGUpIG9wdGlvbnMuY2IodHJ1ZSwgZS5tc2csIHhocik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmhlYWRlcnMgPT09IFwib2JqZWN0XCIpXG4gICAge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy5oZWFkZXJzW25hbWVdO1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdHJ5XG4gICAge1xuICAgICAgICBpZiAoIW9wdGlvbnMucG9zdCAmJiAhb3B0aW9ucy5kYXRhKVxuICAgICAgICB7XG4gICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXG4gICAgICAgICAgICAgICAgXCJDb250ZW50LXR5cGVcIixcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbnRlbnR0eXBlID8gb3B0aW9ucy5jb250ZW50dHlwZSA6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeGhyLnNlbmQob3B0aW9ucy5kYXRhIHx8IG9wdGlvbnMucG9zdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpXG4gICAge1xuICAgICAgICBpZiAob3B0aW9ucy5jYikgb3B0aW9ucy5jYih0cnVlLCBlLm1zZywgeGhyKTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydCBjb25zdCBrZXlDb2RlVG9OYW1lID0gZnVuY3Rpb24gKGtleUNvZGUpXG57XG4gICAgaWYgKCFrZXlDb2RlICYmIGtleUNvZGUgIT09IDApIHJldHVybiBcIlVuaWRlbnRpZmllZFwiO1xuICAgIGNvbnN0IGtleXMgPSB7XG4gICAgICAgIFwiOFwiOiBcIkJhY2tzcGFjZVwiLFxuICAgICAgICBcIjlcIjogXCJUYWJcIixcbiAgICAgICAgXCIxMlwiOiBcIkNsZWFyXCIsXG4gICAgICAgIFwiMTNcIjogXCJFbnRlclwiLFxuICAgICAgICBcIjE2XCI6IFwiU2hpZnRcIixcbiAgICAgICAgXCIxN1wiOiBcIkNvbnRyb2xcIixcbiAgICAgICAgXCIxOFwiOiBcIkFsdFwiLFxuICAgICAgICBcIjE5XCI6IFwiUGF1c2VcIixcbiAgICAgICAgXCIyMFwiOiBcIkNhcHNMb2NrXCIsXG4gICAgICAgIFwiMjdcIjogXCJFc2NhcGVcIixcbiAgICAgICAgXCIzMlwiOiBcIlNwYWNlXCIsXG4gICAgICAgIFwiMzNcIjogXCJQYWdlVXBcIixcbiAgICAgICAgXCIzNFwiOiBcIlBhZ2VEb3duXCIsXG4gICAgICAgIFwiMzVcIjogXCJFbmRcIixcbiAgICAgICAgXCIzNlwiOiBcIkhvbWVcIixcbiAgICAgICAgXCIzN1wiOiBcIkFycm93TGVmdFwiLFxuICAgICAgICBcIjM4XCI6IFwiQXJyb3dVcFwiLFxuICAgICAgICBcIjM5XCI6IFwiQXJyb3dSaWdodFwiLFxuICAgICAgICBcIjQwXCI6IFwiQXJyb3dEb3duXCIsXG4gICAgICAgIFwiNDVcIjogXCJJbnNlcnRcIixcbiAgICAgICAgXCI0NlwiOiBcIkRlbGV0ZVwiLFxuICAgICAgICBcIjExMlwiOiBcIkYxXCIsXG4gICAgICAgIFwiMTEzXCI6IFwiRjJcIixcbiAgICAgICAgXCIxMTRcIjogXCJGM1wiLFxuICAgICAgICBcIjExNVwiOiBcIkY0XCIsXG4gICAgICAgIFwiMTE2XCI6IFwiRjVcIixcbiAgICAgICAgXCIxMTdcIjogXCJGNlwiLFxuICAgICAgICBcIjExOFwiOiBcIkY3XCIsXG4gICAgICAgIFwiMTE5XCI6IFwiRjhcIixcbiAgICAgICAgXCIxMjBcIjogXCJGOVwiLFxuICAgICAgICBcIjEyMVwiOiBcIkYxMFwiLFxuICAgICAgICBcIjEyMlwiOiBcIkYxMVwiLFxuICAgICAgICBcIjEyM1wiOiBcIkYxMlwiLFxuICAgICAgICBcIjE0NFwiOiBcIk51bUxvY2tcIixcbiAgICAgICAgXCIxNDVcIjogXCJTY3JvbGxMb2NrXCIsXG4gICAgICAgIFwiMjI0XCI6IFwiTWV0YVwiXG4gICAgfTtcbiAgICBpZiAoa2V5c1trZXlDb2RlXSlcbiAgICB7XG4gICAgICAgIHJldHVybiBrZXlzW2tleUNvZGVdO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShrZXlDb2RlKTtcbiAgICB9XG59O1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG53aW5kb3cucGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwge1xuICAgIFwib2Zmc2V0XCI6IERhdGUubm93KCksXG4gICAgXCJub3dcIjogZnVuY3Rpb24gbm93KClcbiAgICB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5vZmZzZXQ7XG4gICAgfSxcbn07XG5cbmV4cG9ydCB7IFVUSUxTIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core/utils.js\n");

/***/ }),

/***/ "./src/core/webaudio.js":
/*!******************************!*\
  !*** ./src/core/webaudio.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WEBAUDIO\": () => (/* binding */ WEBAUDIO)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./src/core/constants.js\");\n/** @namespace WEBAUDIO */\n\n\n\nconst WEBAUDIO = {};\n\nWEBAUDIO.toneJsInitialized = false;\n\n/*\n * External JSDoc definitions\n */\n\n/**\n * Part of the Web Audio API, the AudioBuffer interface represents a short audio asset residing in memory.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer}\n */\n\n/**\n * Part of the Web Audio API, the AudioNode interface is a generic interface for representing an audio processing module.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioNode}\n */\n\n/**\n * The AudioContext interface represents an audio-processing graph built from audio modules linked together\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext}\n */\n\n/**\n * Checks if a global audio context has been created and creates\n * it if necessary. This audio context can be used for native Web Audio as well as Tone.js ops.\n * Associates the audio context with Tone.js if it is being used\n * @param {CABLES.Op} op - The operator which needs the Audio Context\n */\nWEBAUDIO.createAudioContext = function (op)\n{\n    window.AudioContext = window.AudioContext || window.webkitAudioContext;\n    if (window.AudioContext)\n    {\n        if (!window.audioContext)\n        {\n            window.audioContext = new AudioContext();\n        }\n        // check if tone.js lib is being used\n        if (window.Tone && !WEBAUDIO.toneJsInitialized)\n        {\n            // set current audio context in tone.js\n            Tone.setContext(window.audioContext);\n            WEBAUDIO.toneJsInitialized = true;\n        }\n    }\n    else\n    {\n        op.patch.config.onError(\"NO_WEBAUDIO\", \"Web Audio is not supported in this browser.\");\n        return;\n    }\n    return window.audioContext;\n};\n\n/**\n * Returns the audio context.\n * Before `createAudioContext` must have been called at least once.\n * It most cases you should use `createAudioContext`, which just returns the audio context\n * when it has been created already.\n */\nWEBAUDIO.getAudioContext = function ()\n{\n    return window.audioContext;\n};\n\n/**\n * Creates an audio in port for the op with name `portName`\n * When disconnected it will disconnect the previous connected audio node\n * from the op's audio node.\n * @param {CABLES.Op} op - The operator to create the audio port in\n * @param {string} portName - The name of the port\n * @param {AudioNode} audioNode - The audionode incoming connections should connect to\n * @param {number} [inputChannelIndex=0] - If the audio node has multiple inputs, this is the index of the input channel to connect to\n * @returns {CABLES.Port|undefined} - The newly created audio in port or `undefined` if there was an error\n */\nWEBAUDIO.createAudioInPort = function (op, portName, audioNode, inputChannelIndex)\n{\n    if (!op || !portName || !audioNode)\n    {\n        const msg = \"ERROR: createAudioInPort needs three parameters, op, portName and audioNode\";\n        op.log(msg);\n        throw new Error(msg);\n        // return;\n    }\n    if (!inputChannelIndex)\n    {\n        inputChannelIndex = 0;\n    }\n    op.webAudio = op.webAudio || {};\n    op.webAudio.audioInPorts = op.webAudio.audioInPorts || [];\n    const port = op.inObject(portName);\n    port.webAudio = {};\n    port.webAudio.previousAudioInNode = null;\n    port.webAudio.audioNode = audioNode;\n\n    op.webAudio.audioInPorts[portName] = port;\n\n    port.onChange = function ()\n    {\n        const audioInNode = port.get();\n        // when port disconnected, disconnect audio nodes\n        if (!audioInNode)\n        {\n            if (port.webAudio.previousAudioInNode)\n            {\n                try\n                {\n                    if (port.webAudio.previousAudioInNode.disconnect) port.webAudio.previousAudioInNode.disconnect(port.webAudio.audioNode, 0, inputChannelIndex);\n                    op.setUiError(\"audioCtx\", null);\n                }\n                catch (e)\n                {\n                    try\n                    {\n                        port.webAudio.previousAudioInNode.disconnect(port.webAudio.audioNode);\n                    }\n                    catch (er)\n                    {\n                        op.log(\n                            \"Disconnecting audio node with in/out port index, as well as without in/out-port-index did not work \",\n                            e,\n                        );\n                        if (e.printStackTrace)\n                        {\n                            e.printStackTrace();\n                        }\n                        throw e;\n                    }\n                }\n            }\n        }\n        else\n        {\n            try\n            {\n                if (audioInNode.connect)\n                {\n                    audioInNode.connect(port.webAudio.audioNode, 0, inputChannelIndex);\n                    op.setUiError(\"audioCtx\", null);\n                }\n                else op.setUiError(\"audioCtx\", \"The passed input is not an audio context. Please make sure you connect an audio context to the input.\", 2);\n            }\n            catch (e)\n            {\n                op.log(\"Error: Failed to connect web audio node!\", e);\n                op.log(\"port.webAudio.audioNode\", port.webAudio.audioNode);\n                op.log(\"audioInNode: \", audioInNode);\n                op.log(\"inputChannelIndex:\", inputChannelIndex);\n                op.log(\"audioInNode.connect: \", audioInNode.connect);\n                throw e;\n            }\n        }\n        port.webAudio.previousAudioInNode = audioInNode;\n    };\n    // TODO: Maybe add subtype to audio-node-object?\n    return port;\n};\n\n/**\n * Sometimes it is necessary to replace a node of a port, if so all\n * connections to this node must be disconnected and connections to the new\n * node must be made.\n * Can be used for both Audio ports as well as AudioParam ports\n * if used with an AudioParam pass e.g. `synth.frequency` as newNode\n * @param {CABLES.Port} port - The port where the audio node needs to be replaced\n */\nWEBAUDIO.replaceNodeInPort = function (port, oldNode, newNode)\n{\n    const connectedNode = port.webAudio.previousAudioInNode;\n    // check if connected\n    if (connectedNode && connectedNode.disconnect)\n    {\n        try\n        {\n            connectedNode.disconnect(oldNode);\n        }\n        catch (e)\n        {\n            if (e.printStackTrace)\n            {\n                e.printStackTrace();\n            }\n            throw new Error(\"replaceNodeInPort: Could not disconnect old audio node. \" + e.name + \" \" + e.message);\n        }\n        port.webAudio.audioNode = newNode;\n        try\n        {\n            connectedNode.connect(newNode);\n        }\n        catch (e)\n        {\n            if (e.printStackTrace)\n            {\n                e.printStackTrace();\n            }\n            throw new Error(\"replaceNodeInPort: Could not connect to new node. \" + e.name + \" \" + e.message);\n        }\n    }\n};\n\n/**\n * Creates an audio out port which takes care of (dis-)connecting on it’s own\n * @param {CABLES.op} op - The op to create an audio out port for\n * @param {string} portName - The name of the port to be created\n * @param {AudioNode} audioNode - The audio node to link to the port\n * @returns {(CABLES.Port|undefined)} - The newly created audio out port or `undefined` if there was an error\n */\nWEBAUDIO.createAudioOutPort = function (op, portName, audioNode)\n{\n    if (!op || !portName || !audioNode)\n    {\n        const msg = \"ERROR: createAudioOutPort needs three parameters, op, portName and audioNode\";\n        op.log(msg);\n        throw new Error(msg);\n    }\n\n    const port = op.outObject(portName);\n    // TODO: Maybe add subtype to audio-node-object?\n    port.set(audioNode);\n    return port;\n};\n\n/**\n * Creates an audio param in port for the op with name portName.\n * The port accepts other audio nodes as signals as well as values (numbers)\n * When the port is disconnected it will disconnect the previous connected audio node\n * from the op's audio node and restore the number value set before.\n * @param {CABLES.Op} op - The operator to create an audio param input port for\n * @param {string} portName - The name of the port to create\n * @returns {(CABLES.Port|undefined)} - The newly created port, which takes care of (dis-)connecting on its own, or `undefined` if there was an error\n */\nWEBAUDIO.createAudioParamInPort = function (op, portName, audioNode, options, defaultValue)\n{\n    if (!op || !portName || !audioNode)\n    {\n        op.log(\"ERROR: createAudioParamInPort needs three parameters, op, portName and audioNode\");\n        if (op && op.name) op.log(\"opname: \", op.name);\n        op.log(\"portName\", portName);\n        op.log(\"audioNode: \", audioNode);\n        return;\n    }\n    op.webAudio = op.webAudio || {};\n    op.webAudio.audioInPorts = op.webAudio.audioInPorts || [];\n    // var port = op.inObject(portName);\n    const port = op.inDynamic(\n        portName,\n        [_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_VALUE, _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONSTANTS.OP.OP_PORT_TYPE_OBJECT],\n        options,\n        defaultValue,\n    );\n    port.webAudio = {};\n    port.webAudio.previousAudioInNode = null;\n    port.webAudio.audioNode = audioNode;\n\n    op.webAudio.audioInPorts[portName] = port;\n\n    // port.onLinkChanged = function() {\n    //   op.log(\"onLinkChanged\");\n    //   if(port.isLinked()) {\n    //\n    //       if(port.links[0].portOut.type === CABLES.CONSTANTS.OP.OP_PORT_TYPE_) { // value\n    //\n    //       } else if(port.links[0].portOut.type === CABLES.CONSTANTS.OP.OP_PORT_TYPE_OBJECT) { // object\n    //\n    //       }\n    //   } else { // unlinked\n    //\n    //   }\n    // };\n\n    port.onChange = function ()\n    {\n        const audioInNode = port.get();\n        const node = port.webAudio.audioNode;\n        const audioCtx = WEBAUDIO.getAudioContext();\n\n        if (audioInNode != undefined)\n        {\n            if (typeof audioInNode === \"object\" && audioInNode.connect)\n            {\n                try\n                {\n                    audioInNode.connect(node);\n                }\n                catch (e)\n                {\n                    op.log(\"Could not connect audio node: \", e);\n                    if (e.printStackTrace)\n                    {\n                        e.printStackTrace();\n                    }\n                    throw e;\n                }\n                port.webAudio.previousAudioInNode = audioInNode;\n            }\n            else\n            {\n                // tone.js audio param\n                if (node._param && node._param.minValue && node._param.maxValue)\n                {\n                    if (audioInNode >= node._param.minValue && audioInNode <= node._param.maxValue)\n                    {\n                        try\n                        {\n                            if (node.setValueAtTime)\n                            {\n                                node.setValueAtTime(audioInNode, audioCtx.currentTime);\n                            }\n                            else\n                            {\n                                node.value = audioInNode;\n                            }\n                        }\n                        catch (e)\n                        {\n                            op.log(\"Possible AudioParam problem with tone.js op: \", e);\n                            if (e.printStackTrace)\n                            {\n                                e.printStackTrace();\n                            }\n                            throw e;\n                        }\n                    }\n                    else\n                    {\n                        op.log(\"Warning: The value for an audio parameter is out of range!\");\n                    }\n                } // native Web Audio param\n                else if (node.minValue && node.maxValue)\n                {\n                    if (audioInNode >= node.minValue && audioInNode <= node.maxValue)\n                    {\n                        try\n                        {\n                            if (node.setValueAtTime)\n                            {\n                                node.setValueAtTime(audioInNode, audioCtx.currentTime);\n                            }\n                            else\n                            {\n                                node.value = audioInNode;\n                            }\n                        }\n                        catch (e)\n                        {\n                            op.log(\n                                \"AudioParam has minValue / maxValue defined, and value is in range, but setting the value failed! \",\n                                e,\n                            );\n                            if (e.printStackTrace)\n                            {\n                                e.printStackTrace();\n                            }\n                            throw e;\n                        }\n                    }\n                    else\n                    {\n                        op.log(\"Warning: The value for an audio parameter is out of range!\");\n                    }\n                } // no min-max values, try anyway\n                else\n                {\n                    try\n                    {\n                        if (node.setValueAtTime)\n                        {\n                            node.setValueAtTime(audioInNode, audioCtx.currentTime);\n                        }\n                        else\n                        {\n                            node.value = audioInNode;\n                        }\n                    }\n                    catch (e)\n                    {\n                        op.log(\"Possible AudioParam problem (without minValue / maxValue): \", e);\n                        if (e.printStackTrace)\n                        {\n                            e.printStackTrace();\n                        }\n                        throw e;\n                    }\n                }\n\n                if (port.webAudio.previousAudioInNode && port.webAudio.previousAudioInNode.disconnect)\n                {\n                    try\n                    {\n                        port.webAudio.previousAudioInNode.disconnect(node);\n                    }\n                    catch (e)\n                    {\n                        op.log(\"Could not disconnect previous audio node: \", e);\n                        throw e;\n                    }\n                    port.webAudio.previousAudioInNode = undefined;\n                }\n            }\n        }\n        else\n        {\n            // disconnected\n            if (port.webAudio.previousAudioInNode)\n            {\n            }\n        }\n    };\n    return port;\n};\n\n\n/**\n * Loads an audio file and updates the loading indicators when cables is run in the editor.\n * @param {CABLES.Patch} patch - The cables patch, when called from inside an op this is `op.patch`\n * @param {string} url - The url of the audio file to load\n * @param {loadAudioFileFinishedCallback} onFinished - The callback to be called when the loading is finished, passes the AudioBuffer\n * @param {loadAudioFileErrorCallback} onError - The callback when there was an error loading the file, the rror message is passed\n * @see {@link https://developer.mozilla.org/de/docs/Web/API/AudioContext/decodeAudioData}\n */\nWEBAUDIO.loadAudioFile = function (patch, url, onFinished, onError, loadingTask)\n{\n    const audioContext = WEBAUDIO.createAudioContext();\n\n    let loadingId = null;\n    if (loadingTask || loadingTask === undefined)\n    {\n        loadingId = patch.loading.start(\"audio\", url);\n        if (patch.isEditorMode()) gui.jobs().start({ \"id\": \"loadaudio\" + loadingId, \"title\": \" loading audio (\" + url + \")\" });\n    }\n    const request = new XMLHttpRequest();\n    if (!url)\n    {\n        return;\n    }\n    request.open(\"GET\", url, true);\n    request.responseType = \"arraybuffer\";\n    // TODO: maybe crossorigin stuff needed?\n    // Decode asynchronously\n    request.onload = function ()\n    {\n        patch.loading.finished(loadingId);\n        if (patch.isEditorMode()) gui.jobs().finish(\"loadaudio\" + loadingId);\n        audioContext.decodeAudioData(request.response, onFinished, onError);\n    };\n    request.send();\n};\n\n/**\n * Checks if the passed time is a valid time to be used in any of the Tone.js ops.\n * @param {(string|number)} t - The time to check\n * @returns {boolean} - True if time is valid, false if not\n */\nWEBAUDIO.isValidToneTime = function (t)\n{\n    try\n    {\n        const time = new Tone.Time(t);\n    }\n    catch (e)\n    {\n        return false;\n    }\n    return true;\n};\n\n/**\n * Checks if the passed note is a valid note to be used with Tone.js\n * @param {string} note - The note to be checked, e.g. `\"C4\"`\n * @returns {boolean} - True if the note is a valid note, false otherwise\n */\nWEBAUDIO.isValidToneNote = function (note)\n{\n    try\n    {\n        Tone.Frequency(note);\n    }\n    catch (e)\n    {\n        return false;\n    }\n    return true;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS93ZWJhdWRpby5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4vc3JjL2NvcmUvd2ViYXVkaW8uanM/YWFhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQG5hbWVzcGFjZSBXRUJBVURJTyAqL1xuXG5pbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tIFwiLi9jb25zdGFudHMuanNcIjtcblxuY29uc3QgV0VCQVVESU8gPSB7fTtcblxuV0VCQVVESU8udG9uZUpzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLypcbiAqIEV4dGVybmFsIEpTRG9jIGRlZmluaXRpb25zXG4gKi9cblxuLyoqXG4gKiBQYXJ0IG9mIHRoZSBXZWIgQXVkaW8gQVBJLCB0aGUgQXVkaW9CdWZmZXIgaW50ZXJmYWNlIHJlcHJlc2VudHMgYSBzaG9ydCBhdWRpbyBhc3NldCByZXNpZGluZyBpbiBtZW1vcnkuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9CdWZmZXJ9XG4gKi9cblxuLyoqXG4gKiBQYXJ0IG9mIHRoZSBXZWIgQXVkaW8gQVBJLCB0aGUgQXVkaW9Ob2RlIGludGVyZmFjZSBpcyBhIGdlbmVyaWMgaW50ZXJmYWNlIGZvciByZXByZXNlbnRpbmcgYW4gYXVkaW8gcHJvY2Vzc2luZyBtb2R1bGUuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlfVxuICovXG5cbi8qKlxuICogVGhlIEF1ZGlvQ29udGV4dCBpbnRlcmZhY2UgcmVwcmVzZW50cyBhbiBhdWRpby1wcm9jZXNzaW5nIGdyYXBoIGJ1aWx0IGZyb20gYXVkaW8gbW9kdWxlcyBsaW5rZWQgdG9nZXRoZXJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb0NvbnRleHR9XG4gKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnbG9iYWwgYXVkaW8gY29udGV4dCBoYXMgYmVlbiBjcmVhdGVkIGFuZCBjcmVhdGVzXG4gKiBpdCBpZiBuZWNlc3NhcnkuIFRoaXMgYXVkaW8gY29udGV4dCBjYW4gYmUgdXNlZCBmb3IgbmF0aXZlIFdlYiBBdWRpbyBhcyB3ZWxsIGFzIFRvbmUuanMgb3BzLlxuICogQXNzb2NpYXRlcyB0aGUgYXVkaW8gY29udGV4dCB3aXRoIFRvbmUuanMgaWYgaXQgaXMgYmVpbmcgdXNlZFxuICogQHBhcmFtIHtDQUJMRVMuT3B9IG9wIC0gVGhlIG9wZXJhdG9yIHdoaWNoIG5lZWRzIHRoZSBBdWRpbyBDb250ZXh0XG4gKi9cbldFQkFVRElPLmNyZWF0ZUF1ZGlvQ29udGV4dCA9IGZ1bmN0aW9uIChvcClcbntcbiAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xuICAgIGlmICh3aW5kb3cuQXVkaW9Db250ZXh0KVxuICAgIHtcbiAgICAgICAgaWYgKCF3aW5kb3cuYXVkaW9Db250ZXh0KVxuICAgICAgICB7XG4gICAgICAgICAgICB3aW5kb3cuYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHRvbmUuanMgbGliIGlzIGJlaW5nIHVzZWRcbiAgICAgICAgaWYgKHdpbmRvdy5Ub25lICYmICFXRUJBVURJTy50b25lSnNJbml0aWFsaXplZClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gc2V0IGN1cnJlbnQgYXVkaW8gY29udGV4dCBpbiB0b25lLmpzXG4gICAgICAgICAgICBUb25lLnNldENvbnRleHQod2luZG93LmF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICBXRUJBVURJTy50b25lSnNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgb3AucGF0Y2guY29uZmlnLm9uRXJyb3IoXCJOT19XRUJBVURJT1wiLCBcIldlYiBBdWRpbyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5hdWRpb0NvbnRleHQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGF1ZGlvIGNvbnRleHQuXG4gKiBCZWZvcmUgYGNyZWF0ZUF1ZGlvQ29udGV4dGAgbXVzdCBoYXZlIGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2UuXG4gKiBJdCBtb3N0IGNhc2VzIHlvdSBzaG91bGQgdXNlIGBjcmVhdGVBdWRpb0NvbnRleHRgLCB3aGljaCBqdXN0IHJldHVybnMgdGhlIGF1ZGlvIGNvbnRleHRcbiAqIHdoZW4gaXQgaGFzIGJlZW4gY3JlYXRlZCBhbHJlYWR5LlxuICovXG5XRUJBVURJTy5nZXRBdWRpb0NvbnRleHQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB3aW5kb3cuYXVkaW9Db250ZXh0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGF1ZGlvIGluIHBvcnQgZm9yIHRoZSBvcCB3aXRoIG5hbWUgYHBvcnROYW1lYFxuICogV2hlbiBkaXNjb25uZWN0ZWQgaXQgd2lsbCBkaXNjb25uZWN0IHRoZSBwcmV2aW91cyBjb25uZWN0ZWQgYXVkaW8gbm9kZVxuICogZnJvbSB0aGUgb3AncyBhdWRpbyBub2RlLlxuICogQHBhcmFtIHtDQUJMRVMuT3B9IG9wIC0gVGhlIG9wZXJhdG9yIHRvIGNyZWF0ZSB0aGUgYXVkaW8gcG9ydCBpblxuICogQHBhcmFtIHtzdHJpbmd9IHBvcnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBvcnRcbiAqIEBwYXJhbSB7QXVkaW9Ob2RlfSBhdWRpb05vZGUgLSBUaGUgYXVkaW9ub2RlIGluY29taW5nIGNvbm5lY3Rpb25zIHNob3VsZCBjb25uZWN0IHRvXG4gKiBAcGFyYW0ge251bWJlcn0gW2lucHV0Q2hhbm5lbEluZGV4PTBdIC0gSWYgdGhlIGF1ZGlvIG5vZGUgaGFzIG11bHRpcGxlIGlucHV0cywgdGhpcyBpcyB0aGUgaW5kZXggb2YgdGhlIGlucHV0IGNoYW5uZWwgdG8gY29ubmVjdCB0b1xuICogQHJldHVybnMge0NBQkxFUy5Qb3J0fHVuZGVmaW5lZH0gLSBUaGUgbmV3bHkgY3JlYXRlZCBhdWRpbyBpbiBwb3J0IG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlIHdhcyBhbiBlcnJvclxuICovXG5XRUJBVURJTy5jcmVhdGVBdWRpb0luUG9ydCA9IGZ1bmN0aW9uIChvcCwgcG9ydE5hbWUsIGF1ZGlvTm9kZSwgaW5wdXRDaGFubmVsSW5kZXgpXG57XG4gICAgaWYgKCFvcCB8fCAhcG9ydE5hbWUgfHwgIWF1ZGlvTm9kZSlcbiAgICB7XG4gICAgICAgIGNvbnN0IG1zZyA9IFwiRVJST1I6IGNyZWF0ZUF1ZGlvSW5Qb3J0IG5lZWRzIHRocmVlIHBhcmFtZXRlcnMsIG9wLCBwb3J0TmFtZSBhbmQgYXVkaW9Ob2RlXCI7XG4gICAgICAgIG9wLmxvZyhtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgLy8gcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlucHV0Q2hhbm5lbEluZGV4KVxuICAgIHtcbiAgICAgICAgaW5wdXRDaGFubmVsSW5kZXggPSAwO1xuICAgIH1cbiAgICBvcC53ZWJBdWRpbyA9IG9wLndlYkF1ZGlvIHx8IHt9O1xuICAgIG9wLndlYkF1ZGlvLmF1ZGlvSW5Qb3J0cyA9IG9wLndlYkF1ZGlvLmF1ZGlvSW5Qb3J0cyB8fCBbXTtcbiAgICBjb25zdCBwb3J0ID0gb3AuaW5PYmplY3QocG9ydE5hbWUpO1xuICAgIHBvcnQud2ViQXVkaW8gPSB7fTtcbiAgICBwb3J0LndlYkF1ZGlvLnByZXZpb3VzQXVkaW9Jbk5vZGUgPSBudWxsO1xuICAgIHBvcnQud2ViQXVkaW8uYXVkaW9Ob2RlID0gYXVkaW9Ob2RlO1xuXG4gICAgb3Aud2ViQXVkaW8uYXVkaW9JblBvcnRzW3BvcnROYW1lXSA9IHBvcnQ7XG5cbiAgICBwb3J0Lm9uQ2hhbmdlID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIGNvbnN0IGF1ZGlvSW5Ob2RlID0gcG9ydC5nZXQoKTtcbiAgICAgICAgLy8gd2hlbiBwb3J0IGRpc2Nvbm5lY3RlZCwgZGlzY29ubmVjdCBhdWRpbyBub2Rlc1xuICAgICAgICBpZiAoIWF1ZGlvSW5Ob2RlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAocG9ydC53ZWJBdWRpby5wcmV2aW91c0F1ZGlvSW5Ob2RlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcnQud2ViQXVkaW8ucHJldmlvdXNBdWRpb0luTm9kZS5kaXNjb25uZWN0KSBwb3J0LndlYkF1ZGlvLnByZXZpb3VzQXVkaW9Jbk5vZGUuZGlzY29ubmVjdChwb3J0LndlYkF1ZGlvLmF1ZGlvTm9kZSwgMCwgaW5wdXRDaGFubmVsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBvcC5zZXRVaUVycm9yKFwiYXVkaW9DdHhcIiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQud2ViQXVkaW8ucHJldmlvdXNBdWRpb0luTm9kZS5kaXNjb25uZWN0KHBvcnQud2ViQXVkaW8uYXVkaW9Ob2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXIpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkRpc2Nvbm5lY3RpbmcgYXVkaW8gbm9kZSB3aXRoIGluL291dCBwb3J0IGluZGV4LCBhcyB3ZWxsIGFzIHdpdGhvdXQgaW4vb3V0LXBvcnQtaW5kZXggZGlkIG5vdCB3b3JrIFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUucHJpbnRTdGFja1RyYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJpbnRTdGFja1RyYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGF1ZGlvSW5Ob2RlLmNvbm5lY3QpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBhdWRpb0luTm9kZS5jb25uZWN0KHBvcnQud2ViQXVkaW8uYXVkaW9Ob2RlLCAwLCBpbnB1dENoYW5uZWxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIG9wLnNldFVpRXJyb3IoXCJhdWRpb0N0eFwiLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBvcC5zZXRVaUVycm9yKFwiYXVkaW9DdHhcIiwgXCJUaGUgcGFzc2VkIGlucHV0IGlzIG5vdCBhbiBhdWRpbyBjb250ZXh0LiBQbGVhc2UgbWFrZSBzdXJlIHlvdSBjb25uZWN0IGFuIGF1ZGlvIGNvbnRleHQgdG8gdGhlIGlucHV0LlwiLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9wLmxvZyhcIkVycm9yOiBGYWlsZWQgdG8gY29ubmVjdCB3ZWIgYXVkaW8gbm9kZSFcIiwgZSk7XG4gICAgICAgICAgICAgICAgb3AubG9nKFwicG9ydC53ZWJBdWRpby5hdWRpb05vZGVcIiwgcG9ydC53ZWJBdWRpby5hdWRpb05vZGUpO1xuICAgICAgICAgICAgICAgIG9wLmxvZyhcImF1ZGlvSW5Ob2RlOiBcIiwgYXVkaW9Jbk5vZGUpO1xuICAgICAgICAgICAgICAgIG9wLmxvZyhcImlucHV0Q2hhbm5lbEluZGV4OlwiLCBpbnB1dENoYW5uZWxJbmRleCk7XG4gICAgICAgICAgICAgICAgb3AubG9nKFwiYXVkaW9Jbk5vZGUuY29ubmVjdDogXCIsIGF1ZGlvSW5Ob2RlLmNvbm5lY3QpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9ydC53ZWJBdWRpby5wcmV2aW91c0F1ZGlvSW5Ob2RlID0gYXVkaW9Jbk5vZGU7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBNYXliZSBhZGQgc3VidHlwZSB0byBhdWRpby1ub2RlLW9iamVjdD9cbiAgICByZXR1cm4gcG9ydDtcbn07XG5cbi8qKlxuICogU29tZXRpbWVzIGl0IGlzIG5lY2Vzc2FyeSB0byByZXBsYWNlIGEgbm9kZSBvZiBhIHBvcnQsIGlmIHNvIGFsbFxuICogY29ubmVjdGlvbnMgdG8gdGhpcyBub2RlIG11c3QgYmUgZGlzY29ubmVjdGVkIGFuZCBjb25uZWN0aW9ucyB0byB0aGUgbmV3XG4gKiBub2RlIG11c3QgYmUgbWFkZS5cbiAqIENhbiBiZSB1c2VkIGZvciBib3RoIEF1ZGlvIHBvcnRzIGFzIHdlbGwgYXMgQXVkaW9QYXJhbSBwb3J0c1xuICogaWYgdXNlZCB3aXRoIGFuIEF1ZGlvUGFyYW0gcGFzcyBlLmcuIGBzeW50aC5mcmVxdWVuY3lgIGFzIG5ld05vZGVcbiAqIEBwYXJhbSB7Q0FCTEVTLlBvcnR9IHBvcnQgLSBUaGUgcG9ydCB3aGVyZSB0aGUgYXVkaW8gbm9kZSBuZWVkcyB0byBiZSByZXBsYWNlZFxuICovXG5XRUJBVURJTy5yZXBsYWNlTm9kZUluUG9ydCA9IGZ1bmN0aW9uIChwb3J0LCBvbGROb2RlLCBuZXdOb2RlKVxue1xuICAgIGNvbnN0IGNvbm5lY3RlZE5vZGUgPSBwb3J0LndlYkF1ZGlvLnByZXZpb3VzQXVkaW9Jbk5vZGU7XG4gICAgLy8gY2hlY2sgaWYgY29ubmVjdGVkXG4gICAgaWYgKGNvbm5lY3RlZE5vZGUgJiYgY29ubmVjdGVkTm9kZS5kaXNjb25uZWN0KVxuICAgIHtcbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbm5lY3RlZE5vZGUuZGlzY29ubmVjdChvbGROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGUucHJpbnRTdGFja1RyYWNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGUucHJpbnRTdGFja1RyYWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXBsYWNlTm9kZUluUG9ydDogQ291bGQgbm90IGRpc2Nvbm5lY3Qgb2xkIGF1ZGlvIG5vZGUuIFwiICsgZS5uYW1lICsgXCIgXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHBvcnQud2ViQXVkaW8uYXVkaW9Ob2RlID0gbmV3Tm9kZTtcbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbm5lY3RlZE5vZGUuY29ubmVjdChuZXdOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGUucHJpbnRTdGFja1RyYWNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGUucHJpbnRTdGFja1RyYWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXBsYWNlTm9kZUluUG9ydDogQ291bGQgbm90IGNvbm5lY3QgdG8gbmV3IG5vZGUuIFwiICsgZS5uYW1lICsgXCIgXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGF1ZGlvIG91dCBwb3J0IHdoaWNoIHRha2VzIGNhcmUgb2YgKGRpcy0pY29ubmVjdGluZyBvbiBpdOKAmXMgb3duXG4gKiBAcGFyYW0ge0NBQkxFUy5vcH0gb3AgLSBUaGUgb3AgdG8gY3JlYXRlIGFuIGF1ZGlvIG91dCBwb3J0IGZvclxuICogQHBhcmFtIHtzdHJpbmd9IHBvcnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHBvcnQgdG8gYmUgY3JlYXRlZFxuICogQHBhcmFtIHtBdWRpb05vZGV9IGF1ZGlvTm9kZSAtIFRoZSBhdWRpbyBub2RlIHRvIGxpbmsgdG8gdGhlIHBvcnRcbiAqIEByZXR1cm5zIHsoQ0FCTEVTLlBvcnR8dW5kZWZpbmVkKX0gLSBUaGUgbmV3bHkgY3JlYXRlZCBhdWRpbyBvdXQgcG9ydCBvciBgdW5kZWZpbmVkYCBpZiB0aGVyZSB3YXMgYW4gZXJyb3JcbiAqL1xuV0VCQVVESU8uY3JlYXRlQXVkaW9PdXRQb3J0ID0gZnVuY3Rpb24gKG9wLCBwb3J0TmFtZSwgYXVkaW9Ob2RlKVxue1xuICAgIGlmICghb3AgfHwgIXBvcnROYW1lIHx8ICFhdWRpb05vZGUpXG4gICAge1xuICAgICAgICBjb25zdCBtc2cgPSBcIkVSUk9SOiBjcmVhdGVBdWRpb091dFBvcnQgbmVlZHMgdGhyZWUgcGFyYW1ldGVycywgb3AsIHBvcnROYW1lIGFuZCBhdWRpb05vZGVcIjtcbiAgICAgICAgb3AubG9nKG1zZyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cblxuICAgIGNvbnN0IHBvcnQgPSBvcC5vdXRPYmplY3QocG9ydE5hbWUpO1xuICAgIC8vIFRPRE86IE1heWJlIGFkZCBzdWJ0eXBlIHRvIGF1ZGlvLW5vZGUtb2JqZWN0P1xuICAgIHBvcnQuc2V0KGF1ZGlvTm9kZSk7XG4gICAgcmV0dXJuIHBvcnQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXVkaW8gcGFyYW0gaW4gcG9ydCBmb3IgdGhlIG9wIHdpdGggbmFtZSBwb3J0TmFtZS5cbiAqIFRoZSBwb3J0IGFjY2VwdHMgb3RoZXIgYXVkaW8gbm9kZXMgYXMgc2lnbmFscyBhcyB3ZWxsIGFzIHZhbHVlcyAobnVtYmVycylcbiAqIFdoZW4gdGhlIHBvcnQgaXMgZGlzY29ubmVjdGVkIGl0IHdpbGwgZGlzY29ubmVjdCB0aGUgcHJldmlvdXMgY29ubmVjdGVkIGF1ZGlvIG5vZGVcbiAqIGZyb20gdGhlIG9wJ3MgYXVkaW8gbm9kZSBhbmQgcmVzdG9yZSB0aGUgbnVtYmVyIHZhbHVlIHNldCBiZWZvcmUuXG4gKiBAcGFyYW0ge0NBQkxFUy5PcH0gb3AgLSBUaGUgb3BlcmF0b3IgdG8gY3JlYXRlIGFuIGF1ZGlvIHBhcmFtIGlucHV0IHBvcnQgZm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9ydE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcG9ydCB0byBjcmVhdGVcbiAqIEByZXR1cm5zIHsoQ0FCTEVTLlBvcnR8dW5kZWZpbmVkKX0gLSBUaGUgbmV3bHkgY3JlYXRlZCBwb3J0LCB3aGljaCB0YWtlcyBjYXJlIG9mIChkaXMtKWNvbm5lY3Rpbmcgb24gaXRzIG93biwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlcmUgd2FzIGFuIGVycm9yXG4gKi9cbldFQkFVRElPLmNyZWF0ZUF1ZGlvUGFyYW1JblBvcnQgPSBmdW5jdGlvbiAob3AsIHBvcnROYW1lLCBhdWRpb05vZGUsIG9wdGlvbnMsIGRlZmF1bHRWYWx1ZSlcbntcbiAgICBpZiAoIW9wIHx8ICFwb3J0TmFtZSB8fCAhYXVkaW9Ob2RlKVxuICAgIHtcbiAgICAgICAgb3AubG9nKFwiRVJST1I6IGNyZWF0ZUF1ZGlvUGFyYW1JblBvcnQgbmVlZHMgdGhyZWUgcGFyYW1ldGVycywgb3AsIHBvcnROYW1lIGFuZCBhdWRpb05vZGVcIik7XG4gICAgICAgIGlmIChvcCAmJiBvcC5uYW1lKSBvcC5sb2coXCJvcG5hbWU6IFwiLCBvcC5uYW1lKTtcbiAgICAgICAgb3AubG9nKFwicG9ydE5hbWVcIiwgcG9ydE5hbWUpO1xuICAgICAgICBvcC5sb2coXCJhdWRpb05vZGU6IFwiLCBhdWRpb05vZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIG9wLndlYkF1ZGlvID0gb3Aud2ViQXVkaW8gfHwge307XG4gICAgb3Aud2ViQXVkaW8uYXVkaW9JblBvcnRzID0gb3Aud2ViQXVkaW8uYXVkaW9JblBvcnRzIHx8IFtdO1xuICAgIC8vIHZhciBwb3J0ID0gb3AuaW5PYmplY3QocG9ydE5hbWUpO1xuICAgIGNvbnN0IHBvcnQgPSBvcC5pbkR5bmFtaWMoXG4gICAgICAgIHBvcnROYW1lLFxuICAgICAgICBbQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9WQUxVRSwgQ09OU1RBTlRTLk9QLk9QX1BPUlRfVFlQRV9PQkpFQ1RdLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBkZWZhdWx0VmFsdWUsXG4gICAgKTtcbiAgICBwb3J0LndlYkF1ZGlvID0ge307XG4gICAgcG9ydC53ZWJBdWRpby5wcmV2aW91c0F1ZGlvSW5Ob2RlID0gbnVsbDtcbiAgICBwb3J0LndlYkF1ZGlvLmF1ZGlvTm9kZSA9IGF1ZGlvTm9kZTtcblxuICAgIG9wLndlYkF1ZGlvLmF1ZGlvSW5Qb3J0c1twb3J0TmFtZV0gPSBwb3J0O1xuXG4gICAgLy8gcG9ydC5vbkxpbmtDaGFuZ2VkID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gICBvcC5sb2coXCJvbkxpbmtDaGFuZ2VkXCIpO1xuICAgIC8vICAgaWYocG9ydC5pc0xpbmtlZCgpKSB7XG4gICAgLy9cbiAgICAvLyAgICAgICBpZihwb3J0LmxpbmtzWzBdLnBvcnRPdXQudHlwZSA9PT0gQ0FCTEVTLkNPTlNUQU5UUy5PUC5PUF9QT1JUX1RZUEVfKSB7IC8vIHZhbHVlXG4gICAgLy9cbiAgICAvLyAgICAgICB9IGVsc2UgaWYocG9ydC5saW5rc1swXS5wb3J0T3V0LnR5cGUgPT09IENBQkxFUy5DT05TVEFOVFMuT1AuT1BfUE9SVF9UWVBFX09CSkVDVCkgeyAvLyBvYmplY3RcbiAgICAvL1xuICAgIC8vICAgICAgIH1cbiAgICAvLyAgIH0gZWxzZSB7IC8vIHVubGlua2VkXG4gICAgLy9cbiAgICAvLyAgIH1cbiAgICAvLyB9O1xuXG4gICAgcG9ydC5vbkNoYW5nZSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBjb25zdCBhdWRpb0luTm9kZSA9IHBvcnQuZ2V0KCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBwb3J0LndlYkF1ZGlvLmF1ZGlvTm9kZTtcbiAgICAgICAgY29uc3QgYXVkaW9DdHggPSBXRUJBVURJTy5nZXRBdWRpb0NvbnRleHQoKTtcblxuICAgICAgICBpZiAoYXVkaW9Jbk5vZGUgIT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGF1ZGlvSW5Ob2RlID09PSBcIm9iamVjdFwiICYmIGF1ZGlvSW5Ob2RlLmNvbm5lY3QpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBhdWRpb0luTm9kZS5jb25uZWN0KG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9wLmxvZyhcIkNvdWxkIG5vdCBjb25uZWN0IGF1ZGlvIG5vZGU6IFwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUucHJpbnRTdGFja1RyYWNlKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByaW50U3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcnQud2ViQXVkaW8ucHJldmlvdXNBdWRpb0luTm9kZSA9IGF1ZGlvSW5Ob2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIHRvbmUuanMgYXVkaW8gcGFyYW1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5fcGFyYW0gJiYgbm9kZS5fcGFyYW0ubWluVmFsdWUgJiYgbm9kZS5fcGFyYW0ubWF4VmFsdWUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXVkaW9Jbk5vZGUgPj0gbm9kZS5fcGFyYW0ubWluVmFsdWUgJiYgYXVkaW9Jbk5vZGUgPD0gbm9kZS5fcGFyYW0ubWF4VmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnNldFZhbHVlQXRUaW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRWYWx1ZUF0VGltZShhdWRpb0luTm9kZSwgYXVkaW9DdHguY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gYXVkaW9Jbk5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AubG9nKFwiUG9zc2libGUgQXVkaW9QYXJhbSBwcm9ibGVtIHdpdGggdG9uZS5qcyBvcDogXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnByaW50U3RhY2tUcmFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJpbnRTdGFja1RyYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcC5sb2coXCJXYXJuaW5nOiBUaGUgdmFsdWUgZm9yIGFuIGF1ZGlvIHBhcmFtZXRlciBpcyBvdXQgb2YgcmFuZ2UhXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBuYXRpdmUgV2ViIEF1ZGlvIHBhcmFtXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5taW5WYWx1ZSAmJiBub2RlLm1heFZhbHVlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvSW5Ob2RlID49IG5vZGUubWluVmFsdWUgJiYgYXVkaW9Jbk5vZGUgPD0gbm9kZS5tYXhWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc2V0VmFsdWVBdFRpbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldFZhbHVlQXRUaW1lKGF1ZGlvSW5Ob2RlLCBhdWRpb0N0eC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBhdWRpb0luTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcC5sb2coXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQXVkaW9QYXJhbSBoYXMgbWluVmFsdWUgLyBtYXhWYWx1ZSBkZWZpbmVkLCBhbmQgdmFsdWUgaXMgaW4gcmFuZ2UsIGJ1dCBzZXR0aW5nIHRoZSB2YWx1ZSBmYWlsZWQhIFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUucHJpbnRTdGFja1RyYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmludFN0YWNrVHJhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wLmxvZyhcIldhcm5pbmc6IFRoZSB2YWx1ZSBmb3IgYW4gYXVkaW8gcGFyYW1ldGVyIGlzIG91dCBvZiByYW5nZSFcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIG5vIG1pbi1tYXggdmFsdWVzLCB0cnkgYW55d2F5XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnNldFZhbHVlQXRUaW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0VmFsdWVBdFRpbWUoYXVkaW9Jbk5vZGUsIGF1ZGlvQ3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gYXVkaW9Jbk5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wLmxvZyhcIlBvc3NpYmxlIEF1ZGlvUGFyYW0gcHJvYmxlbSAod2l0aG91dCBtaW5WYWx1ZSAvIG1heFZhbHVlKTogXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUucHJpbnRTdGFja1RyYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJpbnRTdGFja1RyYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBvcnQud2ViQXVkaW8ucHJldmlvdXNBdWRpb0luTm9kZSAmJiBwb3J0LndlYkF1ZGlvLnByZXZpb3VzQXVkaW9Jbk5vZGUuZGlzY29ubmVjdClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0LndlYkF1ZGlvLnByZXZpb3VzQXVkaW9Jbk5vZGUuZGlzY29ubmVjdChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3AubG9nKFwiQ291bGQgbm90IGRpc2Nvbm5lY3QgcHJldmlvdXMgYXVkaW8gbm9kZTogXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb3J0LndlYkF1ZGlvLnByZXZpb3VzQXVkaW9Jbk5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gZGlzY29ubmVjdGVkXG4gICAgICAgICAgICBpZiAocG9ydC53ZWJBdWRpby5wcmV2aW91c0F1ZGlvSW5Ob2RlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcG9ydDtcbn07XG5cblxuLyoqXG4gKiBMb2FkcyBhbiBhdWRpbyBmaWxlIGFuZCB1cGRhdGVzIHRoZSBsb2FkaW5nIGluZGljYXRvcnMgd2hlbiBjYWJsZXMgaXMgcnVuIGluIHRoZSBlZGl0b3IuXG4gKiBAcGFyYW0ge0NBQkxFUy5QYXRjaH0gcGF0Y2ggLSBUaGUgY2FibGVzIHBhdGNoLCB3aGVuIGNhbGxlZCBmcm9tIGluc2lkZSBhbiBvcCB0aGlzIGlzIGBvcC5wYXRjaGBcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdXJsIG9mIHRoZSBhdWRpbyBmaWxlIHRvIGxvYWRcbiAqIEBwYXJhbSB7bG9hZEF1ZGlvRmlsZUZpbmlzaGVkQ2FsbGJhY2t9IG9uRmluaXNoZWQgLSBUaGUgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGxvYWRpbmcgaXMgZmluaXNoZWQsIHBhc3NlcyB0aGUgQXVkaW9CdWZmZXJcbiAqIEBwYXJhbSB7bG9hZEF1ZGlvRmlsZUVycm9yQ2FsbGJhY2t9IG9uRXJyb3IgLSBUaGUgY2FsbGJhY2sgd2hlbiB0aGVyZSB3YXMgYW4gZXJyb3IgbG9hZGluZyB0aGUgZmlsZSwgdGhlIHJyb3IgbWVzc2FnZSBpcyBwYXNzZWRcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RlL2RvY3MvV2ViL0FQSS9BdWRpb0NvbnRleHQvZGVjb2RlQXVkaW9EYXRhfVxuICovXG5XRUJBVURJTy5sb2FkQXVkaW9GaWxlID0gZnVuY3Rpb24gKHBhdGNoLCB1cmwsIG9uRmluaXNoZWQsIG9uRXJyb3IsIGxvYWRpbmdUYXNrKVxue1xuICAgIGNvbnN0IGF1ZGlvQ29udGV4dCA9IFdFQkFVRElPLmNyZWF0ZUF1ZGlvQ29udGV4dCgpO1xuXG4gICAgbGV0IGxvYWRpbmdJZCA9IG51bGw7XG4gICAgaWYgKGxvYWRpbmdUYXNrIHx8IGxvYWRpbmdUYXNrID09PSB1bmRlZmluZWQpXG4gICAge1xuICAgICAgICBsb2FkaW5nSWQgPSBwYXRjaC5sb2FkaW5nLnN0YXJ0KFwiYXVkaW9cIiwgdXJsKTtcbiAgICAgICAgaWYgKHBhdGNoLmlzRWRpdG9yTW9kZSgpKSBndWkuam9icygpLnN0YXJ0KHsgXCJpZFwiOiBcImxvYWRhdWRpb1wiICsgbG9hZGluZ0lkLCBcInRpdGxlXCI6IFwiIGxvYWRpbmcgYXVkaW8gKFwiICsgdXJsICsgXCIpXCIgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBpZiAoIXVybClcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVxdWVzdC5vcGVuKFwiR0VUXCIsIHVybCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgLy8gVE9ETzogbWF5YmUgY3Jvc3NvcmlnaW4gc3R1ZmYgbmVlZGVkP1xuICAgIC8vIERlY29kZSBhc3luY2hyb25vdXNseVxuICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHBhdGNoLmxvYWRpbmcuZmluaXNoZWQobG9hZGluZ0lkKTtcbiAgICAgICAgaWYgKHBhdGNoLmlzRWRpdG9yTW9kZSgpKSBndWkuam9icygpLmZpbmlzaChcImxvYWRhdWRpb1wiICsgbG9hZGluZ0lkKTtcbiAgICAgICAgYXVkaW9Db250ZXh0LmRlY29kZUF1ZGlvRGF0YShyZXF1ZXN0LnJlc3BvbnNlLCBvbkZpbmlzaGVkLCBvbkVycm9yKTtcbiAgICB9O1xuICAgIHJlcXVlc3Quc2VuZCgpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHBhc3NlZCB0aW1lIGlzIGEgdmFsaWQgdGltZSB0byBiZSB1c2VkIGluIGFueSBvZiB0aGUgVG9uZS5qcyBvcHMuXG4gKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKX0gdCAtIFRoZSB0aW1lIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRpbWUgaXMgdmFsaWQsIGZhbHNlIGlmIG5vdFxuICovXG5XRUJBVURJTy5pc1ZhbGlkVG9uZVRpbWUgPSBmdW5jdGlvbiAodClcbntcbiAgICB0cnlcbiAgICB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBuZXcgVG9uZS5UaW1lKHQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcGFzc2VkIG5vdGUgaXMgYSB2YWxpZCBub3RlIHRvIGJlIHVzZWQgd2l0aCBUb25lLmpzXG4gKiBAcGFyYW0ge3N0cmluZ30gbm90ZSAtIFRoZSBub3RlIHRvIGJlIGNoZWNrZWQsIGUuZy4gYFwiQzRcImBcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgdGhlIG5vdGUgaXMgYSB2YWxpZCBub3RlLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuV0VCQVVESU8uaXNWYWxpZFRvbmVOb3RlID0gZnVuY3Rpb24gKG5vdGUpXG57XG4gICAgdHJ5XG4gICAge1xuICAgICAgICBUb25lLkZyZXF1ZW5jeShub3RlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IHsgV0VCQVVESU8gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/webaudio.js\n");

/***/ }),

/***/ "../shared/client/src/eventtarget.js":
/*!*******************************************!*\
  !*** ../shared/client/src/eventtarget.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Events)\n/* harmony export */ });\n/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper.js */ \"../shared/client/src/helper.js\");\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger.js */ \"../shared/client/src/logger.js\");\n\n\n\nclass Events\n{\n    constructor()\n    {\n        this._log = new _logger_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"eventtarget\");\n        this._eventCallbacks = {};\n        this._logName = \"\";\n        this._logEvents = false;\n        this._listeners = {};\n\n        this.on = this.addEventListener;\n        this.off = this.removeEventListener;\n    }\n\n    addEventListener(which, cb, idPrefix)\n    {\n        const event =\n            {\n                \"id\": (idPrefix || \"\") + _helper_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].simpleId(),\n                \"name\": which,\n                \"cb\": cb,\n            };\n        if (!this._eventCallbacks[which]) this._eventCallbacks[which] = [event];\n        else this._eventCallbacks[which].push(event);\n\n        this._listeners[event.id] = event;\n\n        return event.id;\n    }\n\n    hasEventListener(which, cb)\n    {\n        if (which && !cb)\n        {\n            // check by id\n            return !!this._listeners[which];\n        }\n        else\n        {\n            this._log.warn(\"old eventtarget function haseventlistener!\");\n            if (which && cb)\n            {\n                if (this._eventCallbacks[which])\n                {\n                    const idx = this._eventCallbacks[which].indexOf(cb);\n                    return idx !== -1;\n                }\n            }\n        }\n    }\n\n    hasListenerForEventName(eventName)\n    {\n        return this._eventCallbacks[eventName] && this._eventCallbacks[eventName].length > 0;\n    }\n\n    removeEventListener(which, cb)\n    {\n        if (which === null || which === undefined) return;\n\n        if (!cb) // new style, remove by id, not by name/callback\n        {\n            const event = this._listeners[which];\n            if (!event)\n            {\n                this._log.log(\"could not find event...\");\n                return;\n            }\n\n            let found = true;\n            while (found)\n            {\n                found = false;\n                let index = -1;\n                for (let i = 0; i < this._eventCallbacks[event.name].length; i++)\n                {\n                    if (this._eventCallbacks[event.name][i].id.indexOf(which) === 0) // this._eventCallbacks[event.name][i].id == which ||\n                    {\n                        found = true;\n                        index = i;\n                    }\n                }\n\n                if (index !== -1)\n                {\n                    this._eventCallbacks[event.name].splice(index, 1);\n                    delete this._listeners[which];\n                }\n            }\n\n            return;\n        }\n\n        this._log.info(\"[eventtaget] \", \"old function signature: removeEventListener! use listener id\");\n        this._log.log((new Error()).stack);\n\n        let index = null;\n        for (let i = 0; i < this._eventCallbacks[which].length; i++)\n            if (this._eventCallbacks[which][i].cb === cb)\n                index = i;\n\n        if (index !== null)\n        {\n            delete this._eventCallbacks[index];\n        }\n        else this._log.warn(\"removeEventListener not found \" + which);\n    }\n\n    logEvents(enabled, name)\n    {\n        this._logEvents = enabled;\n        this._logName = name;\n    }\n\n    emitEvent(which, param1, param2, param3, param4, param5, param6)\n    {\n        if (this._logEvents) this._log.log(\"[event] \", this._logName, which, this._eventCallbacks);\n\n        if (this._eventCallbacks[which])\n        {\n            for (let i = 0; i < this._eventCallbacks[which].length; i++)\n            {\n                if (this._eventCallbacks[which][i])\n                {\n                    this._eventCallbacks[which][i].cb(param1, param2, param3, param4, param5, param6);\n                }\n            }\n        }\n        else\n        {\n            if (this._logEvents) this._log.log(\"[event] has no event callback\", which, this._eventCallbacks);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2hhcmVkL2NsaWVudC9zcmMvZXZlbnR0YXJnZXQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DQUJMRVMvLi4vc2hhcmVkL2NsaWVudC9zcmMvZXZlbnR0YXJnZXQuanM/YWJmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaGVscGVyIGZyb20gXCIuL2hlbHBlci5qc1wiO1xuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi9sb2dnZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRzXG57XG4gICAgY29uc3RydWN0b3IoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbG9nID0gbmV3IExvZ2dlcihcImV2ZW50dGFyZ2V0XCIpO1xuICAgICAgICB0aGlzLl9ldmVudENhbGxiYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLl9sb2dOYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5fbG9nRXZlbnRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXG4gICAgICAgIHRoaXMub24gPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXI7XG4gICAgICAgIHRoaXMub2ZmID0gdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyO1xuICAgIH1cblxuICAgIGFkZEV2ZW50TGlzdGVuZXIod2hpY2gsIGNiLCBpZFByZWZpeClcbiAgICB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IChpZFByZWZpeCB8fCBcIlwiKSArIGhlbHBlci5zaW1wbGVJZCgpLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiB3aGljaCxcbiAgICAgICAgICAgICAgICBcImNiXCI6IGNiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudENhbGxiYWNrc1t3aGljaF0pIHRoaXMuX2V2ZW50Q2FsbGJhY2tzW3doaWNoXSA9IFtldmVudF07XG4gICAgICAgIGVsc2UgdGhpcy5fZXZlbnRDYWxsYmFja3Nbd2hpY2hdLnB1c2goZXZlbnQpO1xuXG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudC5pZF0gPSBldmVudDtcblxuICAgICAgICByZXR1cm4gZXZlbnQuaWQ7XG4gICAgfVxuXG4gICAgaGFzRXZlbnRMaXN0ZW5lcih3aGljaCwgY2IpXG4gICAge1xuICAgICAgICBpZiAod2hpY2ggJiYgIWNiKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjaGVjayBieSBpZFxuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5fbGlzdGVuZXJzW3doaWNoXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwib2xkIGV2ZW50dGFyZ2V0IGZ1bmN0aW9uIGhhc2V2ZW50bGlzdGVuZXIhXCIpO1xuICAgICAgICAgICAgaWYgKHdoaWNoICYmIGNiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudENhbGxiYWNrc1t3aGljaF0pXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9ldmVudENhbGxiYWNrc1t3aGljaF0uaW5kZXhPZihjYik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZHggIT09IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhc0xpc3RlbmVyRm9yRXZlbnROYW1lKGV2ZW50TmFtZSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudENhbGxiYWNrc1tldmVudE5hbWVdICYmIHRoaXMuX2V2ZW50Q2FsbGJhY2tzW2V2ZW50TmFtZV0ubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHdoaWNoLCBjYilcbiAgICB7XG4gICAgICAgIGlmICh3aGljaCA9PT0gbnVsbCB8fCB3aGljaCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCFjYikgLy8gbmV3IHN0eWxlLCByZW1vdmUgYnkgaWQsIG5vdCBieSBuYW1lL2NhbGxiYWNrXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5fbGlzdGVuZXJzW3doaWNoXTtcbiAgICAgICAgICAgIGlmICghZXZlbnQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmxvZyhcImNvdWxkIG5vdCBmaW5kIGV2ZW50Li4uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChmb3VuZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRDYWxsYmFja3NbZXZlbnQubmFtZV0ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRDYWxsYmFja3NbZXZlbnQubmFtZV1baV0uaWQuaW5kZXhPZih3aGljaCkgPT09IDApIC8vIHRoaXMuX2V2ZW50Q2FsbGJhY2tzW2V2ZW50Lm5hbWVdW2ldLmlkID09IHdoaWNoIHx8XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudENhbGxiYWNrc1tldmVudC5uYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3doaWNoXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvZy5pbmZvKFwiW2V2ZW50dGFnZXRdIFwiLCBcIm9sZCBmdW5jdGlvbiBzaWduYXR1cmU6IHJlbW92ZUV2ZW50TGlzdGVuZXIhIHVzZSBsaXN0ZW5lciBpZFwiKTtcbiAgICAgICAgdGhpcy5fbG9nLmxvZygobmV3IEVycm9yKCkpLnN0YWNrKTtcblxuICAgICAgICBsZXQgaW5kZXggPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2V2ZW50Q2FsbGJhY2tzW3doaWNoXS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudENhbGxiYWNrc1t3aGljaF1baV0uY2IgPT09IGNiKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudENhbGxiYWNrc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aGlzLl9sb2cud2FybihcInJlbW92ZUV2ZW50TGlzdGVuZXIgbm90IGZvdW5kIFwiICsgd2hpY2gpO1xuICAgIH1cblxuICAgIGxvZ0V2ZW50cyhlbmFibGVkLCBuYW1lKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbG9nRXZlbnRzID0gZW5hYmxlZDtcbiAgICAgICAgdGhpcy5fbG9nTmFtZSA9IG5hbWU7XG4gICAgfVxuXG4gICAgZW1pdEV2ZW50KHdoaWNoLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQsIHBhcmFtNSwgcGFyYW02KVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvZ0V2ZW50cykgdGhpcy5fbG9nLmxvZyhcIltldmVudF0gXCIsIHRoaXMuX2xvZ05hbWUsIHdoaWNoLCB0aGlzLl9ldmVudENhbGxiYWNrcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50Q2FsbGJhY2tzW3doaWNoXSlcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ldmVudENhbGxiYWNrc1t3aGljaF0ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50Q2FsbGJhY2tzW3doaWNoXVtpXSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50Q2FsbGJhY2tzW3doaWNoXVtpXS5jYihwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQsIHBhcmFtNSwgcGFyYW02KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG9nRXZlbnRzKSB0aGlzLl9sb2cubG9nKFwiW2V2ZW50XSBoYXMgbm8gZXZlbnQgY2FsbGJhY2tcIiwgd2hpY2gsIHRoaXMuX2V2ZW50Q2FsbGJhY2tzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../shared/client/src/eventtarget.js\n");

/***/ }),

/***/ "../shared/client/src/helper.js":
/*!**************************************!*\
  !*** ../shared/client/src/helper.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Helper\n{\n    constructor()\n    {\n        this._simpleIdCounter = 0;\n    }\n\n    uuid()\n    {\n        let d = new Date().getTime();\n        return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) =>\n        {\n            const r = (d + Math.random() * 16) % 16 | 0;\n            d = Math.floor(d / 16);\n            return (c === \"x\" ? r : (r & 0x3) | 0x8).toString(16);\n        });\n    }\n\n    isNumeric(n)\n    {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    /**\n     * generate a simple ID\n     * @function simpleId\n     * @memberof Utils\n     * @return {Number} new id\n     * @static\n     */\n    simpleId()\n    {\n        this._simpleIdCounter++;\n        return this._simpleIdCounter;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Helper());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2hhcmVkL2NsaWVudC9zcmMvaGVscGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQ0FCTEVTLy4uL3NoYXJlZC9jbGllbnQvc3JjL2hlbHBlci5qcz8xZGIzIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEhlbHBlclxue1xuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3NpbXBsZUlkQ291bnRlciA9IDA7XG4gICAgfVxuXG4gICAgdXVpZCgpXG4gICAge1xuICAgICAgICBsZXQgZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICByZXR1cm4gXCJ4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHhcIi5yZXBsYWNlKC9beHldL2csIChjKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByID0gKGQgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xuICAgICAgICAgICAgZCA9IE1hdGguZmxvb3IoZCAvIDE2KTtcbiAgICAgICAgICAgIHJldHVybiAoYyA9PT0gXCJ4XCIgPyByIDogKHIgJiAweDMpIHwgMHg4KS50b1N0cmluZygxNik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlzTnVtZXJpYyhuKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSBhIHNpbXBsZSBJRFxuICAgICAqIEBmdW5jdGlvbiBzaW1wbGVJZFxuICAgICAqIEBtZW1iZXJvZiBVdGlsc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gbmV3IGlkXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHNpbXBsZUlkKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3NpbXBsZUlkQ291bnRlcisrO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlSWRDb3VudGVyO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IG5ldyBIZWxwZXIoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../shared/client/src/helper.js\n");

/***/ }),

/***/ "../shared/client/src/logger.js":
/*!**************************************!*\
  !*** ../shared/client/src/logger.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Logger)\n/* harmony export */ });\n/* eslint-disable no-console */\n\nclass Logger\n{\n    constructor(initiator)\n    {\n        this._logs = [];\n        this.initiator = initiator;\n    }\n\n    stack(t)\n    {\n        console.info(\"[\" + this.initiator + \"] \", t);\n        console.log((new Error()).stack);\n    }\n\n    groupCollapsed(t)\n    {\n        console.groupCollapsed(\"[\" + this.initiator + \"] \" + t);\n    }\n\n    table(t)\n    {\n        console.table(t);\n    }\n\n    groupEnd()\n    {\n        console.groupEnd();\n    }\n\n    error(args)\n    {\n        console.error(\"[\" + this.initiator + \"]\", ...arguments);\n        if (window.gui) window.gui.emitEvent(\"coreLogEvent\", this.initiator, \"error\", arguments);\n    }\n\n    info(args)\n    {\n        console.error(\"[\" + this.initiator + \"]\", ...arguments);\n        if (window.gui) window.gui.emitEvent(\"coreLogEvent\", this.initiator, \"info\", arguments);\n    }\n\n    warn(args)\n    {\n        console.warn(\"[\" + this.initiator + \"]\", ...arguments);\n        // console.log((new Error()).stack);\n        if (window.gui) window.gui.emitEvent(\"coreLogEvent\", this.initiator, \"warn\", arguments);\n    }\n\n    verbose()\n    {\n        if ((CABLES.UI && CABLES.UI.logFilter.shouldPrint(this.initiator, ...arguments)) || !CABLES.logSilent)\n            console.log(\"[\" + this.initiator + \"]\", ...arguments);\n        if (window.gui) window.gui.emitEvent(\"coreLogEvent\", this.initiator, \"verbose\", arguments);\n    }\n\n    log(args)\n    {\n        if ((CABLES.UI && CABLES.UI.logFilter.shouldPrint(this.initiator, ...arguments)) || !CABLES.logSilent)\n            console.log(\"[\" + this.initiator + \"]\", ...arguments);\n        if (window.gui) window.gui.emitEvent(\"coreLogEvent\", this.initiator, \"log\", arguments);\n    }\n\n    userInteraction(text)\n    {\n        // this.log({ \"initiator\": \"userinteraction\", \"text\": text });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2hhcmVkL2NsaWVudC9zcmMvbG9nZ2VyLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0NBQkxFUy8uLi9zaGFyZWQvY2xpZW50L3NyYy9sb2dnZXIuanM/NjYyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvZ2dlclxue1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYXRvcilcbiAgICB7XG4gICAgICAgIHRoaXMuX2xvZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5pbml0aWF0b3IgPSBpbml0aWF0b3I7XG4gICAgfVxuXG4gICAgc3RhY2sodClcbiAgICB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIltcIiArIHRoaXMuaW5pdGlhdG9yICsgXCJdIFwiLCB0KTtcbiAgICAgICAgY29uc29sZS5sb2coKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgfVxuXG4gICAgZ3JvdXBDb2xsYXBzZWQodClcbiAgICB7XG4gICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCJbXCIgKyB0aGlzLmluaXRpYXRvciArIFwiXSBcIiArIHQpO1xuICAgIH1cblxuICAgIHRhYmxlKHQpXG4gICAge1xuICAgICAgICBjb25zb2xlLnRhYmxlKHQpO1xuICAgIH1cblxuICAgIGdyb3VwRW5kKClcbiAgICB7XG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9XG5cbiAgICBlcnJvcihhcmdzKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIltcIiArIHRoaXMuaW5pdGlhdG9yICsgXCJdXCIsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh3aW5kb3cuZ3VpKSB3aW5kb3cuZ3VpLmVtaXRFdmVudChcImNvcmVMb2dFdmVudFwiLCB0aGlzLmluaXRpYXRvciwgXCJlcnJvclwiLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGluZm8oYXJncylcbiAgICB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbXCIgKyB0aGlzLmluaXRpYXRvciArIFwiXVwiLCAuLi5hcmd1bWVudHMpO1xuICAgICAgICBpZiAod2luZG93Lmd1aSkgd2luZG93Lmd1aS5lbWl0RXZlbnQoXCJjb3JlTG9nRXZlbnRcIiwgdGhpcy5pbml0aWF0b3IsIFwiaW5mb1wiLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHdhcm4oYXJncylcbiAgICB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltcIiArIHRoaXMuaW5pdGlhdG9yICsgXCJdXCIsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICBpZiAod2luZG93Lmd1aSkgd2luZG93Lmd1aS5lbWl0RXZlbnQoXCJjb3JlTG9nRXZlbnRcIiwgdGhpcy5pbml0aWF0b3IsIFwid2FyblwiLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHZlcmJvc2UoKVxuICAgIHtcbiAgICAgICAgaWYgKChDQUJMRVMuVUkgJiYgQ0FCTEVTLlVJLmxvZ0ZpbHRlci5zaG91bGRQcmludCh0aGlzLmluaXRpYXRvciwgLi4uYXJndW1lbnRzKSkgfHwgIUNBQkxFUy5sb2dTaWxlbnQpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltcIiArIHRoaXMuaW5pdGlhdG9yICsgXCJdXCIsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh3aW5kb3cuZ3VpKSB3aW5kb3cuZ3VpLmVtaXRFdmVudChcImNvcmVMb2dFdmVudFwiLCB0aGlzLmluaXRpYXRvciwgXCJ2ZXJib3NlXCIsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgbG9nKGFyZ3MpXG4gICAge1xuICAgICAgICBpZiAoKENBQkxFUy5VSSAmJiBDQUJMRVMuVUkubG9nRmlsdGVyLnNob3VsZFByaW50KHRoaXMuaW5pdGlhdG9yLCAuLi5hcmd1bWVudHMpKSB8fCAhQ0FCTEVTLmxvZ1NpbGVudClcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1wiICsgdGhpcy5pbml0aWF0b3IgKyBcIl1cIiwgLi4uYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHdpbmRvdy5ndWkpIHdpbmRvdy5ndWkuZW1pdEV2ZW50KFwiY29yZUxvZ0V2ZW50XCIsIHRoaXMuaW5pdGlhdG9yLCBcImxvZ1wiLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHVzZXJJbnRlcmFjdGlvbih0ZXh0KVxuICAgIHtcbiAgICAgICAgLy8gdGhpcy5sb2coeyBcImluaXRpYXRvclwiOiBcInVzZXJpbnRlcmFjdGlvblwiLCBcInRleHRcIjogdGV4dCB9KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../shared/client/src/logger.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/core/index.js");
/******/ 	CABLES = __webpack_exports__["default"];
/******/ 	
/******/ })()
;

var CABLES = CABLES || {}; CABLES.build = {"timestamp":1714998332421,"created":"2024-05-06T12:25:32.421Z","git":{"branch":"master","commit":"818c25616aa874f43ba75866145ad0813fc50425","date":null,"message":null}};
/*!
@fileoverview gl-matrix - High performance matrix and vector operations
@author Brandon Jones
@author Colin MacKenzie IV
@version 3.1.0

Copyright (c) 2015-2019, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((t=t||self).glMatrix={})}(this,function(t){"use strict";var n=1e-6,a="undefined"!=typeof Float32Array?Float32Array:Array,r=Math.random;var u=Math.PI/180;Math.hypot||(Math.hypot=function(){for(var t=0,n=arguments.length;n--;)t+=arguments[n]*arguments[n];return Math.sqrt(t)});var e=Object.freeze({EPSILON:n,get ARRAY_TYPE(){return a},RANDOM:r,setMatrixArrayType:function(t){a=t},toRadian:function(t){return t*u},equals:function(t,a){return Math.abs(t-a)<=n*Math.max(1,Math.abs(t),Math.abs(a))}});function o(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=a[0],c=a[1],h=a[2],s=a[3];return t[0]=r*i+e*c,t[1]=u*i+o*c,t[2]=r*h+e*s,t[3]=u*h+o*s,t}function i(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t[3]=n[3]-a[3],t}var c=o,h=i,s=Object.freeze({create:function(){var t=new a(4);return a!=Float32Array&&(t[1]=0,t[2]=0),t[0]=1,t[3]=1,t},clone:function(t){var n=new a(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n},copy:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t},identity:function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t},fromValues:function(t,n,r,u){var e=new a(4);return e[0]=t,e[1]=n,e[2]=r,e[3]=u,e},set:function(t,n,a,r,u){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t},transpose:function(t,n){if(t===n){var a=n[1];t[1]=n[2],t[2]=a}else t[0]=n[0],t[1]=n[2],t[2]=n[1],t[3]=n[3];return t},invert:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=a*e-u*r;return o?(o=1/o,t[0]=e*o,t[1]=-r*o,t[2]=-u*o,t[3]=a*o,t):null},adjoint:function(t,n){var a=n[0];return t[0]=n[3],t[1]=-n[1],t[2]=-n[2],t[3]=a,t},determinant:function(t){return t[0]*t[3]-t[2]*t[1]},multiply:o,rotate:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=Math.sin(a),c=Math.cos(a);return t[0]=r*c+e*i,t[1]=u*c+o*i,t[2]=r*-i+e*c,t[3]=u*-i+o*c,t},scale:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=a[0],c=a[1];return t[0]=r*i,t[1]=u*i,t[2]=e*c,t[3]=o*c,t},fromRotation:function(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=a,t[2]=-a,t[3]=r,t},fromScaling:function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t},str:function(t){return"mat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},frob:function(t){return Math.hypot(t[0],t[1],t[2],t[3])},LDU:function(t,n,a,r){return t[2]=r[2]/r[0],a[0]=r[0],a[1]=r[1],a[3]=r[3]-t[2]*a[1],[t,n,a]},add:function(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t},subtract:i,exactEquals:function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]},equals:function(t,a){var r=t[0],u=t[1],e=t[2],o=t[3],i=a[0],c=a[1],h=a[2],s=a[3];return Math.abs(r-i)<=n*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(u-c)<=n*Math.max(1,Math.abs(u),Math.abs(c))&&Math.abs(e-h)<=n*Math.max(1,Math.abs(e),Math.abs(h))&&Math.abs(o-s)<=n*Math.max(1,Math.abs(o),Math.abs(s))},multiplyScalar:function(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t},multiplyScalarAndAdd:function(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t[3]=n[3]+a[3]*r,t},mul:c,sub:h});function M(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=a[0],s=a[1],M=a[2],f=a[3],l=a[4],v=a[5];return t[0]=r*h+e*s,t[1]=u*h+o*s,t[2]=r*M+e*f,t[3]=u*M+o*f,t[4]=r*l+e*v+i,t[5]=u*l+o*v+c,t}function f(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t[3]=n[3]-a[3],t[4]=n[4]-a[4],t[5]=n[5]-a[5],t}var l=M,v=f,b=Object.freeze({create:function(){var t=new a(6);return a!=Float32Array&&(t[1]=0,t[2]=0,t[4]=0,t[5]=0),t[0]=1,t[3]=1,t},clone:function(t){var n=new a(6);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n},copy:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t},identity:function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t},fromValues:function(t,n,r,u,e,o){var i=new a(6);return i[0]=t,i[1]=n,i[2]=r,i[3]=u,i[4]=e,i[5]=o,i},set:function(t,n,a,r,u,e,o){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t[4]=e,t[5]=o,t},invert:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],c=a*e-r*u;return c?(c=1/c,t[0]=e*c,t[1]=-r*c,t[2]=-u*c,t[3]=a*c,t[4]=(u*i-e*o)*c,t[5]=(r*o-a*i)*c,t):null},determinant:function(t){return t[0]*t[3]-t[1]*t[2]},multiply:M,rotate:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=Math.sin(a),s=Math.cos(a);return t[0]=r*s+e*h,t[1]=u*s+o*h,t[2]=r*-h+e*s,t[3]=u*-h+o*s,t[4]=i,t[5]=c,t},scale:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=a[0],s=a[1];return t[0]=r*h,t[1]=u*h,t[2]=e*s,t[3]=o*s,t[4]=i,t[5]=c,t},translate:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=a[0],s=a[1];return t[0]=r,t[1]=u,t[2]=e,t[3]=o,t[4]=r*h+e*s+i,t[5]=u*h+o*s+c,t},fromRotation:function(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=a,t[2]=-a,t[3]=r,t[4]=0,t[5]=0,t},fromScaling:function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t[4]=0,t[5]=0,t},fromTranslation:function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=n[0],t[5]=n[1],t},str:function(t){return"mat2d("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+")"},frob:function(t){return Math.hypot(t[0],t[1],t[2],t[3],t[4],t[5],1)},add:function(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t[4]=n[4]+a[4],t[5]=n[5]+a[5],t},subtract:f,multiplyScalar:function(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*a,t[5]=n[5]*a,t},multiplyScalarAndAdd:function(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t[3]=n[3]+a[3]*r,t[4]=n[4]+a[4]*r,t[5]=n[5]+a[5]*r,t},exactEquals:function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]},equals:function(t,a){var r=t[0],u=t[1],e=t[2],o=t[3],i=t[4],c=t[5],h=a[0],s=a[1],M=a[2],f=a[3],l=a[4],v=a[5];return Math.abs(r-h)<=n*Math.max(1,Math.abs(r),Math.abs(h))&&Math.abs(u-s)<=n*Math.max(1,Math.abs(u),Math.abs(s))&&Math.abs(e-M)<=n*Math.max(1,Math.abs(e),Math.abs(M))&&Math.abs(o-f)<=n*Math.max(1,Math.abs(o),Math.abs(f))&&Math.abs(i-l)<=n*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(c-v)<=n*Math.max(1,Math.abs(c),Math.abs(v))},mul:l,sub:v});function m(){var t=new a(9);return a!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t}function d(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=n[6],s=n[7],M=n[8],f=a[0],l=a[1],v=a[2],b=a[3],m=a[4],d=a[5],x=a[6],p=a[7],y=a[8];return t[0]=f*r+l*o+v*h,t[1]=f*u+l*i+v*s,t[2]=f*e+l*c+v*M,t[3]=b*r+m*o+d*h,t[4]=b*u+m*i+d*s,t[5]=b*e+m*c+d*M,t[6]=x*r+p*o+y*h,t[7]=x*u+p*i+y*s,t[8]=x*e+p*c+y*M,t}function x(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t[3]=n[3]-a[3],t[4]=n[4]-a[4],t[5]=n[5]-a[5],t[6]=n[6]-a[6],t[7]=n[7]-a[7],t[8]=n[8]-a[8],t}var p=d,y=x,q=Object.freeze({create:m,fromMat4:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[4],t[4]=n[5],t[5]=n[6],t[6]=n[8],t[7]=n[9],t[8]=n[10],t},clone:function(t){var n=new a(9);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n},copy:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t},fromValues:function(t,n,r,u,e,o,i,c,h){var s=new a(9);return s[0]=t,s[1]=n,s[2]=r,s[3]=u,s[4]=e,s[5]=o,s[6]=i,s[7]=c,s[8]=h,s},set:function(t,n,a,r,u,e,o,i,c,h){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t[4]=e,t[5]=o,t[6]=i,t[7]=c,t[8]=h,t},identity:function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},transpose:function(t,n){if(t===n){var a=n[1],r=n[2],u=n[5];t[1]=n[3],t[2]=n[6],t[3]=a,t[5]=n[7],t[6]=r,t[7]=u}else t[0]=n[0],t[1]=n[3],t[2]=n[6],t[3]=n[1],t[4]=n[4],t[5]=n[7],t[6]=n[2],t[7]=n[5],t[8]=n[8];return t},invert:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],c=n[6],h=n[7],s=n[8],M=s*o-i*h,f=-s*e+i*c,l=h*e-o*c,v=a*M+r*f+u*l;return v?(v=1/v,t[0]=M*v,t[1]=(-s*r+u*h)*v,t[2]=(i*r-u*o)*v,t[3]=f*v,t[4]=(s*a-u*c)*v,t[5]=(-i*a+u*e)*v,t[6]=l*v,t[7]=(-h*a+r*c)*v,t[8]=(o*a-r*e)*v,t):null},adjoint:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],c=n[6],h=n[7],s=n[8];return t[0]=o*s-i*h,t[1]=u*h-r*s,t[2]=r*i-u*o,t[3]=i*c-e*s,t[4]=a*s-u*c,t[5]=u*e-a*i,t[6]=e*h-o*c,t[7]=r*c-a*h,t[8]=a*o-r*e,t},determinant:function(t){var n=t[0],a=t[1],r=t[2],u=t[3],e=t[4],o=t[5],i=t[6],c=t[7],h=t[8];return n*(h*e-o*c)+a*(-h*u+o*i)+r*(c*u-e*i)},multiply:d,translate:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=n[6],s=n[7],M=n[8],f=a[0],l=a[1];return t[0]=r,t[1]=u,t[2]=e,t[3]=o,t[4]=i,t[5]=c,t[6]=f*r+l*o+h,t[7]=f*u+l*i+s,t[8]=f*e+l*c+M,t},rotate:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=n[6],s=n[7],M=n[8],f=Math.sin(a),l=Math.cos(a);return t[0]=l*r+f*o,t[1]=l*u+f*i,t[2]=l*e+f*c,t[3]=l*o-f*r,t[4]=l*i-f*u,t[5]=l*c-f*e,t[6]=h,t[7]=s,t[8]=M,t},scale:function(t,n,a){var r=a[0],u=a[1];return t[0]=r*n[0],t[1]=r*n[1],t[2]=r*n[2],t[3]=u*n[3],t[4]=u*n[4],t[5]=u*n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t},fromTranslation:function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=n[0],t[7]=n[1],t[8]=1,t},fromRotation:function(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=a,t[2]=0,t[3]=-a,t[4]=r,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},fromScaling:function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=n[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},fromMat2d:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=0,t[3]=n[2],t[4]=n[3],t[5]=0,t[6]=n[4],t[7]=n[5],t[8]=1,t},fromQuat:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=a+a,i=r+r,c=u+u,h=a*o,s=r*o,M=r*i,f=u*o,l=u*i,v=u*c,b=e*o,m=e*i,d=e*c;return t[0]=1-M-v,t[3]=s-d,t[6]=f+m,t[1]=s+d,t[4]=1-h-v,t[7]=l-b,t[2]=f-m,t[5]=l+b,t[8]=1-h-M,t},normalFromMat4:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],c=n[6],h=n[7],s=n[8],M=n[9],f=n[10],l=n[11],v=n[12],b=n[13],m=n[14],d=n[15],x=a*i-r*o,p=a*c-u*o,y=a*h-e*o,q=r*c-u*i,g=r*h-e*i,A=u*h-e*c,w=s*b-M*v,R=s*m-f*v,z=s*d-l*v,P=M*m-f*b,j=M*d-l*b,I=f*d-l*m,S=x*I-p*j+y*P+q*z-g*R+A*w;return S?(S=1/S,t[0]=(i*I-c*j+h*P)*S,t[1]=(c*z-o*I-h*R)*S,t[2]=(o*j-i*z+h*w)*S,t[3]=(u*j-r*I-e*P)*S,t[4]=(a*I-u*z+e*R)*S,t[5]=(r*z-a*j-e*w)*S,t[6]=(b*A-m*g+d*q)*S,t[7]=(m*y-v*A-d*p)*S,t[8]=(v*g-b*y+d*x)*S,t):null},projection:function(t,n,a){return t[0]=2/n,t[1]=0,t[2]=0,t[3]=0,t[4]=-2/a,t[5]=0,t[6]=-1,t[7]=1,t[8]=1,t},str:function(t){return"mat3("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+")"},frob:function(t){return Math.hypot(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])},add:function(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t[4]=n[4]+a[4],t[5]=n[5]+a[5],t[6]=n[6]+a[6],t[7]=n[7]+a[7],t[8]=n[8]+a[8],t},subtract:x,multiplyScalar:function(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*a,t[5]=n[5]*a,t[6]=n[6]*a,t[7]=n[7]*a,t[8]=n[8]*a,t},multiplyScalarAndAdd:function(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t[3]=n[3]+a[3]*r,t[4]=n[4]+a[4]*r,t[5]=n[5]+a[5]*r,t[6]=n[6]+a[6]*r,t[7]=n[7]+a[7]*r,t[8]=n[8]+a[8]*r,t},exactEquals:function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]},equals:function(t,a){var r=t[0],u=t[1],e=t[2],o=t[3],i=t[4],c=t[5],h=t[6],s=t[7],M=t[8],f=a[0],l=a[1],v=a[2],b=a[3],m=a[4],d=a[5],x=a[6],p=a[7],y=a[8];return Math.abs(r-f)<=n*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(u-l)<=n*Math.max(1,Math.abs(u),Math.abs(l))&&Math.abs(e-v)<=n*Math.max(1,Math.abs(e),Math.abs(v))&&Math.abs(o-b)<=n*Math.max(1,Math.abs(o),Math.abs(b))&&Math.abs(i-m)<=n*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(c-d)<=n*Math.max(1,Math.abs(c),Math.abs(d))&&Math.abs(h-x)<=n*Math.max(1,Math.abs(h),Math.abs(x))&&Math.abs(s-p)<=n*Math.max(1,Math.abs(s),Math.abs(p))&&Math.abs(M-y)<=n*Math.max(1,Math.abs(M),Math.abs(y))},mul:p,sub:y});function g(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function A(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=n[6],s=n[7],M=n[8],f=n[9],l=n[10],v=n[11],b=n[12],m=n[13],d=n[14],x=n[15],p=a[0],y=a[1],q=a[2],g=a[3];return t[0]=p*r+y*i+q*M+g*b,t[1]=p*u+y*c+q*f+g*m,t[2]=p*e+y*h+q*l+g*d,t[3]=p*o+y*s+q*v+g*x,p=a[4],y=a[5],q=a[6],g=a[7],t[4]=p*r+y*i+q*M+g*b,t[5]=p*u+y*c+q*f+g*m,t[6]=p*e+y*h+q*l+g*d,t[7]=p*o+y*s+q*v+g*x,p=a[8],y=a[9],q=a[10],g=a[11],t[8]=p*r+y*i+q*M+g*b,t[9]=p*u+y*c+q*f+g*m,t[10]=p*e+y*h+q*l+g*d,t[11]=p*o+y*s+q*v+g*x,p=a[12],y=a[13],q=a[14],g=a[15],t[12]=p*r+y*i+q*M+g*b,t[13]=p*u+y*c+q*f+g*m,t[14]=p*e+y*h+q*l+g*d,t[15]=p*o+y*s+q*v+g*x,t}function w(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=r+r,c=u+u,h=e+e,s=r*i,M=r*c,f=r*h,l=u*c,v=u*h,b=e*h,m=o*i,d=o*c,x=o*h;return t[0]=1-(l+b),t[1]=M+x,t[2]=f-d,t[3]=0,t[4]=M-x,t[5]=1-(s+b),t[6]=v+m,t[7]=0,t[8]=f+d,t[9]=v-m,t[10]=1-(s+l),t[11]=0,t[12]=a[0],t[13]=a[1],t[14]=a[2],t[15]=1,t}function R(t,n){return t[0]=n[12],t[1]=n[13],t[2]=n[14],t}function z(t,n){var a=n[0],r=n[1],u=n[2],e=n[4],o=n[5],i=n[6],c=n[8],h=n[9],s=n[10];return t[0]=Math.hypot(a,r,u),t[1]=Math.hypot(e,o,i),t[2]=Math.hypot(c,h,s),t}function P(t,n){var r=new a(3);z(r,n);var u=1/r[0],e=1/r[1],o=1/r[2],i=n[0]*u,c=n[1]*e,h=n[2]*o,s=n[4]*u,M=n[5]*e,f=n[6]*o,l=n[8]*u,v=n[9]*e,b=n[10]*o,m=i+M+b,d=0;return m>0?(d=2*Math.sqrt(m+1),t[3]=.25*d,t[0]=(f-v)/d,t[1]=(l-h)/d,t[2]=(c-s)/d):i>M&&i>b?(d=2*Math.sqrt(1+i-M-b),t[3]=(f-v)/d,t[0]=.25*d,t[1]=(c+s)/d,t[2]=(l+h)/d):M>b?(d=2*Math.sqrt(1+M-i-b),t[3]=(l-h)/d,t[0]=(c+s)/d,t[1]=.25*d,t[2]=(f+v)/d):(d=2*Math.sqrt(1+b-i-M),t[3]=(c-s)/d,t[0]=(l+h)/d,t[1]=(f+v)/d,t[2]=.25*d),t}function j(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t[3]=n[3]-a[3],t[4]=n[4]-a[4],t[5]=n[5]-a[5],t[6]=n[6]-a[6],t[7]=n[7]-a[7],t[8]=n[8]-a[8],t[9]=n[9]-a[9],t[10]=n[10]-a[10],t[11]=n[11]-a[11],t[12]=n[12]-a[12],t[13]=n[13]-a[13],t[14]=n[14]-a[14],t[15]=n[15]-a[15],t}var I=A,S=j,E=Object.freeze({create:function(){var t=new a(16);return a!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t},clone:function(t){var n=new a(16);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],n},copy:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t},fromValues:function(t,n,r,u,e,o,i,c,h,s,M,f,l,v,b,m){var d=new a(16);return d[0]=t,d[1]=n,d[2]=r,d[3]=u,d[4]=e,d[5]=o,d[6]=i,d[7]=c,d[8]=h,d[9]=s,d[10]=M,d[11]=f,d[12]=l,d[13]=v,d[14]=b,d[15]=m,d},set:function(t,n,a,r,u,e,o,i,c,h,s,M,f,l,v,b,m){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t[4]=e,t[5]=o,t[6]=i,t[7]=c,t[8]=h,t[9]=s,t[10]=M,t[11]=f,t[12]=l,t[13]=v,t[14]=b,t[15]=m,t},identity:g,transpose:function(t,n){if(t===n){var a=n[1],r=n[2],u=n[3],e=n[6],o=n[7],i=n[11];t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=a,t[6]=n[9],t[7]=n[13],t[8]=r,t[9]=e,t[11]=n[14],t[12]=u,t[13]=o,t[14]=i}else t[0]=n[0],t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=n[1],t[5]=n[5],t[6]=n[9],t[7]=n[13],t[8]=n[2],t[9]=n[6],t[10]=n[10],t[11]=n[14],t[12]=n[3],t[13]=n[7],t[14]=n[11],t[15]=n[15];return t},invert:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],c=n[6],h=n[7],s=n[8],M=n[9],f=n[10],l=n[11],v=n[12],b=n[13],m=n[14],d=n[15],x=a*i-r*o,p=a*c-u*o,y=a*h-e*o,q=r*c-u*i,g=r*h-e*i,A=u*h-e*c,w=s*b-M*v,R=s*m-f*v,z=s*d-l*v,P=M*m-f*b,j=M*d-l*b,I=f*d-l*m,S=x*I-p*j+y*P+q*z-g*R+A*w;return S?(S=1/S,t[0]=(i*I-c*j+h*P)*S,t[1]=(u*j-r*I-e*P)*S,t[2]=(b*A-m*g+d*q)*S,t[3]=(f*g-M*A-l*q)*S,t[4]=(c*z-o*I-h*R)*S,t[5]=(a*I-u*z+e*R)*S,t[6]=(m*y-v*A-d*p)*S,t[7]=(s*A-f*y+l*p)*S,t[8]=(o*j-i*z+h*w)*S,t[9]=(r*z-a*j-e*w)*S,t[10]=(v*g-b*y+d*x)*S,t[11]=(M*y-s*g-l*x)*S,t[12]=(i*R-o*P-c*w)*S,t[13]=(a*P-r*R+u*w)*S,t[14]=(b*p-v*q-m*x)*S,t[15]=(s*q-M*p+f*x)*S,t):null},adjoint:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=n[4],i=n[5],c=n[6],h=n[7],s=n[8],M=n[9],f=n[10],l=n[11],v=n[12],b=n[13],m=n[14],d=n[15];return t[0]=i*(f*d-l*m)-M*(c*d-h*m)+b*(c*l-h*f),t[1]=-(r*(f*d-l*m)-M*(u*d-e*m)+b*(u*l-e*f)),t[2]=r*(c*d-h*m)-i*(u*d-e*m)+b*(u*h-e*c),t[3]=-(r*(c*l-h*f)-i*(u*l-e*f)+M*(u*h-e*c)),t[4]=-(o*(f*d-l*m)-s*(c*d-h*m)+v*(c*l-h*f)),t[5]=a*(f*d-l*m)-s*(u*d-e*m)+v*(u*l-e*f),t[6]=-(a*(c*d-h*m)-o*(u*d-e*m)+v*(u*h-e*c)),t[7]=a*(c*l-h*f)-o*(u*l-e*f)+s*(u*h-e*c),t[8]=o*(M*d-l*b)-s*(i*d-h*b)+v*(i*l-h*M),t[9]=-(a*(M*d-l*b)-s*(r*d-e*b)+v*(r*l-e*M)),t[10]=a*(i*d-h*b)-o*(r*d-e*b)+v*(r*h-e*i),t[11]=-(a*(i*l-h*M)-o*(r*l-e*M)+s*(r*h-e*i)),t[12]=-(o*(M*m-f*b)-s*(i*m-c*b)+v*(i*f-c*M)),t[13]=a*(M*m-f*b)-s*(r*m-u*b)+v*(r*f-u*M),t[14]=-(a*(i*m-c*b)-o*(r*m-u*b)+v*(r*c-u*i)),t[15]=a*(i*f-c*M)-o*(r*f-u*M)+s*(r*c-u*i),t},determinant:function(t){var n=t[0],a=t[1],r=t[2],u=t[3],e=t[4],o=t[5],i=t[6],c=t[7],h=t[8],s=t[9],M=t[10],f=t[11],l=t[12],v=t[13],b=t[14],m=t[15];return(n*o-a*e)*(M*m-f*b)-(n*i-r*e)*(s*m-f*v)+(n*c-u*e)*(s*b-M*v)+(a*i-r*o)*(h*m-f*l)-(a*c-u*o)*(h*b-M*l)+(r*c-u*i)*(h*v-s*l)},multiply:A,translate:function(t,n,a){var r,u,e,o,i,c,h,s,M,f,l,v,b=a[0],m=a[1],d=a[2];return n===t?(t[12]=n[0]*b+n[4]*m+n[8]*d+n[12],t[13]=n[1]*b+n[5]*m+n[9]*d+n[13],t[14]=n[2]*b+n[6]*m+n[10]*d+n[14],t[15]=n[3]*b+n[7]*m+n[11]*d+n[15]):(r=n[0],u=n[1],e=n[2],o=n[3],i=n[4],c=n[5],h=n[6],s=n[7],M=n[8],f=n[9],l=n[10],v=n[11],t[0]=r,t[1]=u,t[2]=e,t[3]=o,t[4]=i,t[5]=c,t[6]=h,t[7]=s,t[8]=M,t[9]=f,t[10]=l,t[11]=v,t[12]=r*b+i*m+M*d+n[12],t[13]=u*b+c*m+f*d+n[13],t[14]=e*b+h*m+l*d+n[14],t[15]=o*b+s*m+v*d+n[15]),t},scale:function(t,n,a){var r=a[0],u=a[1],e=a[2];return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*u,t[5]=n[5]*u,t[6]=n[6]*u,t[7]=n[7]*u,t[8]=n[8]*e,t[9]=n[9]*e,t[10]=n[10]*e,t[11]=n[11]*e,t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t},rotate:function(t,a,r,u){var e,o,i,c,h,s,M,f,l,v,b,m,d,x,p,y,q,g,A,w,R,z,P,j,I=u[0],S=u[1],E=u[2],O=Math.hypot(I,S,E);return O<n?null:(I*=O=1/O,S*=O,E*=O,e=Math.sin(r),i=1-(o=Math.cos(r)),c=a[0],h=a[1],s=a[2],M=a[3],f=a[4],l=a[5],v=a[6],b=a[7],m=a[8],d=a[9],x=a[10],p=a[11],y=I*I*i+o,q=S*I*i+E*e,g=E*I*i-S*e,A=I*S*i-E*e,w=S*S*i+o,R=E*S*i+I*e,z=I*E*i+S*e,P=S*E*i-I*e,j=E*E*i+o,t[0]=c*y+f*q+m*g,t[1]=h*y+l*q+d*g,t[2]=s*y+v*q+x*g,t[3]=M*y+b*q+p*g,t[4]=c*A+f*w+m*R,t[5]=h*A+l*w+d*R,t[6]=s*A+v*w+x*R,t[7]=M*A+b*w+p*R,t[8]=c*z+f*P+m*j,t[9]=h*z+l*P+d*j,t[10]=s*z+v*P+x*j,t[11]=M*z+b*P+p*j,a!==t&&(t[12]=a[12],t[13]=a[13],t[14]=a[14],t[15]=a[15]),t)},rotateX:function(t,n,a){var r=Math.sin(a),u=Math.cos(a),e=n[4],o=n[5],i=n[6],c=n[7],h=n[8],s=n[9],M=n[10],f=n[11];return n!==t&&(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[4]=e*u+h*r,t[5]=o*u+s*r,t[6]=i*u+M*r,t[7]=c*u+f*r,t[8]=h*u-e*r,t[9]=s*u-o*r,t[10]=M*u-i*r,t[11]=f*u-c*r,t},rotateY:function(t,n,a){var r=Math.sin(a),u=Math.cos(a),e=n[0],o=n[1],i=n[2],c=n[3],h=n[8],s=n[9],M=n[10],f=n[11];return n!==t&&(t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=e*u-h*r,t[1]=o*u-s*r,t[2]=i*u-M*r,t[3]=c*u-f*r,t[8]=e*r+h*u,t[9]=o*r+s*u,t[10]=i*r+M*u,t[11]=c*r+f*u,t},rotateZ:function(t,n,a){var r=Math.sin(a),u=Math.cos(a),e=n[0],o=n[1],i=n[2],c=n[3],h=n[4],s=n[5],M=n[6],f=n[7];return n!==t&&(t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=e*u+h*r,t[1]=o*u+s*r,t[2]=i*u+M*r,t[3]=c*u+f*r,t[4]=h*u-e*r,t[5]=s*u-o*r,t[6]=M*u-i*r,t[7]=f*u-c*r,t},fromTranslation:function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t},fromScaling:function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=n[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},fromRotation:function(t,a,r){var u,e,o,i=r[0],c=r[1],h=r[2],s=Math.hypot(i,c,h);return s<n?null:(i*=s=1/s,c*=s,h*=s,u=Math.sin(a),o=1-(e=Math.cos(a)),t[0]=i*i*o+e,t[1]=c*i*o+h*u,t[2]=h*i*o-c*u,t[3]=0,t[4]=i*c*o-h*u,t[5]=c*c*o+e,t[6]=h*c*o+i*u,t[7]=0,t[8]=i*h*o+c*u,t[9]=c*h*o-i*u,t[10]=h*h*o+e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t)},fromXRotation:function(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=r,t[6]=a,t[7]=0,t[8]=0,t[9]=-a,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},fromYRotation:function(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=0,t[2]=-a,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=a,t[9]=0,t[10]=r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},fromZRotation:function(t,n){var a=Math.sin(n),r=Math.cos(n);return t[0]=r,t[1]=a,t[2]=0,t[3]=0,t[4]=-a,t[5]=r,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},fromRotationTranslation:w,fromQuat2:function(t,n){var r=new a(3),u=-n[0],e=-n[1],o=-n[2],i=n[3],c=n[4],h=n[5],s=n[6],M=n[7],f=u*u+e*e+o*o+i*i;return f>0?(r[0]=2*(c*i+M*u+h*o-s*e)/f,r[1]=2*(h*i+M*e+s*u-c*o)/f,r[2]=2*(s*i+M*o+c*e-h*u)/f):(r[0]=2*(c*i+M*u+h*o-s*e),r[1]=2*(h*i+M*e+s*u-c*o),r[2]=2*(s*i+M*o+c*e-h*u)),w(t,n,r),t},getTranslation:R,getScaling:z,getRotation:P,fromRotationTranslationScale:function(t,n,a,r){var u=n[0],e=n[1],o=n[2],i=n[3],c=u+u,h=e+e,s=o+o,M=u*c,f=u*h,l=u*s,v=e*h,b=e*s,m=o*s,d=i*c,x=i*h,p=i*s,y=r[0],q=r[1],g=r[2];return t[0]=(1-(v+m))*y,t[1]=(f+p)*y,t[2]=(l-x)*y,t[3]=0,t[4]=(f-p)*q,t[5]=(1-(M+m))*q,t[6]=(b+d)*q,t[7]=0,t[8]=(l+x)*g,t[9]=(b-d)*g,t[10]=(1-(M+v))*g,t[11]=0,t[12]=a[0],t[13]=a[1],t[14]=a[2],t[15]=1,t},fromRotationTranslationScaleOrigin:function(t,n,a,r,u){var e=n[0],o=n[1],i=n[2],c=n[3],h=e+e,s=o+o,M=i+i,f=e*h,l=e*s,v=e*M,b=o*s,m=o*M,d=i*M,x=c*h,p=c*s,y=c*M,q=r[0],g=r[1],A=r[2],w=u[0],R=u[1],z=u[2],P=(1-(b+d))*q,j=(l+y)*q,I=(v-p)*q,S=(l-y)*g,E=(1-(f+d))*g,O=(m+x)*g,T=(v+p)*A,D=(m-x)*A,F=(1-(f+b))*A;return t[0]=P,t[1]=j,t[2]=I,t[3]=0,t[4]=S,t[5]=E,t[6]=O,t[7]=0,t[8]=T,t[9]=D,t[10]=F,t[11]=0,t[12]=a[0]+w-(P*w+S*R+T*z),t[13]=a[1]+R-(j*w+E*R+D*z),t[14]=a[2]+z-(I*w+O*R+F*z),t[15]=1,t},fromQuat:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=a+a,i=r+r,c=u+u,h=a*o,s=r*o,M=r*i,f=u*o,l=u*i,v=u*c,b=e*o,m=e*i,d=e*c;return t[0]=1-M-v,t[1]=s+d,t[2]=f-m,t[3]=0,t[4]=s-d,t[5]=1-h-v,t[6]=l+b,t[7]=0,t[8]=f+m,t[9]=l-b,t[10]=1-h-M,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},frustum:function(t,n,a,r,u,e,o){var i=1/(a-n),c=1/(u-r),h=1/(e-o);return t[0]=2*e*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*e*c,t[6]=0,t[7]=0,t[8]=(a+n)*i,t[9]=(u+r)*c,t[10]=(o+e)*h,t[11]=-1,t[12]=0,t[13]=0,t[14]=o*e*2*h,t[15]=0,t},perspective:function(t,n,a,r,u){var e,o=1/Math.tan(n/2);return t[0]=o/a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=u&&u!==1/0?(e=1/(r-u),t[10]=(u+r)*e,t[14]=2*u*r*e):(t[10]=-1,t[14]=-2*r),t},perspectiveFromFieldOfView:function(t,n,a,r){var u=Math.tan(n.upDegrees*Math.PI/180),e=Math.tan(n.downDegrees*Math.PI/180),o=Math.tan(n.leftDegrees*Math.PI/180),i=Math.tan(n.rightDegrees*Math.PI/180),c=2/(o+i),h=2/(u+e);return t[0]=c,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=h,t[6]=0,t[7]=0,t[8]=-(o-i)*c*.5,t[9]=(u-e)*h*.5,t[10]=r/(a-r),t[11]=-1,t[12]=0,t[13]=0,t[14]=r*a/(a-r),t[15]=0,t},ortho:function(t,n,a,r,u,e,o){var i=1/(n-a),c=1/(r-u),h=1/(e-o);return t[0]=-2*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*c,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*h,t[11]=0,t[12]=(n+a)*i,t[13]=(u+r)*c,t[14]=(o+e)*h,t[15]=1,t},lookAt:function(t,a,r,u){var e,o,i,c,h,s,M,f,l,v,b=a[0],m=a[1],d=a[2],x=u[0],p=u[1],y=u[2],q=r[0],A=r[1],w=r[2];return Math.abs(b-q)<n&&Math.abs(m-A)<n&&Math.abs(d-w)<n?g(t):(M=b-q,f=m-A,l=d-w,e=p*(l*=v=1/Math.hypot(M,f,l))-y*(f*=v),o=y*(M*=v)-x*l,i=x*f-p*M,(v=Math.hypot(e,o,i))?(e*=v=1/v,o*=v,i*=v):(e=0,o=0,i=0),c=f*i-l*o,h=l*e-M*i,s=M*o-f*e,(v=Math.hypot(c,h,s))?(c*=v=1/v,h*=v,s*=v):(c=0,h=0,s=0),t[0]=e,t[1]=c,t[2]=M,t[3]=0,t[4]=o,t[5]=h,t[6]=f,t[7]=0,t[8]=i,t[9]=s,t[10]=l,t[11]=0,t[12]=-(e*b+o*m+i*d),t[13]=-(c*b+h*m+s*d),t[14]=-(M*b+f*m+l*d),t[15]=1,t)},targetTo:function(t,n,a,r){var u=n[0],e=n[1],o=n[2],i=r[0],c=r[1],h=r[2],s=u-a[0],M=e-a[1],f=o-a[2],l=s*s+M*M+f*f;l>0&&(s*=l=1/Math.sqrt(l),M*=l,f*=l);var v=c*f-h*M,b=h*s-i*f,m=i*M-c*s;return(l=v*v+b*b+m*m)>0&&(v*=l=1/Math.sqrt(l),b*=l,m*=l),t[0]=v,t[1]=b,t[2]=m,t[3]=0,t[4]=M*m-f*b,t[5]=f*v-s*m,t[6]=s*b-M*v,t[7]=0,t[8]=s,t[9]=M,t[10]=f,t[11]=0,t[12]=u,t[13]=e,t[14]=o,t[15]=1,t},str:function(t){return"mat4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+", "+t[9]+", "+t[10]+", "+t[11]+", "+t[12]+", "+t[13]+", "+t[14]+", "+t[15]+")"},frob:function(t){return Math.hypot(t[0],t[1],t[3],t[4],t[5],t[6],t[7],t[8],t[9],t[10],t[11],t[12],t[13],t[14],t[15])},add:function(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t[4]=n[4]+a[4],t[5]=n[5]+a[5],t[6]=n[6]+a[6],t[7]=n[7]+a[7],t[8]=n[8]+a[8],t[9]=n[9]+a[9],t[10]=n[10]+a[10],t[11]=n[11]+a[11],t[12]=n[12]+a[12],t[13]=n[13]+a[13],t[14]=n[14]+a[14],t[15]=n[15]+a[15],t},subtract:j,multiplyScalar:function(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*a,t[5]=n[5]*a,t[6]=n[6]*a,t[7]=n[7]*a,t[8]=n[8]*a,t[9]=n[9]*a,t[10]=n[10]*a,t[11]=n[11]*a,t[12]=n[12]*a,t[13]=n[13]*a,t[14]=n[14]*a,t[15]=n[15]*a,t},multiplyScalarAndAdd:function(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t[3]=n[3]+a[3]*r,t[4]=n[4]+a[4]*r,t[5]=n[5]+a[5]*r,t[6]=n[6]+a[6]*r,t[7]=n[7]+a[7]*r,t[8]=n[8]+a[8]*r,t[9]=n[9]+a[9]*r,t[10]=n[10]+a[10]*r,t[11]=n[11]+a[11]*r,t[12]=n[12]+a[12]*r,t[13]=n[13]+a[13]*r,t[14]=n[14]+a[14]*r,t[15]=n[15]+a[15]*r,t},exactEquals:function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]&&t[9]===n[9]&&t[10]===n[10]&&t[11]===n[11]&&t[12]===n[12]&&t[13]===n[13]&&t[14]===n[14]&&t[15]===n[15]},equals:function(t,a){var r=t[0],u=t[1],e=t[2],o=t[3],i=t[4],c=t[5],h=t[6],s=t[7],M=t[8],f=t[9],l=t[10],v=t[11],b=t[12],m=t[13],d=t[14],x=t[15],p=a[0],y=a[1],q=a[2],g=a[3],A=a[4],w=a[5],R=a[6],z=a[7],P=a[8],j=a[9],I=a[10],S=a[11],E=a[12],O=a[13],T=a[14],D=a[15];return Math.abs(r-p)<=n*Math.max(1,Math.abs(r),Math.abs(p))&&Math.abs(u-y)<=n*Math.max(1,Math.abs(u),Math.abs(y))&&Math.abs(e-q)<=n*Math.max(1,Math.abs(e),Math.abs(q))&&Math.abs(o-g)<=n*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-A)<=n*Math.max(1,Math.abs(i),Math.abs(A))&&Math.abs(c-w)<=n*Math.max(1,Math.abs(c),Math.abs(w))&&Math.abs(h-R)<=n*Math.max(1,Math.abs(h),Math.abs(R))&&Math.abs(s-z)<=n*Math.max(1,Math.abs(s),Math.abs(z))&&Math.abs(M-P)<=n*Math.max(1,Math.abs(M),Math.abs(P))&&Math.abs(f-j)<=n*Math.max(1,Math.abs(f),Math.abs(j))&&Math.abs(l-I)<=n*Math.max(1,Math.abs(l),Math.abs(I))&&Math.abs(v-S)<=n*Math.max(1,Math.abs(v),Math.abs(S))&&Math.abs(b-E)<=n*Math.max(1,Math.abs(b),Math.abs(E))&&Math.abs(m-O)<=n*Math.max(1,Math.abs(m),Math.abs(O))&&Math.abs(d-T)<=n*Math.max(1,Math.abs(d),Math.abs(T))&&Math.abs(x-D)<=n*Math.max(1,Math.abs(x),Math.abs(D))},mul:I,sub:S});function O(){var t=new a(3);return a!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function T(t){var n=t[0],a=t[1],r=t[2];return Math.hypot(n,a,r)}function D(t,n,r){var u=new a(3);return u[0]=t,u[1]=n,u[2]=r,u}function F(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t}function L(t,n,a){return t[0]=n[0]*a[0],t[1]=n[1]*a[1],t[2]=n[2]*a[2],t}function V(t,n,a){return t[0]=n[0]/a[0],t[1]=n[1]/a[1],t[2]=n[2]/a[2],t}function Q(t,n){var a=n[0]-t[0],r=n[1]-t[1],u=n[2]-t[2];return Math.hypot(a,r,u)}function Y(t,n){var a=n[0]-t[0],r=n[1]-t[1],u=n[2]-t[2];return a*a+r*r+u*u}function X(t){var n=t[0],a=t[1],r=t[2];return n*n+a*a+r*r}function Z(t,n){var a=n[0],r=n[1],u=n[2],e=a*a+r*r+u*u;return e>0&&(e=1/Math.sqrt(e)),t[0]=n[0]*e,t[1]=n[1]*e,t[2]=n[2]*e,t}function _(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}function B(t,n,a){var r=n[0],u=n[1],e=n[2],o=a[0],i=a[1],c=a[2];return t[0]=u*c-e*i,t[1]=e*o-r*c,t[2]=r*i-u*o,t}var N,k=F,U=L,W=V,C=Q,G=Y,H=T,J=X,K=(N=O(),function(t,n,a,r,u,e){var o,i;for(n||(n=3),a||(a=0),i=r?Math.min(r*n+a,t.length):t.length,o=a;o<i;o+=n)N[0]=t[o],N[1]=t[o+1],N[2]=t[o+2],u(N,N,e),t[o]=N[0],t[o+1]=N[1],t[o+2]=N[2];return t}),$=Object.freeze({create:O,clone:function(t){var n=new a(3);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n},length:T,fromValues:D,copy:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t},set:function(t,n,a,r){return t[0]=n,t[1]=a,t[2]=r,t},add:function(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t},subtract:F,multiply:L,divide:V,ceil:function(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t[2]=Math.ceil(n[2]),t},floor:function(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t[2]=Math.floor(n[2]),t},min:function(t,n,a){return t[0]=Math.min(n[0],a[0]),t[1]=Math.min(n[1],a[1]),t[2]=Math.min(n[2],a[2]),t},max:function(t,n,a){return t[0]=Math.max(n[0],a[0]),t[1]=Math.max(n[1],a[1]),t[2]=Math.max(n[2],a[2]),t},round:function(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t[2]=Math.round(n[2]),t},scale:function(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t},scaleAndAdd:function(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t},distance:Q,squaredDistance:Y,squaredLength:X,negate:function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t},inverse:function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t},normalize:Z,dot:_,cross:B,lerp:function(t,n,a,r){var u=n[0],e=n[1],o=n[2];return t[0]=u+r*(a[0]-u),t[1]=e+r*(a[1]-e),t[2]=o+r*(a[2]-o),t},hermite:function(t,n,a,r,u,e){var o=e*e,i=o*(2*e-3)+1,c=o*(e-2)+e,h=o*(e-1),s=o*(3-2*e);return t[0]=n[0]*i+a[0]*c+r[0]*h+u[0]*s,t[1]=n[1]*i+a[1]*c+r[1]*h+u[1]*s,t[2]=n[2]*i+a[2]*c+r[2]*h+u[2]*s,t},bezier:function(t,n,a,r,u,e){var o=1-e,i=o*o,c=e*e,h=i*o,s=3*e*i,M=3*c*o,f=c*e;return t[0]=n[0]*h+a[0]*s+r[0]*M+u[0]*f,t[1]=n[1]*h+a[1]*s+r[1]*M+u[1]*f,t[2]=n[2]*h+a[2]*s+r[2]*M+u[2]*f,t},random:function(t,n){n=n||1;var a=2*r()*Math.PI,u=2*r()-1,e=Math.sqrt(1-u*u)*n;return t[0]=Math.cos(a)*e,t[1]=Math.sin(a)*e,t[2]=u*n,t},transformMat4:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=a[3]*r+a[7]*u+a[11]*e+a[15];return o=o||1,t[0]=(a[0]*r+a[4]*u+a[8]*e+a[12])/o,t[1]=(a[1]*r+a[5]*u+a[9]*e+a[13])/o,t[2]=(a[2]*r+a[6]*u+a[10]*e+a[14])/o,t},transformMat3:function(t,n,a){var r=n[0],u=n[1],e=n[2];return t[0]=r*a[0]+u*a[3]+e*a[6],t[1]=r*a[1]+u*a[4]+e*a[7],t[2]=r*a[2]+u*a[5]+e*a[8],t},transformQuat:function(t,n,a){var r=a[0],u=a[1],e=a[2],o=a[3],i=n[0],c=n[1],h=n[2],s=u*h-e*c,M=e*i-r*h,f=r*c-u*i,l=u*f-e*M,v=e*s-r*f,b=r*M-u*s,m=2*o;return s*=m,M*=m,f*=m,l*=2,v*=2,b*=2,t[0]=i+s+l,t[1]=c+M+v,t[2]=h+f+b,t},rotateX:function(t,n,a,r){var u=[],e=[];return u[0]=n[0]-a[0],u[1]=n[1]-a[1],u[2]=n[2]-a[2],e[0]=u[0],e[1]=u[1]*Math.cos(r)-u[2]*Math.sin(r),e[2]=u[1]*Math.sin(r)+u[2]*Math.cos(r),t[0]=e[0]+a[0],t[1]=e[1]+a[1],t[2]=e[2]+a[2],t},rotateY:function(t,n,a,r){var u=[],e=[];return u[0]=n[0]-a[0],u[1]=n[1]-a[1],u[2]=n[2]-a[2],e[0]=u[2]*Math.sin(r)+u[0]*Math.cos(r),e[1]=u[1],e[2]=u[2]*Math.cos(r)-u[0]*Math.sin(r),t[0]=e[0]+a[0],t[1]=e[1]+a[1],t[2]=e[2]+a[2],t},rotateZ:function(t,n,a,r){var u=[],e=[];return u[0]=n[0]-a[0],u[1]=n[1]-a[1],u[2]=n[2]-a[2],e[0]=u[0]*Math.cos(r)-u[1]*Math.sin(r),e[1]=u[0]*Math.sin(r)+u[1]*Math.cos(r),e[2]=u[2],t[0]=e[0]+a[0],t[1]=e[1]+a[1],t[2]=e[2]+a[2],t},angle:function(t,n){var a=D(t[0],t[1],t[2]),r=D(n[0],n[1],n[2]);Z(a,a),Z(r,r);var u=_(a,r);return u>1?0:u<-1?Math.PI:Math.acos(u)},zero:function(t){return t[0]=0,t[1]=0,t[2]=0,t},str:function(t){return"vec3("+t[0]+", "+t[1]+", "+t[2]+")"},exactEquals:function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]},equals:function(t,a){var r=t[0],u=t[1],e=t[2],o=a[0],i=a[1],c=a[2];return Math.abs(r-o)<=n*Math.max(1,Math.abs(r),Math.abs(o))&&Math.abs(u-i)<=n*Math.max(1,Math.abs(u),Math.abs(i))&&Math.abs(e-c)<=n*Math.max(1,Math.abs(e),Math.abs(c))},sub:k,mul:U,div:W,dist:C,sqrDist:G,len:H,sqrLen:J,forEach:K});function tt(){var t=new a(4);return a!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function nt(t){var n=new a(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n}function at(t,n,r,u){var e=new a(4);return e[0]=t,e[1]=n,e[2]=r,e[3]=u,e}function rt(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t}function ut(t,n,a,r,u){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t}function et(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t}function ot(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t[2]=n[2]-a[2],t[3]=n[3]-a[3],t}function it(t,n,a){return t[0]=n[0]*a[0],t[1]=n[1]*a[1],t[2]=n[2]*a[2],t[3]=n[3]*a[3],t}function ct(t,n,a){return t[0]=n[0]/a[0],t[1]=n[1]/a[1],t[2]=n[2]/a[2],t[3]=n[3]/a[3],t}function ht(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t}function st(t,n){var a=n[0]-t[0],r=n[1]-t[1],u=n[2]-t[2],e=n[3]-t[3];return Math.hypot(a,r,u,e)}function Mt(t,n){var a=n[0]-t[0],r=n[1]-t[1],u=n[2]-t[2],e=n[3]-t[3];return a*a+r*r+u*u+e*e}function ft(t){var n=t[0],a=t[1],r=t[2],u=t[3];return Math.hypot(n,a,r,u)}function lt(t){var n=t[0],a=t[1],r=t[2],u=t[3];return n*n+a*a+r*r+u*u}function vt(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=a*a+r*r+u*u+e*e;return o>0&&(o=1/Math.sqrt(o)),t[0]=a*o,t[1]=r*o,t[2]=u*o,t[3]=e*o,t}function bt(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]+t[3]*n[3]}function mt(t,n,a,r){var u=n[0],e=n[1],o=n[2],i=n[3];return t[0]=u+r*(a[0]-u),t[1]=e+r*(a[1]-e),t[2]=o+r*(a[2]-o),t[3]=i+r*(a[3]-i),t}function dt(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]}function xt(t,a){var r=t[0],u=t[1],e=t[2],o=t[3],i=a[0],c=a[1],h=a[2],s=a[3];return Math.abs(r-i)<=n*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(u-c)<=n*Math.max(1,Math.abs(u),Math.abs(c))&&Math.abs(e-h)<=n*Math.max(1,Math.abs(e),Math.abs(h))&&Math.abs(o-s)<=n*Math.max(1,Math.abs(o),Math.abs(s))}var pt=ot,yt=it,qt=ct,gt=st,At=Mt,wt=ft,Rt=lt,zt=function(){var t=tt();return function(n,a,r,u,e,o){var i,c;for(a||(a=4),r||(r=0),c=u?Math.min(u*a+r,n.length):n.length,i=r;i<c;i+=a)t[0]=n[i],t[1]=n[i+1],t[2]=n[i+2],t[3]=n[i+3],e(t,t,o),n[i]=t[0],n[i+1]=t[1],n[i+2]=t[2],n[i+3]=t[3];return n}}(),Pt=Object.freeze({create:tt,clone:nt,fromValues:at,copy:rt,set:ut,add:et,subtract:ot,multiply:it,divide:ct,ceil:function(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t[2]=Math.ceil(n[2]),t[3]=Math.ceil(n[3]),t},floor:function(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t[2]=Math.floor(n[2]),t[3]=Math.floor(n[3]),t},min:function(t,n,a){return t[0]=Math.min(n[0],a[0]),t[1]=Math.min(n[1],a[1]),t[2]=Math.min(n[2],a[2]),t[3]=Math.min(n[3],a[3]),t},max:function(t,n,a){return t[0]=Math.max(n[0],a[0]),t[1]=Math.max(n[1],a[1]),t[2]=Math.max(n[2],a[2]),t[3]=Math.max(n[3],a[3]),t},round:function(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t[2]=Math.round(n[2]),t[3]=Math.round(n[3]),t},scale:ht,scaleAndAdd:function(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t[2]=n[2]+a[2]*r,t[3]=n[3]+a[3]*r,t},distance:st,squaredDistance:Mt,length:ft,squaredLength:lt,negate:function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=-n[3],t},inverse:function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t[3]=1/n[3],t},normalize:vt,dot:bt,cross:function(t,n,a,r){var u=a[0]*r[1]-a[1]*r[0],e=a[0]*r[2]-a[2]*r[0],o=a[0]*r[3]-a[3]*r[0],i=a[1]*r[2]-a[2]*r[1],c=a[1]*r[3]-a[3]*r[1],h=a[2]*r[3]-a[3]*r[2],s=n[0],M=n[1],f=n[2],l=n[3];return t[0]=M*h-f*c+l*i,t[1]=-s*h+f*o-l*e,t[2]=s*c-M*o+l*u,t[3]=-s*i+M*e-f*u,t},lerp:mt,random:function(t,n){var a,u,e,o,i,c;n=n||1;do{i=(a=2*r()-1)*a+(u=2*r()-1)*u}while(i>=1);do{c=(e=2*r()-1)*e+(o=2*r()-1)*o}while(c>=1);var h=Math.sqrt((1-i)/c);return t[0]=n*a,t[1]=n*u,t[2]=n*e*h,t[3]=n*o*h,t},transformMat4:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3];return t[0]=a[0]*r+a[4]*u+a[8]*e+a[12]*o,t[1]=a[1]*r+a[5]*u+a[9]*e+a[13]*o,t[2]=a[2]*r+a[6]*u+a[10]*e+a[14]*o,t[3]=a[3]*r+a[7]*u+a[11]*e+a[15]*o,t},transformQuat:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=a[0],i=a[1],c=a[2],h=a[3],s=h*r+i*e-c*u,M=h*u+c*r-o*e,f=h*e+o*u-i*r,l=-o*r-i*u-c*e;return t[0]=s*h+l*-o+M*-c-f*-i,t[1]=M*h+l*-i+f*-o-s*-c,t[2]=f*h+l*-c+s*-i-M*-o,t[3]=n[3],t},zero:function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t},str:function(t){return"vec4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},exactEquals:dt,equals:xt,sub:pt,mul:yt,div:qt,dist:gt,sqrDist:At,len:wt,sqrLen:Rt,forEach:zt});function jt(){var t=new a(4);return a!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}function It(t,n,a){a*=.5;var r=Math.sin(a);return t[0]=r*n[0],t[1]=r*n[1],t[2]=r*n[2],t[3]=Math.cos(a),t}function St(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=a[0],c=a[1],h=a[2],s=a[3];return t[0]=r*s+o*i+u*h-e*c,t[1]=u*s+o*c+e*i-r*h,t[2]=e*s+o*h+r*c-u*i,t[3]=o*s-r*i-u*c-e*h,t}function Et(t,n,a){a*=.5;var r=n[0],u=n[1],e=n[2],o=n[3],i=Math.sin(a),c=Math.cos(a);return t[0]=r*c+o*i,t[1]=u*c+e*i,t[2]=e*c-u*i,t[3]=o*c-r*i,t}function Ot(t,n,a){a*=.5;var r=n[0],u=n[1],e=n[2],o=n[3],i=Math.sin(a),c=Math.cos(a);return t[0]=r*c-e*i,t[1]=u*c+o*i,t[2]=e*c+r*i,t[3]=o*c-u*i,t}function Tt(t,n,a){a*=.5;var r=n[0],u=n[1],e=n[2],o=n[3],i=Math.sin(a),c=Math.cos(a);return t[0]=r*c+u*i,t[1]=u*c-r*i,t[2]=e*c+o*i,t[3]=o*c-e*i,t}function Dt(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=Math.sqrt(a*a+r*r+u*u),i=Math.exp(e),c=o>0?i*Math.sin(o)/o:0;return t[0]=a*c,t[1]=r*c,t[2]=u*c,t[3]=i*Math.cos(o),t}function Ft(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=Math.sqrt(a*a+r*r+u*u),i=o>0?Math.atan2(o,e)/o:0;return t[0]=a*i,t[1]=r*i,t[2]=u*i,t[3]=.5*Math.log(a*a+r*r+u*u+e*e),t}function Lt(t,a,r,u){var e,o,i,c,h,s=a[0],M=a[1],f=a[2],l=a[3],v=r[0],b=r[1],m=r[2],d=r[3];return(o=s*v+M*b+f*m+l*d)<0&&(o=-o,v=-v,b=-b,m=-m,d=-d),1-o>n?(e=Math.acos(o),i=Math.sin(e),c=Math.sin((1-u)*e)/i,h=Math.sin(u*e)/i):(c=1-u,h=u),t[0]=c*s+h*v,t[1]=c*M+h*b,t[2]=c*f+h*m,t[3]=c*l+h*d,t}function Vt(t,n){var a,r=n[0]+n[4]+n[8];if(r>0)a=Math.sqrt(r+1),t[3]=.5*a,a=.5/a,t[0]=(n[5]-n[7])*a,t[1]=(n[6]-n[2])*a,t[2]=(n[1]-n[3])*a;else{var u=0;n[4]>n[0]&&(u=1),n[8]>n[3*u+u]&&(u=2);var e=(u+1)%3,o=(u+2)%3;a=Math.sqrt(n[3*u+u]-n[3*e+e]-n[3*o+o]+1),t[u]=.5*a,a=.5/a,t[3]=(n[3*e+o]-n[3*o+e])*a,t[e]=(n[3*e+u]+n[3*u+e])*a,t[o]=(n[3*o+u]+n[3*u+o])*a}return t}var Qt,Yt,Xt,Zt,_t,Bt,Nt=nt,kt=at,Ut=rt,Wt=ut,Ct=et,Gt=St,Ht=ht,Jt=bt,Kt=mt,$t=ft,tn=$t,nn=lt,an=nn,rn=vt,un=dt,en=xt,on=(Qt=O(),Yt=D(1,0,0),Xt=D(0,1,0),function(t,n,a){var r=_(n,a);return r<-.999999?(B(Qt,Yt,n),H(Qt)<1e-6&&B(Qt,Xt,n),Z(Qt,Qt),It(t,Qt,Math.PI),t):r>.999999?(t[0]=0,t[1]=0,t[2]=0,t[3]=1,t):(B(Qt,n,a),t[0]=Qt[0],t[1]=Qt[1],t[2]=Qt[2],t[3]=1+r,rn(t,t))}),cn=(Zt=jt(),_t=jt(),function(t,n,a,r,u,e){return Lt(Zt,n,u,e),Lt(_t,a,r,e),Lt(t,Zt,_t,2*e*(1-e)),t}),hn=(Bt=m(),function(t,n,a,r){return Bt[0]=a[0],Bt[3]=a[1],Bt[6]=a[2],Bt[1]=r[0],Bt[4]=r[1],Bt[7]=r[2],Bt[2]=-n[0],Bt[5]=-n[1],Bt[8]=-n[2],rn(t,Vt(t,Bt))}),sn=Object.freeze({create:jt,identity:function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t},setAxisAngle:It,getAxisAngle:function(t,a){var r=2*Math.acos(a[3]),u=Math.sin(r/2);return u>n?(t[0]=a[0]/u,t[1]=a[1]/u,t[2]=a[2]/u):(t[0]=1,t[1]=0,t[2]=0),r},getAngle:function(t,n){var a=Jt(t,n);return Math.acos(2*a*a-1)},multiply:St,rotateX:Et,rotateY:Ot,rotateZ:Tt,calculateW:function(t,n){var a=n[0],r=n[1],u=n[2];return t[0]=a,t[1]=r,t[2]=u,t[3]=Math.sqrt(Math.abs(1-a*a-r*r-u*u)),t},exp:Dt,ln:Ft,pow:function(t,n,a){return Ft(t,n),Ht(t,t,a),Dt(t,t),t},slerp:Lt,random:function(t){var n=r(),a=r(),u=r(),e=Math.sqrt(1-n),o=Math.sqrt(n);return t[0]=e*Math.sin(2*Math.PI*a),t[1]=e*Math.cos(2*Math.PI*a),t[2]=o*Math.sin(2*Math.PI*u),t[3]=o*Math.cos(2*Math.PI*u),t},invert:function(t,n){var a=n[0],r=n[1],u=n[2],e=n[3],o=a*a+r*r+u*u+e*e,i=o?1/o:0;return t[0]=-a*i,t[1]=-r*i,t[2]=-u*i,t[3]=e*i,t},conjugate:function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t},fromMat3:Vt,fromEuler:function(t,n,a,r){var u=.5*Math.PI/180;n*=u,a*=u,r*=u;var e=Math.sin(n),o=Math.cos(n),i=Math.sin(a),c=Math.cos(a),h=Math.sin(r),s=Math.cos(r);return t[0]=e*c*s-o*i*h,t[1]=o*i*s+e*c*h,t[2]=o*c*h-e*i*s,t[3]=o*c*s+e*i*h,t},str:function(t){return"quat("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},clone:Nt,fromValues:kt,copy:Ut,set:Wt,add:Ct,mul:Gt,scale:Ht,dot:Jt,lerp:Kt,length:$t,len:tn,squaredLength:nn,sqrLen:an,normalize:rn,exactEquals:un,equals:en,rotationTo:on,sqlerp:cn,setAxes:hn});function Mn(t,n,a){var r=.5*a[0],u=.5*a[1],e=.5*a[2],o=n[0],i=n[1],c=n[2],h=n[3];return t[0]=o,t[1]=i,t[2]=c,t[3]=h,t[4]=r*h+u*c-e*i,t[5]=u*h+e*o-r*c,t[6]=e*h+r*i-u*o,t[7]=-r*o-u*i-e*c,t}function fn(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t}var ln=Ut;var vn=Ut;function bn(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=a[4],c=a[5],h=a[6],s=a[7],M=n[4],f=n[5],l=n[6],v=n[7],b=a[0],m=a[1],d=a[2],x=a[3];return t[0]=r*x+o*b+u*d-e*m,t[1]=u*x+o*m+e*b-r*d,t[2]=e*x+o*d+r*m-u*b,t[3]=o*x-r*b-u*m-e*d,t[4]=r*s+o*i+u*h-e*c+M*x+v*b+f*d-l*m,t[5]=u*s+o*c+e*i-r*h+f*x+v*m+l*b-M*d,t[6]=e*s+o*h+r*c-u*i+l*x+v*d+M*m-f*b,t[7]=o*s-r*i-u*c-e*h+v*x-M*b-f*m-l*d,t}var mn=bn;var dn=Jt;var xn=$t,pn=xn,yn=nn,qn=yn;var gn=Object.freeze({create:function(){var t=new a(8);return a!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0),t[3]=1,t},clone:function(t){var n=new a(8);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n},fromValues:function(t,n,r,u,e,o,i,c){var h=new a(8);return h[0]=t,h[1]=n,h[2]=r,h[3]=u,h[4]=e,h[5]=o,h[6]=i,h[7]=c,h},fromRotationTranslationValues:function(t,n,r,u,e,o,i){var c=new a(8);c[0]=t,c[1]=n,c[2]=r,c[3]=u;var h=.5*e,s=.5*o,M=.5*i;return c[4]=h*u+s*r-M*n,c[5]=s*u+M*t-h*r,c[6]=M*u+h*n-s*t,c[7]=-h*t-s*n-M*r,c},fromRotationTranslation:Mn,fromTranslation:function(t,n){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t[4]=.5*n[0],t[5]=.5*n[1],t[6]=.5*n[2],t[7]=0,t},fromRotation:function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=0,t[5]=0,t[6]=0,t[7]=0,t},fromMat4:function(t,n){var r=jt();P(r,n);var u=new a(3);return R(u,n),Mn(t,r,u),t},copy:fn,identity:function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t},set:function(t,n,a,r,u,e,o,i,c){return t[0]=n,t[1]=a,t[2]=r,t[3]=u,t[4]=e,t[5]=o,t[6]=i,t[7]=c,t},getReal:ln,getDual:function(t,n){return t[0]=n[4],t[1]=n[5],t[2]=n[6],t[3]=n[7],t},setReal:vn,setDual:function(t,n){return t[4]=n[0],t[5]=n[1],t[6]=n[2],t[7]=n[3],t},getTranslation:function(t,n){var a=n[4],r=n[5],u=n[6],e=n[7],o=-n[0],i=-n[1],c=-n[2],h=n[3];return t[0]=2*(a*h+e*o+r*c-u*i),t[1]=2*(r*h+e*i+u*o-a*c),t[2]=2*(u*h+e*c+a*i-r*o),t},translate:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=.5*a[0],c=.5*a[1],h=.5*a[2],s=n[4],M=n[5],f=n[6],l=n[7];return t[0]=r,t[1]=u,t[2]=e,t[3]=o,t[4]=o*i+u*h-e*c+s,t[5]=o*c+e*i-r*h+M,t[6]=o*h+r*c-u*i+f,t[7]=-r*i-u*c-e*h+l,t},rotateX:function(t,n,a){var r=-n[0],u=-n[1],e=-n[2],o=n[3],i=n[4],c=n[5],h=n[6],s=n[7],M=i*o+s*r+c*e-h*u,f=c*o+s*u+h*r-i*e,l=h*o+s*e+i*u-c*r,v=s*o-i*r-c*u-h*e;return Et(t,n,a),r=t[0],u=t[1],e=t[2],o=t[3],t[4]=M*o+v*r+f*e-l*u,t[5]=f*o+v*u+l*r-M*e,t[6]=l*o+v*e+M*u-f*r,t[7]=v*o-M*r-f*u-l*e,t},rotateY:function(t,n,a){var r=-n[0],u=-n[1],e=-n[2],o=n[3],i=n[4],c=n[5],h=n[6],s=n[7],M=i*o+s*r+c*e-h*u,f=c*o+s*u+h*r-i*e,l=h*o+s*e+i*u-c*r,v=s*o-i*r-c*u-h*e;return Ot(t,n,a),r=t[0],u=t[1],e=t[2],o=t[3],t[4]=M*o+v*r+f*e-l*u,t[5]=f*o+v*u+l*r-M*e,t[6]=l*o+v*e+M*u-f*r,t[7]=v*o-M*r-f*u-l*e,t},rotateZ:function(t,n,a){var r=-n[0],u=-n[1],e=-n[2],o=n[3],i=n[4],c=n[5],h=n[6],s=n[7],M=i*o+s*r+c*e-h*u,f=c*o+s*u+h*r-i*e,l=h*o+s*e+i*u-c*r,v=s*o-i*r-c*u-h*e;return Tt(t,n,a),r=t[0],u=t[1],e=t[2],o=t[3],t[4]=M*o+v*r+f*e-l*u,t[5]=f*o+v*u+l*r-M*e,t[6]=l*o+v*e+M*u-f*r,t[7]=v*o-M*r-f*u-l*e,t},rotateByQuatAppend:function(t,n,a){var r=a[0],u=a[1],e=a[2],o=a[3],i=n[0],c=n[1],h=n[2],s=n[3];return t[0]=i*o+s*r+c*e-h*u,t[1]=c*o+s*u+h*r-i*e,t[2]=h*o+s*e+i*u-c*r,t[3]=s*o-i*r-c*u-h*e,i=n[4],c=n[5],h=n[6],s=n[7],t[4]=i*o+s*r+c*e-h*u,t[5]=c*o+s*u+h*r-i*e,t[6]=h*o+s*e+i*u-c*r,t[7]=s*o-i*r-c*u-h*e,t},rotateByQuatPrepend:function(t,n,a){var r=n[0],u=n[1],e=n[2],o=n[3],i=a[0],c=a[1],h=a[2],s=a[3];return t[0]=r*s+o*i+u*h-e*c,t[1]=u*s+o*c+e*i-r*h,t[2]=e*s+o*h+r*c-u*i,t[3]=o*s-r*i-u*c-e*h,i=a[4],c=a[5],h=a[6],s=a[7],t[4]=r*s+o*i+u*h-e*c,t[5]=u*s+o*c+e*i-r*h,t[6]=e*s+o*h+r*c-u*i,t[7]=o*s-r*i-u*c-e*h,t},rotateAroundAxis:function(t,a,r,u){if(Math.abs(u)<n)return fn(t,a);var e=Math.hypot(r[0],r[1],r[2]);u*=.5;var o=Math.sin(u),i=o*r[0]/e,c=o*r[1]/e,h=o*r[2]/e,s=Math.cos(u),M=a[0],f=a[1],l=a[2],v=a[3];t[0]=M*s+v*i+f*h-l*c,t[1]=f*s+v*c+l*i-M*h,t[2]=l*s+v*h+M*c-f*i,t[3]=v*s-M*i-f*c-l*h;var b=a[4],m=a[5],d=a[6],x=a[7];return t[4]=b*s+x*i+m*h-d*c,t[5]=m*s+x*c+d*i-b*h,t[6]=d*s+x*h+b*c-m*i,t[7]=x*s-b*i-m*c-d*h,t},add:function(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t[2]=n[2]+a[2],t[3]=n[3]+a[3],t[4]=n[4]+a[4],t[5]=n[5]+a[5],t[6]=n[6]+a[6],t[7]=n[7]+a[7],t},multiply:bn,mul:mn,scale:function(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*a,t[5]=n[5]*a,t[6]=n[6]*a,t[7]=n[7]*a,t},dot:dn,lerp:function(t,n,a,r){var u=1-r;return dn(n,a)<0&&(r=-r),t[0]=n[0]*u+a[0]*r,t[1]=n[1]*u+a[1]*r,t[2]=n[2]*u+a[2]*r,t[3]=n[3]*u+a[3]*r,t[4]=n[4]*u+a[4]*r,t[5]=n[5]*u+a[5]*r,t[6]=n[6]*u+a[6]*r,t[7]=n[7]*u+a[7]*r,t},invert:function(t,n){var a=yn(n);return t[0]=-n[0]/a,t[1]=-n[1]/a,t[2]=-n[2]/a,t[3]=n[3]/a,t[4]=-n[4]/a,t[5]=-n[5]/a,t[6]=-n[6]/a,t[7]=n[7]/a,t},conjugate:function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t[4]=-n[4],t[5]=-n[5],t[6]=-n[6],t[7]=n[7],t},length:xn,len:pn,squaredLength:yn,sqrLen:qn,normalize:function(t,n){var a=yn(n);if(a>0){a=Math.sqrt(a);var r=n[0]/a,u=n[1]/a,e=n[2]/a,o=n[3]/a,i=n[4],c=n[5],h=n[6],s=n[7],M=r*i+u*c+e*h+o*s;t[0]=r,t[1]=u,t[2]=e,t[3]=o,t[4]=(i-r*M)/a,t[5]=(c-u*M)/a,t[6]=(h-e*M)/a,t[7]=(s-o*M)/a}return t},str:function(t){return"quat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+")"},exactEquals:function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]},equals:function(t,a){var r=t[0],u=t[1],e=t[2],o=t[3],i=t[4],c=t[5],h=t[6],s=t[7],M=a[0],f=a[1],l=a[2],v=a[3],b=a[4],m=a[5],d=a[6],x=a[7];return Math.abs(r-M)<=n*Math.max(1,Math.abs(r),Math.abs(M))&&Math.abs(u-f)<=n*Math.max(1,Math.abs(u),Math.abs(f))&&Math.abs(e-l)<=n*Math.max(1,Math.abs(e),Math.abs(l))&&Math.abs(o-v)<=n*Math.max(1,Math.abs(o),Math.abs(v))&&Math.abs(i-b)<=n*Math.max(1,Math.abs(i),Math.abs(b))&&Math.abs(c-m)<=n*Math.max(1,Math.abs(c),Math.abs(m))&&Math.abs(h-d)<=n*Math.max(1,Math.abs(h),Math.abs(d))&&Math.abs(s-x)<=n*Math.max(1,Math.abs(s),Math.abs(x))}});function An(){var t=new a(2);return a!=Float32Array&&(t[0]=0,t[1]=0),t}function wn(t,n,a){return t[0]=n[0]-a[0],t[1]=n[1]-a[1],t}function Rn(t,n,a){return t[0]=n[0]*a[0],t[1]=n[1]*a[1],t}function zn(t,n,a){return t[0]=n[0]/a[0],t[1]=n[1]/a[1],t}function Pn(t,n){var a=n[0]-t[0],r=n[1]-t[1];return Math.hypot(a,r)}function jn(t,n){var a=n[0]-t[0],r=n[1]-t[1];return a*a+r*r}function In(t){var n=t[0],a=t[1];return Math.hypot(n,a)}function Sn(t){var n=t[0],a=t[1];return n*n+a*a}var En=In,On=wn,Tn=Rn,Dn=zn,Fn=Pn,Ln=jn,Vn=Sn,Qn=function(){var t=An();return function(n,a,r,u,e,o){var i,c;for(a||(a=2),r||(r=0),c=u?Math.min(u*a+r,n.length):n.length,i=r;i<c;i+=a)t[0]=n[i],t[1]=n[i+1],e(t,t,o),n[i]=t[0],n[i+1]=t[1];return n}}(),Yn=Object.freeze({create:An,clone:function(t){var n=new a(2);return n[0]=t[0],n[1]=t[1],n},fromValues:function(t,n){var r=new a(2);return r[0]=t,r[1]=n,r},copy:function(t,n){return t[0]=n[0],t[1]=n[1],t},set:function(t,n,a){return t[0]=n,t[1]=a,t},add:function(t,n,a){return t[0]=n[0]+a[0],t[1]=n[1]+a[1],t},subtract:wn,multiply:Rn,divide:zn,ceil:function(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t},floor:function(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t},min:function(t,n,a){return t[0]=Math.min(n[0],a[0]),t[1]=Math.min(n[1],a[1]),t},max:function(t,n,a){return t[0]=Math.max(n[0],a[0]),t[1]=Math.max(n[1],a[1]),t},round:function(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t},scale:function(t,n,a){return t[0]=n[0]*a,t[1]=n[1]*a,t},scaleAndAdd:function(t,n,a,r){return t[0]=n[0]+a[0]*r,t[1]=n[1]+a[1]*r,t},distance:Pn,squaredDistance:jn,length:In,squaredLength:Sn,negate:function(t,n){return t[0]=-n[0],t[1]=-n[1],t},inverse:function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t},normalize:function(t,n){var a=n[0],r=n[1],u=a*a+r*r;return u>0&&(u=1/Math.sqrt(u)),t[0]=n[0]*u,t[1]=n[1]*u,t},dot:function(t,n){return t[0]*n[0]+t[1]*n[1]},cross:function(t,n,a){var r=n[0]*a[1]-n[1]*a[0];return t[0]=t[1]=0,t[2]=r,t},lerp:function(t,n,a,r){var u=n[0],e=n[1];return t[0]=u+r*(a[0]-u),t[1]=e+r*(a[1]-e),t},random:function(t,n){n=n||1;var a=2*r()*Math.PI;return t[0]=Math.cos(a)*n,t[1]=Math.sin(a)*n,t},transformMat2:function(t,n,a){var r=n[0],u=n[1];return t[0]=a[0]*r+a[2]*u,t[1]=a[1]*r+a[3]*u,t},transformMat2d:function(t,n,a){var r=n[0],u=n[1];return t[0]=a[0]*r+a[2]*u+a[4],t[1]=a[1]*r+a[3]*u+a[5],t},transformMat3:function(t,n,a){var r=n[0],u=n[1];return t[0]=a[0]*r+a[3]*u+a[6],t[1]=a[1]*r+a[4]*u+a[7],t},transformMat4:function(t,n,a){var r=n[0],u=n[1];return t[0]=a[0]*r+a[4]*u+a[12],t[1]=a[1]*r+a[5]*u+a[13],t},rotate:function(t,n,a,r){var u=n[0]-a[0],e=n[1]-a[1],o=Math.sin(r),i=Math.cos(r);return t[0]=u*i-e*o+a[0],t[1]=u*o+e*i+a[1],t},angle:function(t,n){var a=t[0],r=t[1],u=n[0],e=n[1],o=a*a+r*r;o>0&&(o=1/Math.sqrt(o));var i=u*u+e*e;i>0&&(i=1/Math.sqrt(i));var c=(a*u+r*e)*o*i;return c>1?0:c<-1?Math.PI:Math.acos(c)},zero:function(t){return t[0]=0,t[1]=0,t},str:function(t){return"vec2("+t[0]+", "+t[1]+")"},exactEquals:function(t,n){return t[0]===n[0]&&t[1]===n[1]},equals:function(t,a){var r=t[0],u=t[1],e=a[0],o=a[1];return Math.abs(r-e)<=n*Math.max(1,Math.abs(r),Math.abs(e))&&Math.abs(u-o)<=n*Math.max(1,Math.abs(u),Math.abs(o))},len:En,sub:On,mul:Tn,div:Dn,dist:Fn,sqrDist:Ln,sqrLen:Vn,forEach:Qn});t.glMatrix=e,t.mat2=s,t.mat2d=b,t.mat3=q,t.mat4=E,t.quat=sn,t.quat2=gn,t.vec2=Yn,t.vec3=$,t.vec4=Pt,Object.defineProperty(t,"__esModule",{value:!0})});

// ["glMatrix", "mat2", "mat2d", "mat3", "mat4", "quat", "quat2", "vec2", "vec3", "vec4"]
window.glMatrix = glMatrix;
window.mat2 = glMatrix.mat2;
window.mat2d = glMatrix.mat2d;
window.mat3 = glMatrix.mat3;
window.mat4 = glMatrix.mat4;
window.quat = glMatrix.quat;
window.quat2 = glMatrix.quat2;
window.vec2 = glMatrix.vec2;
window.vec3 = glMatrix.vec3;
window.vec4 = glMatrix.vec4;



var CABLES = CABLES || {}; CABLES.build = {"timestamp":1714998332421,"created":"2024-05-06T12:25:32.421Z","git":{"branch":"master","commit":"818c25616aa874f43ba75866145ad0813fc50425","date":null,"message":null}};

if(!CABLES.exportedPatches) CABLES.exportedPatches={};CABLES.exportedPatches['u8Ainc']={"ops":[{"id":"1ne1866wo","uiAttribs":{},"portsIn":[{"name":"FPS Limit","value":0},{"name":"Reduce FPS not focussed","value":true},{"name":"Reduce FPS loading","value":false},{"name":"Clear","value":true},{"name":"ClearAlpha","value":true},{"name":"Fullscreen Button","value":false},{"name":"Active","value":true},{"name":"Hires Displays","value":false},{"name":"Pixel Unit index","value":0},{"name":"Pixel Unit","value":"Display"}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"bpdxk275f","objOut":"1ne1866wo"},{"portIn":"Reset","portOut":"trigger","objIn":"qvr8rypqv","objOut":"1ne1866wo"},{"portIn":"exe","portOut":"trigger","objIn":"whe5hkrfy","objOut":"1ne1866wo"}]},{"name":"width","value":713},{"name":"height","value":509}],"objName":"Ops.Gl.MainLoop"},{"id":"r4j9opm0t","uiAttribs":{},"portsIn":[{"name":"posX","value":0},{"name":"posY","value":0.3},{"name":"posZ","value":-3.69},{"name":"scale","value":1},{"name":"rotX","value":0},{"name":"rotY","value":0},{"name":"rotZ","value":0}],"portsOut":[{"name":"trigger","links":[{"portIn":"Trigger In","portOut":"trigger","objIn":"7ixfj4k34","objOut":"r4j9opm0t"}]}],"objName":"Ops.Gl.Matrix.Transform"},{"id":"nz53jynfp","uiAttribs":{},"portsIn":[{"name":"File","value":"assets/dreamstime_xxl_186010340.jpg","display":"file"},{"name":"Filter index","value":0},{"name":"Filter","value":"linear"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"repeat"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":0},{"name":"Data Format index","value":3},{"name":"Data Format","value":"RGBA"},{"name":"Flip","value":false},{"name":"Pre Multiplied Alpha","value":false},{"name":"Active","value":true},{"name":"Save Memory","value":true},{"name":"Add Cachebuster","value":true}],"portsOut":[{"name":"Texture","links":[{"portIn":"Texture","portOut":"Texture","objIn":"bpdxk275f","objOut":"nz53jynfp"}]},{"name":"Width","value":4928},{"name":"Height","value":4052},{"name":"Aspect Ratio","value":1.2161895360315893},{"name":"Loaded","value":1},{"name":"Loading","value":0}],"objName":"Ops.Gl.Texture_v2"},{"id":"bfpyuaurc","uiAttribs":{},"portsIn":[{"name":"title","value":" "},{"name":"text","value":"render a cube using the custom shader"}],"objName":"Ops.Ui.Comment_v2"},{"id":"0x93r1yme","uiAttribs":{},"portsIn":[{"name":"title","value":" "},{"name":"text","value":"render the generated texture"}],"objName":"Ops.Ui.Comment_v2"},{"id":"bpdxk275f","uiAttribs":{},"portsIn":[{"name":"Scale index","value":0},{"name":"Scale","value":"Stretch"},{"name":"Flip Y","value":false},{"name":"Flip X","value":false}],"objName":"Ops.Gl.Meshes.FullscreenRectangle_v2"},{"id":"mocuheerp","uiAttribs":{},"portsIn":[{"name":"min distance","value":0.01},{"name":"max distance","value":99999},{"name":"min rot y","value":0},{"name":"max rot y","value":0},{"name":"initial radius","value":0.05},{"name":"initial axis y","value":0.5},{"name":"initial axis x","value":0.25},{"name":"mul","value":1},{"name":"Smoothness","value":1},{"name":"Speed X","value":1},{"name":"Speed Y","value":1},{"name":"Active","value":true},{"name":"Allow Panning","value":true},{"name":"Allow Zooming","value":true},{"name":"Allow Rotation","value":true},{"name":"restricted","value":true}],"portsOut":[{"name":"trigger","links":[{"portIn":"render","portOut":"trigger","objIn":"r4j9opm0t","objOut":"mocuheerp"},{"portIn":"exe","portOut":"trigger","objIn":"kcjdsz2f4","objOut":"mocuheerp"}]},{"name":"radius","value":0.05},{"name":"Rot X","value":90},{"name":"Rot Y","value":90}],"objName":"Ops.Gl.Matrix.OrbitControls"},{"id":"rzjwuzfm8","uiAttribs":{},"portsIn":[{"name":"File","value":"assets/1809380.webp","display":"file"},{"name":"Filter index","value":0},{"name":"Filter","value":"nearest"},{"name":"Wrap index","value":2},{"name":"Wrap","value":"mirrored repeat"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":"0"},{"name":"Data Format index","value":3},{"name":"Data Format","value":"RGB"},{"name":"Flip","value":true},{"name":"Pre Multiplied Alpha","value":false},{"name":"Active","value":true},{"name":"Save Memory","value":true},{"name":"Add Cachebuster","value":true}],"portsOut":[{"name":"Texture","links":[{"portIn":"Diffuse Texture","portOut":"Texture","objIn":"7ixfj4k34","objOut":"rzjwuzfm8"}]},{"name":"Width","value":2400},{"name":"Height","value":1600},{"name":"Aspect Ratio","value":1.5},{"name":"Loaded","value":1},{"name":"Loading","value":0}],"objName":"Ops.Gl.Texture_v2"},{"id":"dklm548rz","uiAttribs":{},"portsIn":[{"name":"sides","value":32},{"name":"rings","value":32},{"name":"innerRadius","value":0.48},{"name":"outerRadius","value":1.64},{"name":"Draw","value":true,"title":"Render mesh"}],"objName":"Ops.Gl.Meshes.Torus_v3"},{"id":"w5xpb5qug","uiAttribs":{},"portsIn":[{"name":"Cast Light","value":true},{"name":"Intensity","value":4.9},{"name":"Radius","value":1.94},{"name":"Z","value":2.8},{"name":"Point At X","value":0},{"name":"Point At Y","value":0},{"name":"Point At Z","value":0},{"name":"R","value":1},{"name":"G","value":1},{"name":"B","value":1},{"name":"Specular R","value":0.632},{"name":"Specular G","value":1},{"name":"Specular B","value":1},{"name":"Cone Angle","value":120},{"name":"Inner Cone Angle","value":60},{"name":"Spot Exponent","value":0.85},{"name":"Falloff","value":0.08},{"name":"Cast Shadow","value":true},{"name":"Rendering Active","value":true},{"name":"Map Size index","value":1},{"name":"Map Size","value":512},{"name":"Shadow Strength","value":1},{"name":"Near","value":6.85},{"name":"Far","value":30},{"name":"Bias","value":0.0001},{"name":"Polygon Offset","value":0},{"name":"Normal Offset","value":0},{"name":"Blur Amount","value":0.416},{"name":"Enable Advanced","value":false},{"name":"MSAA index","value":0},{"name":"MSAA","value":"none"},{"name":"Texture Filter index","value":0},{"name":"Texture Filter","value":"Linear"},{"name":"Anisotropic index","value":0},{"name":"Anisotropic","value":"0"}],"portsOut":[{"name":"Trigger Out","links":[{"portIn":"render","portOut":"Trigger Out","objIn":"mocuheerp","objOut":"w5xpb5qug"}]},{"name":"World Position X","value":1.2736172676086426},{"name":"World Position Y","value":1.2736172676086426},{"name":"World Position Z","value":2.799999952316284}],"objName":"Ops.Gl.Phong.SpotLight_v5"},{"id":"7ixfj4k34","uiAttribs":{},"portsIn":[{"name":"R","value":0.15556923037651527},{"name":"G","value":0.4225888841209009},{"name":"B","value":0.5393914887245048},{"name":"A","value":1},{"name":"Enable","value":false},{"name":"Albedo","value":0.707},{"name":"Roughness","value":0.835},{"name":"Active","value":false},{"name":"Fresnel Intensity","value":0.7},{"name":"Fresnel Width","value":1},{"name":"Fresnel Exponent","value":6},{"name":"Fresnel R","value":1},{"name":"Fresnel G","value":1},{"name":"Fresnel B","value":1},{"name":"Emissive Active","value":false},{"name":"Color Intensity","value":0.3},{"name":"Emissive R","value":0.07230746221018802},{"name":"Emissive G","value":0.19052751749603258},{"name":"Emissive B","value":0.8863975706885161},{"name":"Shininess","value":4},{"name":"Specular Amount","value":0.5},{"name":"Specular Model index","value":0},{"name":"Specular Model","value":"Blinn"},{"name":"Energy Conservation","value":false},{"name":"Double Sided Material","value":false},{"name":"Falloff Mode index","value":0},{"name":"Falloff Mode","value":"A"},{"name":"Colorize Texture","value":false},{"name":"Diffuse Repeat X","value":1},{"name":"Diffuse Repeat Y","value":1},{"name":"Texture Offset X","value":0},{"name":"Texture Offset Y","value":0},{"name":"Specular Intensity","value":1},{"name":"Normal Map Intensity","value":0.5},{"name":"AO Intensity","value":1},{"name":"AO UV Channel index","value":0},{"name":"AO UV Channel","value":1},{"name":"Emissive Intensity","value":1},{"name":"Emissive Mask Intensity","value":1},{"name":"Env Map Intensity","value":1},{"name":"Env Map Blend index","value":0},{"name":"Env Map Blend","value":"Add"},{"name":"Env Mask Intensity","value":1},{"name":"Alpha Mask Source index","value":0},{"name":"Alpha Mask Source","value":"Luminance"},{"name":"Discard Transparent Pixels","value":false}],"portsOut":[{"name":"Trigger Out","links":[{"portIn":"render","portOut":"Trigger Out","objIn":"dklm548rz","objOut":"7ixfj4k34"}]}],"objName":"Ops.Gl.Phong.PhongMaterial_v6"},{"id":"qvr8rypqv","uiAttribs":{},"portsIn":[{"name":"Speed","value":-5.16},{"name":"Play","value":true},{"name":"Sync to timeline","value":false}],"portsOut":[{"name":"Time","value":0}],"objName":"Ops.Anim.Timer_v2"},{"id":"whe5hkrfy","uiAttribs":{},"portsIn":[{"name":"Mode index","value":0},{"name":"Mode","value":"Sine"},{"name":"phase","value":0},{"name":"frequency","value":1},{"name":"amplitude","value":3.81}],"portsOut":[{"name":"Trigger out","links":[{"portIn":"Trigger In","portOut":"Trigger out","objIn":"w5xpb5qug","objOut":"whe5hkrfy"}]},{"name":"result","links":[{"portIn":"X","portOut":"result","objIn":"w5xpb5qug","objOut":"whe5hkrfy"},{"portIn":"Y","portOut":"result","objIn":"w5xpb5qug","objOut":"whe5hkrfy"}]}],"objName":"Ops.Anim.SineAnim"},{"id":"6i0dez8q8","uiAttribs":{},"portsIn":[{"name":"number2","value":9.03}],"portsOut":[{"name":"result","value":95.7215706563072}],"objName":"Ops.Math.Multiply"},{"id":"kcjdsz2f4","uiAttribs":{},"portsIn":[{"name":"min","value":0},{"name":"max","value":11.84},{"name":"random seed","value":0},{"name":"duration","value":1.97},{"name":"pause between","value":0},{"name":"easing index","value":0},{"name":"easing","value":"smootherstep"}],"portsOut":[{"name":"result","links":[{"portIn":"number1","portOut":"result","objIn":"6i0dez8q8","objOut":"kcjdsz2f4"}]}],"objName":"Ops.Anim.RandomAnim"}],"_id":"663e16329f55d779f0d11786","export":{"time":"2024-05-10 16:06:01","service":"github","exportNumber":1}};
if(!CABLES.exportedPatch){CABLES.exportedPatch=CABLES.exportedPatches['u8Ainc']}
"use strict";

var CABLES=CABLES||{};
CABLES.OPS=CABLES.OPS||{};

var Ops=Ops || {};
Ops.Gl=Ops.Gl || {};
Ops.Ui=Ops.Ui || {};
Ops.Anim=Ops.Anim || {};
Ops.Math=Ops.Math || {};
Ops.Gl.Phong=Ops.Gl.Phong || {};
Ops.Gl.Matrix=Ops.Gl.Matrix || {};
Ops.Gl.Meshes=Ops.Gl.Meshes || {};



// **************************************************************
// 
// Ops.Gl.MainLoop
// 
// **************************************************************

Ops.Gl.MainLoop = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    fpsLimit = op.inValue("FPS Limit", 0),
    trigger = op.outTrigger("trigger"),
    width = op.outNumber("width"),
    height = op.outNumber("height"),
    reduceFocusFPS = op.inValueBool("Reduce FPS not focussed", true),
    reduceLoadingFPS = op.inValueBool("Reduce FPS loading"),
    clear = op.inValueBool("Clear", true),
    clearAlpha = op.inValueBool("ClearAlpha", true),
    fullscreen = op.inValueBool("Fullscreen Button", false),
    active = op.inValueBool("Active", true),
    hdpi = op.inValueBool("Hires Displays", false),
    inUnit = op.inSwitch("Pixel Unit", ["Display", "CSS"], "Display");

op.onAnimFrame = render;
hdpi.onChange = function ()
{
    if (hdpi.get()) op.patch.cgl.pixelDensity = window.devicePixelRatio;
    else op.patch.cgl.pixelDensity = 1;

    op.patch.cgl.updateSize();
    if (CABLES.UI) gui.setLayout();
};

active.onChange = function ()
{
    op.patch.removeOnAnimFrame(op);

    if (active.get())
    {
        op.setUiAttrib({ "extendTitle": "" });
        op.onAnimFrame = render;
        op.patch.addOnAnimFrame(op);
        op.log("adding again!");
    }
    else
    {
        op.setUiAttrib({ "extendTitle": "Inactive" });
    }
};

const cgl = op.patch.cgl;
let rframes = 0;
let rframeStart = 0;
let timeOutTest = null;
let addedListener = false;

if (!op.patch.cgl) op.uiAttr({ "error": "No webgl cgl context" });

const identTranslate = vec3.create();
vec3.set(identTranslate, 0, 0, 0);
const identTranslateView = vec3.create();
vec3.set(identTranslateView, 0, 0, -2);

fullscreen.onChange = updateFullscreenButton;
setTimeout(updateFullscreenButton, 100);
let fsElement = null;

let winhasFocus = true;
let winVisible = true;

window.addEventListener("blur", () => { winhasFocus = false; });
window.addEventListener("focus", () => { winhasFocus = true; });
document.addEventListener("visibilitychange", () => { winVisible = !document.hidden; });
testMultiMainloop();

cgl.mainloopOp = this;

inUnit.onChange = () =>
{
    width.set(0);
    height.set(0);
};

function getFpsLimit()
{
    if (reduceLoadingFPS.get() && op.patch.loading.getProgress() < 1.0) return 5;

    if (reduceFocusFPS.get())
    {
        if (!winVisible) return 10;
        if (!winhasFocus) return 30;
    }

    return fpsLimit.get();
}

function updateFullscreenButton()
{
    function onMouseEnter()
    {
        if (fsElement)fsElement.style.display = "block";
    }

    function onMouseLeave()
    {
        if (fsElement)fsElement.style.display = "none";
    }

    op.patch.cgl.canvas.addEventListener("mouseleave", onMouseLeave);
    op.patch.cgl.canvas.addEventListener("mouseenter", onMouseEnter);

    if (fullscreen.get())
    {
        if (!fsElement)
        {
            fsElement = document.createElement("div");

            const container = op.patch.cgl.canvas.parentElement;
            if (container)container.appendChild(fsElement);

            fsElement.addEventListener("mouseenter", onMouseEnter);
            fsElement.addEventListener("click", function (e)
            {
                if (CABLES.UI && !e.shiftKey) gui.cycleFullscreen();
                else cgl.fullScreen();
            });
        }

        fsElement.style.padding = "10px";
        fsElement.style.position = "absolute";
        fsElement.style.right = "5px";
        fsElement.style.top = "5px";
        fsElement.style.width = "20px";
        fsElement.style.height = "20px";
        fsElement.style.cursor = "pointer";
        fsElement.style["border-radius"] = "40px";
        fsElement.style.background = "#444";
        fsElement.style["z-index"] = "9999";
        fsElement.style.display = "none";
        fsElement.innerHTML = "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 490 490\" style=\"width:20px;height:20px;\" xml:space=\"preserve\" width=\"512px\" height=\"512px\"><g><path d=\"M173.792,301.792L21.333,454.251v-80.917c0-5.891-4.776-10.667-10.667-10.667C4.776,362.667,0,367.442,0,373.333V480     c0,5.891,4.776,10.667,10.667,10.667h106.667c5.891,0,10.667-4.776,10.667-10.667s-4.776-10.667-10.667-10.667H36.416     l152.459-152.459c4.093-4.237,3.975-10.99-0.262-15.083C184.479,297.799,177.926,297.799,173.792,301.792z\" fill=\"#FFFFFF\"/><path d=\"M480,0H373.333c-5.891,0-10.667,4.776-10.667,10.667c0,5.891,4.776,10.667,10.667,10.667h80.917L301.792,173.792     c-4.237,4.093-4.354,10.845-0.262,15.083c4.093,4.237,10.845,4.354,15.083,0.262c0.089-0.086,0.176-0.173,0.262-0.262     L469.333,36.416v80.917c0,5.891,4.776,10.667,10.667,10.667s10.667-4.776,10.667-10.667V10.667C490.667,4.776,485.891,0,480,0z\" fill=\"#FFFFFF\"/><path d=\"M36.416,21.333h80.917c5.891,0,10.667-4.776,10.667-10.667C128,4.776,123.224,0,117.333,0H10.667     C4.776,0,0,4.776,0,10.667v106.667C0,123.224,4.776,128,10.667,128c5.891,0,10.667-4.776,10.667-10.667V36.416l152.459,152.459     c4.237,4.093,10.99,3.975,15.083-0.262c3.992-4.134,3.992-10.687,0-14.82L36.416,21.333z\" fill=\"#FFFFFF\"/><path d=\"M480,362.667c-5.891,0-10.667,4.776-10.667,10.667v80.917L316.875,301.792c-4.237-4.093-10.99-3.976-15.083,0.261     c-3.993,4.134-3.993,10.688,0,14.821l152.459,152.459h-80.917c-5.891,0-10.667,4.776-10.667,10.667s4.776,10.667,10.667,10.667     H480c5.891,0,10.667-4.776,10.667-10.667V373.333C490.667,367.442,485.891,362.667,480,362.667z\" fill=\"#FFFFFF\"/></g></svg>";
    }
    else
    {
        if (fsElement)
        {
            fsElement.style.display = "none";
            fsElement.remove();
            fsElement = null;
        }
    }
}

op.onDelete = function ()
{
    cgl.gl.clearColor(0, 0, 0, 0);
    cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
};

function render(time)
{
    if (!active.get()) return;
    if (cgl.aborted || cgl.canvas.clientWidth === 0 || cgl.canvas.clientHeight === 0) return;

    op.patch.cg = cgl;

    if (hdpi.get())op.patch.cgl.pixelDensity = window.devicePixelRatio;

    const startTime = performance.now();

    op.patch.config.fpsLimit = getFpsLimit();

    if (cgl.canvasWidth == -1)
    {
        cgl.setCanvas(op.patch.config.glCanvasId);
        return;
    }

    if (cgl.canvasWidth != width.get() || cgl.canvasHeight != height.get())
    {
        let div = 1;
        if (inUnit.get() == "CSS")div = op.patch.cgl.pixelDensity;

        width.set(cgl.canvasWidth / div);
        height.set(cgl.canvasHeight / div);
    }

    if (CABLES.now() - rframeStart > 1000)
    {
        CGL.fpsReport = CGL.fpsReport || [];
        if (op.patch.loading.getProgress() >= 1.0 && rframeStart !== 0)CGL.fpsReport.push(rframes);
        rframes = 0;
        rframeStart = CABLES.now();
    }
    CGL.MESH.lastShader = null;
    CGL.MESH.lastMesh = null;

    cgl.renderStart(cgl, identTranslate, identTranslateView);

    if (clear.get())
    {
        cgl.gl.clearColor(0, 0, 0, 1);
        cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT | cgl.gl.DEPTH_BUFFER_BIT);
    }

    trigger.trigger();

    if (CGL.MESH.lastMesh)CGL.MESH.lastMesh.unBind();

    if (CGL.Texture.previewTexture)
    {
        if (!CGL.Texture.texturePreviewer) CGL.Texture.texturePreviewer = new CGL.Texture.texturePreview(cgl);
        CGL.Texture.texturePreviewer.render(CGL.Texture.previewTexture);
    }
    cgl.renderEnd(cgl);

    op.patch.cg = null;

    if (clearAlpha.get())
    {
        cgl.gl.clearColor(1, 1, 1, 1);
        cgl.gl.colorMask(false, false, false, true);
        cgl.gl.clear(cgl.gl.COLOR_BUFFER_BIT);
        cgl.gl.colorMask(true, true, true, true);
    }

    if (!cgl.frameStore.phong)cgl.frameStore.phong = {};
    rframes++;

    op.patch.cgl.profileData.profileMainloopMs = performance.now() - startTime;
}

function testMultiMainloop()
{
    clearTimeout(timeOutTest);
    timeOutTest = setTimeout(
        () =>
        {
            if (op.patch.getOpsByObjName(op.name).length > 1)
            {
                op.setUiError("multimainloop", "there should only be one mainloop op!");
                if (!addedListener)addedListener = op.patch.addEventListener("onOpDelete", testMultiMainloop);
            }
            else op.setUiError("multimainloop", null, 1);
        }, 500);
}


};

Ops.Gl.MainLoop.prototype = new CABLES.Op();
CABLES.OPS["b0472a1d-db16-4ba6-8787-f300fbdc77bb"]={f:Ops.Gl.MainLoop,objName:"Ops.Gl.MainLoop"};




// **************************************************************
// 
// Ops.Gl.Matrix.Transform
// 
// **************************************************************

Ops.Gl.Matrix.Transform = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    posX = op.inValue("posX", 0),
    posY = op.inValue("posY", 0),
    posZ = op.inValue("posZ", 0),
    scale = op.inValue("scale", 1),
    rotX = op.inValue("rotX", 0),
    rotY = op.inValue("rotY", 0),
    rotZ = op.inValue("rotZ", 0),
    trigger = op.outTrigger("trigger");

op.setPortGroup("Rotation", [rotX, rotY, rotZ]);
op.setPortGroup("Position", [posX, posY, posZ]);
op.setPortGroup("Scale", [scale]);
op.setUiAxisPorts(posX, posY, posZ);

op.toWorkPortsNeedToBeLinked(render, trigger);

const vPos = vec3.create();
const vScale = vec3.create();
const transMatrix = mat4.create();
mat4.identity(transMatrix);

let
    doScale = false,
    doTranslate = false,
    translationChanged = true,
    scaleChanged = true,
    rotChanged = true;

rotX.onChange = rotY.onChange = rotZ.onChange = setRotChanged;
posX.onChange = posY.onChange = posZ.onChange = setTranslateChanged;
scale.onChange = setScaleChanged;

render.onTriggered = function ()
{
    // if(!CGL.TextureEffect.checkOpNotInTextureEffect(op)) return;

    let updateMatrix = false;
    if (translationChanged)
    {
        updateTranslation();
        updateMatrix = true;
    }
    if (scaleChanged)
    {
        updateScale();
        updateMatrix = true;
    }
    if (rotChanged) updateMatrix = true;

    if (updateMatrix) doUpdateMatrix();

    const cg = op.patch.cg || op.patch.cgl;
    cg.pushModelMatrix();
    mat4.multiply(cg.mMatrix, cg.mMatrix, transMatrix);

    trigger.trigger();
    cg.popModelMatrix();

    if (CABLES.UI && CABLES.UI.showCanvasTransforms) gui.setTransform(op.id, posX.get(), posY.get(), posZ.get());

    if (op.isCurrentUiOp())
        gui.setTransformGizmo(
            {
                "posX": posX,
                "posY": posY,
                "posZ": posZ,
            });
};

op.transform3d = function ()
{
    return { "pos": [posX, posY, posZ] };
};

function doUpdateMatrix()
{
    mat4.identity(transMatrix);
    if (doTranslate)mat4.translate(transMatrix, transMatrix, vPos);

    if (rotX.get() !== 0)mat4.rotateX(transMatrix, transMatrix, rotX.get() * CGL.DEG2RAD);
    if (rotY.get() !== 0)mat4.rotateY(transMatrix, transMatrix, rotY.get() * CGL.DEG2RAD);
    if (rotZ.get() !== 0)mat4.rotateZ(transMatrix, transMatrix, rotZ.get() * CGL.DEG2RAD);

    if (doScale)mat4.scale(transMatrix, transMatrix, vScale);
    rotChanged = false;
}

function updateTranslation()
{
    doTranslate = false;
    if (posX.get() !== 0.0 || posY.get() !== 0.0 || posZ.get() !== 0.0) doTranslate = true;
    vec3.set(vPos, posX.get(), posY.get(), posZ.get());
    translationChanged = false;
}

function updateScale()
{
    // doScale=false;
    // if(scale.get()!==0.0)
    doScale = true;
    vec3.set(vScale, scale.get(), scale.get(), scale.get());
    scaleChanged = false;
}

function setTranslateChanged()
{
    translationChanged = true;
}

function setScaleChanged()
{
    scaleChanged = true;
}

function setRotChanged()
{
    rotChanged = true;
}

doUpdateMatrix();


};

Ops.Gl.Matrix.Transform.prototype = new CABLES.Op();
CABLES.OPS["650baeb1-db2d-4781-9af6-ab4e9d4277be"]={f:Ops.Gl.Matrix.Transform,objName:"Ops.Gl.Matrix.Transform"};




// **************************************************************
// 
// Ops.Gl.Texture_v2
// 
// **************************************************************

Ops.Gl.Texture_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    filename = op.inUrl("File", [".jpg", ".png", ".webp", ".jpeg", ".avif"]),
    tfilter = op.inSwitch("Filter", ["nearest", "linear", "mipmap"]),
    wrap = op.inValueSelect("Wrap", ["repeat", "mirrored repeat", "clamp to edge"], "clamp to edge"),
    aniso = op.inSwitch("Anisotropic", ["0", "1", "2", "4", "8", "16"], "0"),
    dataFrmt = op.inSwitch("Data Format", ["R", "RG", "RGB", "RGBA", "SRGBA"], "RGBA"),
    flip = op.inValueBool("Flip", false),
    unpackAlpha = op.inValueBool("Pre Multiplied Alpha", false),
    active = op.inValueBool("Active", true),
    inFreeMemory = op.inBool("Save Memory", true),
    textureOut = op.outTexture("Texture"),
    addCacheBust = op.inBool("Add Cachebuster", true),
    width = op.outNumber("Width"),
    height = op.outNumber("Height"),
    ratio = op.outNumber("Aspect Ratio"),
    loaded = op.outBoolNum("Loaded", 0),
    loading = op.outBoolNum("Loading", 0);

const cgl = op.patch.cgl;

op.toWorkPortsNeedToBeLinked(textureOut);
op.setPortGroup("Size", [width, height]);

let loadedFilename = null;
let loadingId = null;
let tex = null;
let cgl_filter = CGL.Texture.FILTER_MIPMAP;
let cgl_wrap = CGL.Texture.WRAP_REPEAT;
let cgl_aniso = 0;
let timedLoader = 0;

unpackAlpha.setUiAttribs({ "hidePort": true });
unpackAlpha.onChange =
    filename.onChange =
    dataFrmt.onChange =
    addCacheBust.onChange =
    flip.onChange = reloadSoon;
aniso.onChange = tfilter.onChange = onFilterChange;
wrap.onChange = onWrapChange;

tfilter.set("mipmap");
wrap.set("repeat");

textureOut.set(CGL.Texture.getEmptyTexture(cgl));

active.onChange = function ()
{
    if (active.get())
    {
        if (loadedFilename != filename.get() || !tex) reloadSoon();
        else textureOut.set(tex);
    }
    else
    {
        textureOut.set(CGL.Texture.getEmptyTexture(cgl));
        width.set(CGL.Texture.getEmptyTexture(cgl).width);
        height.set(CGL.Texture.getEmptyTexture(cgl).height);
        if (tex)tex.delete();
        op.setUiAttrib({ "extendTitle": "" });
        tex = null;
    }
};

const setTempTexture = function ()
{
    const t = CGL.Texture.getTempTexture(cgl);
    textureOut.set(t);
};

function reloadSoon(nocache)
{
    clearTimeout(timedLoader);
    timedLoader = setTimeout(function ()
    {
        realReload(nocache);
    }, 30);
}

function getPixelFormat()
{
    if (dataFrmt.get() == "R") return CGL.Texture.PFORMATSTR_R8UB;
    if (dataFrmt.get() == "RG") return CGL.Texture.PFORMATSTR_RG8UB;
    if (dataFrmt.get() == "RGB") return CGL.Texture.PFORMATSTR_RGB8UB;
    if (dataFrmt.get() == "SRGBA") return CGL.Texture.PFORMATSTR_SRGBA8;

    return CGL.Texture.PFORMATSTR_RGBA8UB;
}

function realReload(nocache)
{
    op.checkMainloopExists();
    if (!active.get()) return;
    if (loadingId)loadingId = cgl.patch.loading.finished(loadingId);

    loadingId = cgl.patch.loading.start("textureOp", filename.get(), op);

    let url = op.patch.getFilePath(String(filename.get()));

    if ((addCacheBust.get() || nocache) && CABLES.UI)url = CABLES.cacheBust(url);

    if (String(filename.get()).indexOf("data:") == 0) url = filename.get();

    let needsRefresh = false;
    loadedFilename = filename.get();

    if ((filename.get() && filename.get().length > 1))
    {
        loaded.set(false);
        loading.set(true);

        const fileToLoad = filename.get();

        op.setUiAttrib({ "extendTitle": CABLES.basename(url) });
        if (needsRefresh) op.refreshParams();

        cgl.patch.loading.addAssetLoadingTask(() =>
        {
            op.setUiError("urlerror", null);
            CGL.Texture.load(cgl, url, function (err, newTex)
            {
                cgl.checkFrameStarted("texture inittexture");

                if (filename.get() != fileToLoad)
                {
                    cgl.patch.loading.finished(loadingId);
                    loadingId = null;
                    return;
                }

                if (tex)tex.delete();

                if (err)
                {
                    const t = CGL.Texture.getErrorTexture(cgl);
                    textureOut.setRef(t);

                    op.setUiError("urlerror", "could not load texture: \"" + filename.get() + "\"", 2);
                    cgl.patch.loading.finished(loadingId);
                    loadingId = null;
                    return;
                }

                // textureOut.setRef(newTex);

                width.set(newTex.width);
                height.set(newTex.height);
                ratio.set(newTex.width / newTex.height);

                // if (!newTex.isPowerOfTwo()) op.setUiError("npot", "Texture dimensions not power of two! - Texture filtering will not work in WebGL 1.", 0);
                // else op.setUiError("npot", null);

                tex = newTex;
                // textureOut.set(null);
                textureOut.setRef(tex);

                loading.set(false);
                loaded.set(true);

                if (inFreeMemory.get()) tex.image = null;

                if (loadingId)
                {
                    cgl.patch.loading.finished(loadingId);
                    loadingId = null;
                }
                op.checkMainloopExists();
            }, {
                "anisotropic": cgl_aniso,
                "wrap": cgl_wrap,
                "flip": flip.get(),
                "unpackAlpha": unpackAlpha.get(),
                "pixelFormat": getPixelFormat(),
                "filter": cgl_filter
            });

            op.checkMainloopExists();
        });
    }
    else
    {
        cgl.patch.loading.finished(loadingId);
        loadingId = null;
        setTempTexture();
    }
}

function onFilterChange()
{
    if (tfilter.get() == "nearest") cgl_filter = CGL.Texture.FILTER_NEAREST;
    else if (tfilter.get() == "linear") cgl_filter = CGL.Texture.FILTER_LINEAR;
    else if (tfilter.get() == "mipmap") cgl_filter = CGL.Texture.FILTER_MIPMAP;
    else if (tfilter.get() == "Anisotropic") cgl_filter = CGL.Texture.FILTER_ANISOTROPIC;
    aniso.setUiAttribs({ "greyout": cgl_filter != CGL.Texture.FILTER_MIPMAP });

    cgl_aniso = parseFloat(aniso.get());

    reloadSoon();
}

function onWrapChange()
{
    if (wrap.get() == "repeat") cgl_wrap = CGL.Texture.WRAP_REPEAT;
    if (wrap.get() == "mirrored repeat") cgl_wrap = CGL.Texture.WRAP_MIRRORED_REPEAT;
    if (wrap.get() == "clamp to edge") cgl_wrap = CGL.Texture.WRAP_CLAMP_TO_EDGE;

    reloadSoon();
}

op.onFileChanged = function (fn)
{
    if (filename.get() && filename.get().indexOf(fn) > -1)
    {
        textureOut.set(CGL.Texture.getEmptyTexture(op.patch.cgl));
        textureOut.set(CGL.Texture.getTempTexture(cgl));
        realReload(true);
    }
};

// function testTexture()
// {
//     cgl.setTexture(0, tex.tex);

//     const filter = cgl.gl.getTexParameter(cgl.gl.TEXTURE_2D, cgl.gl.TEXTURE_MIN_FILTER);
//     const wrap = cgl.gl.getTexParameter(cgl.gl.TEXTURE_2D, cgl.gl.TEXTURE_WRAP_S);

//     if (cgl_filter === CGL.Texture.FILTER_MIPMAP && filter != cgl.gl.LINEAR_MIPMAP_LINEAR) console.log("wrong texture filter!", filename.get());
//     if (cgl_filter === CGL.Texture.FILTER_NEAREST && filter != cgl.gl.NEAREST) console.log("wrong texture filter!", filename.get());
//     if (cgl_filter === CGL.Texture.FILTER_LINEAR && filter != cgl.gl.LINEAR) console.log("wrong texture filter!", filename.get());

//     if (cgl_wrap === CGL.Texture.WRAP_REPEAT && wrap != cgl.gl.REPEAT) console.log("wrong texture wrap1!", filename.get());
//     if (cgl_wrap === CGL.Texture.WRAP_MIRRORED_REPEAT && wrap != cgl.gl.MIRRORED_REPEAT) console.log("wrong texture wrap2!", filename.get());
//     if (cgl_wrap === CGL.Texture.WRAP_CLAMP_TO_EDGE && wrap != cgl.gl.CLAMP_TO_EDGE) console.log("wrong texture wrap3!", filename.get());
// }


};

Ops.Gl.Texture_v2.prototype = new CABLES.Op();
CABLES.OPS["790f3702-9833-464e-8e37-6f0f813f7e16"]={f:Ops.Gl.Texture_v2,objName:"Ops.Gl.Texture_v2"};




// **************************************************************
// 
// Ops.Ui.Comment_v2
// 
// **************************************************************

Ops.Ui.Comment_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inTitle = op.inString("title", "New comment"),
    inText = op.inTextarea("text");
inTitle.setUiAttribs({ "hidePort": true });
inText.setUiAttribs({ "hidePort": true });

op.init =
    inTitle.onChange =
    inText.onChange =
    op.onLoaded = update;

update();

function update()
{
    if (CABLES.UI)
    {
        op.uiAttr(
            {
                "comment_title": inTitle.get(),
                "comment_text": inText.get()
            });

        op.name = inTitle.get();
    }
}


};

Ops.Ui.Comment_v2.prototype = new CABLES.Op();
CABLES.OPS["93492eeb-bf35-4a62-98f7-d85b0b79bfe5"]={f:Ops.Ui.Comment_v2,objName:"Ops.Ui.Comment_v2"};




// **************************************************************
// 
// Ops.Gl.Meshes.FullscreenRectangle_v2
// 
// **************************************************************

Ops.Gl.Meshes.FullscreenRectangle_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={"shader_frag":"UNI sampler2D tex;\nIN vec2 texCoord;\n\nvoid main()\n{\n    outColor= texture(tex,texCoord);\n}\n\n","shader_vert":"{{MODULES_HEAD}}\n\nIN vec3 vPosition;\nUNI mat4 projMatrix;\nUNI mat4 mvMatrix;\n\nOUT vec2 texCoord;\nIN vec2 attrTexCoord;\n\nvoid main()\n{\n   vec4 pos=vec4(vPosition,  1.0);\n\n   texCoord=vec2(attrTexCoord.x,(1.0-attrTexCoord.y));\n\n   gl_Position = projMatrix * mvMatrix * pos;\n}\n",};
const
    render = op.inTrigger("render"),
    inScale = op.inSwitch("Scale", ["Stretch", "Fit"], "Fit"),
    flipY = op.inValueBool("Flip Y"),
    flipX = op.inValueBool("Flip X"),
    inTexture = op.inTexture("Texture"),
    trigger = op.outTrigger("trigger");

const cgl = op.patch.cgl;
let mesh = null;
let geom = new CGL.Geometry("fullscreen rectangle");
let x = 0, y = 0, w = 0, h = 0;

op.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose", CABLES.OP_PORT_TYPE_FUNCTION);
op.toWorkPortsNeedToBeLinked(render);

flipX.onChange = rebuildFlip;
flipY.onChange = rebuildFlip;
render.onTriggered = doRender;
inTexture.onLinkChanged = updateUi;
inScale.onChange = updateScale;

const shader = new CGL.Shader(cgl, "fullscreenrectangle", this);
shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG"]);

shader.setSource(attachments.shader_vert, attachments.shader_frag);
shader.fullscreenRectUniform = new CGL.Uniform(shader, "t", "tex", 0);
shader.aspectUni = new CGL.Uniform(shader, "f", "aspectTex", 0);

let useShader = false;
let updateShaderLater = true;
let fitImageAspect = false;

updateUi();
updateScale();

inTexture.onChange = function ()
{
    updateShaderLater = true;
};

function updateUi()
{
    if (!CABLES.UI) return;
    flipY.setUiAttribs({ "greyout": !inTexture.isLinked() });
    flipX.setUiAttribs({ "greyout": !inTexture.isLinked() });
    inScale.setUiAttribs({ "greyout": !inTexture.isLinked() });
}

function updateShader()
{
    let tex = inTexture.get();
    if (tex) useShader = true;
    else useShader = false;
}

op.preRender = function ()
{
    updateShader();
    shader.bind();
    if (mesh)mesh.render(shader);
    doRender();
};

function updateScale()
{
    fitImageAspect = inScale.get() == "Fit";
}

function doRender()
{
    if (cgl.viewPort[2] != w || cgl.viewPort[3] != h || !mesh) rebuild();

    if (updateShaderLater) updateShader();

    cgl.pushPMatrix();
    mat4.identity(cgl.pMatrix);
    mat4.ortho(cgl.pMatrix, 0, w, h, 0, -10.0, 1000);

    cgl.pushModelMatrix();
    mat4.identity(cgl.mMatrix);

    cgl.pushViewMatrix();
    mat4.identity(cgl.vMatrix);

    if (fitImageAspect && inTexture.get())
    {
        const rat = inTexture.get().width / inTexture.get().height;

        let _h = h;
        let _w = h * rat;

        if (_w > w)
        {
            _h = w * 1 / rat;
            _w = w;
        }

        cgl.pushViewPort((w - _w) / 2, (h - _h) / 2, _w, _h);
    }

    if (useShader)
    {
        if (inTexture.get()) cgl.setTexture(0, inTexture.get().tex);
        mesh.render(shader);
    }
    else
    {
        mesh.render(cgl.getShader());
    }

    cgl.gl.clear(cgl.gl.DEPTH_BUFFER_BIT);

    cgl.popPMatrix();
    cgl.popModelMatrix();
    cgl.popViewMatrix();

    if (fitImageAspect && inTexture.get()) cgl.popViewPort();

    trigger.trigger();
}

function rebuildFlip()
{
    mesh = null;
}

function rebuild()
{
    if (cgl.viewPort[2] == w && cgl.viewPort[3] == h && mesh) return;

    let xx = 0, xy = 0;

    w = cgl.viewPort[2];
    h = cgl.viewPort[3];

    geom.vertices = new Float32Array([
        xx + w, xy + h, 0.0,
        xx, xy + h, 0.0,
        xx + w, xy, 0.0,
        xx, xy, 0.0
    ]);

    let tc = null;

    if (flipY.get())
        tc = new Float32Array([
            1.0, 0.0,
            0.0, 0.0,
            1.0, 1.0,
            0.0, 1.0
        ]);
    else
        tc = new Float32Array([
            1.0, 1.0,
            0.0, 1.0,
            1.0, 0.0,
            0.0, 0.0
        ]);

    if (flipX.get())
    {
        tc[0] = 0.0;
        tc[2] = 1.0;
        tc[4] = 0.0;
        tc[6] = 1.0;
    }

    geom.setTexCoords(tc);

    geom.verticesIndices = new Uint16Array([
        2, 1, 0,
        3, 1, 2
    ]);

    geom.vertexNormals = new Float32Array([
        0, 0, 1,
        0, 0, 1,
        0, 0, 1,
        0, 0, 1,
    ]);
    geom.tangents = new Float32Array([
        -1, 0, 0,
        -1, 0, 0,
        -1, 0, 0,
        -1, 0, 0]);
    geom.biTangents == new Float32Array([
        0, -1, 0,
        0, -1, 0,
        0, -1, 0,
        0, -1, 0]);

    if (!mesh) mesh = new CGL.Mesh(cgl, geom);
    else mesh.setGeom(geom);
}


};

Ops.Gl.Meshes.FullscreenRectangle_v2.prototype = new CABLES.Op();
CABLES.OPS["fb70721a-eac2-4ff5-a5a2-5c59e2393972"]={f:Ops.Gl.Meshes.FullscreenRectangle_v2,objName:"Ops.Gl.Meshes.FullscreenRectangle_v2"};




// **************************************************************
// 
// Ops.Gl.Matrix.OrbitControls
// 
// **************************************************************

Ops.Gl.Matrix.OrbitControls = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    minDist = op.inValueFloat("min distance"),
    maxDist = op.inValueFloat("max distance"),

    minRotY = op.inValue("min rot y", 0),
    maxRotY = op.inValue("max rot y", 0),

    initialRadius = op.inValue("initial radius", 0),
    initialAxis = op.inValueSlider("initial axis y"),
    initialX = op.inValueSlider("initial axis x"),

    mul = op.inValueFloat("mul"),
    smoothness = op.inValueSlider("Smoothness", 1.0),
    speedX = op.inValue("Speed X", 1),
    speedY = op.inValue("Speed Y", 1),

    active = op.inValueBool("Active", true),

    allowPanning = op.inValueBool("Allow Panning", true),
    allowZooming = op.inValueBool("Allow Zooming", true),
    allowRotation = op.inValueBool("Allow Rotation", true),
    restricted = op.inValueBool("restricted", true),

    trigger = op.outTrigger("trigger"),
    outRadius = op.outNumber("radius"),
    outXDeg = op.outNumber("Rot X"),
    outYDeg = op.outNumber("Rot Y"),

    inReset = op.inTriggerButton("Reset");

op.setPortGroup("Initial Values", [initialAxis, initialX, initialRadius]);
op.setPortGroup("Interaction", [mul, smoothness, speedX, speedY]);
op.setPortGroup("Boundaries", [minRotY, maxRotY, minDist, maxDist]);

mul.set(1);
minDist.set(0.01);
maxDist.set(99999);

inReset.onTriggered = reset;

let eye = vec3.create();
const vUp = vec3.create();
const vCenter = vec3.create();
const viewMatrix = mat4.create();
const tempViewMatrix = mat4.create();
const vOffset = vec3.create();
const finalEyeAbs = vec3.create();

initialAxis.set(0.5);

let mouseDown = false;
let radius = 5;
outRadius.set(radius);

let lastMouseX = 0, lastMouseY = 0;
let percX = 0, percY = 0;

vec3.set(vCenter, 0, 0, 0);
vec3.set(vUp, 0, 1, 0);

const tempEye = vec3.create();
const finalEye = vec3.create();
const tempCenter = vec3.create();
const finalCenter = vec3.create();

let px = 0;
let py = 0;

let divisor = 1;
let element = null;
updateSmoothness();

op.onDelete = unbind;

const halfCircle = Math.PI;
const fullCircle = Math.PI * 2;

function reset()
{
    let off = 0;

    if (px % fullCircle < -halfCircle)
    {
        off = -fullCircle;
        px %= -fullCircle;
    }
    else
    if (px % fullCircle > halfCircle)
    {
        off = fullCircle;
        px %= fullCircle;
    }
    else px %= fullCircle;

    py %= (Math.PI);

    vec3.set(vOffset, 0, 0, 0);
    vec3.set(vCenter, 0, 0, 0);
    vec3.set(vUp, 0, 1, 0);

    percX = (initialX.get() * Math.PI * 2 + off);
    percY = (initialAxis.get() - 0.5);

    radius = initialRadius.get();
    eye = circlePos(percY);
}

function updateSmoothness()
{
    divisor = smoothness.get() * 10 + 1.0;
}

smoothness.onChange = updateSmoothness;

let initializing = true;

function ip(val, goal)
{
    if (initializing) return goal;
    return val + (goal - val) / divisor;
}

let lastPy = 0;
const lastPx = 0;

render.onTriggered = function ()
{
    const cgl = op.patch.cg;

    if (!element)
    {
        setElement(cgl.canvas);
        bind();
    }

    cgl.pushViewMatrix();

    px = ip(px, percX);
    py = ip(py, percY);

    let degY = (py + 0.5) * 180;

    if (minRotY.get() !== 0 && degY < minRotY.get())
    {
        degY = minRotY.get();
        py = lastPy;
    }
    else if (maxRotY.get() !== 0 && degY > maxRotY.get())
    {
        degY = maxRotY.get();
        py = lastPy;
    }
    else
    {
        lastPy = py;
    }

    const degX = (px) * CGL.RAD2DEG;

    outYDeg.set(degY);
    outXDeg.set(degX);

    circlePosi(eye, py);

    vec3.add(tempEye, eye, vOffset);
    vec3.add(tempCenter, vCenter, vOffset);

    finalEye[0] = ip(finalEye[0], tempEye[0]);
    finalEye[1] = ip(finalEye[1], tempEye[1]);
    finalEye[2] = ip(finalEye[2], tempEye[2]);

    finalCenter[0] = ip(finalCenter[0], tempCenter[0]);
    finalCenter[1] = ip(finalCenter[1], tempCenter[1]);
    finalCenter[2] = ip(finalCenter[2], tempCenter[2]);

    const empty = vec3.create();

    mat4.lookAt(viewMatrix, finalEye, finalCenter, vUp);
    mat4.rotate(viewMatrix, viewMatrix, px, vUp);

    // finaly multiply current scene viewmatrix
    mat4.multiply(cgl.vMatrix, cgl.vMatrix, viewMatrix);

    trigger.trigger();
    cgl.popViewMatrix();
    initializing = false;
};

function circlePosi(vec, perc)
{
    const mmul = mul.get();
    if (radius < minDist.get() * mmul) radius = minDist.get() * mmul;
    if (radius > maxDist.get() * mmul) radius = maxDist.get() * mmul;

    outRadius.set(radius * mmul);

    let i = 0, degInRad = 0;

    degInRad = 360 * perc / 2 * CGL.DEG2RAD;
    vec3.set(vec,
        Math.cos(degInRad) * radius * mmul,
        Math.sin(degInRad) * radius * mmul,
        0);
    return vec;
}

function circlePos(perc)
{
    const mmul = mul.get();
    if (radius < minDist.get() * mmul)radius = minDist.get() * mmul;
    if (radius > maxDist.get() * mmul)radius = maxDist.get() * mmul;

    outRadius.set(radius * mmul);

    let i = 0, degInRad = 0;
    const vec = vec3.create();
    degInRad = 360 * perc / 2 * CGL.DEG2RAD;
    vec3.set(vec,
        Math.cos(degInRad) * radius * mmul,
        Math.sin(degInRad) * radius * mmul,
        0);
    return vec;
}

function onmousemove(event)
{
    if (!mouseDown) return;

    const x = event.clientX;
    const y = event.clientY;

    let movementX = (x - lastMouseX);
    let movementY = (y - lastMouseY);

    movementX *= speedX.get();
    movementY *= speedY.get();

    if (event.buttons == 2 && allowPanning.get())
    {
        vOffset[2] += movementX * 0.01 * mul.get();
        vOffset[1] += movementY * 0.01 * mul.get();
    }
    else
    if (event.buttons == 4 && allowZooming.get())
    {
        radius += movementY * 0.05;
        eye = circlePos(percY);
    }
    else
    {
        if (allowRotation.get())
        {
            percX += movementX * 0.003;
            percY += movementY * 0.002;

            if (restricted.get())
            {
                if (percY > 0.5)percY = 0.5;
                if (percY < -0.5)percY = -0.5;
            }
        }
    }

    lastMouseX = x;
    lastMouseY = y;
}

function onMouseDown(event)
{
    lastMouseX = event.clientX;
    lastMouseY = event.clientY;
    mouseDown = true;

    try { element.setPointerCapture(event.pointerId); }
    catch (e) {}
}

function onMouseUp(e)
{
    mouseDown = false;
    // cgl.canvas.style.cursor='url(/ui/img/rotate.png),pointer';

    try { element.releasePointerCapture(e.pointerId); }
    catch (e) {}
}

function lockChange()
{
    const el = op.patch.cg.canvas;

    if (document.pointerLockElement === el || document.mozPointerLockElement === el || document.webkitPointerLockElement === el)
    {
        document.addEventListener("mousemove", onmousemove, false);
    }
}

function onMouseEnter(e)
{
    // cgl.canvas.style.cursor='url(/ui/img/rotate.png),pointer';
}

initialRadius.onChange = function ()
{
    radius = initialRadius.get();
    reset();
};

initialX.onChange = function ()
{
    px = percX = (initialX.get() * Math.PI * 2);
};

initialAxis.onChange = function ()
{
    py = percY = (initialAxis.get() - 0.5);
    eye = circlePos(percY);
};

const onMouseWheel = function (event)
{
    if (allowZooming.get())
    {
        const delta = CGL.getWheelSpeed(event) * 0.06;
        radius += (parseFloat(delta)) * 1.2;

        eye = circlePos(percY);
    }
};

const ontouchstart = function (event)
{
    if (event.touches && event.touches.length > 0) onMouseDown(event.touches[0]);
};

const ontouchend = function (event)
{
    onMouseUp();
};

const ontouchmove = function (event)
{
    if (event.touches && event.touches.length > 0) onmousemove(event.touches[0]);
};

active.onChange = function ()
{
    if (active.get())bind();
    else unbind();
};

function setElement(ele)
{
    unbind();
    element = ele;
    bind();
}

function bind()
{
    if (!element) return;

    element.addEventListener("pointermove", onmousemove);
    element.addEventListener("pointerdown", onMouseDown);
    element.addEventListener("pointerup", onMouseUp);
    element.addEventListener("pointerleave", onMouseUp);
    element.addEventListener("pointerenter", onMouseEnter);
    element.addEventListener("contextmenu", function (e) { e.preventDefault(); });
    element.addEventListener("wheel", onMouseWheel, { "passive": true });
}

function unbind()
{
    if (!element) return;

    element.removeEventListener("pointermove", onmousemove);
    element.removeEventListener("pointerdown", onMouseDown);
    element.removeEventListener("pointerup", onMouseUp);
    element.removeEventListener("pointerleave", onMouseUp);
    element.removeEventListener("pointerenter", onMouseUp);
    element.removeEventListener("wheel", onMouseWheel);
}

eye = circlePos(0);

initialX.set(0.25);
initialRadius.set(0.05);


};

Ops.Gl.Matrix.OrbitControls.prototype = new CABLES.Op();
CABLES.OPS["eaf4f7ce-08a3-4d1b-b9f4-ebc0b7b1cde1"]={f:Ops.Gl.Matrix.OrbitControls,objName:"Ops.Gl.Matrix.OrbitControls"};




// **************************************************************
// 
// Ops.Gl.Meshes.Torus_v3
// 
// **************************************************************

Ops.Gl.Meshes.Torus_v3 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    render = op.inTrigger("render"),
    sides = op.inValue("sides", 32),
    rings = op.inValue("rings", 32),
    innerRadius = op.inValue("innerRadius", 0.5),
    outerRadius = op.inValue("outerRadius", 1),
    indraw = op.inBool("Draw", true),
    trigger = op.outTrigger("trigger"),
    geomOut = op.outObject("geometry");

indraw.setUiAttribs({ "title": "Render mesh" });

const UP = vec3.fromValues(0, 1, 0), RIGHT = vec3.fromValues(1, 0, 0);
let tmpNormal = vec3.create(), tmpVec = vec3.create();

geomOut.ignoreValueSerialize = true;

let cgl = op.patch.cgl;
let mesh = null;
let geom = null;
let j = 0, i = 0, idx = 0;
let needsUpdate = true;

rings.onChange =
sides.onChange =
innerRadius.onChange =
outerRadius.onChange = function ()
{
    needsUpdate = true;
};

render.onTriggered = function ()
{
    if (needsUpdate) updateMesh();
    if (indraw.get() && mesh !== null) mesh.render(cgl.getShader());

    trigger.trigger();
};

function updateMesh()
{
    let nrings = Math.round(rings.get()) + 1;
    let nsides = Math.round(sides.get()) + 1;
    if (nrings < 3)nrings = 3;
    if (nsides < 3)nsides = 3;
    let r = innerRadius.get();
    let r2 = outerRadius.get();
    generateTorus(r, r2, nrings, nsides);
    needsUpdate = false;
}

function circleTable(n, flip)
{
    let i;

    /* Table size, the sign of n flips the circle direction */
    let size = Math.abs(n);

    /* Determine the angle between samples */
    let angle = 2 * Math.PI / (n - 1);
    if (flip) angle = -angle;

    /* Allocate memory for n samples, plus duplicate of first entry at the end */
    let sint = [];
    let cost = [];

    sint[0] = 0;
    cost[0] = 1;

    /* Compute cos and sin around the circle */
    for (i = 1; i < size - 1; i++)
    {
        sint[i] = Math.sin(angle * i);
        cost[i] = Math.cos(angle * i);
    }

    sint[size - 1] = 0;
    cost[size - 1] = 1;

    return { "cost": cost, "sint": sint };
}

function generateTorus(iradius, oradius, nRings, nSides)
{
    let table1 = circleTable(nRings, false);
    let table2 = circleTable(nSides, true);
    let t;

    geom = new CGL.Geometry("torus");
    let tangents = [];
    let biTangents = [];
    let vertexNormals = [];
    let tc = [];

    for (j = 0; j < nRings; j++)
    {
        for (i = 0; i < nSides; i++)
        {
            let offset = 3 * (j * nSides + i);
            let offset2 = 2 * (j * nSides + i);

            geom.vertices[offset] = table1.cost[j] * (oradius + table2.cost[i] * iradius);
            geom.vertices[offset + 1] = table1.sint[j] * (oradius + table2.cost[i] * iradius);
            geom.vertices[offset + 2] = table2.sint[i] * iradius;

            vertexNormals[offset] = tmpNormal[0] = table1.cost[j] * table2.cost[i];
            vertexNormals[offset + 1] = tmpNormal[1] = table1.sint[j] * table2.cost[i];
            vertexNormals[offset + 2] = tmpNormal[2] = table2.sint[i];

            if (Math.abs(tmpNormal[1]) == 1) t = RIGHT;
            else t = UP;

            vec3.cross(tmpVec, tmpNormal, t);
            vec3.normalize(tmpVec, tmpVec);
            tangents[offset] = tmpVec[0];
            tangents[offset + 1] = tmpVec[1];
            tangents[offset + 2] = tmpVec[2];
            vec3.cross(tmpVec, tmpVec, tmpNormal);
            biTangents[offset] = tmpVec[0];
            biTangents[offset + 1] = tmpVec[1];
            biTangents[offset + 2] = tmpVec[2];

            tc[offset2] = j / (nRings - 1);
            tc[offset2 + 1] = i / (nSides - 1);
        }
    }

    for (j = 0, idx = 0; j < nRings - 1; j++)
    {
        for (i = 0; i < nSides - 1; i++)
        {
            let offset = j * nSides + i;
            geom.verticesIndices[idx++] = offset;
            geom.verticesIndices[idx++] = offset + 1;
            geom.verticesIndices[idx++] = offset + nSides;

            geom.verticesIndices[idx++] = offset + 1;
            geom.verticesIndices[idx++] = offset + nSides + 1;
            geom.verticesIndices[idx++] = offset + nSides;
        }
    }

    if (geom.biTangents.length == biTangents.length)geom.biTangents.set(biTangents);
    else geom.biTangents = new Float32Array(biTangents);

    if (geom.tangents.length == tangents.length)geom.tangents.set(tangents);
    else geom.tangents = new Float32Array(tangents);

    if (geom.vertexNormals.length == vertexNormals.length)geom.vertexNormals.set(vertexNormals);
    else geom.vertexNormals = new Float32Array(vertexNormals);

    geom.setTexCoords(tc);

    geomOut.set(null);
    geomOut.set(geom);

    if (!mesh)mesh = new CGL.Mesh(cgl, geom);
    else mesh.setGeom(geom);
}


};

Ops.Gl.Meshes.Torus_v3.prototype = new CABLES.Op();
CABLES.OPS["bfe60760-6cf6-43d0-96da-b4848c2b146a"]={f:Ops.Gl.Meshes.Torus_v3,objName:"Ops.Gl.Meshes.Torus_v3"};




// **************************************************************
// 
// Ops.Gl.Phong.SpotLight_v5
// 
// **************************************************************

Ops.Gl.Phong.SpotLight_v5 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const cgl = op.patch.cgl;

// * OP START *
const inTrigger = op.inTrigger("Trigger In");

const inCastLight = op.inBool("Cast Light", true);
const inIntensity = op.inFloat("Intensity", 2);
const inRadius = op.inFloat("Radius", 10);

const inPosX = op.inFloat("X", 1);
const inPosY = op.inFloat("Y", 3);
const inPosZ = op.inFloat("Z", 1);

const positionIn = [inPosX, inPosY, inPosZ];
op.setPortGroup("Position", positionIn);

const inPointAtX = op.inFloat("Point At X", 0);
const inPointAtY = op.inFloat("Point At Y", 0);
const inPointAtZ = op.inFloat("Point At Z", 0);
const pointAtIn = [inPointAtX, inPointAtY, inPointAtZ];
op.setPortGroup("Point At", pointAtIn);

const inR = op.inFloatSlider("R", 1);
const inG = op.inFloatSlider("G", 1);
const inB = op.inFloatSlider("B", 1);
inR.setUiAttribs({ "colorPick": true });
const colorIn = [inR, inG, inB];
op.setPortGroup("Color", colorIn);

const inSpecularR = op.inFloatSlider("Specular R", 1);
const inSpecularG = op.inFloatSlider("Specular G", 1);
const inSpecularB = op.inFloatSlider("Specular B", 1);
inSpecularR.setUiAttribs({ "colorPick": true });
const colorSpecularIn = [inSpecularR, inSpecularG, inSpecularB];
op.setPortGroup("Specular Color", colorSpecularIn);

const inConeAngle = op.inFloat("Cone Angle", 120);
const inConeAngleInner = op.inFloat("Inner Cone Angle", 60);
const inSpotExponent = op.inFloat("Spot Exponent", 0.97);
const coneAttribsIn = [inConeAngle, inConeAngleInner, inSpotExponent];
op.setPortGroup("Cone Attributes", coneAttribsIn);

const inFalloff = op.inFloatSlider("Falloff", 0.00001);
const lightAttribsIn = [inCastLight, inIntensity, inRadius];
op.setPortGroup("Light Attributes", lightAttribsIn);

const inCastShadow = op.inBool("Cast Shadow", false);
const inRenderMapActive = op.inBool("Rendering Active", true);
const inMapSize = op.inSwitch("Map Size", [256, 512, 1024, 2048], 512);
const inShadowStrength = op.inFloatSlider("Shadow Strength", 0.99);
const inNear = op.inFloat("Near", 0.1);
const inFar = op.inFloat("Far", 30);
const inBias = op.inFloatSlider("Bias", 0.0001);
const inPolygonOffset = op.inInt("Polygon Offset", 0);
const inNormalOffset = op.inFloatSlider("Normal Offset", 0);
const inBlur = op.inFloatSlider("Blur Amount", 0);
op.setPortGroup("", [inCastShadow]);
op.setPortGroup("Shadow Map Settings", [
    inMapSize,
    inRenderMapActive,
    inShadowStrength,
    inNear,
    inFar,
    inBias,
    inPolygonOffset,
    inNormalOffset,
    inBlur
]);

inMapSize.setUiAttribs({ "greyout": true, "hidePort": true });
inRenderMapActive.setUiAttribs({ "greyout": true });
inShadowStrength.setUiAttribs({ "greyout": true });
inNear.setUiAttribs({ "greyout": true, "hidePort": true });
inFar.setUiAttribs({ "greyout": true, "hidePort": true });
inBlur.setUiAttribs({ "greyout": true, "hidePort": true });
inPolygonOffset.setUiAttribs({ "greyout": true, "hidePort": true });
inNormalOffset.setUiAttribs({ "greyout": true, "hidePort": true });
inBias.setUiAttribs({ "greyout": true, "hidePort": true });

const inAdvanced = op.inBool("Enable Advanced", false);
const inMSAA = op.inSwitch("MSAA", ["none", "2x", "4x", "8x"], "none");
const inFilterType = op.inSwitch("Texture Filter", ["Linear", "Nearest", "Mip Map"], "Linear");
const inAnisotropic = op.inSwitch("Anisotropic", [0, 1, 2, 4, 8, 16], "0");
inMSAA.setUiAttribs({ "greyout": true, "hidePort": true });
inFilterType.setUiAttribs({ "greyout": true, "hidePort": true });
inAnisotropic.setUiAttribs({ "greyout": true, "hidePort": true });
op.setPortGroup("Advanced Options", [inAdvanced, inMSAA, inFilterType, inAnisotropic]);

let updating = false;

inAdvanced.setUiAttribs({ "hidePort": true });

inAdvanced.onChange = function ()
{
    inMSAA.setUiAttribs({ "greyout": !inAdvanced.get() });
    inFilterType.setUiAttribs({ "greyout": !inAdvanced.get() });
    inAnisotropic.setUiAttribs({ "greyout": !inAdvanced.get() });
};

const outTrigger = op.outTrigger("Trigger Out");
const outTexture = op.outTexture("Shadow Map");
const outWorldPosX = op.outNumber("World Position X");
const outWorldPosY = op.outNumber("World Position Y");
const outWorldPosZ = op.outNumber("World Position Z");

const newLight = new CGL.Light(cgl, {
    "type": "spot",
    "position": [0, 1, 2].map(function (i) { return positionIn[i].get(); }),
    "color": [0, 1, 2].map(function (i) { return colorIn[i].get(); }),
    "specular": [0, 1, 2].map(function (i) { return colorSpecularIn[i].get(); }),
    "conePointAt": [0, 1, 2].map(function (i) { return pointAtIn[i].get(); }),
    "intensity": inIntensity.get(),
    "radius": inRadius.get(),
    "falloff": inFalloff.get(),
    "cosConeAngleInner": Math.cos(CGL.DEG2RAD * inConeAngleInner.get()),
    "cosConeAngle": Math.cos(CGL.DEG2RAD * inConeAngle.get()),
    "spotExponent": inSpotExponent.get(),
    "castShadow": false,
    "shadowStrength": inShadowStrength.get(),
    "shadowBias": inBias.get(),
    "normalOffset": inNormalOffset.get(),
});
newLight.castLight = inCastLight.get();

let updateLight = false;
inR.onChange = inG.onChange = inB.onChange = inSpecularR.onChange = inSpecularG.onChange = inSpecularB.onChange
= inPointAtX.onChange = inPointAtY.onChange = inPointAtZ.onChange = inPosX.onChange = inPosY.onChange = inPosZ.onChange;
inCastLight.onChange = inIntensity.onChange = inRadius.onChange = inFalloff.onChange = inConeAngle.onChange = inConeAngleInner.onChange
= inSpotExponent.onChange = inShadowStrength.onChange = inNear.onChange = inFar.onChange = updateLightParameters;

function updateLightParameters()
{
    updateLight = true;
}

inCastShadow.onChange = function ()
{
    updating = true;
    const castShadow = inCastShadow.get();

    inMapSize.setUiAttribs({ "greyout": !castShadow });
    inRenderMapActive.setUiAttribs({ "greyout": !castShadow });
    inShadowStrength.setUiAttribs({ "greyout": !castShadow });
    inNear.setUiAttribs({ "greyout": !castShadow });
    inFar.setUiAttribs({ "greyout": !castShadow });
    inNormalOffset.setUiAttribs({ "greyout": !castShadow });
    inBlur.setUiAttribs({ "greyout": !castShadow });
    inBias.setUiAttribs({ "greyout": !castShadow });
    inPolygonOffset.setUiAttribs({ "greyout": !castShadow });

    updateLight = true;
};

let texelSize = 1 / Number(inMapSize.get());

function updateBuffers()
{
    const MSAA = Number(inMSAA.get().charAt(0));

    let filterType = null;
    const anisotropyFactor = Number(inAnisotropic.get());

    if (inFilterType.get() == "Linear")
    {
        filterType = CGL.Texture.FILTER_LINEAR;
    }
    else if (inFilterType.get() == "Nearest")
    {
        filterType = CGL.Texture.FILTER_NEAREST;
    }
    else if (inFilterType.get() == "Mip Map")
    {
        filterType = CGL.Texture.FILTER_MIPMAP;
    }

    const mapSize = Number(inMapSize.get());
    const textureOptions = {
        "isFloatingPointTexture": true,
        "filter": filterType,
    };

    if (MSAA) Object.assign(textureOptions, { "multisampling": true, "multisamplingSamples": MSAA });
    Object.assign(textureOptions, { "anisotropic": anisotropyFactor });

    newLight.createFramebuffer(mapSize, mapSize, textureOptions);
    newLight.createBlurEffect(textureOptions);
}

inMSAA.onChange = inAnisotropic.onChange = inFilterType.onChange = inMapSize.onChange = function ()
{
    updating = true;
};

function updateShadowMapFramebuffer()
{
    const size = Number(inMapSize.get());
    texelSize = 1 / size;

    if (inCastShadow.get())
    {
        newLight.createFramebuffer(Number(inMapSize.get()), Number(inMapSize.get()), {});
        newLight.createShadowMapShader();
        newLight.createBlurEffect({});
        newLight.createBlurShader();
        newLight.updateProjectionMatrix(null, inNear.get(), inFar.get(), inConeAngle.get());
    }

    if (inAdvanced.get()) updateBuffers();

    updating = false;
}

const position = vec3.create();
const pointAtPos = vec3.create();
const resultPos = vec3.create();
const resultPointAt = vec3.create();

function drawHelpers()
{
    if (cgl.frameStore.shadowPass) return;
    if (cgl.shouldDrawHelpers(op))
    {
        gui.setTransformGizmo({
            "posX": inPosX,
            "posY": inPosY,
            "posZ": inPosZ,
        });

        CABLES.GL_MARKER.drawLineSourceDest(
            op,
            newLight.position[0],
            newLight.position[1],
            newLight.position[2],
            newLight.conePointAt[0],
            newLight.conePointAt[1],
            newLight.conePointAt[2],
        );
    }
}

let errorActive = false;
inTrigger.onTriggered = renderLight;

op.preRender = () =>
{
    updateShadowMapFramebuffer();
    renderLight();
};

function renderLight()
{
    if (updating)
    {
        if (cgl.frameStore.shadowPass) return;
        updateShadowMapFramebuffer();
    }

    if (!cgl.frameStore.shadowPass)
    {
        if (!newLight.isUsed && !errorActive)
        {
            op.setUiError("lightUsed", "No operator is using this light. Make sure this op is positioned before an operator that uses lights. Also make sure there is an operator that uses lights after this.", 1); // newLight.isUsed = false;
            errorActive = true;
        }
        else if (!newLight.isUsed && errorActive) {}
        else if (newLight.isUsed && errorActive)
        {
            op.setUiError("lightUsed", null);
            errorActive = false;
        }
        else if (newLight.isUsed && !errorActive) {}
        newLight.isUsed = false;
    }

    if (updateLight)
    {
        newLight.position = [0, 1, 2].map(function (i) { return positionIn[i].get(); });
        newLight.color = [0, 1, 2].map(function (i) { return colorIn[i].get(); });
        newLight.specular = [0, 1, 2].map(function (i) { return colorSpecularIn[i].get(); });
        newLight.conePointAt = [0, 1, 2].map(function (i) { return pointAtIn[i].get(); });
        newLight.intensity = inIntensity.get();
        newLight.castLight = inCastLight.get();
        newLight.radius = inRadius.get();
        newLight.falloff = inFalloff.get();
        newLight.cosConeAngleInner = Math.cos(CGL.DEG2RAD * inConeAngleInner.get());
        newLight.cosConeAngle = Math.cos(CGL.DEG2RAD * inConeAngle.get());
        newLight.spotExponent = inSpotExponent.get();
        newLight.castShadow = inCastShadow.get();
        newLight.updateProjectionMatrix(null, inNear.get(), inFar.get(), inConeAngle.get());
    }

    if (!cgl.frameStore.lightStack) cgl.frameStore.lightStack = [];

    vec3.set(position, inPosX.get(), inPosY.get(), inPosZ.get());
    vec3.set(pointAtPos, inPointAtX.get(), inPointAtY.get(), inPointAtZ.get());

    vec3.transformMat4(resultPos, position, cgl.mMatrix);
    vec3.transformMat4(resultPointAt, pointAtPos, cgl.mMatrix);

    newLight.position = resultPos;
    newLight.conePointAt = resultPointAt;

    outWorldPosX.set(newLight.position[0]);
    outWorldPosY.set(newLight.position[1]);
    outWorldPosZ.set(newLight.position[2]);

    if (!cgl.frameStore.shadowPass) drawHelpers();

    cgl.frameStore.lightStack.push(newLight);

    if (inCastShadow.get())
    {
        const blurAmount = 1.5 * inBlur.get() * texelSize;
        if (inRenderMapActive.get()) newLight.renderPasses(inPolygonOffset.get(), blurAmount, function () { outTrigger.trigger(); });
        outTexture.set(null);
        outTexture.set(newLight.getShadowMapDepth());

        // remove light from stack and readd it with shadow map & mvp matrix
        cgl.frameStore.lightStack.pop();

        newLight.castShadow = inCastShadow.get();
        newLight.blurAmount = inBlur.get();
        newLight.normalOffset = inNormalOffset.get();
        newLight.shadowBias = inBias.get();
        newLight.shadowStrength = inShadowStrength.get();
        cgl.frameStore.lightStack.push(newLight);
    }

    outTrigger.trigger();

    cgl.frameStore.lightStack.pop();
}


};

Ops.Gl.Phong.SpotLight_v5.prototype = new CABLES.Op();
CABLES.OPS["76418c17-abd5-401b-82e2-688db6f966ee"]={f:Ops.Gl.Phong.SpotLight_v5,objName:"Ops.Gl.Phong.SpotLight_v5"};




// **************************************************************
// 
// Ops.Gl.Phong.PhongMaterial_v6
// 
// **************************************************************

Ops.Gl.Phong.PhongMaterial_v6 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={"phong_frag":"IN vec3 viewDirection;\nIN vec3 normInterpolated;\nIN vec2 texCoord;\n\n#ifdef AO_CHAN_1\n    #ifndef ATTRIB_texCoord1\n        #define ATTRIB_texCoord1\n\n        IN vec2 texCoord1;\n    #endif\n#endif\n\n#ifdef HAS_TEXTURE_AO\nvec2 tcAo;\n#endif\n\n\n\n#ifdef ENABLE_FRESNEL\n    IN vec4 cameraSpace_pos;\n#endif\n\n// IN mat3 normalMatrix; // when instancing...\n\n#ifdef HAS_TEXTURE_NORMAL\n    IN mat3 TBN_Matrix; // tangent bitangent normal space transform matrix\n#endif\n\nIN vec3 fragPos;\nIN vec3 v_viewDirection;\n\nUNI vec4 inDiffuseColor;\nUNI vec4 inMaterialProperties;\n\n#ifdef ADD_EMISSIVE_COLOR\n    UNI vec4 inEmissiveColor; // .w = intensity\n#endif\n\n#ifdef ENABLE_FRESNEL\n    UNI mat4 viewMatrix;\n    UNI vec4 inFresnel;\n    UNI vec2 inFresnelWidthExponent;\n#endif\n\n#ifdef ENVMAP_MATCAP\n    IN vec3 viewSpaceNormal;\n    IN vec3 viewSpacePosition;\n#endif\n\nstruct Light {\n    vec3 color;\n    vec3 position;\n    vec3 specular;\n\n\n    // * SPOT LIGHT * //\n    #ifdef HAS_SPOT\n        vec3 conePointAt;\n        #define COSCONEANGLE x\n        #define COSCONEANGLEINNER y\n        #define SPOTEXPONENT z\n        vec3 spotProperties;\n    #endif\n\n    #define INTENSITY x\n    #define ATTENUATION y\n    #define FALLOFF z\n    #define RADIUS w\n    vec4 lightProperties;\n\n    int castLight;\n};\n\n/* CONSTANTS */\n#define NONE -1\n#define ALBEDO x\n#define ROUGHNESS y\n#define SHININESS z\n#define SPECULAR_AMT w\n#define NORMAL x\n#define AO y\n#define SPECULAR z\n#define EMISSIVE w\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = (2. * PI);\nconst float EIGHT_PI = (8. * PI);\n\n#define RECIPROCAL_PI 1./PI\n#define RECIPROCAL_PI2 RECIPROCAL_PI/2.\n\n// TEXTURES\n// #ifdef HAS_TEXTURES\n    UNI vec4 inTextureIntensities;\n\n    #ifdef HAS_TEXTURE_ENV\n        #ifdef TEX_FORMAT_CUBEMAP\n            UNI samplerCube texEnv;\n            #ifndef WEBGL1\n                #define SAMPLETEX textureLod\n            #endif\n            #ifdef WEBGL1\n                #define SAMPLETEX textureCubeLodEXT\n            #endif\n        #endif\n\n        #ifdef TEX_FORMAT_EQUIRECT\n            UNI sampler2D texEnv;\n            #ifdef WEBGL1\n                // #extension GL_EXT_shader_texture_lod : enable\n                #ifdef GL_EXT_shader_texture_lod\n                    #define textureLod texture2DLodEXT\n                #endif\n                // #define textureLod texture2D\n            #endif\n\n            #define SAMPLETEX sampleEquirect\n\n            const vec2 invAtan = vec2(0.1591, 0.3183);\n            vec4 sampleEquirect(sampler2D tex,vec3 direction,float lod)\n            {\n                #ifndef WEBGL1\n                    vec3 newDirection = normalize(direction);\n            \t\tvec2 sampleUV;\n            \t\tsampleUV.x = -1. * (atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.75);\n            \t\tsampleUV.y = asin( clamp(direction.y, -1., 1.) ) * RECIPROCAL_PI + 0.5;\n                #endif\n\n                #ifdef WEBGL1\n                    vec3 newDirection = normalize(direction);\n                \t\tvec2 sampleUV = vec2(atan(newDirection.z, newDirection.x), asin(newDirection.y+1e-6));\n                        sampleUV *= vec2(0.1591, 0.3183);\n                        sampleUV += 0.5;\n                #endif\n                return textureLod(tex, sampleUV, lod);\n            }\n        #endif\n        #ifdef ENVMAP_MATCAP\n            UNI sampler2D texEnv;\n            #ifdef WEBGL1\n                // #extension GL_EXT_shader_texture_lod : enable\n                #ifdef GL_EXT_shader_texture_lod\n                    #define textureLod texture2DLodEXT\n                #endif\n                // #define textureLod texture2D\n            #endif\n\n\n            // * taken & modified from https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderLib/meshmatcap_frag.glsl.js\n            vec2 getMatCapUV(vec3 viewSpacePosition, vec3 viewSpaceNormal) {\n                vec3 viewDir = normalize(-viewSpacePosition);\n            \tvec3 x = normalize(vec3(viewDir.z, 0.0, - viewDir.x));\n            \tvec3 y = normalize(cross(viewDir, x));\n            \tvec2 uv = vec2(dot(x, viewSpaceNormal), dot(y, viewSpaceNormal)) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n            \treturn uv;\n            }\n        #endif\n\n        UNI float inEnvMapIntensity;\n        UNI float inEnvMapWidth;\n    #endif\n\n    #ifdef HAS_TEXTURE_LUMINANCE_MASK\n        UNI sampler2D texLuminance;\n        UNI float inLuminanceMaskIntensity;\n    #endif\n\n    #ifdef HAS_TEXTURE_DIFFUSE\n        UNI sampler2D texDiffuse;\n    #endif\n\n    #ifdef HAS_TEXTURE_SPECULAR\n        UNI sampler2D texSpecular;\n    #endif\n\n    #ifdef HAS_TEXTURE_NORMAL\n        UNI sampler2D texNormal;\n    #endif\n\n    #ifdef HAS_TEXTURE_AO\n        UNI sampler2D texAO;\n    #endif\n\n    #ifdef HAS_TEXTURE_EMISSIVE\n        UNI sampler2D texEmissive;\n    #endif\n\n    #ifdef HAS_TEXTURE_EMISSIVE_MASK\n        UNI sampler2D texMaskEmissive;\n        UNI float inEmissiveMaskIntensity;\n    #endif\n    #ifdef HAS_TEXTURE_ALPHA\n        UNI sampler2D texAlpha;\n    #endif\n// #endif\n\n{{MODULES_HEAD}}\n\nfloat when_gt(float x, float y) { return max(sign(x - y), 0.0); } // comparator function\nfloat when_lt(float x, float y) { return max(sign(y - x), 0.0); }\nfloat when_eq(float x, float y) { return 1. - abs(sign(x - y)); } // comparator function\nfloat when_neq(float x, float y) { return abs(sign(x - y)); } // comparator function\nfloat when_ge(float x, float y) { return 1.0 - when_lt(x, y); }\nfloat when_le(float x, float y) { return 1.0 - when_gt(x, y); }\n\n#ifdef FALLOFF_MODE_A\n    float CalculateFalloff(float distance, vec3 lightDirection, float falloff, float radius) {\n        // * original falloff\n        float denom = distance / radius + 1.0;\n        float attenuation = 1.0 / (denom*denom);\n        float t = (attenuation - falloff) / (1.0 - falloff);\n        return max(t, 0.0);\n    }\n#endif\n\n#ifdef FALLOFF_MODE_B\n    float CalculateFalloff(float distance, vec3 lightDirection, float falloff, float radius) {\n        float distanceSquared = dot(lightDirection, lightDirection);\n        float factor = distanceSquared * falloff;\n        float smoothFactor = clamp(1. - factor * factor, 0., 1.);\n        float attenuation = smoothFactor * smoothFactor;\n\n        return attenuation * 1. / max(distanceSquared, 0.00001);\n    }\n#endif\n\n#ifdef FALLOFF_MODE_C\n    float CalculateFalloff(float distance, vec3 lightDirection, float falloff, float radius) {\n        // https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n        float falloffNumerator = 1. - pow(distance/radius, 4.);\n        falloffNumerator = clamp(falloffNumerator, 0., 1.);\n        falloffNumerator *= falloffNumerator;\n\n        float denominator = distance*distance + falloff;\n\n        return falloffNumerator/denominator;\n    }\n#endif\n\n#ifdef FALLOFF_MODE_D\n    float CalculateFalloff(float distance, vec3 lightDirection, float falloff, float radius) {\n        // inverse square falloff, \"physically correct\"\n        return 1.0 / max(distance * distance, 0.0001);\n    }\n#endif\n\n#ifdef ENABLE_FRESNEL\n    float CalculateFresnel(vec3 direction, vec3 normal)\n    {\n        vec3 nDirection = normalize( direction );\n        vec3 nNormal = normalize( mat3(viewMatrix) * normal );\n        vec3 halfDirection = normalize( nNormal + nDirection );\n\n        float cosine = dot( halfDirection, nDirection );\n        float product = max( cosine, 0.0 );\n        float factor = pow(product, inFresnelWidthExponent.y);\n\n        return 5. * factor;\n    }\n#endif\n\n#ifdef CONSERVE_ENERGY\n    // http://www.rorydriscoll.com/2009/01/25/energy-conservation-in-games/\n    // http://www.farbrausch.de/~fg/articles/phong.pdf\n    float EnergyConservation(float shininess) {\n        #ifdef SPECULAR_PHONG\n            return (shininess + 2.)/TWO_PI;\n        #endif\n        #ifdef SPECULAR_BLINN\n            return (shininess + 8.)/EIGHT_PI;\n        #endif\n\n        #ifdef SPECULAR_SCHLICK\n            return (shininess + 8.)/EIGHT_PI;\n        #endif\n\n        #ifdef SPECULAR_GAUSS\n            return (shininess + 8.)/EIGHT_PI;\n        #endif\n    }\n#endif\n\n#ifdef ENABLE_OREN_NAYAR_DIFFUSE\n    float CalculateOrenNayar(vec3 lightDirection, vec3 viewDirection, vec3 normal) {\n        float LdotV = dot(lightDirection, viewDirection);\n        float NdotL = dot(lightDirection, normal);\n        float NdotV = dot(normal, viewDirection);\n\n        float albedo = inMaterialProperties.ALBEDO;\n        albedo *= 1.8;\n        float s = LdotV - NdotL * NdotV;\n        float t = mix(1., max(NdotL, NdotV), step(0., s));\n\n        float roughness = inMaterialProperties.ROUGHNESS;\n        float sigma2 = roughness * roughness;\n        float A = 1. + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n        float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n        float factor = albedo * max(0., NdotL) * (A + B * s / t) / PI;\n\n        return factor;\n\n    }\n#endif\n\nvec3 CalculateDiffuseColor(\n    vec3 lightDirection,\n    vec3 viewDirection,\n    vec3 normal,\n    vec3 lightColor,\n    vec3 materialColor,\n    inout float lambert\n) {\n    #ifndef ENABLE_OREN_NAYAR_DIFFUSE\n        lambert = clamp(dot(lightDirection, normal), 0., 1.);\n    #endif\n\n    #ifdef ENABLE_OREN_NAYAR_DIFFUSE\n        lambert = CalculateOrenNayar(lightDirection, viewDirection, normal);\n    #endif\n\n    vec3 diffuseColor = lambert * lightColor * materialColor;\n    return diffuseColor;\n}\n\nvec3 CalculateSpecularColor(\n    vec3 specularColor,\n    float specularCoefficient,\n    float shininess,\n    vec3 lightDirection,\n    vec3 viewDirection,\n    vec3 normal,\n    float lambertian\n) {\n    vec3 resultColor = vec3(0.);\n\n    #ifdef SPECULAR_PHONG\n        vec3 reflectDirection = reflect(-lightDirection, normal);\n        float specularAngle = max(dot(reflectDirection, viewDirection), 0.);\n        float specularFactor = pow(specularAngle, max(0., shininess));\n    resultColor = lambertian * specularFactor * specularCoefficient * specularColor;\n    #endif\n\n    #ifdef SPECULAR_BLINN\n        vec3 halfDirection = normalize(lightDirection + viewDirection);\n        float specularAngle = max(dot(halfDirection, normal), 0.);\n        float specularFactor = pow(specularAngle, max(0., shininess));\n        resultColor = lambertian * specularFactor * specularCoefficient * specularColor;\n    #endif\n\n    #ifdef SPECULAR_SCHLICK\n        vec3 halfDirection = normalize(lightDirection + viewDirection);\n        float specularAngle = dot(halfDirection, normal);\n        float schlickShininess = max(0., shininess);\n        float specularFactor = specularAngle / (schlickShininess - schlickShininess*specularAngle + specularAngle);\n        resultColor = lambertian * specularFactor * specularCoefficient * specularColor;\n    #endif\n\n    #ifdef SPECULAR_GAUSS\n        vec3 halfDirection = normalize(lightDirection + viewDirection);\n        float specularAngle = acos(max(dot(halfDirection, normal), 0.));\n        float exponent = specularAngle * shininess * 0.17;\n        exponent = -(exponent*exponent);\n        float specularFactor = exp(exponent);\n\n        resultColor = lambertian * specularFactor * specularCoefficient * specularColor;\n    #endif\n\n    #ifdef CONSERVE_ENERGY\n        float conserveEnergyFactor = EnergyConservation(shininess);\n        resultColor = conserveEnergyFactor * resultColor;\n    #endif\n\n    return resultColor;\n}\n\n#ifdef HAS_SPOT\n    float CalculateSpotLightEffect(vec3 lightPosition, vec3 conePointAt, float cosConeAngle, float cosConeAngleInner, float spotExponent, vec3 lightDirection) {\n        vec3 spotLightDirection = normalize(lightPosition-conePointAt);\n        float spotAngle = dot(-lightDirection, spotLightDirection);\n        float epsilon = cosConeAngle - cosConeAngleInner;\n\n        float spotIntensity = clamp((spotAngle - cosConeAngle)/epsilon, 0.0, 1.0);\n        spotIntensity = pow(spotIntensity, max(0.01, spotExponent));\n\n        return max(0., spotIntensity);\n    }\n#endif\n\n\n\n{{PHONG_FRAGMENT_HEAD}}\n\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n\n    vec4 col=vec4(0., 0., 0., inDiffuseColor.a);\n    vec3 calculatedColor = vec3(0.);\n    vec3 normal = normalize(normInterpolated);\n    vec3 baseColor = inDiffuseColor.rgb;\n\n    {{MODULE_BASE_COLOR}}\n\n\n\n    #ifdef AO_CHAN_0\n        vec2 tcAo=texCoord;\n    #endif\n    #ifdef AO_CHAN_1\n        vec2 tcAo=texCoord1;\n    #endif\n\n\n    vec3 viewDirection = normalize(v_viewDirection);\n\n    #ifdef DOUBLE_SIDED\n        if(!gl_FrontFacing) normal = normal * -1.0;\n    #endif\n\n    #ifdef HAS_TEXTURES\n        #ifdef HAS_TEXTURE_DIFFUSE\n            baseColor = texture(texDiffuse, texCoord).rgb;\n\n            #ifdef COLORIZE_TEXTURE\n                baseColor *= inDiffuseColor.rgb;\n            #endif\n        #endif\n\n        #ifdef HAS_TEXTURE_NORMAL\n            normal = texture(texNormal, texCoord).rgb;\n            normal = normalize(normal * 2. - 1.);\n            float normalIntensity = inTextureIntensities.NORMAL;\n            normal = normalize(mix(vec3(0., 0., 1.), normal, 2. * normalIntensity));\n            normal = normalize(TBN_Matrix * normal);\n        #endif\n    #endif\n\n    {{PHONG_FRAGMENT_BODY}}\n\n\n\n\n\n\n    #ifdef ENABLE_FRESNEL\n        calculatedColor += inFresnel.rgb * (CalculateFresnel(vec3(cameraSpace_pos), normal) * inFresnel.w * inFresnelWidthExponent.x);\n    #endif\n\n     #ifdef HAS_TEXTURE_ALPHA\n        #ifdef ALPHA_MASK_ALPHA\n            col.a*=texture(texAlpha,texCoord).a;\n        #endif\n        #ifdef ALPHA_MASK_LUMI\n            col.a*= dot(vec3(0.2126,0.7152,0.0722), texture(texAlpha,texCoord).rgb);\n        #endif\n        #ifdef ALPHA_MASK_R\n            col.a*=texture(texAlpha,texCoord).r;\n        #endif\n        #ifdef ALPHA_MASK_G\n            col.a*=texture(texAlpha,texCoord).g;\n        #endif\n        #ifdef ALPHA_MASK_B\n            col.a*=texture(texAlpha,texCoord).b;\n        #endif\n    #endif\n\n    #ifdef DISCARDTRANS\n        if(col.a<0.2) discard;\n    #endif\n\n\n    #ifdef HAS_TEXTURE_ENV\n        vec3 luminanceColor = vec3(0.);\n\n        #ifndef ENVMAP_MATCAP\n            float environmentMapWidth = inEnvMapWidth;\n            float glossyExponent = inMaterialProperties.SHININESS;\n            float glossyCoefficient = inMaterialProperties.SPECULAR_AMT;\n\n            vec3 envMapNormal =  normal;\n            vec3 reflectDirection = reflect(normalize(-viewDirection), normal);\n\n            float lambertianCoefficient = dot(viewDirection, reflectDirection); //0.44; // TODO: need prefiltered map for this\n            // lambertianCoefficient = 1.;\n            float specularAngle = max(dot(reflectDirection, viewDirection), 0.);\n            float specularFactor = pow(specularAngle, max(0., inMaterialProperties.SHININESS));\n\n            glossyExponent = specularFactor;\n\n            float maxMIPLevel = 10.;\n            float MIPlevel = log2(environmentMapWidth / 1024. * sqrt(3.)) - 0.5 * log2(glossyExponent + 1.);\n\n            luminanceColor = inEnvMapIntensity * (\n                inDiffuseColor.rgb *\n                SAMPLETEX(texEnv, envMapNormal, maxMIPLevel).rgb\n                +\n                glossyCoefficient * SAMPLETEX(texEnv, reflectDirection, MIPlevel).rgb\n            );\n        #endif\n        #ifdef ENVMAP_MATCAP\n            luminanceColor = inEnvMapIntensity * (\n                texture(texEnv, getMatCapUV(viewSpacePosition, viewSpaceNormal)).rgb\n                //inDiffuseColor.rgb\n                //* textureLod(texEnv, getMatCapUV(envMapNormal), maxMIPLevel).rgb\n                //+\n                //glossyCoefficient * textureLod(texEnv, getMatCapUV(reflectDirection), MIPlevel).rgb\n            );\n        #endif\n\n\n\n        #ifdef HAS_TEXTURE_LUMINANCE_MASK\n            luminanceColor *= texture(texLuminance, texCoord).r * inLuminanceMaskIntensity;\n        #endif\n\n        #ifdef HAS_TEXTURE_AO\n            luminanceColor *= texture(texAO, tcAo).r*inTextureIntensities.AO;\n        #endif\n\n        #ifdef ENV_BLEND_ADD\n            calculatedColor.rgb += luminanceColor;\n        #endif\n        #ifdef ENV_BLEND_MUL\n            calculatedColor.rgb *= luminanceColor;\n        #endif\n\n        #ifdef ENV_BLEND_MIX\n            calculatedColor.rgb=mix(luminanceColor,calculatedColor.rgb,luminanceColor);\n        #endif\n\n\n    #endif\n\n    #ifdef ADD_EMISSIVE_COLOR\n        vec3 emissiveRadiance = mix(calculatedColor, inEmissiveColor.rgb, inEmissiveColor.w); // .w = intensity of color;\n\n        #ifdef HAS_TEXTURE_EMISSIVE\n            float emissiveIntensity = inTextureIntensities.EMISSIVE;\n            emissiveRadiance = mix(calculatedColor, texture(texEmissive, texCoord).rgb, emissiveIntensity);\n        #endif\n\n        #ifdef HAS_TEXTURE_EMISSIVE_MASK\n           float emissiveMixValue = mix(1., texture(texMaskEmissive, texCoord).r, inEmissiveMaskIntensity);\n           calculatedColor = mix(calculatedColor, emissiveRadiance, emissiveMixValue);\n        #endif\n\n        #ifndef HAS_TEXTURE_EMISSIVE_MASK\n            calculatedColor = emissiveRadiance;\n        #endif\n    #endif\n\n    col.rgb = clamp(calculatedColor, 0., 1.);\n\n\n    {{MODULE_COLOR}}\n\n    outColor = col;\n\n}\n","phong_vert":"\n{{MODULES_HEAD}}\n\n#define NONE -1\n#define AMBIENT 0\n#define POINT 1\n#define DIRECTIONAL 2\n#define SPOT 3\n\n#define TEX_REPEAT_X x;\n#define TEX_REPEAT_Y y;\n#define TEX_OFFSET_X z;\n#define TEX_OFFSET_Y w;\n\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\nIN float attrVertIndex;\nIN vec3 attrTangent;\nIN vec3 attrBiTangent;\n\nOUT vec2 texCoord;\nOUT vec3 normInterpolated;\nOUT vec3 fragPos;\n\n#ifdef AO_CHAN_1\n    #ifndef ATTRIB_attrTexCoord1\n        IN vec2 attrTexCoord1;\n        OUT vec2 texCoord1;\n        #define ATTRIB_attrTexCoord1\n        #define ATTRIB_texCoord1\n    #endif\n#endif\n\n#ifdef HAS_TEXTURE_NORMAL\n    OUT mat3 TBN_Matrix; // tangent bitangent normal space transform matrix\n#endif\n\n#ifdef ENABLE_FRESNEL\n    OUT vec4 cameraSpace_pos;\n#endif\n\nOUT vec3 v_viewDirection;\nOUT mat3 normalMatrix;\nOUT mat4 mvMatrix;\n\n#ifdef HAS_TEXTURES\n    UNI vec4 inTextureRepeatOffset;\n#endif\n\nUNI vec3 camPos;\nUNI mat4 projMatrix;\nUNI mat4 viewMatrix;\nUNI mat4 modelMatrix;\n\n#ifdef ENVMAP_MATCAP\n    OUT vec3 viewSpaceNormal;\n    OUT vec3 viewSpacePosition;\n#endif\n\n\nmat3 transposeMat3(mat3 m)\n{\n    return mat3(m[0][0], m[1][0], m[2][0],\n        m[0][1], m[1][1], m[2][1],\n        m[0][2], m[1][2], m[2][2]);\n}\n\nmat3 inverseMat3(mat3 m)\n{\n    float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n    float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n    float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n    float b01 = a22 * a11 - a12 * a21;\n    float b11 = -a22 * a10 + a12 * a20;\n    float b21 = a21 * a10 - a11 * a20;\n\n    float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n        b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n        b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nvoid main()\n{\n    mat4 mMatrix=modelMatrix;\n    vec4 pos=vec4(vPosition,  1.0);\n\n    texCoord=attrTexCoord;\n    texCoord.y = 1. - texCoord.y;\n\n    #ifdef ATTRIB_texCoord1\n        texCoord1=attrTexCoord1;\n    #endif\n\n    vec3 norm=attrVertNormal;\n    vec3 tangent = attrTangent;\n    vec3 bitangent = attrBiTangent;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    normalMatrix = transposeMat3(inverseMat3(mat3(mMatrix)));\n    mvMatrix = (viewMatrix * mMatrix);\n\n\n\n    #ifdef ENABLE_FRESNEL\n        cameraSpace_pos = mvMatrix * pos;\n    #endif\n\n    #ifdef HAS_TEXTURES\n        float repeatX = inTextureRepeatOffset.TEX_REPEAT_X;\n        float offsetX = inTextureRepeatOffset.TEX_OFFSET_X;\n        float repeatY = inTextureRepeatOffset.TEX_REPEAT_Y;\n        float offsetY = inTextureRepeatOffset.TEX_OFFSET_Y;\n\n        texCoord.x *= repeatX;\n        texCoord.x += offsetX;\n        texCoord.y *= repeatY;\n        texCoord.y += offsetY;\n    #endif\n\n   normInterpolated = vec3(normalMatrix*norm);\n\n    #ifdef HAS_TEXTURE_NORMAL\n        vec3 normCameraSpace = normalize((vec4(normInterpolated, 0.0)).xyz);\n        vec3 tangCameraSpace = normalize((mMatrix * vec4(tangent, 0.0)).xyz);\n        vec3 bitangCameraSpace = normalize((mMatrix * vec4(bitangent, 0.0)).xyz);\n\n        // re orthogonalization for smoother normals\n        tangCameraSpace = normalize(tangCameraSpace - dot(tangCameraSpace, normCameraSpace) * normCameraSpace);\n        bitangCameraSpace = cross(normCameraSpace, tangCameraSpace);\n\n        TBN_Matrix = mat3(tangCameraSpace, bitangCameraSpace, normCameraSpace);\n    #endif\n\n    fragPos = vec3((mMatrix) * pos);\n    v_viewDirection = normalize(camPos - fragPos);\n    // modelPos=mMatrix*pos;\n\n    #ifdef ENVMAP_MATCAP\n        mat3 viewSpaceNormalMatrix = normalMatrix = transposeMat3(inverseMat3(mat3(mvMatrix)));\n        viewSpaceNormal = normalize(viewSpaceNormalMatrix * norm);\n        viewSpacePosition = vec3(mvMatrix * pos);\n    #endif\n\n    mat4 modelViewMatrix=mvMatrix;\n    {{MODULE_VERTEX_MOVELVIEW}}\n\n\n    gl_Position = projMatrix * modelViewMatrix * pos;\n}\n","snippet_body_ambient_frag":"    // * AMBIENT LIGHT {{LIGHT_INDEX}} *\n    vec3 diffuseColor{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.lightProperties.INTENSITY*phongLight{{LIGHT_INDEX}}.color;\n    calculatedColor += diffuseColor{{LIGHT_INDEX}};\n","snippet_body_directional_frag":"    // * DIRECTIONAL LIGHT {{LIGHT_INDEX}} *\n\n    if (phongLight{{LIGHT_INDEX}}.castLight == 1) {\n        vec3 phongLightDirection{{LIGHT_INDEX}} = normalize(phongLight{{LIGHT_INDEX}}.position);\n\n        float phongLambert{{LIGHT_INDEX}} = 1.; // inout variable\n\n        vec3 lightColor{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.color;\n        vec3 lightSpecular{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.specular;\n\n        #ifdef HAS_TEXTURES\n            #ifdef HAS_TEXTURE_AO\n                // lightColor{{LIGHT_INDEX}} *= mix(vec3(1.), texture(texAO, texCoord).rgb, inTextureIntensities.AO);\n                lightColor{{LIGHT_INDEX}} *= texture(texAO, tcAo).g, inTextureIntensities.AO;\n\n            #endif\n\n            #ifdef HAS_TEXTURE_SPECULAR\n                lightSpecular{{LIGHT_INDEX}} *= mix(1., texture(texSpecular, texCoord).r, inTextureIntensities.SPECULAR);\n            #endif\n        #endif\n\n        vec3 diffuseColor{{LIGHT_INDEX}} = CalculateDiffuseColor(phongLightDirection{{LIGHT_INDEX}}, viewDirection, normal, lightColor{{LIGHT_INDEX}}, baseColor, phongLambert{{LIGHT_INDEX}});\n        vec3 specularColor{{LIGHT_INDEX}} = CalculateSpecularColor(\n            lightSpecular{{LIGHT_INDEX}},\n            inMaterialProperties.SPECULAR_AMT,\n            inMaterialProperties.SHININESS,\n            phongLightDirection{{LIGHT_INDEX}},\n            viewDirection,\n            normal,\n            phongLambert{{LIGHT_INDEX}}\n        );\n\n        vec3 combinedColor{{LIGHT_INDEX}} = (diffuseColor{{LIGHT_INDEX}} + specularColor{{LIGHT_INDEX}});\n\n        vec3 lightModelDiff{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.position - fragPos.xyz;\n\n        combinedColor{{LIGHT_INDEX}} *= phongLight{{LIGHT_INDEX}}.lightProperties.INTENSITY;\n        calculatedColor += combinedColor{{LIGHT_INDEX}};\n    }","snippet_body_point_frag":"// * POINT LIGHT {{LIGHT_INDEX}} *\n    if (phongLight{{LIGHT_INDEX}}.castLight == 1) {\n        vec3 phongLightDirection{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.position - fragPos.xyz;\n        // * get length before normalization for falloff calculation\n        phongLightDirection{{LIGHT_INDEX}} = normalize(phongLightDirection{{LIGHT_INDEX}});\n        float phongLightDistance{{LIGHT_INDEX}} = length(phongLightDirection{{LIGHT_INDEX}});\n\n        float phongLambert{{LIGHT_INDEX}} = 1.; // inout variable\n\n        vec3 lightColor{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.color;\n        vec3 lightSpecular{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.specular;\n\n        #ifdef HAS_TEXTURES\n            #ifdef HAS_TEXTURE_AO\n                lightColor{{LIGHT_INDEX}} -= (1.0-texture(texAO, tcAo).g)* (inTextureIntensities.AO);\n            #endif\n\n            #ifdef HAS_TEXTURE_SPECULAR\n                lightSpecular{{LIGHT_INDEX}} *= mix(1., texture(texSpecular, texCoord).r, inTextureIntensities.SPECULAR);\n            #endif\n        #endif\n\n        vec3 diffuseColor{{LIGHT_INDEX}} = CalculateDiffuseColor(phongLightDirection{{LIGHT_INDEX}}, viewDirection, normal, lightColor{{LIGHT_INDEX}}, baseColor, phongLambert{{LIGHT_INDEX}});\n        vec3 specularColor{{LIGHT_INDEX}} = CalculateSpecularColor(\n            lightSpecular{{LIGHT_INDEX}},\n            inMaterialProperties.SPECULAR_AMT,\n            inMaterialProperties.SHININESS,\n            phongLightDirection{{LIGHT_INDEX}},\n            viewDirection,\n            normal,\n            phongLambert{{LIGHT_INDEX}}\n        );\n\n        vec3 combinedColor{{LIGHT_INDEX}} = (diffuseColor{{LIGHT_INDEX}} + specularColor{{LIGHT_INDEX}});\n\n        combinedColor{{LIGHT_INDEX}} *= phongLight{{LIGHT_INDEX}}.lightProperties.INTENSITY;\n\n        float attenuation{{LIGHT_INDEX}} = CalculateFalloff(\n            phongLightDistance{{LIGHT_INDEX}},\n            phongLightDirection{{LIGHT_INDEX}},\n            phongLight{{LIGHT_INDEX}}.lightProperties.FALLOFF,\n            phongLight{{LIGHT_INDEX}}.lightProperties.RADIUS\n        );\n\n        attenuation{{LIGHT_INDEX}} *= when_gt(phongLambert{{LIGHT_INDEX}}, 0.);\n        combinedColor{{LIGHT_INDEX}} *= attenuation{{LIGHT_INDEX}};\n\n        calculatedColor += combinedColor{{LIGHT_INDEX}};\n    }\n","snippet_body_spot_frag":"    // * SPOT LIGHT {{LIGHT_INDEX}} *\n    if (phongLight{{LIGHT_INDEX}}.castLight == 1) {\n        vec3 phongLightDirection{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.position - fragPos.xyz;\n        phongLightDirection{{LIGHT_INDEX}} = normalize( phongLightDirection{{LIGHT_INDEX}});\n        float phongLightDistance{{LIGHT_INDEX}} = length(phongLightDirection{{LIGHT_INDEX}});\n\n        float phongLambert{{LIGHT_INDEX}} = 1.; // inout variable\n\n        vec3 lightColor{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.color;\n        vec3 lightSpecular{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.specular;\n\n        #ifdef HAS_TEXTURES\n            #ifdef HAS_TEXTURE_AO\n                // lightColor{{LIGHT_INDEX}} *= mix(vec3(1.), texture(texAO, texCoord).rgb, inTextureIntensities.AO);\n                lightColor{{LIGHT_INDEX}} *= texture(texAO, texCoord).g, inTextureIntensities.AO;\n\n            #endif\n\n            #ifdef HAS_TEXTURE_SPECULAR\n                lightSpecular{{LIGHT_INDEX}} *= mix(1., texture(texSpecular, texCoord).r, inTextureIntensities.SPECULAR);\n            #endif\n        #endif\n\n        vec3 diffuseColor{{LIGHT_INDEX}} = CalculateDiffuseColor(phongLightDirection{{LIGHT_INDEX}}, viewDirection, normal, lightColor{{LIGHT_INDEX}}, baseColor, phongLambert{{LIGHT_INDEX}});\n        vec3 specularColor{{LIGHT_INDEX}} = CalculateSpecularColor(\n            lightSpecular{{LIGHT_INDEX}},\n            inMaterialProperties.SPECULAR_AMT,\n            inMaterialProperties.SHININESS,\n            phongLightDirection{{LIGHT_INDEX}},\n            viewDirection,\n            normal,\n            phongLambert{{LIGHT_INDEX}}\n        );\n\n        vec3 combinedColor{{LIGHT_INDEX}} = (diffuseColor{{LIGHT_INDEX}} + specularColor{{LIGHT_INDEX}});\n\n        float spotIntensity{{LIGHT_INDEX}} = CalculateSpotLightEffect(\n            phongLight{{LIGHT_INDEX}}.position, phongLight{{LIGHT_INDEX}}.conePointAt, phongLight{{LIGHT_INDEX}}.spotProperties.COSCONEANGLE,\n            phongLight{{LIGHT_INDEX}}.spotProperties.COSCONEANGLEINNER, phongLight{{LIGHT_INDEX}}.spotProperties.SPOTEXPONENT,\n            phongLightDirection{{LIGHT_INDEX}}\n        );\n\n        combinedColor{{LIGHT_INDEX}} *= spotIntensity{{LIGHT_INDEX}};\n\n        vec3 lightModelDiff{{LIGHT_INDEX}} = phongLight{{LIGHT_INDEX}}.position - fragPos.xyz;\n\n        float attenuation{{LIGHT_INDEX}} = CalculateFalloff(\n            phongLightDistance{{LIGHT_INDEX}},\n            phongLightDirection{{LIGHT_INDEX}},\n            phongLight{{LIGHT_INDEX}}.lightProperties.FALLOFF,\n            phongLight{{LIGHT_INDEX}}.lightProperties.RADIUS\n        );\n\n        attenuation{{LIGHT_INDEX}} *= when_gt(phongLambert{{LIGHT_INDEX}}, 0.);\n\n        combinedColor{{LIGHT_INDEX}} *= attenuation{{LIGHT_INDEX}};\n\n        combinedColor{{LIGHT_INDEX}} *= phongLight{{LIGHT_INDEX}}.lightProperties.INTENSITY;\n        calculatedColor += combinedColor{{LIGHT_INDEX}};\n    }","snippet_head_frag":"UNI Light phongLight{{LIGHT_INDEX}};\n",};
const cgl = op.patch.cgl;

const attachmentFragmentHead = attachments.snippet_head_frag;
const snippets = {
    "point": attachments.snippet_body_point_frag,
    "spot": attachments.snippet_body_spot_frag,
    "ambient": attachments.snippet_body_ambient_frag,
    "directional": attachments.snippet_body_directional_frag,
    "area": attachments.snippet_body_area_frag,
};
const LIGHT_INDEX_REGEX = new RegExp("{{LIGHT_INDEX}}", "g");

const createFragmentHead = (n) => { return attachmentFragmentHead.replace("{{LIGHT_INDEX}}", n); };
const createFragmentBody = (n, type) => { return snippets[type].replace(LIGHT_INDEX_REGEX, n); };

function createDefaultShader()
{
    const vertexShader = attachments.phong_vert;
    let fragmentShader = attachments.phong_frag;

    let fragmentHead = createFragmentHead(0);
    let fragmentBody = createFragmentBody(0, DEFAULT_LIGHTSTACK[0].type);

    fragmentShader = fragmentShader.replace(FRAGMENT_HEAD_REGEX, fragmentHead);
    fragmentShader = fragmentShader.replace(FRAGMENT_BODY_REGEX, fragmentBody);

    shader.setSource(vertexShader, fragmentShader);
    shader.define("HAS_POINT");
    shader.removeDefine("HAS_SPOT");
    shader.removeDefine("HAS_DIRECTIONAL");
    shader.removeDefine("HAS_AMBIENT");
}

const inTrigger = op.inTrigger("Trigger In");

// * DIFFUSE *
const inDiffuseR = op.inFloat("R", Math.random());
const inDiffuseG = op.inFloat("G", Math.random());
const inDiffuseB = op.inFloat("B", Math.random());
const inDiffuseA = op.inFloatSlider("A", 1);
const diffuseColors = [inDiffuseR, inDiffuseG, inDiffuseB, inDiffuseA];
op.setPortGroup("Diffuse Color", diffuseColors);

const inToggleOrenNayar = op.inBool("Enable", false);
const inAlbedo = op.inFloatSlider("Albedo", 0.707);
const inRoughness = op.inFloatSlider("Roughness", 0.835);

inToggleOrenNayar.setUiAttribs({ "hidePort": true });
inAlbedo.setUiAttribs({ "greyout": true });
inRoughness.setUiAttribs({ "greyout": true });
inDiffuseR.setUiAttribs({ "colorPick": true });
op.setPortGroup("Oren-Nayar Diffuse", [inToggleOrenNayar, inAlbedo, inRoughness]);
op.toWorkShouldNotBeChild("Ops.Gl.TextureEffects.ImageCompose", CABLES.OP_PORT_TYPE_FUNCTION);

inToggleOrenNayar.onChange = function ()
{
    shader.toggleDefine("ENABLE_OREN_NAYAR_DIFFUSE", inToggleOrenNayar);
    inAlbedo.setUiAttribs({ "greyout": !inToggleOrenNayar.get() });
    inRoughness.setUiAttribs({ "greyout": !inToggleOrenNayar.get() });
};

// * FRESNEL *
const inToggleFresnel = op.inValueBool("Active", false);
inToggleFresnel.setUiAttribs({ "hidePort": true });
const inFresnel = op.inValueSlider("Fresnel Intensity", 0.7);
const inFresnelWidth = op.inFloat("Fresnel Width", 1);
const inFresnelExponent = op.inFloat("Fresnel Exponent", 6);
const inFresnelR = op.inFloat("Fresnel R", 1);
const inFresnelG = op.inFloat("Fresnel G", 1);
const inFresnelB = op.inFloat("Fresnel B", 1);
inFresnelR.setUiAttribs({ "colorPick": true });

const fresnelArr = [inFresnel, inFresnelWidth, inFresnelExponent, inFresnelR, inFresnelG, inFresnelB];
fresnelArr.forEach(function (port) { port.setUiAttribs({ "greyout": true }); });
op.setPortGroup("Fresnel", fresnelArr.concat([inToggleFresnel]));

let uniFresnel = null;
let uniFresnelWidthExponent = null;
inToggleFresnel.onChange = function ()
{
    shader.toggleDefine("ENABLE_FRESNEL", inToggleFresnel);
    if (inToggleFresnel.get())
    {
        if (!uniFresnel) uniFresnel = new CGL.Uniform(shader, "4f", "inFresnel", inFresnelR, inFresnelG, inFresnelB, inFresnel);
        if (!uniFresnelWidthExponent) uniFresnelWidthExponent = new CGL.Uniform(shader, "2f", "inFresnelWidthExponent", inFresnelWidth, inFresnelExponent);
    }
    else
    {
        if (uniFresnel)
        {
            shader.removeUniform("inFresnel");
            uniFresnel = null;
        }

        if (uniFresnelWidthExponent)
        {
            shader.removeUniform("inFresnelWidthExponent");
            uniFresnelWidthExponent = null;
        }
    }

    fresnelArr.forEach(function (port) { port.setUiAttribs({ "greyout": !inToggleFresnel.get() }); });
};
// * EMISSIVE *
const inEmissiveActive = op.inBool("Emissive Active", false);
const inEmissiveColorIntensity = op.inFloatSlider("Color Intensity", 0.3);
const inEmissiveR = op.inFloatSlider("Emissive R", Math.random());
const inEmissiveG = op.inFloatSlider("Emissive G", Math.random());
const inEmissiveB = op.inFloatSlider("Emissive B", Math.random());
inEmissiveR.setUiAttribs({ "colorPick": true });
op.setPortGroup("Emissive Color", [inEmissiveActive, inEmissiveColorIntensity, inEmissiveR, inEmissiveG, inEmissiveB]);

inEmissiveColorIntensity.setUiAttribs({ "greyout": !inEmissiveActive.get() });
inEmissiveR.setUiAttribs({ "greyout": !inEmissiveActive.get() });
inEmissiveG.setUiAttribs({ "greyout": !inEmissiveActive.get() });
inEmissiveB.setUiAttribs({ "greyout": !inEmissiveActive.get() });

let uniEmissiveColor = null;

inEmissiveActive.onChange = () =>
{
    shader.toggleDefine("ADD_EMISSIVE_COLOR", inEmissiveActive);

    if (inEmissiveActive.get())
    {
        uniEmissiveColor = new CGL.Uniform(shader, "4f", "inEmissiveColor", inEmissiveR, inEmissiveG, inEmissiveB, inEmissiveColorIntensity);
        inEmissiveTexture.setUiAttribs({ "greyout": false });
        inEmissiveMaskTexture.setUiAttribs({ "greyout": false });

        if (inEmissiveTexture.get()) inEmissiveIntensity.setUiAttribs({ "greyout": false });
        if (inEmissiveMaskTexture.get()) inEmissiveMaskIntensity.setUiAttribs({ "greyout": false });
    }
    else
    {
        op.log("ayayay");
        inEmissiveTexture.setUiAttribs({ "greyout": true });
        inEmissiveMaskTexture.setUiAttribs({ "greyout": true });
        inEmissiveIntensity.setUiAttribs({ "greyout": true });
        inEmissiveMaskIntensity.setUiAttribs({ "greyout": true });

        shader.removeUniform("inEmissiveColor");
        uniEmissiveColor = null;
    }

    if (inEmissiveTexture.get())
    {
        inEmissiveColorIntensity.setUiAttribs({ "greyout": true });
        inEmissiveR.setUiAttribs({ "greyout": true });
        inEmissiveG.setUiAttribs({ "greyout": true });
        inEmissiveB.setUiAttribs({ "greyout": true });
    }
    else
    {
        if (inEmissiveActive.get())
        {
            inEmissiveColorIntensity.setUiAttribs({ "greyout": false });
            inEmissiveR.setUiAttribs({ "greyout": false });
            inEmissiveG.setUiAttribs({ "greyout": false });
            inEmissiveB.setUiAttribs({ "greyout": false });
        }
        else
        {
            inEmissiveColorIntensity.setUiAttribs({ "greyout": true });
            inEmissiveR.setUiAttribs({ "greyout": true });
            inEmissiveG.setUiAttribs({ "greyout": true });
            inEmissiveB.setUiAttribs({ "greyout": true });
        }
    }
};
// * SPECULAR *
const inShininess = op.inFloat("Shininess", 4);
const inSpecularCoefficient = op.inFloatSlider("Specular Amount", 0.5);
const inSpecularMode = op.inSwitch("Specular Model", ["Blinn", "Schlick", "Phong", "Gauss"], "Blinn");

inSpecularMode.setUiAttribs({ "hidePort": true });
const specularColors = [inShininess, inSpecularCoefficient, inSpecularMode];
op.setPortGroup("Specular", specularColors);

// * LIGHT *
const inEnergyConservation = op.inValueBool("Energy Conservation", false);
const inToggleDoubleSided = op.inBool("Double Sided Material", false);
const inFalloffMode = op.inSwitch("Falloff Mode", ["A", "B", "C", "D"], "A");
inEnergyConservation.setUiAttribs({ "hidePort": true });
inToggleDoubleSided.setUiAttribs({ "hidePort": true });
inFalloffMode.setUiAttribs({ "hidePort": true });
inFalloffMode.onChange = () =>
{
    const MODES = ["A", "B", "C", "D"];
    shader.define("FALLOFF_MODE_" + inFalloffMode.get());
    MODES.filter((mode) => { return mode !== inFalloffMode.get(); })
        .forEach((mode) => { return shader.removeDefine("FALLOFF_MODE_" + mode); });
};

const lightProps = [inEnergyConservation, inToggleDoubleSided, inFalloffMode];
op.setPortGroup("Light Options", lightProps);

// TEXTURES
const inDiffuseTexture = op.inTexture("Diffuse Texture");
const inSpecularTexture = op.inTexture("Specular Texture");
const inNormalTexture = op.inTexture("Normal Map");
const inAoTexture = op.inTexture("AO Texture");
const inEmissiveTexture = op.inTexture("Emissive Texture");
const inEmissiveMaskTexture = op.inTexture("Emissive Mask");
const inAlphaTexture = op.inTexture("Opacity Texture");
const inEnvTexture = op.inTexture("Environment Map");
const inLuminanceMaskTexture = op.inTexture("Env Map Mask");
op.setPortGroup("Textures", [inDiffuseTexture, inSpecularTexture, inNormalTexture, inAoTexture, inEmissiveTexture, inEmissiveMaskTexture, inAlphaTexture, inEnvTexture, inLuminanceMaskTexture]);

// TEXTURE TRANSFORMS
const inColorizeTexture = op.inBool("Colorize Texture", false);
const inDiffuseRepeatX = op.inFloat("Diffuse Repeat X", 1);
const inDiffuseRepeatY = op.inFloat("Diffuse Repeat Y", 1);
const inTextureOffsetX = op.inFloat("Texture Offset X", 0);
const inTextureOffsetY = op.inFloat("Texture Offset Y", 0);

const inSpecularIntensity = op.inFloatSlider("Specular Intensity", 1);
const inNormalIntensity = op.inFloatSlider("Normal Map Intensity", 0.5);
const inAoIntensity = op.inFloatSlider("AO Intensity", 1);
const inAoChannel = op.inSwitch("AO UV Channel", ["1", "2"], 1);
const inEmissiveIntensity = op.inFloatSlider("Emissive Intensity", 1);
const inEmissiveMaskIntensity = op.inFloatSlider("Emissive Mask Intensity", 1);
const inEnvMapIntensity = op.inFloatSlider("Env Map Intensity", 1);
const inEnvMapBlend = op.inSwitch("Env Map Blend", ["Add", "Multiply", "Mix"], "Add");
const inLuminanceMaskIntensity = op.inFloatSlider("Env Mask Intensity", 1);

inColorizeTexture.setUiAttribs({ "hidePort": true });
op.setPortGroup("Texture Transforms", [inColorizeTexture, inDiffuseRepeatY, inDiffuseRepeatX, inTextureOffsetY, inTextureOffsetX]);
op.setPortGroup("Texture Intensities", [inNormalIntensity, inAoIntensity, inSpecularIntensity, inEmissiveIntensity, inEnvMapBlend, inEmissiveMaskIntensity, inEnvMapIntensity, inLuminanceMaskIntensity]);
const alphaMaskSource = op.inSwitch("Alpha Mask Source", ["Luminance", "R", "G", "B", "A"], "Luminance");
alphaMaskSource.setUiAttribs({ "greyout": true });

const discardTransPxl = op.inValueBool("Discard Transparent Pixels");
discardTransPxl.setUiAttribs({ "hidePort": true });

op.setPortGroup("Opacity Texture", [alphaMaskSource, discardTransPxl]);

inAoChannel.onChange =
    inEnvMapBlend.onChange =
    alphaMaskSource.onChange = updateDefines;

const outTrigger = op.outTrigger("Trigger Out");
const shaderOut = op.outObject("Shader", null, "shader");
shaderOut.ignoreValueSerialize = true;

const shader = new CGL.Shader(cgl, "phongmaterial_" + op.id, this);
shader.op = this;
shader.setModules(["MODULE_VERTEX_POSITION", "MODULE_COLOR", "MODULE_BEGIN_FRAG", "MODULE_BASE_COLOR", "MODULE_VERTEX_MOVELVIEW"]);
shader.setSource(attachments.simosphong_vert, attachments.simosphong_frag);
// let recompileShader = false;
shader.define("FALLOFF_MODE_A");

if (cgl.glVersion < 2)
{
    shader.enableExtension("GL_OES_standard_derivatives");

    if (cgl.enableExtension("OES_texture_float")) shader.enableExtension("GL_OES_texture_float");
    else op.log("error loading extension OES_texture_float");

    if (cgl.enableExtension("OES_texture_float_linear")) shader.enableExtension("GL_OES_texture_float_linear");
    else op.log("error loading extention OES_texture_float_linear");

    if (cgl.enableExtension("GL_OES_texture_half_float")) shader.enableExtension("GL_OES_texture_half_float");
    else op.log("error loading extention GL_OES_texture_half_float");

    if (cgl.enableExtension("GL_OES_texture_half_float_linear")) shader.enableExtension("GL_OES_texture_half_float_linear");
    else op.log("error loading extention GL_OES_texture_half_float_linear");
}

const FRAGMENT_HEAD_REGEX = new RegExp("{{PHONG_FRAGMENT_HEAD}}", "g");
const FRAGMENT_BODY_REGEX = new RegExp("{{PHONG_FRAGMENT_BODY}}", "g");

const hasLight = {
    "directional": false,
    "spot": false,
    "ambient": false,
    "point": false,
};

function createShader(lightStack)
{
    let fragmentShader = attachments.phong_frag;

    let fragmentHead = "";
    let fragmentBody = "";

    hasLight.directional = false;
    hasLight.spot = false;
    hasLight.ambient = false;
    hasLight.point = false;

    for (let i = 0; i < lightStack.length; i += 1)
    {
        const light = lightStack[i];

        const type = light.type;

        if (!hasLight[type])
        {
            hasLight[type] = true;
        }

        fragmentHead = fragmentHead.concat(createFragmentHead(i));
        fragmentBody = fragmentBody.concat(createFragmentBody(i, light.type));
    }

    fragmentShader = fragmentShader.replace(FRAGMENT_HEAD_REGEX, fragmentHead);
    fragmentShader = fragmentShader.replace(FRAGMENT_BODY_REGEX, fragmentBody);

    shader.setSource(attachments.phong_vert, fragmentShader);

    for (let i = 0, keys = Object.keys(hasLight); i < keys.length; i += 1)
    {
        const key = keys[i];

        if (hasLight[key])
        {
            if (!shader.hasDefine("HAS_" + key.toUpperCase()))
            {
                shader.define("HAS_" + key.toUpperCase());
            }
        }
        else
        {
            if (shader.hasDefine("HAS_" + key.toUpperCase()))
            {
                shader.removeDefine("HAS_" + key.toUpperCase());
            }
        }
    }
}

shaderOut.set(shader);

let diffuseTextureUniform = null;
let specularTextureUniform = null;
let normalTextureUniform = null;
let aoTextureUniform = null;
let emissiveTextureUniform = null;
let emissiveMaskTextureUniform = null;
let emissiveMaskIntensityUniform = null;
let alphaTextureUniform = null;
let envTextureUniform = null;
let inEnvMapIntensityUni = null;
let inEnvMapWidthUni = null;
let luminanceTextureUniform = null;
let inLuminanceMaskIntensityUniform = null;

inColorizeTexture.onChange = function ()
{
    shader.toggleDefine("COLORIZE_TEXTURE", inColorizeTexture.get());
};

function updateDiffuseTexture()
{
    if (inDiffuseTexture.get())
    {
        if (!shader.hasDefine("HAS_TEXTURE_DIFFUSE"))
        {
            shader.define("HAS_TEXTURE_DIFFUSE");
            if (!diffuseTextureUniform) diffuseTextureUniform = new CGL.Uniform(shader, "t", "texDiffuse", 0);
        }
    }
    else
    {
        shader.removeUniform("texDiffuse");
        shader.removeDefine("HAS_TEXTURE_DIFFUSE");
        diffuseTextureUniform = null;
    }
}

function updateSpecularTexture()
{
    if (inSpecularTexture.get())
    {
        inSpecularIntensity.setUiAttribs({ "greyout": false });
        if (!shader.hasDefine("HAS_TEXTURE_SPECULAR"))
        {
            shader.define("HAS_TEXTURE_SPECULAR");
            if (!specularTextureUniform) specularTextureUniform = new CGL.Uniform(shader, "t", "texSpecular", 0);
        }
    }
    else
    {
        inSpecularIntensity.setUiAttribs({ "greyout": true });
        shader.removeUniform("texSpecular");
        shader.removeDefine("HAS_TEXTURE_SPECULAR");
        specularTextureUniform = null;
    }
}

function updateNormalTexture()
{
    if (inNormalTexture.get())
    {
        inNormalIntensity.setUiAttribs({ "greyout": false });

        if (!shader.hasDefine("HAS_TEXTURE_NORMAL"))
        {
            shader.define("HAS_TEXTURE_NORMAL");
            if (!normalTextureUniform) normalTextureUniform = new CGL.Uniform(shader, "t", "texNormal", 0);
        }
    }
    else
    {
        inNormalIntensity.setUiAttribs({ "greyout": true });

        shader.removeUniform("texNormal");
        shader.removeDefine("HAS_TEXTURE_NORMAL");
        normalTextureUniform = null;
    }
}

aoTextureUniform = new CGL.Uniform(shader, "t", "texAO");

function updateAoTexture()
{
    shader.toggleDefine("HAS_TEXTURE_AO", inAoTexture.get());

    inAoIntensity.setUiAttribs({ "greyout": !inAoTexture.get() });

    // if (inAoTexture.get())
    // {
    //     // inAoIntensity.setUiAttribs({ "greyout": false });

    //     // if (!shader.hasDefine("HAS_TEXTURE_AO"))
    //     // {
    //         // shader.define("HAS_TEXTURE_AO");
    //         // if (!aoTextureUniform)
    //         aoTextureUniform = new CGL.Uniform(shader, "t", "texAO", 0);
    //     // }
    // }
    // else
    // {
    //     // inAoIntensity.setUiAttribs({ "greyout": true });

    //     shader.removeUniform("texAO");
    //     // shader.removeDefine("HAS_TEXTURE_AO");
    //     aoTextureUniform = null;
    // }
}

function updateEmissiveTexture()
{
    if (inEmissiveTexture.get())
    {
        inEmissiveR.setUiAttribs({ "greyout": true });
        inEmissiveG.setUiAttribs({ "greyout": true });
        inEmissiveB.setUiAttribs({ "greyout": true });
        inEmissiveColorIntensity.setUiAttribs({ "greyout": true });

        if (inEmissiveActive.get())
        {
            inEmissiveIntensity.setUiAttribs({ "greyout": false });
        }

        if (!shader.hasDefine("HAS_TEXTURE_EMISSIVE"))
        {
            shader.define("HAS_TEXTURE_EMISSIVE");
            if (!emissiveTextureUniform) emissiveTextureUniform = new CGL.Uniform(shader, "t", "texEmissive", 0);
        }
    }
    else
    {
        inEmissiveIntensity.setUiAttribs({ "greyout": true });

        if (inEmissiveActive.get())
        {
            inEmissiveR.setUiAttribs({ "greyout": false });
            inEmissiveG.setUiAttribs({ "greyout": false });
            inEmissiveB.setUiAttribs({ "greyout": false });
            inEmissiveColorIntensity.setUiAttribs({ "greyout": false });
        }
        else
        {
            inEmissiveTexture.setUiAttribs({ "greyout": true });
        }

        shader.removeUniform("texEmissive");
        shader.removeDefine("HAS_TEXTURE_EMISSIVE");
        emissiveTextureUniform = null;
    }
}

function updateEmissiveMaskTexture()
{
    if (inEmissiveMaskTexture.get())
    { // we have a emissive texture
        if (inEmissiveActive.get())
        {
            inEmissiveMaskIntensity.setUiAttribs({ "greyout": false });
        }

        if (!shader.hasDefine("HAS_TEXTURE_EMISSIVE_MASK"))
        {
            shader.define("HAS_TEXTURE_EMISSIVE_MASK");
            if (!emissiveMaskTextureUniform) emissiveMaskTextureUniform = new CGL.Uniform(shader, "t", "texMaskEmissive", 0);
            if (!emissiveMaskIntensityUniform) emissiveMaskIntensityUniform = new CGL.Uniform(shader, "f", "inEmissiveMaskIntensity", inEmissiveMaskIntensity);
        }
    }
    else
    {
        if (!inEmissiveActive.get())
        {
            inEmissiveMaskTexture.setUiAttribs({ "greyout": true });
        }
        inEmissiveMaskIntensity.setUiAttribs({ "greyout": true });
        shader.removeUniform("texMaskEmissive");
        shader.removeUniform("inEmissiveMaskIntensity");
        shader.removeDefine("HAS_TEXTURE_EMISSIVE_MASK");
        emissiveMaskTextureUniform = null;
        emissiveMaskIntensityUniform = null;
    }
}

let updateEnvTextureLater = false;
function updateEnvTexture()
{
    shader.toggleDefine("HAS_TEXTURE_ENV", inEnvTexture.get());

    inEnvMapIntensity.setUiAttribs({ "greyout": !inEnvTexture.get() });

    if (inEnvTexture.get())
    {
        if (!envTextureUniform) envTextureUniform = new CGL.Uniform(shader, "t", "texEnv", 0);

        shader.toggleDefine("TEX_FORMAT_CUBEMAP", inEnvTexture.get().cubemap);

        if (inEnvTexture.get().cubemap)
        {
            shader.removeDefine("TEX_FORMAT_EQUIRECT");
            shader.removeDefine("ENVMAP_MATCAP");
            if (!inEnvMapIntensityUni)inEnvMapIntensityUni = new CGL.Uniform(shader, "f", "inEnvMapIntensity", inEnvMapIntensity);
            if (!inEnvMapWidthUni)inEnvMapWidthUni = new CGL.Uniform(shader, "f", "inEnvMapWidth", inEnvTexture.get().cubemap.width);
        }
        else
        {
            const isSquare = inEnvTexture.get().width === inEnvTexture.get().height;
            shader.toggleDefine("TEX_FORMAT_EQUIRECT", !isSquare);
            shader.toggleDefine("ENVMAP_MATCAP", isSquare);

            if (!inEnvMapIntensityUni)inEnvMapIntensityUni = new CGL.Uniform(shader, "f", "inEnvMapIntensity", inEnvMapIntensity);
            if (!inEnvMapWidthUni) inEnvMapWidthUni = new CGL.Uniform(shader, "f", "inEnvMapWidth", inEnvTexture.get().width);
        }
    }
    else
    {
        shader.removeUniform("inEnvMapIntensity");
        shader.removeUniform("inEnvMapWidth");
        shader.removeUniform("texEnv");
        shader.removeDefine("HAS_TEXTURE_ENV");
        shader.removeDefine("ENVMAP_MATCAP");
        envTextureUniform = null;
        inEnvMapIntensityUni = null;
    }

    updateEnvTextureLater = false;
}

function updateLuminanceMaskTexture()
{
    if (inLuminanceMaskTexture.get())
    {
        inLuminanceMaskIntensity.setUiAttribs({ "greyout": false });
        if (!luminanceTextureUniform)
        {
            shader.define("HAS_TEXTURE_LUMINANCE_MASK");
            luminanceTextureUniform = new CGL.Uniform(shader, "t", "texLuminance", 0);
            inLuminanceMaskIntensityUniform = new CGL.Uniform(shader, "f", "inLuminanceMaskIntensity", inLuminanceMaskIntensity);
        }
    }
    else
    {
        inLuminanceMaskIntensity.setUiAttribs({ "greyout": true });
        shader.removeDefine("HAS_TEXTURE_LUMINANCE_MASK");
        shader.removeUniform("inLuminanceMaskIntensity");
        shader.removeUniform("texLuminance");
        luminanceTextureUniform = null;
        inLuminanceMaskIntensityUniform = null;
    }
}

// TEX OPACITY

function updateDefines()
{
    shader.toggleDefine("ENV_BLEND_ADD", inEnvMapBlend.get() == "Add");
    shader.toggleDefine("ENV_BLEND_MUL", inEnvMapBlend.get() == "Multiply");
    shader.toggleDefine("ENV_BLEND_MIX", inEnvMapBlend.get() == "Mix");

    shader.toggleDefine("ALPHA_MASK_ALPHA", alphaMaskSource.get() == "Alpha Channel");
    shader.toggleDefine("ALPHA_MASK_LUMI", alphaMaskSource.get() == "Luminance");
    shader.toggleDefine("ALPHA_MASK_R", alphaMaskSource.get() == "R");
    shader.toggleDefine("ALPHA_MASK_G", alphaMaskSource.get() == "G");
    shader.toggleDefine("ALPHA_MASK_B", alphaMaskSource.get() == "B");

    shader.toggleDefine("AO_CHAN_0", inAoChannel.get() == "1");
    shader.toggleDefine("AO_CHAN_1", inAoChannel.get() == "2");
}

function updateAlphaTexture()
{
    if (inAlphaTexture.get())
    {
        if (alphaTextureUniform !== null) return;
        shader.removeUniform("texAlpha");
        shader.define("HAS_TEXTURE_ALPHA");
        if (!alphaTextureUniform) alphaTextureUniform = new CGL.Uniform(shader, "t", "texAlpha", 0);

        alphaMaskSource.setUiAttribs({ "greyout": false });
        discardTransPxl.setUiAttribs({ "greyout": false });
    }
    else
    {
        shader.removeUniform("texAlpha");
        shader.removeDefine("HAS_TEXTURE_ALPHA");
        alphaTextureUniform = null;

        alphaMaskSource.setUiAttribs({ "greyout": true });
        discardTransPxl.setUiAttribs({ "greyout": true });
    }
    updateDefines();
}

discardTransPxl.onChange = function ()
{
    shader.toggleDefine("DISCARDTRANS", discardTransPxl.get());
};

inDiffuseTexture.onChange = updateDiffuseTexture;
inSpecularTexture.onChange = updateSpecularTexture;
inNormalTexture.onChange = updateNormalTexture;
inAoTexture.onChange = updateAoTexture;
inEmissiveTexture.onChange = updateEmissiveTexture;
inEmissiveMaskTexture.onChange = updateEmissiveMaskTexture;
inAlphaTexture.onChange = updateAlphaTexture;
inEnvTexture.onChange = () => { updateEnvTextureLater = true; };
inLuminanceMaskTexture.onChange = updateLuminanceMaskTexture;

const MAX_UNIFORM_FRAGMENTS = cgl.maxUniformsFrag;
const MAX_LIGHTS = MAX_UNIFORM_FRAGMENTS === 64 ? 6 : 16;

shader.define("MAX_LIGHTS", MAX_LIGHTS.toString());
shader.define("SPECULAR_PHONG");

inSpecularMode.onChange = function ()
{
    if (inSpecularMode.get() === "Phong")
    {
        shader.define("SPECULAR_PHONG");
        shader.removeDefine("SPECULAR_BLINN");
        shader.removeDefine("SPECULAR_GAUSS");
        shader.removeDefine("SPECULAR_SCHLICK");
    }
    else if (inSpecularMode.get() === "Blinn")
    {
        shader.define("SPECULAR_BLINN");
        shader.removeDefine("SPECULAR_PHONG");
        shader.removeDefine("SPECULAR_GAUSS");
        shader.removeDefine("SPECULAR_SCHLICK");
    }
    else if (inSpecularMode.get() === "Gauss")
    {
        shader.define("SPECULAR_GAUSS");
        shader.removeDefine("SPECULAR_BLINN");
        shader.removeDefine("SPECULAR_PHONG");
        shader.removeDefine("SPECULAR_SCHLICK");
    }
    else if (inSpecularMode.get() === "Schlick")
    {
        shader.define("SPECULAR_SCHLICK");
        shader.removeDefine("SPECULAR_BLINN");
        shader.removeDefine("SPECULAR_PHONG");
        shader.removeDefine("SPECULAR_GAUSS");
    }
};

inEnergyConservation.onChange = function ()
{
    shader.toggleDefine("CONSERVE_ENERGY", inEnergyConservation.get());
};

inToggleDoubleSided.onChange = function ()
{
    shader.toggleDefine("DOUBLE_SIDED", inToggleDoubleSided.get());
};

// * INIT UNIFORMS *

const uniMaterialProps = new CGL.Uniform(shader, "4f", "inMaterialProperties", inAlbedo, inRoughness, inShininess, inSpecularCoefficient);
const uniDiffuseColor = new CGL.Uniform(shader, "4f", "inDiffuseColor", inDiffuseR, inDiffuseG, inDiffuseB, inDiffuseA);
const uniTextureIntensities = new CGL.Uniform(shader, "4f", "inTextureIntensities", inNormalIntensity, inAoIntensity, inSpecularIntensity, inEmissiveIntensity);
const uniTextureRepeatOffset = new CGL.Uniform(shader, "4f", "inTextureRepeatOffset", inDiffuseRepeatX, inDiffuseRepeatY, inTextureOffsetX, inTextureOffsetY);

shader.uniformColorDiffuse = uniDiffuseColor;

const lightUniforms = [];
let oldCount = 0;

function createUniforms(lightsCount)
{
    for (let i = 0; i < lightUniforms.length; i += 1)
    {
        lightUniforms[i] = null;
    }

    for (let i = 0; i < lightsCount; i += 1)
    {
        lightUniforms[i] = null;
        if (!lightUniforms[i])
        {
            lightUniforms[i] = {
                "color": new CGL.Uniform(shader, "3f", "phongLight" + i + ".color", [1, 1, 1]),
                "position": new CGL.Uniform(shader, "3f", "phongLight" + i + ".position", [0, 11, 0]),
                "specular": new CGL.Uniform(shader, "3f", "phongLight" + i + ".specular", [1, 1, 1]),
                // intensity, attenuation, falloff, radius
                "lightProperties": new CGL.Uniform(shader, "4f", "phongLight" + i + ".lightProperties", [1, 1, 1, 1]),

                "conePointAt": new CGL.Uniform(shader, "3f", "phongLight" + i + ".conePointAt", vec3.create()),
                "spotProperties": new CGL.Uniform(shader, "3f", "phongLight" + i + ".spotProperties", [0, 0, 0, 0]),
                "castLight": new CGL.Uniform(shader, "i", "phongLight" + i + ".castLight", 1),

            };
        }
    }
}

function setDefaultUniform(light)
{
    defaultUniform.position.setValue(light.position);
    defaultUniform.color.setValue(light.color);
    defaultUniform.specular.setValue(light.specular);
    defaultUniform.lightProperties.setValue([
        light.intensity,
        light.attenuation,
        light.falloff,
        light.radius,
    ]);

    defaultUniform.conePointAt.setValue(light.conePointAt);
    defaultUniform.spotProperties.setValue([
        light.cosConeAngle,
        light.cosConeAngleInner,
        light.spotExponent,
    ]);
}

function setUniforms(lightStack)
{
    for (let i = 0; i < lightStack.length; i += 1)
    {
        const light = lightStack[i];
        light.isUsed = true;

        lightUniforms[i].position.setValue(light.position);
        lightUniforms[i].color.setValue(light.color);
        lightUniforms[i].specular.setValue(light.specular);

        lightUniforms[i].lightProperties.setValue([
            light.intensity,
            light.attenuation,
            light.falloff,
            light.radius,
        ]);

        lightUniforms[i].conePointAt.setValue(light.conePointAt);
        lightUniforms[i].spotProperties.setValue([
            light.cosConeAngle,
            light.cosConeAngleInner,
            light.spotExponent,
        ]);

        lightUniforms[i].castLight.setValue(light.castLight);
    }
}

function compareLights(lightStack)
{
    if (lightStack.length !== oldCount)
    {
        createShader(lightStack);
        createUniforms(lightStack.length);
        oldCount = lightStack.length;
        setUniforms(lightStack);
        // recompileShader = false;
    }
    else
    {
        // if (recompileShader)
        // {
        //     createShader(lightStack);
        //     createUniforms(lightStack.length);
        //     recompileShader = false;
        // }
        setUniforms(lightStack);
    }
}

let defaultUniform = null;

function createDefaultUniform()
{
    defaultUniform = {
        "color": new CGL.Uniform(shader, "3f", "phongLight" + 0 + ".color", [1, 1, 1]),
        "specular": new CGL.Uniform(shader, "3f", "phongLight" + 0 + ".specular", [1, 1, 1]),
        "position": new CGL.Uniform(shader, "3f", "phongLight" + 0 + ".position", [0, 11, 0]),
        // intensity, attenuation, falloff, radius
        "lightProperties": new CGL.Uniform(shader, "4f", "phongLight" + 0 + ".lightProperties", [1, 1, 1, 1]),
        "conePointAt": new CGL.Uniform(shader, "3f", "phongLight" + 0 + ".conePointAt", vec3.create()),
        "spotProperties": new CGL.Uniform(shader, "3f", "phongLight" + 0 + ".spotProperties", [0, 0, 0, 0]),
        "castLight": new CGL.Uniform(shader, "i", "phongLight" + 0 + ".castLight", 1),
    };
}

const DEFAULT_LIGHTSTACK = [{
    "type": "point",
    "position": [5, 5, 5],
    "color": [1, 1, 1],
    "specular": [1, 1, 1],
    "intensity": 1,
    "attenuation": 0,
    "falloff": 0.5,
    "radius": 80,
    "castLight": 1,
}];

const iViewMatrix = mat4.create();

function updateLights()
{
    if (cgl.frameStore.lightStack)
    {
        if (cgl.frameStore.lightStack.length === 0)
        {
            op.setUiError("deflight", "Default light is enabled. Please add lights to your patch to make this warning disappear.", 1);
        }
        else op.setUiError("deflight", null);
    }

    if ((!cgl.frameStore.lightStack || !cgl.frameStore.lightStack.length))
    {
        // if no light in light stack, use default light & set count to -1
        // so when a new light gets added, the shader does recompile
        if (!defaultUniform)
        {
            createDefaultShader();
            createDefaultUniform();
        }

        mat4.invert(iViewMatrix, cgl.vMatrix);
        // set default light position to camera position
        DEFAULT_LIGHTSTACK[0].position = [iViewMatrix[12], iViewMatrix[13], iViewMatrix[14]];
        setDefaultUniform(DEFAULT_LIGHTSTACK[0]);

        oldCount = -1;
    }
    else
    {
        if (shader)
        {
            if (cgl.frameStore.lightStack)
            {
                if (cgl.frameStore.lightStack.length)
                {
                    defaultUniform = null;
                    compareLights(cgl.frameStore.lightStack);
                }
            }
        }
    }
}

const render = function ()
{
    if (!shader)
    {
        op.log("NO SHADER");
        return;
    }

    cgl.pushShader(shader);
    shader.popTextures();

    outTrigger.trigger();
    cgl.popShader();
};

op.preRender = function ()
{
    shader.bind();
    render();
};

/* transform for default light */
const inverseViewMat = mat4.create();
const vecTemp = vec3.create();
const camPos = vec3.create();

inTrigger.onTriggered = function ()
{
    if (!shader)
    {
        op.log("phong has no shader...");
        return;
    }

    if (updateEnvTextureLater)updateEnvTexture();

    cgl.pushShader(shader);

    shader.popTextures();

    if (inDiffuseTexture.get()) shader.pushTexture(diffuseTextureUniform, inDiffuseTexture.get());
    if (inSpecularTexture.get()) shader.pushTexture(specularTextureUniform, inSpecularTexture.get());
    if (inNormalTexture.get()) shader.pushTexture(normalTextureUniform, inNormalTexture.get());
    if (inAoTexture.get()) shader.pushTexture(aoTextureUniform, inAoTexture.get());
    if (inEmissiveTexture.get()) shader.pushTexture(emissiveTextureUniform, inEmissiveTexture.get());
    if (inEmissiveMaskTexture.get()) shader.pushTexture(emissiveMaskTextureUniform, inEmissiveMaskTexture.get());
    if (inAlphaTexture.get()) shader.pushTexture(alphaTextureUniform, inAlphaTexture.get());
    if (inEnvTexture.get())
    {
        if (inEnvTexture.get().cubemap) shader.pushTexture(envTextureUniform, inEnvTexture.get().cubemap, cgl.gl.TEXTURE_CUBE_MAP);
        else shader.pushTexture(envTextureUniform, inEnvTexture.get());
    }

    if (inLuminanceMaskTexture.get())
    {
        shader.pushTexture(luminanceTextureUniform, inLuminanceMaskTexture.get());
    }

    updateLights();

    outTrigger.trigger();

    cgl.popShader();
};

if (cgl.glVersion == 1)
{
    if (!cgl.enableExtension("EXT_shader_texture_lod"))
    {
        op.log("no EXT_shader_texture_lod texture extension");
        // throw "no EXT_shader_texture_lod texture extension";
    }
    else
    {
        shader.enableExtension("GL_EXT_shader_texture_lod");
        cgl.enableExtension("OES_texture_float");
        cgl.enableExtension("OES_texture_float_linear");
        cgl.enableExtension("OES_texture_half_float");
        cgl.enableExtension("OES_texture_half_float_linear");

        shader.enableExtension("GL_OES_standard_derivatives");
        shader.enableExtension("GL_OES_texture_float");
        shader.enableExtension("GL_OES_texture_float_linear");
        shader.enableExtension("GL_OES_texture_half_float");
        shader.enableExtension("GL_OES_texture_half_float_linear");
    }
}

updateDiffuseTexture();
updateSpecularTexture();
updateNormalTexture();
updateAoTexture();
updateAlphaTexture();
updateEmissiveTexture();
updateEmissiveMaskTexture();
updateEnvTexture();
updateLuminanceMaskTexture();


};

Ops.Gl.Phong.PhongMaterial_v6.prototype = new CABLES.Op();
CABLES.OPS["0d83ed06-cdbe-4fe0-87bb-0ccece7fb6e1"]={f:Ops.Gl.Phong.PhongMaterial_v6,objName:"Ops.Gl.Phong.PhongMaterial_v6"};




// **************************************************************
// 
// Ops.Anim.Timer_v2
// 
// **************************************************************

Ops.Anim.Timer_v2 = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    inSpeed = op.inValue("Speed", 1),
    playPause = op.inValueBool("Play", true),
    reset = op.inTriggerButton("Reset"),
    inSyncTimeline = op.inValueBool("Sync to timeline", false),
    outTime = op.outNumber("Time");

op.setPortGroup("Controls", [playPause, reset, inSpeed]);

const timer = new CABLES.Timer();
let lastTime = null;
let time = 0;
let syncTimeline = false;

playPause.onChange = setState;
setState();

function setState()
{
    if (playPause.get())
    {
        timer.play();
        op.patch.addOnAnimFrame(op);
    }
    else
    {
        timer.pause();
        op.patch.removeOnAnimFrame(op);
    }
}

reset.onTriggered = doReset;

function doReset()
{
    time = 0;
    lastTime = null;
    timer.setTime(0);
    outTime.set(0);
}

inSyncTimeline.onChange = function ()
{
    syncTimeline = inSyncTimeline.get();
    playPause.setUiAttribs({ "greyout": syncTimeline });
    reset.setUiAttribs({ "greyout": syncTimeline });
};

op.onAnimFrame = function (tt, frameNum, deltaMs)
{
    if (timer.isPlaying())
    {
        if (CABLES.overwriteTime !== undefined)
        {
            outTime.set(CABLES.overwriteTime * inSpeed.get());
        }
        else

        if (syncTimeline)
        {
            outTime.set(tt * inSpeed.get());
        }
        else
        {
            timer.update();
            const timerVal = timer.get();

            if (lastTime === null)
            {
                lastTime = timerVal;
                return;
            }

            const t = Math.abs(timerVal - lastTime);
            lastTime = timerVal;

            time += t * inSpeed.get();
            if (time != time)time = 0;
            outTime.set(time);
        }
    }
};


};

Ops.Anim.Timer_v2.prototype = new CABLES.Op();
CABLES.OPS["aac7f721-208f-411a-adb3-79adae2e471a"]={f:Ops.Anim.Timer_v2,objName:"Ops.Anim.Timer_v2"};




// **************************************************************
// 
// Ops.Anim.SineAnim
// 
// **************************************************************

Ops.Anim.SineAnim = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    exe = op.inTrigger("exe"),
    mode = op.inSwitch("Mode", ["Sine", "Cosine"], "Sine"),
    phase = op.inValueFloat("phase", 0),
    mul = op.inValueFloat("frequency", 1),
    amplitude = op.inValueFloat("amplitude", 1),
    trigOut = op.outTrigger("Trigger out"),
    result = op.outNumber("result");

let selectIndex = 0;
const SINE = 0;
const COSINE = 1;

op.toWorkPortsNeedToBeLinked(exe);

exe.onTriggered = exec;
mode.onChange = onModeChange;

exec();
onModeChange();

function onModeChange()
{
    let modeSelectValue = mode.get();

    if (modeSelectValue === "Sine") selectIndex = SINE;
    else if (modeSelectValue === "Cosine") selectIndex = COSINE;

    exec();
}

function exec()
{
    if (selectIndex == SINE) result.set(amplitude.get() * Math.sin((op.patch.freeTimer.get() * mul.get()) + phase.get()));
    else result.set(amplitude.get() * Math.cos((op.patch.freeTimer.get() * mul.get()) + phase.get()));
    trigOut.trigger();
}


};

Ops.Anim.SineAnim.prototype = new CABLES.Op();
CABLES.OPS["736d3d0e-c920-449e-ade0-f5ca6018fb5c"]={f:Ops.Anim.SineAnim,objName:"Ops.Anim.SineAnim"};




// **************************************************************
// 
// Ops.Math.Multiply
// 
// **************************************************************

Ops.Math.Multiply = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    number1 = op.inValueFloat("number1", 1),
    number2 = op.inValueFloat("number2", 1),
    result = op.outNumber("result");

op.setUiAttribs({ "mathTitle": true });

number1.onChange = number2.onChange = update;
update();

function update()
{
    const n1 = number1.get();
    const n2 = number2.get();

    result.set(n1 * n2);
}


};

Ops.Math.Multiply.prototype = new CABLES.Op();
CABLES.OPS["1bbdae06-fbb2-489b-9bcc-36c9d65bd441"]={f:Ops.Math.Multiply,objName:"Ops.Math.Multiply"};




// **************************************************************
// 
// Ops.Anim.RandomAnim
// 
// **************************************************************

Ops.Anim.RandomAnim = function()
{
CABLES.Op.apply(this,arguments);
const op=this;
const attachments=op.attachments={};
const
    exe = op.inTrigger("exe"),

    min = op.inValue("min", 0),
    max = op.inValue("max", 1),
    seed = op.inValue("random seed", 0),

    duration = op.inValue("duration", 0.5),
    pause = op.inValue("pause between", 0),
    next = op.outTrigger("Next"),
    result = op.outNumber("result"),
    looped = op.outTrigger("Looped");

const anim = new CABLES.Anim();
anim.createPort(op, "easing", reinit);

op.setPortGroup("Timing", [duration, pause]);
op.setPortGroup("Value", [min, max, seed]);

op.toWorkPortsNeedToBeLinked(exe);

let counter = 0;

min.onChange =
    max.onChange =
    pause.onChange =
    seed.onChange =
    duration.onChange = reinitLater;

let needsReinit = true;

function reinitLater()
{
    needsReinit = true;
}

function getRandom()
{
    const minVal = (min.get());
    return Math.seededRandom() * (max.get() - minVal) + minVal;
}

function reinit()
{
    Math.randomSeed = seed.get() + counter * 100;
    init(getRandom());
    needsReinit = false;
}

function init(v)
{
    anim.clear();

    anim.setValue(CABLES.now() / 1000.0, v);
    if (pause.get() !== 0.0) anim.setValue(CABLES.now() / 1000.0 + pause.get(), v);

    anim.setValue(duration.get() + CABLES.now() / 1000.0 + pause.get(), getRandom());
}

exe.onTriggered = updateExe;

function updateExe()
{
    if (needsReinit)reinit();

    const t = CABLES.now() / 1000.0;
    const v = anim.getValue(t);

    if (anim.hasEnded(t))
    {
        counter++;
        anim.clear();
        init(v);
        looped.trigger();
    }
    result.set(v);
    next.trigger();
}


};

Ops.Anim.RandomAnim.prototype = new CABLES.Op();
CABLES.OPS["2d2e5f0e-b69f-4789-9a48-1ee6ade5049a"]={f:Ops.Anim.RandomAnim,objName:"Ops.Anim.RandomAnim"};



window.addEventListener('load', function(event) {
CABLES.jsLoaded=new Event('CABLES.jsLoaded');
document.dispatchEvent(CABLES.jsLoaded);
});
// start js/cgl_light.js
(()=>{"use strict";function t(t,e){return this.type=e.type||"point",this.color=e.color||[1,1,1],this.specular=e.specular||[0,0,0],this.position=e.position||null,this.intensity=e.intensity||1,this.radius=e.radius||1,this.falloff=e.falloff||1,this.spotExponent=e.spotExponent||1,this.cosConeAngleInner=e.cosConeAngleInner||0,this.cosConeAngle=e.cosConeAngle||0,this.conePointAt=e.conePointAt||[0,0,0],this.castShadow=e.castShadow||!1,this.nearFar=e.nearFar||[0,0],this.normalOffset=e.normalOffset||0,this.shadowBias=e.shadowBias||0,this.shadowStrength=e.shadowStrength||0,this.lightMatrix=null,this.shadowMap=null,this.shadowMapDepth=null,this.shadowCubeMap=null,this._cgl=t,this.state={isUpdating:!1},this._framebuffer=null,this._shaderShadowMap={shader:null,uniforms:{lightPosition:null,nearFar:null},matrices:{modelMatrix:mat4.create(),viewMatrix:mat4.create(),projMatrix:mat4.create(),biasMatrix:mat4.fromValues(.5,0,0,0,0,.5,0,0,0,0,.5,0,.5,.5,.5,1)},vectors:{lookAt:vec3.create(),camPos:vec3.create(),up:vec3.fromValues(0,1,0)}},this._effectBlur=null,this._shaderBlur={shader:null,uniforms:{XY:null}},this._cubemap=null,this}t.prototype.getModifiableParameters=function(){return["color","specular","position","intensity","radius","falloff","spotExponent","cosConeAngleInner","cosConeAngle","conePointAt"]},t.prototype.createProjectionMatrix=t.prototype.updateProjectionMatrix=function(t,e,r,i){"spot"===this.type?mat4.perspective(this._shaderShadowMap.matrices.projMatrix,-2*CGL.DEG2RAD*i,1,e,r):"directional"===this.type?mat4.ortho(this._shaderShadowMap.matrices.projMatrix,-1*t,t,-1*t,t,e,r):"point"===this.type&&(mat4.perspective(this._shaderShadowMap.matrices.projMatrix,90*CGL.DEG2RAD,1,e,r),this.nearFar=[e,r])},t.prototype.hasFramebuffer=function(){return!!this._framebuffer},t.prototype.hasShadowMapShader=function(){return!!this._shaderShadowMap.shader},t.prototype.hasBlurShader=function(){return!!this._shaderBlur.shader},t.prototype.hasBlurEffect=function(){return!!this._effectBlur},t.prototype.getShadowMap=function(){return"point"===this.type?null:this._framebuffer.getTextureColor()},t.prototype.getShadowMapDepth=function(){return"point"===this.type?null:this._framebuffer.getTextureDepth()},t.prototype.createFramebuffer=function(t,e,r){this.state.isUpdating=!0;const i=t||512,a=e||512;if("point"===this.type)return this.hasCubemap()?this._cubemap.setSize(i,a):this._cubemap=new CGL.CubemapFramebuffer(this._cgl,i,a,{name:"point light shadowmap"}),this._cubemap.setCamPos(this.position),this._cubemap.setMatrices(this._shaderShadowMap.matrices.modelMatrix,this._shaderShadowMap.matrices.viewMatrix,this._shaderShadowMap.matrices.projMatrix),void(this.state.isUpdating=!1);this.hasFramebuffer()&&this._framebuffer.delete(),r&&r.filter&&(r.isFloatingPointTexture=r.filter!==CGL.Texture.FILTER_MIPMAP),1==this._cgl.glVersion?this._framebuffer=new CGL.Framebuffer(this._cgl,i,a,{isFloatingPointTexture:!0,filter:CGL.Texture.FILTER_LINEAR,wrap:CGL.Texture.WRAP_CLAMP_TO_EDGE,...r}):this._framebuffer=new CGL.Framebuffer2(this._cgl,i,a,{isFloatingPointTexture:!0,filter:CGL.Texture.FILTER_LINEAR,wrap:CGL.Texture.WRAP_CLAMP_TO_EDGE,...r}),this.state.isUpdating=!1},t.prototype.hasCubemap=function(){return!!this._cubemap},t.prototype.setFramebufferSize=function(t){this.hasFramebuffer()&&this._framebuffer.setSize(t,t)},t.prototype.createShadowMapShader=function(t,e){if(this.hasShadowMapShader())return;this.state.isUpdating=!0,this._shaderShadowMap.shader=new CGL.Shader(this._cgl,"shadowPass"+this.type.charAt(0).toUpperCase()+this.type.slice(1)),this._shaderShadowMap.shader.setModules(["MODULE_VERTEX_POSITION","MODULE_COLOR","MODULE_BEGIN_FRAG"]);const r=t||this.getShadowPassVertexShader(),i=e||this.getShadowPassFragmentShader();this._shaderShadowMap.shader.setSource(r,i),this._shaderShadowMap.shader.offScreenPass=!0,"point"===this.type&&(this._shaderShadowMap.uniforms.lightPosition=new CGL.Uniform(this._shaderShadowMap.shader,"3f","inLightPosition",vec3.create()),this._shaderShadowMap.uniforms.nearFar=new CGL.Uniform(this._shaderShadowMap.shader,"2f","inNearFar",vec2.create())),1==this._cgl.glVersion&&(this._cgl.enableExtension("OES_texture_float"),this._cgl.enableExtension("OES_texture_float_linear"),this._cgl.enableExtension("OES_texture_half_float"),this._cgl.enableExtension("OES_texture_half_float_linear"),this._shaderShadowMap.shader.enableExtension("GL_OES_standard_derivatives"),this._shaderShadowMap.shader.enableExtension("GL_OES_texture_float"),this._shaderShadowMap.shader.enableExtension("GL_OES_texture_float_linear"),this._shaderShadowMap.shader.enableExtension("GL_OES_texture_half_float"),this._shaderShadowMap.shader.enableExtension("GL_OES_texture_half_float_linear")),this.state.isUpdating=!1},t.prototype.createBlurEffect=function(t){"point"!==this.type&&(this.state.isUpdating=!0,this.hasBlurEffect()&&this._effectBlur.delete(),this._effectBlur=new CGL.TextureEffect(this._cgl,{isFloatingPointTexture:!0,filter:CGL.Texture.FILTER_LINEAR,wrap:CGL.Texture.WRAP_CLAMP_TO_EDGE,...t}),this.state.isUpdating=!1)},t.prototype.createBlurShader=function(t,e){if(this.hasBlurShader())return;if("point"===this.type)return;this.state.isUpdating=!0;const r=t||this.getBlurPassVertexShader(),i=e||this.getBlurPassFragmentShader();this._shaderBlur.shader=new CGL.Shader(this._cgl,"blurPass"+this.type.charAt(0).toUpperCase()+this.type.slice(1)),this._shaderBlur.shader.setModules(["MODULE_VERTEX_POSITION","MODULE_COLOR","MODULE_BEGIN_FRAG"]),this._shaderBlur.shader.setSource(r,i),this._shaderBlur.uniforms.XY=new CGL.Uniform(this._shaderBlur.shader,"2f","inXY",vec2.create()),this._shaderBlur.shader.offScreenPass=!0,this.state.isUpdating=!1},t.prototype.renderPasses=function(t,e,r){this.state.isUpdating||this._cgl.frameStore.shadowPass||(this._cgl.pushCullFace(!0),this._cgl.pushCullFaceFacing(this._cgl.gl.FRONT),this._cgl.gl.enable(this._cgl.gl.POLYGON_OFFSET_FILL),this._cgl.gl.polygonOffset(t,t),this._cgl.frameStore.renderOffscreen=!0,this._cgl.frameStore.shadowPass=!0,this._cgl.pushBlend(!1),this._cgl.gl.colorMask(!0,!0,"point"===this.type,"point"===this.type),this.renderShadowPass(r),this._cgl.gl.cullFace(this._cgl.gl.BACK),this._cgl.gl.disable(this._cgl.gl.CULL_FACE),this._cgl.gl.disable(this._cgl.gl.POLYGON_OFFSET_FILL),"point"!==this.type&&this.renderBlurPass(e),this._cgl.gl.colorMask(!0,!0,!0,!0),this._cgl.popBlend(),this._cgl.popCullFaceFacing(),this._cgl.popCullFace(),this._cgl.frameStore.shadowPass=!1,this._cgl.frameStore.renderOffscreen=!1,"point"!==this.type?(this.shadowMap=this._framebuffer.getTextureColor(),this.shadowMapDepth=this._framebuffer.getTextureDepth()):(this.shadowMap=null,this.shadowMapDepth=null))},t.prototype.renderShadowPass=function(t){if(!this.state.isUpdating){if("point"===this.type){this._shaderShadowMap.uniforms.nearFar.setValue(this.nearFar),this._shaderShadowMap.uniforms.lightPosition.setValue(this.position),this._cubemap.setCamPos(this.position),this._cubemap.setMatrices(this._shaderShadowMap.matrices.modelMatrix,this._shaderShadowMap.matrices.viewMatrix,this._shaderShadowMap.matrices.projMatrix),this._cgl.pushShader(this._shaderShadowMap.shader),this._cubemap.renderStart();for(let e=0;e<6;e+=1)this._cubemap.renderStartCubemapFace(e),t&&t(),this._cubemap.renderEndCubemapFace();return this._cubemap.renderEnd(),this._cgl.popShader(),void(this.shadowCubeMap=this._cubemap.getTextureColor())}this._cgl.pushShader(this._shaderShadowMap.shader),this._cgl.pushModelMatrix(),this._cgl.pushViewMatrix(),this._cgl.pushPMatrix(),this._framebuffer.renderStart(this._cgl),mat4.copy(this._cgl.mMatrix,this._shaderShadowMap.matrices.modelMatrix),vec3.set(this._shaderShadowMap.vectors.camPos,this.position[0],this.position[1],this.position[2]),"spot"===this.type&&vec3.set(this._shaderShadowMap.vectors.lookAt,this.conePointAt[0],this.conePointAt[1],this.conePointAt[2]),mat4.lookAt(this._cgl.vMatrix,this._shaderShadowMap.vectors.camPos,this._shaderShadowMap.vectors.lookAt,this._shaderShadowMap.vectors.up),mat4.copy(this._cgl.pMatrix,this._shaderShadowMap.matrices.projMatrix),this.lightMatrix||(this.lightMatrix=mat4.create()),mat4.mul(this.lightMatrix,this._cgl.pMatrix,this._cgl.vMatrix),mat4.mul(this.lightMatrix,this._cgl.mMatrix,this.lightMatrix),mat4.mul(this.lightMatrix,this._shaderShadowMap.matrices.biasMatrix,this.lightMatrix),this._cgl.gl.clearColor(1,1,1,1),this._cgl.gl.clear(this._cgl.gl.DEPTH_BUFFER_BIT|this._cgl.gl.COLOR_BUFFER_BIT),t&&t(),this._framebuffer.renderEnd(this._cgl),this._cgl.popPMatrix(),this._cgl.popModelMatrix(),this._cgl.popViewMatrix(),this._cgl.popShader()}},t.prototype.renderBlurPass=function(t){this.state.isUpdating||(this._cgl.pushShader(this._shaderBlur.shader),this._effectBlur.setSourceTexture(this._framebuffer.getTextureColor()),this._effectBlur.startEffect(),this._effectBlur.bind(),this._cgl.setTexture(0,this._effectBlur.getCurrentSourceTexture().tex),this._shaderBlur.uniforms.XY.setValue([t,0]),this._effectBlur.finish(),this._effectBlur.bind(),this._cgl.setTexture(0,this._effectBlur.getCurrentSourceTexture().tex),this._shaderBlur.uniforms.XY.setValue([0,t]),this._effectBlur.finish(),this._effectBlur.endEffect(),this._cgl.popShader())},t.prototype.getShadowPassVertexShader=function(){return`\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\nIN vec3 attrVertNormal;\nIN float attrVertIndex;\nIN vec3 attrTangent;\nIN vec3 attrBiTangent;\n\nUNI mat4 projMatrix;\nUNI mat4 modelMatrix;\nUNI mat4 viewMatrix;\n\n\nOUT vec2 texCoord;\nOUT vec3 norm;\n\n{{MODULES_HEAD}}\n\n${"point"===this.type?"OUT vec3 modelPos;":""}\nvoid main() {\n    texCoord=attrTexCoord;\n    texCoord.y = 1. - texCoord.y;\n    norm=attrVertNormal;\n    vec4 pos = vec4(vPosition, 1.0);\n    mat4 mMatrix=modelMatrix;\n    vec3 tangent = attrTangent;\n    vec3 bitangent = attrBiTangent;\n\n    {{MODULE_VERTEX_POSITION}}\n\n    mat4 mvMatrix=viewMatrix * mMatrix;\n    vec4 vPos = projMatrix * mvMatrix * pos;\n    ${"point"===this.type?"modelPos = (mMatrix * pos).xyz;":""}\n    gl_Position = vPos;\n}\n`},t.prototype.getShadowPassFragmentShader=function(){return`\n   {{MODULES_HEAD}}\n   ${"point"===this.type?"IN vec3 modelPos;":""}\n   ${"point"===this.type?"UNI vec3 inLightPosition;":""}\n   ${"point"===this.type?"UNI vec2 inNearFar;":""}\n\n    IN vec2 texCoord;\n\n    void main() {\n        {{MODULE_BEGIN_FRAG}}\n        vec4 col = vec4(1.);\n\n\n        outColor = vec4(1.);\n\n        {{MODULE_COLOR}}\n\n        ${"point"===this.type?"vec3 fromLightToFrag = (modelPos - inLightPosition);":""}\n\n\n        ${"point"===this.type?"float depth = (length(fromLightToFrag) - inNearFar.x) / (inNearFar.y - inNearFar.x);":"float depth = gl_FragCoord.z;"}\n\n        float dx = dFdx(depth); // for biasing depth-per-pixel\n        float dy = dFdy(depth); // for biasing depth-per-pixel\n\n        float clampedDerivative = clamp(dot(dx, dx) + dot(dy, dy), 0., 1.);\n        float moment2 = dot(depth, depth) + 0.25 * clampedDerivative;\n\n        outColor.x = depth;\n        outColor.y = moment2;\n        outColor.z = depth;\n    }\n`},t.prototype.getBlurPassVertexShader=function(){return"point"===this.type?"":"\n\nIN vec3 vPosition;\nIN vec2 attrTexCoord;\n\nOUT vec2 texCoord;\nOUT vec2 coord0;\nOUT vec2 coord1;\nOUT vec2 coord2;\nOUT vec2 coord3;\nOUT vec2 coord4;\nOUT vec2 coord5;\nOUT vec2 coord6;\n\nUNI mat4 projMatrix;\nUNI mat4 mvMatrix;\nUNI mat4 modelMatrix;\n\nUNI vec2 inXY;\n\nvoid main() {\n    texCoord=attrTexCoord;\n\n    vec4 pos = vec4(vPosition,  1.0);\n\n    {{MODULE_VERTEX_POSITION}}\n\n    coord3 = attrTexCoord;\n\n\n    coord0 = attrTexCoord + (-3.0368997744118595 * inXY);\n    coord0 = clamp(coord0, 0., 1.);\n    coord1 = attrTexCoord + (-2.089778445362373 * inXY);\n    coord1 = clamp(coord1, 0., 1.);\n    coord2 = attrTexCoord + (-1.2004366090034069 * inXY);\n    coord2 = clamp(coord2, 0., 1.);\n    coord4 = attrTexCoord + (1.2004366090034069 * inXY);\n    coord4 = clamp(coord4, 0., 1.);\n    coord5 = attrTexCoord + (2.089778445362373* inXY);\n    coord5 = clamp(coord5, 0., 1.);\n    coord6 = attrTexCoord + (3.0368997744118595 * inXY);\n    coord6 = clamp(coord6, 0., 1.);\n\n    gl_Position = projMatrix * mvMatrix * pos;\n}\n    "},t.prototype.getBlurPassFragmentShader=function(){return"point"===this.type?"":"\nUNI sampler2D tex;\n\nIN vec2 coord0;\nIN vec2 coord1;\nIN vec2 coord2;\nIN vec2 coord3;\nIN vec2 coord4;\nIN vec2 coord5;\nIN vec2 coord6;\n\nvoid main() {\n\n    vec4 color = vec4(0.0);\n\n\n    color.xyz += texture(tex, coord0).xyz * 0.06927096443792478;  // 1/64\n    color.xyz += texture(tex, coord1).xyz * 0.1383328848652136;   // 6/64\n    color.xyz += texture(tex, coord2).xyz * 0.21920904690397863;  // 15/64\n    color.xyz += texture(tex, coord3).xyz * 0.14637421;           // 20/64\n    color.xyz += texture(tex, coord4).xyz * 0.21920904690397863;  // 15/64\n    color.xyz += texture(tex, coord5).xyz * 0.1383328848652136;   // 6/64\n    color.xyz += texture(tex, coord6).xyz * 0.06927096443795711;  // 1/64\n\n    color.a = 1.;\n\n    outColor = color;\n}\n    "},CGL.Light=t,((this.CGL=this.CGL||{}).COREMODULES=this.CGL.COREMODULES||{}).Light={}.Light})();// end js/cgl_light.js
